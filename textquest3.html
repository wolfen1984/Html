<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Text Adventure - CRPG</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: #000;
            color: #fff;
            line-height: 1.4;
            padding: 20px;
            height: 100vh;
            overflow: hidden;
        }

        #game-container {
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 95vh;
            border: 1px solid #0f0;
            background-color: #000;
            padding: 10px;
            position: relative;
        }

        #game-header {
            text-align: center;
            padding: 10px;
            border-bottom: 1px solid #0f0;
            margin-bottom: 10px;
        }

        h1 {
            font-size: 2.5rem;
            letter-spacing: 2px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }

        #game-content {
            display: flex;
            flex: 1;
            gap: 15px;
            overflow: hidden;
        }

        #game-text {
            flex: 3;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #0f0;
            height: 100%;
            background-color: #111;
        }

        #game-text p {
            margin-bottom: 10px;
            font-size: 1.2rem;
            animation: fadeIn 0.3s ease-in;
            color: #fff;
        }

        #game-text p:last-child {
            margin-bottom: 0;
        }

        #game-text strong {
            color: #fff;
        }

        #game-text em {
            color: #ff0;
        }

        #game-ui {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
        }

        #party-panel {
            border: 1px solid #0f0;
            padding: 10px;
            flex: 2;
            background-color: #111;
            overflow-y: auto;
        }

        #input-panel {
            border: 1px solid #0f0;
            padding: 10px;
            flex: 1;
            background-color: #111;
            display: flex;
            flex-direction: column;
        }

        #stats-panel {
            border: 1px solid #0f0;
            padding: 10px;
            flex: 1;
            background-color: #111;
            overflow-y: auto;
        }

        #travel-panel {
            border: 1px solid #0f0;
            padding: 10px;
            flex: 1;
            background-color: #111;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #travel-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .travel-btn {
            background-color: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            white-space: nowrap;
            width: 100%;
        }

        .travel-btn:hover {
            background-color: #0f0;
            color: #000;
        }

        .travel-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
        }

        .travel-btn:disabled:hover {
            background-color: #000;
            color: #0f0;
        }

        .panel-title {
            color: #0f0;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-transform: uppercase;
        }

        #user-input {
            background-color: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 8px;
            margin-bottom: 10px;
            width: 100%;
        }

        #submit-btn {
            background-color: #000;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #submit-btn:hover {
            background-color: #0f0;
            color: #000;
        }

        #command-list {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #0a0;
        }

        .character {
            margin-bottom: 10px;
            padding: 5px;
            border-bottom: 1px dashed #333;
        }

        .character-name {
            color: #0ff;
            font-weight: bold;
        }

        .character-class {
            color: #f0f;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-name {
            color: #0f0;
        }

        .stat-value {
            color: #fff;
        }

        .location {
            color: #ff0;
            font-weight: bold;
        }

        .npc {
            color: #0ff;
        }

        .item {
            color: #f90;
        }

        .enemy {
            color: #f00;
        }

        .quest {
            color: #ff0;
        }

        .error {
            color: #f00;
        }

        .success {
            color: #0f0;
        }

        .gold {
            color: #ff0;
        }

        .health {
            color: #f00;
        }

        .mana {
            color: #00f;
        }

        .class-option {
            padding: 5px;
            margin: 5px 0;
            border: 1px solid #0f0;
            cursor: pointer;
            transition: all 0.2s;
            color: #0f0;
        }

        .class-option:hover {
            background-color: #0f0;
            color: #000;
        }

        .selected {
            background-color: #0f0;
            color: #000;
        }

        .blink {
            animation: blink 1s infinite;
        }

        .treasure {
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
        }

        .lore {
            color: #87ceeb;
            font-style: italic;
        }

        .shrine {
            color: #ff69b4;
        }

        .artifact {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        .set-item {
            color: #00ff00;
        }

        .legendary {
            color: #ff4500;
            text-shadow: 0 0 5px #ff4500;
        }

        .damage-slashing {
            color: #c0c0c0;
        }

        .damage-piercing {
            color: #a0522d;
        }

        .damage-blunt {
            color: #8b4513;
        }

        .damage-elemental {
            color: #ff0000;
        }

        .status-effect {
            color: #9370db;
        }

        .specialization {
            color: #ffa500;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #0f0;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0c0;
        }

        #game-footer {
            text-align: center;
            padding: 10px;
            border-top: 1px solid #0f0;
            margin-top: 10px;
            font-size: 0.9rem;
            color: #0a0;
        }
        
        .command-suggestion {
            color: #0a0;
            cursor: pointer;
            text-decoration: underline;
        }
        
        .command-suggestion:hover {
            color: #0f0;
        }
        
        .xp {
            color: #90ee90;
        }
        
        .level-up {
            color: #00ffff;
            animation: blink 0.5s infinite;
        }
        
        .skill-check {
            color: #87ceeb;
            font-weight: bold;
        }
        
        .skill-success {
            color: #90ee90;
            font-weight: bold;
        }
        
        .skill-fail {
            color: #ff6b6b;
            font-weight: bold;
        }
        
        .exploration-hint {
            color: #ffa500;
            font-style: italic;
        }
        
        .party-ability {
            color: #9370db;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-header">
            <h1>RETRO TEXT ADVENTURE</h1>
            <p>AN 80s-STYLE CRPG EXPERIENCE</p>
        </div>
        
        <div id="game-content">
            <div id="game-text">
                <p>Welcome to <strong>RETRO TEXT ADVENTURE</strong>, a classic computer role-playing game experience!</p>
                <p>In this game, you will assemble a party of adventurers, explore dangerous lands, complete quests, and battle foes.</p>
                <p>Type <strong>HELP</strong> at any time for a list of commands.</p>
                <p class="blink">>> <strong>PRESS ANY KEY TO BEGIN</strong></p>
            </div>
            
            <div id="game-ui">
                <div id="party-panel">
                    <div class="panel-title">PARTY MEMBERS</div>
                    <div id="party-display">
                        <p>No party members yet.</p>
                    </div>
                </div>
                
                <div id="travel-panel">
                    <div class="panel-title">TRAVEL DESTINATIONS</div>
                    <p style="font-size: 0.9rem; color: #0a0; margin-bottom: 8px; text-align: center;">
                        Click a destination to travel:
                    </p>
                    <div id="travel-buttons">
                        <p style="color:#888; text-align:center; font-size:0.9rem;">Travel destinations will appear here once you start the game.</p>
                    </div>
                </div>
                
                <div id="input-panel">
                    <div class="panel-title">COMMANDS</div>
                    <input type="text" id="user-input" placeholder="Type command here..." autocomplete="off">
                    <button id="submit-btn">EXECUTE</button>
                    <div id="command-list">
                        <p>Common: <span class="command-suggestion" onclick="document.getElementById('user-input').value='help'; processCommand()">HELP</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='look'; processCommand()">LOOK</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='travel'; processCommand()">TRAVEL</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='rest'; processCommand()">REST</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='status'; processCommand()">STATUS</span></p>
                        <p>Village: <span class="command-suggestion" onclick="document.getElementById('user-input').value='shop'; processCommand()">SHOP</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='inn'; processCommand()">INN</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='talk'; processCommand()">TALK</span>, <span class="command-suggestion" onclick="document.getElementById('user-input').value='quest'; processCommand()">QUEST</span></p>
                    </div>
                </div>
                
                <div id="stats-panel">
                    <div class="panel-title">GAME STATS</div>
                    <div id="stats-display">
                        <div class="stat-item">
                            <span class="stat-name">Location:</span>
                            <span class="stat-value" id="location-value">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-name">Gold:</span>
                            <span class="stat-value gold" id="gold-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-name">Day:</span>
                            <span class="stat-value" id="day-value">1</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-name">Quest:</span>
                            <span class="stat-value" id="quest-value">None</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="game-footer">
            <p>Inspired by Ultima, Wizardry, Might & Magic, and Baldur's Gate | Use arrow keys for command history</p>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            // Party
            party: [],
            maxPartySize: 3,
            
            // Game world
            location: 'start',
            day: 1,
            gold: 50,
            currentQuest: null,
            questCompleted: false,
            
            // Exploration tracking
            exploredLocations: {},
            foundTreasures: [],
            foundLoreBooks: [],
            visitedShrines: [],
            completedPuzzles: [],
            
            // Exploration challenges - NEW: Track which challenges have been found
            foundChallenges: [],
            
            // World locations - updated with exploration rewards and skill challenges
            locations: {
                start: {
                    name: 'The Adventurers Guild',
                    description: 'You stand in the Adventurers Guild, where brave souls gather to form parties and seek fortune.',
                    type: 'safe',
                    connections: ['rivertown'],
                    hasTreasure: false,
                    hasLore: true,
                    loreBook: 'History of the Guild',
                    loreEffect: 'All party members gain 50 XP',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'lockpick', description: 'Locked chest in the back room', difficulty: 1, reward: 'starter_gold' },
                        { type: 'arcane', description: 'Magical barrier blocking a side room', difficulty: 2, reward: 'magic_scroll' }
                    ]
                },
                rivertown: {
                    name: 'Rivertown',
                    description: 'A small village built alongside a rushing river. The locals seem friendly but wary of strangers.',
                    type: 'village',
                    connections: ['start', 'deepwood', 'traderspath'],
                    shops: ['weapons', 'items', 'inn'],
                    npcs: ['elder', 'merchant', 'guard'],
                    hasTreasure: true,
                    treasureType: 'hidden',
                    treasureChance: 0.3,
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'persuade', description: 'Convince the merchant to lower prices', difficulty: 3, reward: 'shop_discount' },
                        { type: 'strength', description: 'Move fallen debris blocking a shortcut', difficulty: 2, reward: 'shortcut_access' }
                    ]
                },
                deepwood: {
                    name: 'Deepwood Forest',
                    description: 'A dense, ancient forest with twisted trees and strange sounds echoing from the shadows.',
                    type: 'wilderness',
                    connections: ['rivertown', 'moonhills'],
                    danger: 3,
                    encounters: ['goblin', 'wolf', 'bandit'],
                    hasTreasure: true,
                    treasureType: 'common',
                    treasureChance: 0.4,
                    hasShrine: true,
                    shrineName: 'Forest Shrine',
                    shrineEffect: '+1 permanent Attack to all party members',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'perception', description: 'Spot hidden animal tracks', difficulty: 2, reward: 'hunting_reward' },
                        { type: 'survival', description: 'Find safe path through thick undergrowth', difficulty: 3, reward: 'avoid_encounter' }
                    ]
                },
                moonhills: {
                    name: 'Moon Hills',
                    description: 'Rolling hills under an ever-present moon. Strange standing stones dot the landscape.',
                    type: 'wilderness',
                    connections: ['deepwood', 'darkmarsh', 'stonetower'],
                    danger: 4,
                    encounters: ['bandit', 'skeleton', 'ghost'],
                    hasTreasure: true,
                    treasureType: 'rare',
                    treasureChance: 0.25,
                    hasLore: true,
                    loreBook: 'Moons of Legend',
                    loreEffect: 'Reveals secret location: Moon Temple',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'arcane', description: 'Decipher ancient runes on standing stones', difficulty: 4, reward: 'lore_insight' },
                        { type: 'climb', description: 'Scale steep hill for better vantage point', difficulty: 3, reward: 'map_reveal' }
                    ]
                },
                darkmarsh: {
                    name: 'Darkmarsh',
                    description: 'A foul-smelling swamp with murky waters and grasping roots. The air is thick with insects.',
                    type: 'wilderness',
                    connections: ['moonhills', 'shadowfen'],
                    danger: 5,
                    encounters: ['ghost', 'skeleton', 'zombie'],
                    hasTreasure: true,
                    treasureType: 'artifact',
                    treasureChance: 0.15,
                    hasPuzzle: true,
                    puzzleName: 'Ancient Ruins',
                    puzzleReward: 'Crystal Skull artifact',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'stealth', description: 'Sneak past sleeping swamp creature', difficulty: 4, reward: 'safe_passage' },
                        { type: 'nature', description: 'Identify safe mushrooms for healing', difficulty: 3, reward: 'healing_mushrooms' }
                    ]
                },
                shadowfen: {
                    name: 'Shadowfen Village',
                    description: 'A gloomy village built on stilts above the marsh. The inhabitants are suspicious and secretive.',
                    type: 'village',
                    connections: ['darkmarsh'],
                    shops: ['items', 'inn', 'magic'],
                    npcs: ['witch', 'hunter', 'hermit'],
                    hasTreasure: false,
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'intimidate', description: 'Intimidate local thugs for information', difficulty: 4, reward: 'quest_info' },
                        { type: 'persuade', description: 'Convince hermit to share knowledge', difficulty: 5, reward: 'ancient_secret' }
                    ]
                },
                stonetower: {
                    name: "Wizard's Stone Tower",
                    description: 'A tall stone tower that pierces the clouds. Arcane energy crackles in the air.',
                    type: 'special',
                    connections: ['moonhills'],
                    shops: ['magic'],
                    npcs: ['wizard'],
                    hasLore: true,
                    loreBook: 'Arcane Secrets',
                    loreEffect: 'Wizards and Sorcerers gain +5 MP permanently',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'arcane', description: 'Solve magical door puzzle', difficulty: 5, reward: 'library_access' },
                        { type: 'alchemy', description: 'Identify mysterious potions', difficulty: 4, reward: 'rare_potion' }
                    ]
                },
                traderspath: {
                    name: "Trader's Path",
                    description: 'A well-traveled road between settlements, but still dangerous for the unprepared.',
                    type: 'wilderness',
                    connections: ['rivertown', 'frostpeak'],
                    danger: 2,
                    encounters: ['bandit', 'wolf'],
                    hasTreasure: true,
                    treasureType: 'common',
                    treasureChance: 0.35,
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'perception', description: 'Spot ambush points ahead', difficulty: 2, reward: 'ambush_warning' },
                        { type: 'tracking', description: 'Follow merchant caravan tracks', difficulty: 3, reward: 'caravan_supplies' }
                    ]
                },
                frostpeak: {
                    name: 'Frostpeak Mountains',
                    description: 'Snow-capped peaks where icy winds howl through narrow passes.',
                    type: 'wilderness',
                    connections: ['traderspath', 'dwarffort'],
                    danger: 6,
                    encounters: ['troll', 'yeti', 'goblin'],
                    hasTreasure: true,
                    treasureType: 'legendary',
                    treasureChance: 0.1,
                    hasShrine: true,
                    shrineName: 'Frost Shrine',
                    shrineEffect: '+2 permanent Defense to all party members',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'climb', description: 'Scale icy cliff face', difficulty: 5, reward: 'mountain_vista' },
                        { type: 'survival', description: 'Find shelter from blizzard', difficulty: 4, reward: 'warm_shelter' }
                    ]
                },
                dwarffort: {
                    name: 'Dwarven Fortress',
                    description: 'An imposing fortress carved into the mountain stone. The sounds of industry echo from within.',
                    type: 'village',
                    connections: ['frostpeak'],
                    shops: ['weapons', 'inn'],
                    npcs: ['dwarfking', 'smith', 'miner'],
                    hasTreasure: false,
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'smithing', description: 'Help blacksmith with forge work', difficulty: 3, reward: 'weapon_upgrade' },
                        { type: 'persuade', description: 'Convince dwarves to share ale', difficulty: 2, reward: 'dwarven_ale' }
                    ]
                },
                // Secret location revealed by lore book
                moontemple: {
                    name: 'Moon Temple',
                    description: 'A hidden temple dedicated to lunar deities. Strange magic permeates the air.',
                    type: 'special',
                    connections: ['moonhills'],
                    hasTreasure: true,
                    treasureType: 'set_item',
                    treasureChance: 1.0,
                    hasShrine: true,
                    shrineName: 'Moon Altar',
                    shrineEffect: 'Party gains Moon Blessing: +10% critical hit chance',
                    // NEW: Skill challenges
                    skillChallenges: [
                        { type: 'religion', description: 'Perform correct ritual at altar', difficulty: 5, reward: 'divine_blessing' },
                        { type: 'perception', description: 'Find hidden compartment in statue', difficulty: 4, reward: 'temple_treasure' }
                    ]
                }
            },
            
            // Enhanced Character classes with progression and skills
            classes: [
                { 
                    id: 'warrior', 
                    name: 'Warrior', 
                    baseHp: 30, 
                    baseMp: 5, 
                    baseAttack: 8, 
                    baseDefense: 8, 
                    skills: ['Slash', 'Shield Bash'],
                    specializations: ['Knight', 'Berserker'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['strength', 'intimidate', 'smithing']
                },
                { 
                    id: 'wizard', 
                    name: 'Wizard', 
                    baseHp: 15, 
                    baseMp: 25, 
                    baseAttack: 4, 
                    baseDefense: 3, 
                    skills: ['Fireball', 'Magic Missile'],
                    specializations: ['Elementalist', 'Illusionist'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['arcane', 'alchemy', 'perception']
                },
                { 
                    id: 'rogue', 
                    name: 'Rogue', 
                    baseHp: 20, 
                    baseMp: 10, 
                    baseAttack: 7, 
                    baseDefense: 5, 
                    skills: ['Backstab', 'Pick Lock'],
                    specializations: ['Assassin', 'Swashbuckler'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['lockpick', 'stealth', 'perception']
                },
                { 
                    id: 'necromancer', 
                    name: 'Necromancer', 
                    baseHp: 18, 
                    baseMp: 22, 
                    baseAttack: 5, 
                    baseDefense: 4, 
                    skills: ['Raise Dead', 'Drain Life'],
                    specializations: ['Death Priest', 'Bone Lord'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['arcane', 'religion', 'intimidate']
                },
                { 
                    id: 'thief', 
                    name: 'Thief', 
                    baseHp: 18, 
                    baseMp: 8, 
                    baseAttack: 6, 
                    baseDefense: 4, 
                    skills: ['Steal', 'Trap Disarm'],
                    specializations: ['Master Thief', 'Shadowdancer'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['lockpick', 'stealth', 'climb']
                },
                { 
                    id: 'priest', 
                    name: 'Priest', 
                    baseHp: 22, 
                    baseMp: 20, 
                    baseAttack: 3, 
                    baseDefense: 6, 
                    skills: ['Heal', 'Turn Undead'],
                    specializations: ['High Priest', 'War Priest'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['religion', 'persuade', 'healing']
                },
                { 
                    id: 'sorcerer', 
                    name: 'Sorcerer', 
                    baseHp: 16, 
                    baseMp: 24, 
                    baseAttack: 5, 
                    baseDefense: 3, 
                    skills: ['Lightning Bolt', 'Charm'],
                    specializations: ['Stormcaller', 'Mindbender'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['arcane', 'persuade', 'nature']
                },
                { 
                    id: 'healer', 
                    name: 'Healer', 
                    baseHp: 20, 
                    baseMp: 18, 
                    baseAttack: 2, 
                    baseDefense: 5, 
                    skills: ['Cure Wounds', 'Restore'],
                    specializations: ['Arch Healer', 'Battle Medic'],
                    specializationLevel: 5,
                    xpToNext: 100,
                    // NEW: Exploration skills
                    explorationSkills: ['healing', 'nature', 'persuade']
                }
            ],
            
            // NEW: Exploration abilities for different party compositions
            partyExplorationAbilities: {
                // Single class abilities
                'rogue': {
                    name: 'Detect Traps',
                    description: 'Automatically detect traps in new locations',
                    effect: 'Warns of traps before triggering them'
                },
                'wizard': {
                    name: 'Arcane Sight',
                    description: 'See magical auras and hidden enchantments',
                    effect: 'Reveals magical items and effects'
                },
                'warrior': {
                    name: 'Force Open',
                    description: 'Break through barred doors and obstacles',
                    effect: 'Can access blocked areas without keys'
                },
                'priest': {
                    name: 'Divine Guidance',
                    description: 'Sense hidden shrines and holy sites',
                    effect: 'Shrines are automatically revealed'
                },
                // Party composition abilities (multiple classes required)
                'rogue_wizard': {
                    name: 'Magical Lockpicking',
                    description: 'Use magic to pick magical locks',
                    requires: ['Rogue', 'Wizard'],
                    effect: 'Can open magically sealed containers'
                },
                'warrior_priest': {
                    name: 'Holy Protection',
                    description: 'Bless the party for safer travel',
                    requires: ['Warrior', 'Priest'],
                    effect: '-20% random encounter chance'
                },
                'rogue_warrior': {
                    name: 'Scout Ahead',
                    description: 'Scout for ambushes and hidden paths',
                    requires: ['Rogue', 'Warrior'],
                    effect: 'Reveals hidden connections between locations'
                },
                'wizard_priest': {
                    name: 'Ritual of Warding',
                    description: 'Create protective wards around camp',
                    requires: ['Wizard', 'Priest'],
                    effect: 'Party cannot be ambushed while resting'
                },
                // Three-member party abilities
                'balanced_party': {
                    name: 'Expert Exploration',
                    description: 'Full party coordination for exploration',
                    requires: ['Warrior', 'Wizard', 'Rogue'],
                    effect: '+50% treasure find chance, auto-detect all hidden things'
                },
                'magical_party': {
                    name: 'Arcane Revelation',
                    description: 'Combine magical powers to see all',
                    requires: ['Wizard', 'Sorcerer', 'Necromancer'],
                    effect: 'Reveals all secrets in current location'
                }
            },
            
            // Enhanced Items with rarity and weapon types
            items: {
                weapons: [
                    // Common weapons
                    { name: 'Dagger', cost: 10, attack: 2, damageType: 'piercing', rarity: 'common' },
                    { name: 'Short Sword', cost: 25, attack: 4, damageType: 'slashing', rarity: 'common' },
                    { name: 'Club', cost: 8, attack: 3, damageType: 'blunt', rarity: 'common' },
                    { name: 'Spear', cost: 30, attack: 5, damageType: 'piercing', rarity: 'common' },
                    
                    // Rare weapons
                    { name: 'Long Sword', cost: 50, attack: 6, damageType: 'slashing', rarity: 'rare' },
                    { name: 'Battle Axe', cost: 75, attack: 8, damageType: 'slashing', rarity: 'rare' },
                    { name: 'War Hammer', cost: 65, attack: 7, damageType: 'blunt', rarity: 'rare' },
                    { name: 'Staff', cost: 20, attack: 1, mp: 5, damageType: 'blunt', rarity: 'common' },
                    
                    // Epic weapons
                    { name: 'Mystic Wand', cost: 100, attack: 3, mp: 10, damageType: 'elemental', rarity: 'epic' },
                    { name: 'Frost Blade', cost: 150, attack: 9, damageType: 'slashing', special: 'Chance to freeze enemy', rarity: 'epic' },
                    { name: 'Dragonbone Mace', cost: 180, attack: 10, damageType: 'blunt', special: '+2 attack vs dragons', rarity: 'epic' },
                    
                    // Set items
                    { name: 'Forest Stalker Dagger', cost: 200, attack: 5, damageType: 'piercing', set: 'Forest Stalker', rarity: 'set' },
                    { name: 'Knight\'s Broadsword', cost: 250, attack: 8, defense: 2, damageType: 'slashing', set: 'Knight\'s Armor', rarity: 'set' },
                    
                    // Legendary artifacts
                    { name: 'Soulreaper', cost: 500, attack: 12, mp: 15, damageType: 'elemental', special: 'Drains life from enemies', rarity: 'legendary' },
                    { name: 'World Breaker', cost: 600, attack: 15, damageType: 'blunt', special: 'Ignores enemy defense', rarity: 'legendary' }
                ],
                armor: [
                    { name: 'Leather Armor', cost: 30, defense: 2, rarity: 'common' },
                    { name: 'Chainmail', cost: 70, defense: 4, rarity: 'rare' },
                    { name: 'Plate Armor', cost: 150, defense: 6, rarity: 'epic' },
                    { name: 'Robe', cost: 25, defense: 1, mp: 3, rarity: 'common' },
                    
                    // Set armor
                    { name: 'Forest Stalker Cloak', cost: 120, defense: 3, mp: 5, set: 'Forest Stalker', rarity: 'set' },
                    { name: 'Knight\'s Plate', cost: 300, defense: 8, attack: 1, set: 'Knight\'s Armor', rarity: 'set' },
                    
                    // Legendary armor
                    { name: 'Dragon Scale Mail', cost: 400, defense: 10, special: 'Fire resistance', rarity: 'legendary' }
                ],
                potions: [
                    { name: 'Healing Potion', cost: 15, effect: 'heal', value: 10, rarity: 'common' },
                    { name: 'Mana Potion', cost: 20, effect: 'mana', value: 10, rarity: 'common' },
                    { name: 'Antidote', cost: 10, effect: 'cure', value: 0, rarity: 'common' },
                    
                    // Enhanced potions with trade-offs
                    { name: 'Berserker Potion', cost: 40, effect: 'berserk', value: 5, special: '+5 attack, -3 defense for 3 battles', rarity: 'rare' },
                    { name: 'Stone Skin Elixir', cost: 35, effect: 'stoneskin', value: 4, special: '+4 defense, -2 attack for 3 battles', rarity: 'rare' },
                    { name: 'Focus Draught', cost: 30, effect: 'focus', value: 3, special: 'Next spell costs 0 MP', rarity: 'rare' },
                    
                    // Legendary potions
                    { name: 'Elixir of Life', cost: 100, effect: 'fullheal', value: 0, special: 'Fully restores entire party', rarity: 'legendary' }
                ],
                scrolls: [
                    { name: 'Scroll of Fireball', cost: 50, effect: 'spell', value: 'fireball', uses: 1, rarity: 'rare' },
                    { name: 'Scroll of Healing', cost: 40, effect: 'spell', value: 'heal', uses: 1, rarity: 'rare' },
                    { name: 'Scroll of Teleport', cost: 100, effect: 'teleport', value: 'rivertown', uses: 1, rarity: 'epic' }
                ],
                poisons: [
                    { name: 'Basic Poison', cost: 25, effect: 'poison', value: 2, duration: 3, rarity: 'common' },
                    { name: 'Deathbloom Extract', cost: 60, effect: 'poison', value: 5, duration: 2, rarity: 'rare' }
                ]
            },
            
            // Set bonuses
            setBonuses: {
                'Forest Stalker': {
                    2: 'Backstab does double damage',
                    4: 'Can hide in combat'
                },
                'Knight\'s Armor': {
                    2: '+2 defense',
                    4: 'Taunt forces enemies to attack you'
                }
            },
            
            // Enemy weaknesses based on damage type
            enemyWeaknesses: {
                'skeleton': { strongVs: 'slashing', weakVs: 'blunt', extraDamage: 1.5 },
                'ghost': { strongVs: 'piercing', weakVs: 'elemental', extraDamage: 2.0 },
                'zombie': { strongVs: 'piercing', weakVs: 'slashing', extraDamage: 1.3 },
                'troll': { strongVs: 'blunt', weakVs: 'fire', extraDamage: 1.8 },
                'yeti': { strongVs: 'slashing', weakVs: 'fire', extraDamage: 1.6 }
            },
            
            // Quests
            quests: [
                {
                    id: 'goblinmenace',
                    name: 'Goblin Menace',
                    description: 'Clear the goblins from Deepwood Forest.',
                    location: 'deepwood',
                    reward: 50,
                    required: 'defeat goblin',
                    status: 'available',
                    xpReward: 100
                },
                {
                    id: 'missingminer',
                    name: 'Missing Miner',
                    description: 'Find the missing dwarf miner in the Frostpeak Mountains.',
                    location: 'frostpeak',
                    reward: 75,
                    required: 'find miner',
                    status: 'available',
                    xpReward: 150
                },
                {
                    id: 'wizardsrequest',
                    name: "Wizard's Request",
                    description: 'Retrieve the ancient tome from the Darkmarsh for the wizard.',
                    location: 'darkmarsh',
                    reward: 100,
                    required: 'retrieve tome',
                    status: 'available',
                    xpReward: 200
                }
            ],
            
            // Gameplay
            gamePhase: 'start',
            commandHistory: [],
            historyIndex: -1,
            shopContext: null,
            
            // Combat state
            inCombat: false,
            currentEnemy: null,
            combatTurns: 0,
            combatBonusActive: false,
            
            // NEW: Track active party exploration abilities
            activePartyAbilities: []
        };

        // DOM elements
        const gameText = document.getElementById('game-text');
        const userInput = document.getElementById('user-input');
        const submitBtn = document.getElementById('submit-btn');
        const partyDisplay = document.getElementById('party-display');
        const locationValue = document.getElementById('location-value');
        const goldValue = document.getElementById('gold-value');
        const dayValue = document.getElementById('day-value');
        const questValue = document.getElementById('quest-value');
        const travelButtons = document.getElementById('travel-buttons');

        // Initialize game
        function initGame() {
            gameText.innerHTML = '';
            addText("RETRO TEXT ADVENTURE");
            addText("====================");
            addText("");
            addText("In the tradition of classic 80s CRPGs like Ultima, Wizardry, and Might & Magic.");
            addText("");
            addText("Type <strong>START</strong> to begin your adventure.");
            addText("Type <strong>HELP</strong> for a list of commands at any time.");
            
            submitBtn.addEventListener('click', processCommand);
            userInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') {
                    processCommand();
                } else if (event.key === 'ArrowUp') {
                    if (gameState.commandHistory.length > 0) {
                        if (gameState.historyIndex < gameState.commandHistory.length - 1) {
                            gameState.historyIndex++;
                        }
                        userInput.value = gameState.commandHistory[gameState.commandHistory.length - 1 - gameState.historyIndex];
                    }
                } else if (event.key === 'ArrowDown') {
                    if (gameState.historyIndex > 0) {
                        gameState.historyIndex--;
                        userInput.value = gameState.commandHistory[gameState.commandHistory.length - 1 - gameState.historyIndex];
                    } else {
                        gameState.historyIndex = -1;
                        userInput.value = '';
                    }
                }
            });
            
            document.addEventListener('keydown', function(event) {
                if (gameState.gamePhase === 'start' && event.key !== 'Enter') {
                    addText("");
                    addText("You have entered the Adventurers Guild.");
                    addText("The Guildmaster approaches you.");
                    addText("");
                    addText("<em>'Welcome, adventurer! I see you seek fortune and glory.'</em>");
                    addText("<em>'First, you must assemble your party. Choose 1 to 3 companions from our roster.'</em>");
                    addText("");
                    addText("Type <strong>CREATE PARTY</strong> to begin.");
                    
                    gameState.gamePhase = 'partyCreation';
                    updateStats();
                    updateTravelButtons();
                    userInput.focus();
                }
            });
            
            updateStats();
            updateTravelButtons();
        }

        // Update travel buttons
        function updateTravelButtons() {
            travelButtons.innerHTML = '';
            
            if (gameState.gamePhase !== 'playing') {
                travelButtons.innerHTML = '<p style="color:#888; text-align:center; font-size:0.9rem;">Travel destinations will appear here once you start the game.</p>';
                return;
            }
            
            const currentLocation = gameState.locations[gameState.location];
            
            if (currentLocation && currentLocation.connections) {
                currentLocation.connections.forEach(connectionKey => {
                    const destination = gameState.locations[connectionKey];
                    if (destination) {
                        const button = document.createElement('button');
                        button.className = 'travel-btn';
                        button.textContent = destination.name;
                        button.title = `Travel to ${destination.name}`;
                        
                        button.addEventListener('click', function() {
                            travelToLocation(connectionKey);
                        });
                        
                        travelButtons.appendChild(button);
                    }
                });
                
                // Check for secret locations (revealed by lore)
                if (gameState.foundLoreBooks.includes('Moons of Legend')) {
                    const moonTempleButton = document.createElement('button');
                    moonTempleButton.className = 'travel-btn';
                    moonTempleButton.textContent = 'Moon Temple (Secret)';
                    moonTempleButton.title = 'Travel to secret Moon Temple';
                    moonTempleButton.style.borderColor = '#ff0';
                    moonTempleButton.addEventListener('click', function() {
                        travelToLocation('moontemple');
                    });
                    travelButtons.appendChild(moonTempleButton);
                }
                
                const refreshButton = document.createElement('button');
                refreshButton.className = 'travel-btn';
                refreshButton.textContent = '‚ü≥ Refresh List';
                refreshButton.title = 'Refresh travel destinations';
                refreshButton.style.marginTop = '10px';
                refreshButton.style.backgroundColor = '#111';
                refreshButton.addEventListener('click', function() {
                    updateTravelButtons();
                    addText("Travel destinations list refreshed.");
                });
                travelButtons.appendChild(refreshButton);
            }
            
            if (travelButtons.children.length === 0) {
                travelButtons.innerHTML = '<p style="color:#888; text-align:center; width:100%;">No travel options from here</p>';
            }
        }

        // NEW: Function to handle travel via button click
        function travelToLocation(locationKey) {
            if (!locationKey) return;
            
            const destination = gameState.locations[locationKey];
            if (!destination) return;
            
            // Set the input field to show the command
            userInput.value = `travel ${destination.name.toLowerCase()}`;
            
            // Process the travel command
            addText(`<strong>>></strong> travel ${destination.name.toLowerCase()}`);
            travel(destination.name.toLowerCase());
        }

        // Add text to game display
        function addText(text) {
            const p = document.createElement('p');
            p.innerHTML = text;
            gameText.appendChild(p);
            gameText.scrollTop = gameText.scrollHeight;
        }

        // Process player command
        function processCommand() {
            const command = userInput.value.trim().toLowerCase();
            userInput.value = '';
            
            if (!command) return;
            
            gameState.commandHistory.push(command);
            gameState.historyIndex = -1;
            
            addText(`<strong>>></strong> ${command}`);
            
            switch(gameState.gamePhase) {
                case 'start':
                    handleStartPhase(command);
                    break;
                case 'partyCreation':
                    handlePartyCreation(command);
                    break;
                case 'playing':
                    handlePlayingPhase(command);
                    break;
            }
            
            updateTravelButtons();
        }

        // Handle start phase commands
        function handleStartPhase(command) {
            if (command === 'start') {
                addText("");
                addText("You have entered the Adventurers Guild.");
                addText("The Guildmaster approaches you.");
                addText("");
                addText("<em>'Welcome, adventurer! I see you seek fortune and glory.'</em>");
                addText("<em>'First, you must assemble your party. Choose 1 to 3 companions from our roster.'</em>");
                addText("");
                addText("Type <strong>CREATE PARTY</strong> to begin.");
                
                gameState.gamePhase = 'partyCreation';
                updateTravelButtons();
            } else {
                addText(`Type <strong>START</strong> to begin your adventure.`);
            }
        }

        // Handle party creation commands
        function handlePartyCreation(command) {
            if (command === 'create party' || command === 'create') {
                showClassSelection();
            } else if (command.startsWith('add ')) {
                const className = command.substring(4);
                addPartyMember(className);
            } else if (command === 'done') {
                if (gameState.party.length === 0) {
                    addText("<span class='error'>You need at least one party member to begin!</span>");
                    showClassSelection();
                } else {
                    startGame();
                }
            } else if (command === 'list classes') {
                showClassSelection();
            } else if (command === 'help') {
                addText("<strong>Party Creation Commands:</strong>");
                addText("CREATE PARTY - Show available classes");
                addText("ADD [class] - Add a character of that class to your party");
                addText("LIST CLASSES - Show available classes again");
                addText("DONE - Finish party creation and begin adventure");
                addText("");
                addText("<strong>Available Classes:</strong> Warrior, Wizard, Rogue, Necromancer, Thief, Priest, Sorcerer, Healer");
            } else {
                addText("<span class='error'>Unknown command. Type HELP for available commands.</span>");
            }
        }

        // Show class selection
        function showClassSelection() {
            addText("");
            addText("<strong>Available Adventurers:</strong>");
            
            gameState.classes.forEach(cls => {
                addText(`<span class='class-option' onclick="document.getElementById('user-input').value='add ${cls.id}'; processCommand()">${cls.name}</span> - HP: ${cls.baseHp}, MP: ${cls.baseMp}, Attack: ${cls.baseAttack}, Defense: ${cls.baseDefense}`);
                addText(`  Skills: ${cls.explorationSkills.join(', ')}`);
                addText(`  Specializations at Level 5: ${cls.specializations.join(', ')}`);
            });
            
            addText("");
            addText(`Your party has <strong>${gameState.party.length}/${gameState.maxPartySize}</strong> members.`);
            addText("Type <strong>ADD [class]</strong> to add a character (e.g. ADD warrior)");
            addText("Type <strong>DONE</strong> when your party is complete.");
        }

        // Add a party member
        function addPartyMember(className) {
            if (gameState.party.length >= gameState.maxPartySize) {
                addText(`<span class='error'>Your party is full (max ${gameState.maxPartySize}). Type DONE to continue.</span>`);
                return;
            }
            
            const classData = gameState.classes.find(c => c.id === className || c.name.toLowerCase() === className);
            
            if (!classData) {
                addText(`<span class='error'>Unknown class: ${className}. Type LIST CLASSES to see available classes.</span>`);
                return;
            }
            
            const charId = gameState.party.length + 1;
            const character = {
                id: charId,
                name: `${classData.name} ${charId}`,
                class: classData.name,
                baseClass: classData.id,
                level: 1,
                xp: 0,
                xpToNext: classData.xpToNext,
                hp: classData.baseHp,
                maxHp: classData.baseHp,
                mp: classData.baseMp,
                maxMp: classData.baseMp,
                attack: classData.baseAttack,
                defense: classData.baseDefense,
                skills: [...classData.skills],
                explorationSkills: [...classData.explorationSkills],
                skillLevels: {}, // Will be populated with skill levels
                weapon: 'None',
                armor: 'None',
                damageType: 'slashing', // Default
                specialization: null,
                setItems: []
            };
            
            // Initialize skill levels (1-5 scale based on class affinity)
            character.explorationSkills.forEach(skill => {
                // Base skill level: 1 for primary skills, 0 for others (but we'll set all to 1 for now)
                character.skillLevels[skill] = 1;
            });
            
            // Give bonus to primary class skills
            if (classData.id === 'rogue' || classData.id === 'thief') {
                character.skillLevels['lockpick'] = 3;
                character.skillLevels['stealth'] = 3;
            }
            if (classData.id === 'wizard' || classData.id === 'sorcerer' || classData.id === 'necromancer') {
                character.skillLevels['arcane'] = 3;
            }
            if (classData.id === 'warrior') {
                character.skillLevels['strength'] = 3;
                character.skillLevels['intimidate'] = 2;
            }
            if (classData.id === 'priest') {
                character.skillLevels['religion'] = 3;
                character.skillLevels['persuade'] = 2;
            }
            
            gameState.party.push(character);
            updatePartyDisplay();
            
            addText(`<span class='success'>Added ${character.name} to your party.</span>`);
            addText(`Your party now has <strong>${gameState.party.length}/${gameState.maxPartySize}</strong> members.`);
            
            if (gameState.party.length >= gameState.maxPartySize) {
                addText("<span class='blink'>Your party is full! Type DONE to begin your adventure.</span>");
            }
        }

        // Start the game proper
        function startGame() {
            gameState.gamePhase = 'playing';
            gameState.location = 'start';
            
            // NEW: Calculate and display party exploration abilities
            calculatePartyAbilities();
            
            addText("");
            addText("<span class='success'>Your party is assembled! The adventure begins...</span>");
            addText("");
            addText("The Guildmaster nods approvingly at your party.");
            addText("<em>'Excellent choices! Now, the real challenge begins.'</em>");
            addText("<em>'You should start by traveling to Rivertown. Just click the RIVERTOWN button in the Travel Panel.'</em>");
            addText("");
            addText("You are at the <span class='location'>Adventurers Guild</span>.");
            addText("Type <strong>LOOK</strong> to examine your surroundings.");
            addText("Type <strong>HELP</strong> for a list of commands.");
            addText("You can also click travel destinations in the <strong>TRAVEL DESTINATIONS</strong> panel.");
            
            // NEW: Show available skill challenges
            checkLocationSkillChallenges();
            
            updateStats();
            updateTravelButtons();
        }

        // NEW: Calculate party exploration abilities based on composition
        function calculatePartyAbilities() {
            gameState.activePartyAbilities = [];
            const partyClasses = gameState.party.map(char => char.class);
            
            // Check single class abilities
            gameState.party.forEach(char => {
                const ability = gameState.partyExplorationAbilities[char.baseClass];
                if (ability && !gameState.activePartyAbilities.some(a => a.name === ability.name)) {
                    gameState.activePartyAbilities.push(ability);
                }
            });
            
            // Check multi-class abilities
            Object.entries(gameState.partyExplorationAbilities).forEach(([key, ability]) => {
                if (ability.requires) {
                    const hasAllRequirements = ability.requires.every(reqClass => 
                        partyClasses.some(pClass => pClass.toLowerCase().includes(reqClass.toLowerCase()))
                    );
                    
                    if (hasAllRequirements && !gameState.activePartyAbilities.some(a => a.name === ability.name)) {
                        gameState.activePartyAbilities.push(ability);
                    }
                }
            });
            
            // Display abilities
            if (gameState.activePartyAbilities.length > 0) {
                addText("<strong>Party Exploration Abilities:</strong>");
                gameState.activePartyAbilities.forEach(ability => {
                    addText(`<span class='party-ability'>${ability.name}</span>: ${ability.description}`);
                });
                addText("");
            }
        }

        // NEW: Check for skill challenges in current location
        function checkLocationSkillChallenges() {
            const loc = gameState.locations[gameState.location];
            if (loc.skillChallenges && loc.skillChallenges.length > 0) {
                // Check which challenges are already completed
                const incompleteChallenges = loc.skillChallenges.filter(challenge => 
                    !gameState.foundChallenges.includes(`${gameState.location}_${challenge.type}`)
                );
                
                if (incompleteChallenges.length > 0) {
                    addText("<span class='exploration-hint'>You notice opportunities to use your party's skills here. Type CHECK SKILLS to see them.</span>");
                }
            }
        }

        // Handle playing phase commands
        function handlePlayingPhase(command) {
            const parts = command.split(' ');
            const cmd = parts[0];
            const arg = parts.slice(1).join(' ');
            
            // NEW: Party skill commands
            if (cmd === 'check' && arg === 'skills') {
                showSkillChallenges();
                return;
            }
            
            if (cmd === 'use' && parts[1] === 'skill') {
                const skillType = parts[2];
                usePartySkill(skillType);
                return;
            }
            
            if (cmd === 'party' && arg === 'abilities') {
                showPartyAbilities();
                return;
            }
            
            if (cmd === 'skill' && parts[1] === 'check') {
                const skillType = parts[2];
                attemptSkillCheck(skillType);
                return;
            }
            
            // Check for exploration commands
            if (cmd === 'explore' || cmd === 'search') {
                exploreLocation();
                return;
            }
            
            if (cmd === 'shrine') {
                visitShrine();
                return;
            }
            
            if (cmd === 'puzzle') {
                solvePuzzle(arg);
                return;
            }
            
            if (cmd === 'lore') {
                readLore();
                return;
            }
            
            // Combat tactics
            if (gameState.inCombat) {
                if (cmd === 'tactics' || cmd === 'tactic') {
                    showCombatTactics();
                    return;
                }
                if (cmd === 'defensive' || cmd === 'defend') {
                    useDefensiveStance();
                    return;
                }
                if (cmd === 'power' || cmd === 'powerattack') {
                    usePowerAttack();
                    return;
                }
                if (cmd === 'focus') {
                    useFocus();
                    return;
                }
                if (cmd === 'flee') {
                    attemptFlee();
                    return;
                }
            }
            
            // Check shop context
            if (gameState.shopContext) {
                if (cmd === 'back' || cmd === 'exit') {
                    gameState.shopContext = null;
                    addText("You leave the shop.");
                    return;
                } else if (cmd === 'buy') {
                    buyItem(arg || command);
                    return;
                } else if (cmd === 'look' || cmd === 'list') {
                    showShopItems(gameState.shopContext);
                    return;
                } else {
                    buyItem(command);
                    return;
                }
            }
            
            // Normal command processing
            switch(cmd) {
                case 'help':
                    showHelp();
                    break;
                case 'look':
                    lookAround();
                    break;
                case 'travel':
                    travel(arg);
                    break;
                case 'status':
                    showStatus();
                    break;
                case 'party':
                    showParty();
                    break;
                case 'shop':
                    visitShop(arg);
                    break;
                case 'buy':
                    buyItem(arg);
                    break;
                case 'inn':
                    visitInn();
                    break;
                case 'rest':
                    rest();
                    break;
                case 'talk':
                    talkTo(arg);
                    break;
                case 'quest':
                    checkQuests();
                    break;
                case 'accept':
                    acceptQuest(arg);
                    break;
                case 'gold':
                    addText(`You have <span class='gold'>${gameState.gold} gold</span>.`);
                    break;
                case 'map':
                    showMap();
                    break;
                case 'attack':
                    randomEncounter();
                    break;
                case 'xp':
                    showXP();
                    break;
                case 'specialize':
                    specializeCharacter(arg);
                    break;
                case 'sets':
                    checkSetBonuses();
                    break;
                // Handle direct shop type commands
                case 'weapons':
                case 'items':
                case 'magic':
                    const loc = gameState.locations[gameState.location];
                    if (loc.shops && loc.shops.includes(cmd)) {
                        visitShop(cmd);
                    } else {
                        addText(`<span class='error'>There is no ${cmd} shop here.</span>`);
                    }
                    break;
                default:
                    addText("<span class='error'>Unknown command. Type HELP for available commands.</span>");
            }
        }

        // Show help with new commands
        function showHelp() {
            addText("<strong>Available Commands:</strong>");
            addText("<strong>EXPLORE</strong> - Search current location for hidden treasures");
            addText("<strong>SHRINE</strong> - Visit shrine for blessings (if available)");
            addText("<strong>LORE</strong> - Read lore books you've found");
            
            // NEW: Party skill commands
            addText("<strong>CHECK SKILLS</strong> - See available skill challenges here");
            addText("<strong>PARTY ABILITIES</strong> - Show your party's exploration abilities");
            addText("<strong>SKILL CHECK [type]</strong> - Attempt a skill challenge");
            addText("<strong>USE SKILL [type]</strong> - Use a party skill");
            
            addText("<strong>XP</strong> - Check party experience");
            addText("<strong>SPECIALIZE [name]</strong> - Choose specialization at level 5");
            addText("<strong>SETS</strong> - Check active set bonuses");
            addText("");
            addText("<strong>Combat Tactics (in combat only):</strong>");
            addText("DEFENSIVE - +2 defense, -1 attack");
            addText("POWER - +3 attack, -2 defense");
            addText("FOCUS - Next spell costs 0 MP");
            addText("FLEE - Attempt to escape combat");
            addText("");
            addText("<strong>Other Commands:</strong>");
            addText("HELP - Show this help message");
            addText("LOOK - Examine your surroundings");
            addText("TRAVEL [location] - Travel to another location");
            addText("STATUS - Show party status");
            addText("PARTY - Show detailed party information");
            addText("SHOP [type] - Visit a shop (weapons, items, magic)");
            addText("BUY [item] - Purchase an item");
            addText("INN - Visit the inn to rest");
            addText("REST - Rest to recover HP/MP");
            addText("TALK [npc] - Talk to an NPC");
            addText("QUEST - Check available quests");
            addText("ACCEPT [quest] - Accept a quest");
            addText("GOLD - Check your gold");
            addText("MAP - Show world map");
            addText("ATTACK - Trigger a random encounter");
            addText("");
            addText("<strong>Travel Tip:</strong> Use the <strong>TRAVEL DESTINATIONS</strong> panel to click where you want to go!");
        }

        // NEW: Show available skill challenges in current location
        function showSkillChallenges() {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.skillChallenges || loc.skillChallenges.length === 0) {
                addText("There are no skill challenges here.");
                return;
            }
            
            addText("<strong>Available Skill Challenges:</strong>");
            
            loc.skillChallenges.forEach((challenge, index) => {
                const challengeKey = `${gameState.location}_${challenge.type}`;
                const isCompleted = gameState.foundChallenges.includes(challengeKey);
                
                if (isCompleted) {
                    addText(`${index + 1}. <span class='skill-success'>‚úì ${challenge.description}</span> (Completed)`);
                } else {
                    // Check if party has required skill
                    const skilledMembers = gameState.party.filter(char => 
                        char.explorationSkills.includes(challenge.type) && char.skillLevels[challenge.type] >= challenge.difficulty
                    );
                    
                    if (skilledMembers.length > 0) {
                        const bestMember = skilledMembers.reduce((best, current) => 
                            current.skillLevels[challenge.type] > best.skillLevels[challenge.type] ? current : best
                        );
                        
                        addText(`${index + 1}. <span class='skill-check'>${challenge.description}</span>`);
                        addText(`   Difficulty: ${challenge.difficulty}/5 - Can attempt with ${bestMember.name} (Skill: ${bestMember.skillLevels[challenge.type]})`);
                        addText(`   Type <strong>SKILL CHECK ${challenge.type}</strong> to attempt`);
                    } else {
                        addText(`${index + 1}. <span class='skill-fail'>${challenge.description}</span>`);
                        addText(`   Difficulty: ${challenge.difficulty}/5 - No party member has required skill`);
                    }
                }
            });
            
            addText("");
            addText("Party Skills Summary:");
            gameState.party.forEach(char => {
                const skills = char.explorationSkills.map(skill => 
                    `${skill}: ${char.skillLevels[skill] || 0}`
                ).join(', ');
                addText(`  ${char.name}: ${skills}`);
            });
        }

        // NEW: Attempt a skill check
        function attemptSkillCheck(skillType) {
            if (!skillType) {
                addText("Which skill? Type SKILL CHECK [skill type] or CHECK SKILLS to see options.");
                return;
            }
            
            const loc = gameState.locations[gameState.location];
            if (!loc.skillChallenges) {
                addText("There are no skill challenges here.");
                return;
            }
            
            const challenge = loc.skillChallenges.find(c => c.type === skillType);
            if (!challenge) {
                addText(`No ${skillType} challenge found here. Type CHECK SKILLS to see available challenges.`);
                return;
            }
            
            const challengeKey = `${gameState.location}_${challenge.type}`;
            if (gameState.foundChallenges.includes(challengeKey)) {
                addText(`You've already completed this ${skillType} challenge.`);
                return;
            }
            
            // Find best party member for this skill
            const skilledMembers = gameState.party.filter(char => 
                char.explorationSkills.includes(skillType)
            );
            
            if (skilledMembers.length === 0) {
                addText(`<span class='skill-fail'>No party member has ${skillType} skill!</span>`);
                addText("You'll need to recruit someone with this skill to attempt this challenge.");
                return;
            }
            
            const bestMember = skilledMembers.reduce((best, current) => {
                const bestSkill = best.skillLevels[skillType] || 0;
                const currentSkill = current.skillLevels[skillType] || 0;
                return currentSkill > bestSkill ? current : best;
            });
            
            const memberSkillLevel = bestMember.skillLevels[skillType] || 0;
            const difficulty = challenge.difficulty;
            
            addText(`<span class='skill-check'>${bestMember.name} attempts ${skillType} challenge...</span>`);
            addText(`Challenge: ${challenge.description}`);
            addText(`Difficulty: ${difficulty}/5, ${bestMember.name}'s Skill: ${memberSkillLevel}/5`);
            
            // Calculate success chance (base 50% + 20% per skill level over difficulty)
            let successChance = 0.5;
            if (memberSkillLevel > difficulty) {
                successChance += (memberSkillLevel - difficulty) * 0.2;
            } else if (memberSkillLevel < difficulty) {
                successChance -= (difficulty - memberSkillLevel) * 0.15;
            }
            
            successChance = Math.max(0.1, Math.min(0.9, successChance));
            
            const roll = Math.random();
            const success = roll < successChance;
            
            if (success) {
                addText(`<span class='skill-success'>SUCCESS! ${bestMember.name} masters the challenge!</span>`);
                
                // Apply reward
                applySkillReward(challenge.reward, bestMember);
                
                // Mark challenge as completed
                gameState.foundChallenges.push(challengeKey);
                
                // Award XP
                bestMember.xp += 25 * difficulty;
                checkLevelUp(bestMember);
                
            } else {
                addText(`<span class='skill-fail'>FAILED! ${bestMember.name} couldn't complete the challenge.</span>`);
                
                // Small XP for trying
                bestMember.xp += 5;
                checkLevelUp(bestMember);
                
                // Some failures might have consequences
                if (Math.random() < 0.3) {
                    addText("The failed attempt attracts unwanted attention!");
                    if (loc.type === 'wilderness') {
                        randomEncounter();
                    }
                }
            }
            
            updatePartyDisplay();
        }

        // NEW: Apply skill challenge reward
        function applySkillReward(rewardType, member) {
            switch(rewardType) {
                case 'starter_gold':
                    const gold = Math.floor(Math.random() * 30) + 20;
                    gameState.gold += gold;
                    addText(`You find <span class='gold'>${gold} gold</span> hidden away!`);
                    break;
                    
                case 'magic_scroll':
                    addText("You find a <span class='item'>Scroll of Magic Missile</span>!");
                    // In full implementation, would add to inventory
                    break;
                    
                case 'shop_discount':
                    addText("The merchant is impressed! You get a 20% discount on your next purchase.");
                    // Would set a flag for discount
                    break;
                    
                case 'shortcut_access':
                    addText("You clear a shortcut! Travel time between locations is reduced.");
                    // Would modify travel mechanics
                    break;
                    
                case 'hunting_reward':
                    const meat = Math.floor(Math.random() * 3) + 1;
                    addText(`You successfully hunt and gain ${meat} portions of meat.`);
                    // Would add to supplies
                    break;
                    
                case 'avoid_encounter':
                    addText("You find a safe path, avoiding potential encounters.");
                    // Would reduce encounter chance temporarily
                    break;
                    
                case 'lore_insight':
                    member.xp += 50;
                    addText(`${member.name} gains insight! +50 XP.`);
                    checkLevelUp(member);
                    break;
                    
                case 'map_reveal':
                    addText("From the high vantage point, you spot hidden paths!");
                    // Would reveal hidden locations
                    break;
                    
                case 'safe_passage':
                    addText("You sneak past safely, avoiding a dangerous creature.");
                    break;
                    
                case 'healing_mushrooms':
                    addText("You find healing mushrooms! Restores 10 HP to each party member.");
                    gameState.party.forEach(char => {
                        char.hp = Math.min(char.maxHp, char.hp + 10);
                    });
                    updatePartyDisplay();
                    break;
                    
                case 'quest_info':
                    addText("You learn valuable information about a local quest!");
                    // Would give quest hints
                    break;
                    
                case 'ancient_secret':
                    addText("The hermit shares an ancient secret! All party members gain 30 XP.");
                    gameState.party.forEach(char => {
                        char.xp += 30;
                        checkLevelUp(char);
                    });
                    break;
                    
                case 'library_access':
                    addText("You gain access to the wizard's library! +1 to Arcane skill for all casters.");
                    gameState.party.forEach(char => {
                        if (char.explorationSkills.includes('arcane')) {
                            char.skillLevels['arcane'] = (char.skillLevels['arcane'] || 0) + 1;
                        }
                    });
                    break;
                    
                case 'rare_potion':
                    addText("You identify and claim a <span class='item'>Rare Healing Potion</span>!");
                    break;
                    
                case 'ambush_warning':
                    addText("You spot potential ambush sites! You'll be prepared if attacked.");
                    // Would give combat advantage
                    break;
                    
                case 'caravan_supplies':
                    const supplies = Math.floor(Math.random() * 40) + 20;
                    gameState.gold += supplies;
                    addText(`You find abandoned caravan supplies worth <span class='gold'>${supplies} gold</span>!`);
                    break;
                    
                case 'mountain_vista':
                    addText("The view is breathtaking! You spot distant landmarks.");
                    // Would reveal more of map
                    break;
                    
                case 'warm_shelter':
                    addText("You find a warm cave to rest in! Next rest here is free.");
                    // Would modify rest cost
                    break;
                    
                case 'weapon_upgrade':
                    addText("The blacksmith helps improve your weapon! +1 Attack to your main warrior.");
                    const warrior = gameState.party.find(char => char.class === 'Warrior');
                    if (warrior) {
                        warrior.attack += 1;
                    }
                    break;
                    
                case 'dwarven_ale':
                    addText("The dwarves share their finest ale! Party morale is boosted.");
                    // Would give temporary stat bonus
                    break;
                    
                case 'divine_blessing':
                    addText("The gods smile upon you! All party members gain +1 to all stats temporarily.");
                    gameState.party.forEach(char => {
                        char.attack += 1;
                        char.defense += 1;
                        char.maxHp += 5;
                        char.hp += 5;
                    });
                    break;
                    
                case 'temple_treasure':
                    const templeGold = Math.floor(Math.random() * 100) + 50;
                    gameState.gold += templeGold;
                    addText(`You find temple treasure worth <span class='gold'>${templeGold} gold</span>!`);
                    break;
            }
            
            updateStats();
        }

        // NEW: Use a party exploration ability
        function usePartySkill(skillType) {
            if (!skillType) {
                addText("Which skill? Type USE SKILL [skill type] or PARTY ABILITIES to see options.");
                return;
            }
            
            // Check if ability exists and party meets requirements
            let ability = null;
            
            // Check single class abilities first
            ability = gameState.partyExplorationAbilities[skillType.toLowerCase()];
            
            // If not found, check by name
            if (!ability) {
                Object.entries(gameState.partyExplorationAbilities).forEach(([key, ab]) => {
                    if (ab.name.toLowerCase().includes(skillType.toLowerCase())) {
                        ability = ab;
                    }
                });
            }
            
            if (!ability) {
                addText(`No party ability called '${skillType}'. Type PARTY ABILITIES to see available abilities.`);
                return;
            }
            
            // Check requirements for multi-class abilities
            if (ability.requires) {
                const partyClasses = gameState.party.map(char => char.class);
                const hasAllRequirements = ability.requires.every(reqClass => 
                    partyClasses.some(pClass => pClass.toLowerCase().includes(reqClass.toLowerCase()))
                );
                
                if (!hasAllRequirements) {
                    addText(`<span class='skill-fail'>Cannot use ${ability.name}: Need ${ability.requires.join(' and ')} in party.</span>`);
                    return;
                }
            }
            
            addText(`<span class='party-ability'>Using ${ability.name}...</span>`);
            addText(ability.effect);
            
            // Apply ability effects
            switch(ability.name) {
                case 'Detect Traps':
                    addText("You carefully search for traps...");
                    const loc = gameState.locations[gameState.location];
                    if (loc.hasTreasure && Math.random() < 0.7) {
                        addText("You detect a hidden trap near the treasure!");
                        addText("You can now safely retrieve it with EXPLORE.");
                    } else {
                        addText("No traps detected in this area.");
                    }
                    break;
                    
                case 'Arcane Sight':
                    addText("Magical energies become visible to you...");
                    // Would reveal magical items/secrets
                    if (gameState.location === 'stonetower' || gameState.location === 'moontemple') {
                        addText("You see powerful magical auras everywhere!");
                        addText("Hidden magical items are revealed!");
                    } else {
                        addText("You detect faint magical traces in the area.");
                    }
                    break;
                    
                case 'Force Open':
                    addText("Using brute force to break through obstacles...");
                    // Would open blocked paths
                    if (gameState.location === 'dwarffort' || gameState.location === 'stonetower') {
                        addText("You break open a sealed door! New area accessible.");
                    } else {
                        addText("You clear away debris, making travel easier.");
                    }
                    break;
                    
                case 'Divine Guidance':
                    addText("Praying for divine guidance...");
                    if (gameState.locations[gameState.location].hasShrine) {
                        addText("You sense a powerful holy presence nearby!");
                        addText("The shrine's location is revealed to you.");
                    } else {
                        addText("You feel a faint spiritual presence in the area.");
                    }
                    break;
                    
                case 'Holy Protection':
                    addText("The priest blesses the party for protection...");
                    addText("Divine energy surrounds your party. Random encounters reduced.");
                    // Would reduce encounter chance
                    break;
                    
                case 'Scout Ahead':
                    addText("Scouting the area ahead...");
                    const currentLoc = gameState.locations[gameState.location];
                    if (currentLoc.connections && currentLoc.connections.length > 0) {
                        const randomConnection = currentLoc.connections[Math.floor(Math.random() * currentLoc.connections.length)];
                        const dest = gameState.locations[randomConnection];
                        addText(`You scout the path to ${dest.name}: ${dest.description.substring(0, 100)}...`);
                    }
                    break;
                    
                case 'Expert Exploration':
                    addText("Your well-balanced party expertly explores the area...");
                    addText("All hidden treasures, traps, and secrets are revealed!");
                    // Would reveal everything in location
                    break;
            }
        }

        // NEW: Show party exploration abilities
        function showPartyAbilities() {
            if (gameState.activePartyAbilities.length === 0) {
                addText("Your party has no special exploration abilities yet.");
                addText("Different party compositions unlock different abilities.");
                return;
            }
            
            addText("<strong>Active Party Exploration Abilities:</strong>");
            gameState.activePartyAbilities.forEach(ability => {
                addText(`<span class='party-ability'>${ability.name}</span>: ${ability.description}`);
                addText(`  Effect: ${ability.effect}`);
                addText(`  Use with: <strong>USE SKILL ${ability.name.split(' ')[0].toUpperCase()}</strong>`);
                addText("");
            });
            
            // Show locked abilities based on current party
            addText("<strong>Potential Abilities (need different party):</strong>");
            Object.entries(gameState.partyExplorationAbilities).forEach(([key, ability]) => {
                if (!gameState.activePartyAbilities.some(a => a.name === ability.name)) {
                    const partyClasses = gameState.party.map(char => char.class);
                    
                    if (ability.requires) {
                        const missingClasses = ability.requires.filter(reqClass => 
                            !partyClasses.some(pClass => pClass.toLowerCase().includes(reqClass.toLowerCase()))
                        );
                        
                        if (missingClasses.length > 0) {
                            addText(`  ${ability.name}: Need ${missingClasses.join(' and ')}`);
                        }
                    } else if (!partyClasses.some(pClass => pClass.toLowerCase().includes(key))) {
                        addText(`  ${ability.name}: Need a ${key.charAt(0).toUpperCase() + key.slice(1)}`);
                    }
                }
            });
        }

        // Look around current location - UPDATED to show skill challenges
        function lookAround() {
            const loc = gameState.locations[gameState.location];
            addText(`You are at <span class='location'>${loc.name}</span>.`);
            addText(loc.description);
            
            if (loc.connections) {
                addText("<strong>Connections:</strong> " + loc.connections.map(c => gameState.locations[c].name).join(', '));
            }
            
            if (loc.shops) {
                addText("<strong>Shops:</strong> " + loc.shops.map(s => {
                    if (s === 'weapons') return 'Weapon Shop';
                    if (s === 'items') return 'Item Shop';
                    if (s === 'magic') return 'Magic Shop';
                    if (s === 'inn') return 'Inn';
                    return s;
                }).join(', '));
            }
            
            if (loc.npcs) {
                addText("<strong>NPCs:</strong> " + loc.npcs.map(n => {
                    if (n === 'elder') return 'Village Elder';
                    if (n === 'merchant') return 'Merchant';
                    if (n === 'guard') return 'Town Guard';
                    if (n === 'witch') return 'Swamp Witch';
                    if (n === 'hunter') return 'Marsh Hunter';
                    if (n === 'hermit') return 'Hermit';
                    if (n === 'wizard') return 'Archmage';
                    if (n === 'dwarfking') return 'Dwarf King';
                    if (n === 'smith') return 'Blacksmith';
                    if (n === 'miner') return 'Miner';
                    return n;
                }).join(', '));
            }
            
            // Exploration hints
            if (loc.hasTreasure && !gameState.foundTreasures.includes(gameState.location)) {
                addText("<span class='treasure'>You notice something glinting in the shadows... Type EXPLORE to search.</span>");
            }
            
            if (loc.hasShrine && !gameState.visitedShrines.includes(loc.shrineName)) {
                addText(`<span class='shrine'>You see a ${loc.shrineName} nearby. Type SHRINE to visit.</span>`);
            }
            
            if (loc.hasLore && !gameState.foundLoreBooks.includes(loc.loreBook)) {
                addText(`<span class='lore'>There's a book titled "${loc.loreBook}" here. Type LORE to read it.</span>`);
            }
            
            if (loc.hasPuzzle && !gameState.completedPuzzles.includes(loc.puzzleName)) {
                addText(`<span class='quest'>You discover ${loc.puzzleName}. Type PUZZLE to attempt it.</span>`);
            }
            
            // NEW: Skill challenge hints
            if (loc.skillChallenges && loc.skillChallenges.length > 0) {
                const incompleteChallenges = loc.skillChallenges.filter(challenge => 
                    !gameState.foundChallenges.includes(`${gameState.location}_${challenge.type}`)
                );
                
                if (incompleteChallenges.length > 0) {
                    addText("<span class='exploration-hint'>Opportunities for skilled party members here. Type CHECK SKILLS to see challenges.</span>");
                }
            }
            
            if (loc.type === 'wilderness') {
                addText(`<span class='error'>This area is dangerous! Enemies may appear at any time.</span>`);
            }
        }

        // EXPLORATION REWARDS: Search for treasure
        function exploreLocation() {
            const loc = gameState.locations[gameState.location];
            
            if (gameState.foundTreasures.includes(gameState.location)) {
                addText("<span class='error'>You've already searched this area thoroughly.</span>");
                return;
            }
            
            if (!loc.hasTreasure) {
                addText("You search the area but find nothing of value.");
                gameState.foundTreasures.push(gameState.location);
                return;
            }
            
            // Roll for treasure
            const foundTreasure = Math.random() < loc.treasureChance;
            
            if (foundTreasure) {
                addText("<span class='treasure'>You found hidden treasure!</span>");
                
                switch(loc.treasureType) {
                    case 'common':
                        const commonGold = Math.floor(Math.random() * 30) + 10;
                        gameState.gold += commonGold;
                        addText(`You find <span class='gold'>${commonGold} gold</span>!`);
                        break;
                        
                    case 'rare':
                        const rareGold = Math.floor(Math.random() * 50) + 25;
                        gameState.gold += rareGold;
                        const rareItem = Math.random() > 0.5 ? 'Healing Potion' : 'Mana Potion';
                        addText(`You find <span class='gold'>${rareGold} gold</span> and a <span class='item'>${rareItem}</span>!`);
                        break;
                        
                    case 'artifact':
                        addText(`<span class='artifact'>You discover an ancient artifact: Crystal Skull!</span>`);
                        addText("This powerful item increases all stats by 1 when carried.");
                        // In a full implementation, this would add an artifact item
                        break;
                        
                    case 'set_item':
                        const setItem = Math.random() > 0.5 ? 'Forest Stalker Dagger' : 'Forest Stalker Cloak';
                        addText(`<span class='set-item'>You find a ${setItem}!</span>`);
                        addText("This is part of a set - find more pieces for bonuses.");
                        // In a full implementation, this would add the set item
                        break;
                        
                    case 'legendary':
                        addText(`<span class='legendary'>LEGENDARY TREASURE: Dragon Hoard!</span>`);
                        const legendaryGold = Math.floor(Math.random() * 200) + 100;
                        gameState.gold += legendaryGold;
                        addText(`You find <span class='gold'>${legendaryGold} gold</span> and precious gems!`);
                        break;
                        
                    case 'hidden':
                        const hiddenGold = Math.floor(Math.random() * 40) + 20;
                        gameState.gold += hiddenGold;
                        addText(`You discover a hidden cache with <span class='gold'>${hiddenGold} gold</span>!`);
                        break;
                }
                
                // Award XP for finding treasure
                gameState.party.forEach(char => {
                    char.xp += 25;
                    checkLevelUp(char);
                });
                
            } else {
                addText("You search thoroughly but find nothing valuable.");
            }
            
            gameState.foundTreasures.push(gameState.location);
            updateStats();
        }

        // Visit shrine for blessings
        function visitShrine() {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.hasShrine) {
                addText("<span class='error'>There is no shrine here.</span>");
                return;
            }
            
            if (gameState.visitedShrines.includes(loc.shrineName)) {
                addText(`The ${loc.shrineName} has already blessed you. Its power is spent.`);
                return;
            }
            
            addText(`<span class='shrine'>You approach the ${loc.shrineName}...</span>`);
            addText(`A divine energy flows through your party!`);
            addText(`<strong>Effect:</strong> ${loc.shrineEffect}`);
            
            // Apply shrine effect
            if (loc.shrineEffect.includes('+1 permanent Attack')) {
                gameState.party.forEach(char => {
                    char.attack += 1;
                });
                addText("<span class='success'>All party members gain +1 permanent Attack!</span>");
            } else if (loc.shrineEffect.includes('+2 permanent Defense')) {
                gameState.party.forEach(char => {
                    char.defense += 2;
                });
                addText("<span class='success'>All party members gain +2 permanent Defense!</span>");
            } else if (loc.shrineEffect.includes('Moon Blessing')) {
                gameState.combatBonusActive = true;
                addText("<span class='success'>Party gains Moon Blessing: +10% critical hit chance!</span>");
            }
            
            gameState.visitedShrines.push(loc.shrineName);
            updatePartyDisplay();
        }

        // Read lore books
        function readLore() {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.hasLore) {
                addText("<span class='error'>There are no lore books here.</span>");
                return;
            }
            
            if (gameState.foundLoreBooks.includes(loc.loreBook)) {
                addText(`You've already read "${loc.loreBook}".`);
                return;
            }
            
            addText(`<span class='lore'>You read "${loc.loreBook}"...</span>`);
            addText(loc.loreEffect);
            
            // Apply lore effects
            if (loc.loreEffect.includes('gain 50 XP')) {
                gameState.party.forEach(char => {
                    char.xp += 50;
                    checkLevelUp(char);
                });
                addText("<span class='xp'>All party members gain 50 XP!</span>");
            } else if (loc.loreEffect.includes('+5 MP permanently')) {
                gameState.party.forEach(char => {
                    if (char.baseClass === 'wizard' || char.baseClass === 'sorcerer') {
                        char.maxMp += 5;
                        char.mp += 5;
                        addText(`<span class='success'>${char.name} gains +5 permanent MP!</span>`);
                    }
                });
            } else if (loc.loreEffect.includes('Reveals secret location')) {
                addText("<span class='success'>A secret location has been revealed on your map!</span>");
                addText("Check the Travel Panel to visit the Moon Temple.");
            }
            
            gameState.foundLoreBooks.push(loc.loreBook);
            updatePartyDisplay();
        }

        // Solve puzzle in ruins
        function solvePuzzle(puzzleAnswer) {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.hasPuzzle) {
                addText("<span class='error'>There is no puzzle here.</span>");
                return;
            }
            
            if (gameState.completedPuzzles.includes(loc.puzzleName)) {
                addText(`You've already solved the ${loc.puzzleName}.`);
                return;
            }
            
            if (!puzzleAnswer) {
                addText(`<span class='quest'>You examine the ${loc.puzzleName}...</span>`);
                addText("Ancient runes cover the walls. They seem to form a pattern.");
                addText("The puzzle appears to be a sequence: Sun, Moon, Star, Sun...");
                addText("Type <strong>PUZZLE [answer]</strong> to attempt the puzzle (e.g., PUZZLE moon)");
                return;
            }
            
            // Simple puzzle solution
            const correctAnswer = 'star';
            if (puzzleAnswer.toLowerCase() === correctAnswer) {
                addText(`<span class='success'>You solve the puzzle! The ${loc.puzzleName} opens!</span>`);
                addText(`<span class='artifact'>You find the ${loc.puzzleReward}!</span>`);
                
                // Award artifact and XP
                gameState.party.forEach(char => {
                    char.xp += 100;
                    checkLevelUp(char);
                });
                
                gameState.gold += 200;
                addText(`<span class='gold'>You also find 200 gold!</span>`);
                
                gameState.completedPuzzles.push(loc.puzzleName);
                updateStats();
                updatePartyDisplay();
            } else {
                addText("<span class='error'>Nothing happens. The puzzle remains unsolved.</span>");
                addText("Hint: Look at the pattern: Sun, Moon, Star, Sun... What comes after Moon?");
            }
        }

        // WEAPONS & COMBAT: Enhanced combat with weapon types
        function randomEncounter() {
            const loc = gameState.locations[gameState.location];
            
            if (loc.type !== 'wilderness') {
                addText("<span class='error'>There are no enemies here.</span>");
                return;
            }
            
            const enemies = [
                { name: 'Goblin', type: 'goblin', hp: 15, attack: 4, defense: 2 },
                { name: 'Wolf', type: 'wolf', hp: 12, attack: 5, defense: 1 },
                { name: 'Bandit', type: 'bandit', hp: 20, attack: 6, defense: 3 },
                { name: 'Skeleton', type: 'skeleton', hp: 18, attack: 5, defense: 4 },
                { name: 'Zombie', type: 'zombie', hp: 25, attack: 4, defense: 5 },
                { name: 'Ghost', type: 'ghost', hp: 15, attack: 7, defense: 2 },
                { name: 'Troll', type: 'troll', hp: 40, attack: 10, defense: 6 },
                { name: 'Yeti', type: 'yeti', hp: 35, attack: 9, defense: 5 }
            ];
            
            const enemy = enemies[Math.floor(Math.random() * enemies.length)];
            gameState.currentEnemy = enemy;
            gameState.inCombat = true;
            gameState.combatTurns = 0;
            
            addText(`<span class='enemy'>A wild ${enemy.name} appears!</span>`);
            addText(`Type <strong>ATTACK</strong> to fight or <strong>TACTICS</strong> for combat options.`);
            
            // Show enemy weakness hint if known
            if (gameState.enemyWeaknesses[enemy.type]) {
                const weakness = gameState.enemyWeaknesses[enemy.type];
                addText(`<span class='damage-${weakness.weakVs}'>This enemy looks vulnerable to ${weakness.weakVs} attacks.</span>`);
            }
        }

        // Show combat tactics
        function showCombatTactics() {
            if (!gameState.inCombat) {
                addText("<span class='error'>You're not in combat!</span>");
                return;
            }
            
            addText("<strong>Combat Tactics:</strong>");
            addText("DEFENSIVE - +2 defense, -1 attack for this combat");
            addText("POWER - +3 attack, -2 defense for this combat");
            addText("FOCUS - Next spell costs 0 MP (casters only)");
            addText("FLEE - Attempt to escape (50% chance)");
            addText("ATTACK - Standard attack");
            addText("");
            addText(`Enemy: ${gameState.currentEnemy.name} (HP: ${gameState.currentEnemy.hp})`);
        }

        // Use defensive stance
        function useDefensiveStance() {
            if (!gameState.inCombat) return;
            
            addText("<span class='success'>Your party takes a defensive stance!</span>");
            addText("+2 defense, -1 attack for this combat.");
            
            // Apply temporary bonuses (would be stored in combat state in full implementation)
            gameState.combatTurns++;
            resolveCombatRound('defensive');
        }

        // Use power attack
        function usePowerAttack() {
            if (!gameState.inCombat) return;
            
            addText("<span class='success'>Your party prepares a power attack!</span>");
            addText("+3 attack, -2 defense for this combat.");
            
            gameState.combatTurns++;
            resolveCombatRound('power');
        }

        // Use focus
        function useFocus() {
            if (!gameState.inCombat) return;
            
            // Check if party has casters
            const hasCaster = gameState.party.some(char => 
                char.baseClass === 'wizard' || char.baseClass === 'sorcerer' || char.baseClass === 'priest' || char.baseClass === 'necromancer'
            );
            
            if (!hasCaster) {
                addText("<span class='error'>No spellcasters in party to focus!</span>");
                return;
            }
            
            addText("<span class='success'>Your spellcasters focus their power!</span>");
            addText("Next spell will cost 0 MP.");
            
            gameState.combatTurns++;
            resolveCombatRound('focus');
        }

        // Attempt to flee
        function attemptFlee() {
            if (!gameState.inCombat) return;
            
            const fleeChance = 0.5;
            if (Math.random() < fleeChance) {
                addText("<span class='success'>You successfully escape from combat!</span>");
                gameState.inCombat = false;
                gameState.currentEnemy = null;
            } else {
                addText("<span class='error'>You fail to escape! The enemy attacks!</span>");
                gameState.combatTurns++;
                resolveCombatRound('flee');
            }
        }

        // Resolve combat round
        function resolveCombatRound(tactic) {
            if (!gameState.inCombat || !gameState.currentEnemy) return;
            
            // Calculate party attack with weapon type bonuses
            let partyAttack = gameState.party.reduce((sum, char) => {
                let charAttack = char.attack;
                
                // Apply tactic bonuses
                if (tactic === 'defensive') charAttack -= 1;
                if (tactic === 'power') charAttack += 3;
                
                // Check weapon type vs enemy weakness
                if (gameState.enemyWeaknesses[gameState.currentEnemy.type]) {
                    const weakness = gameState.enemyWeaknesses[gameState.currentEnemy.type];
                    if (char.damageType === weakness.weakVs) {
                        addText(`<span class='damage-${char.damageType}'>${char.name}'s ${char.damageType} weapon is super effective!</span>`);
                        charAttack *= weakness.extraDamage;
                    }
                }
                
                return sum + charAttack;
            }, 0);
            
            // Apply combat bonus if active
            if (gameState.combatBonusActive && Math.random() < 0.1) {
                addText("<span class='shrine'>Moon Blessing activates! Critical hit!</span>");
                partyAttack *= 1.5;
            }
            
            const partyDefense = gameState.party.reduce((sum, char) => {
                let charDefense = char.defense;
                if (tactic === 'defensive') charDefense += 2;
                if (tactic === 'power') charDefense -= 2;
                return sum + charDefense;
            }, 0);
            
            const enemyPower = gameState.currentEnemy.attack * (1 + gameState.combatTurns * 0.1);
            
            if (partyAttack > enemyPower) {
                // Party wins
                const goldGained = Math.floor(Math.random() * 20 * gameState.currentEnemy.hp / 10) + 5;
                const xpGained = Math.floor(gameState.currentEnemy.hp * 2);
                
                gameState.gold += goldGained;
                
                addText(`<span class='success'>Your party defeats the ${gameState.currentEnemy.name}!</span>`);
                addText(`You find <span class='gold'>${goldGained} gold</span> on the body.`);
                
                // Award XP
                gameState.party.forEach(char => {
                    char.xp += xpGained;
                    checkLevelUp(char);
                });
                addText(`<span class='xp'>Party gains ${xpGained} XP!</span>`);
                
                // Check if this completes a quest
                if (gameState.currentQuest && gameState.currentQuest.required === `defeat ${gameState.currentEnemy.type}`) {
                    completeQuest();
                }
                
                gameState.inCombat = false;
                gameState.currentEnemy = null;
                
            } else {
                // Enemy damages party
                const damage = Math.floor(enemyPower / partyDefense);
                
                addText(`<span class='error'>The ${gameState.currentEnemy.name} wounds your party!</span>`);
                addText(`Each party member takes <span class='health'>${damage} damage</span>.`);
                
                // Apply damage
                gameState.party.forEach(char => {
                    char.hp = Math.max(1, char.hp - damage);
                });
                
                updatePartyDisplay();
                
                addText("The enemy prepares for another attack!");
                addText("Type <strong>ATTACK</strong> to continue fighting or <strong>TACTICS</strong> for options.");
            }
        }

        // CLASSES & PROGRESSION: Check for level up
        function checkLevelUp(character) {
            while (character.xp >= character.xpToNext) {
                character.xp -= character.xpToNext;
                character.level++;
                character.xpToNext = Math.floor(character.xpToNext * 1.5);
                
                // Stat increases
                character.maxHp += Math.floor(character.maxHp * 0.1) + 2;
                character.hp = character.maxHp;
                
                if (character.maxMp > 0) {
                    character.maxMp += Math.floor(character.maxMp * 0.1) + 1;
                    character.mp = character.maxMp;
                }
                
                character.attack += 1;
                character.defense += 1;
                
                // NEW: Occasionally improve exploration skills on level up
                if (Math.random() < 0.3) {
                    const skillToImprove = character.explorationSkills[Math.floor(Math.random() * character.explorationSkills.length)];
                    character.skillLevels[skillToImprove] = (character.skillLevels[skillToImprove] || 0) + 1;
                    addText(`<span class='skill-success'>${character.name}'s ${skillToImprove} skill improves to level ${character.skillLevels[skillToImprove]}!</span>`);
                }
                
                addText(`<span class='level-up'>${character.name} reaches level ${character.level}!</span>`);
                addText(`HP: +${Math.floor(character.maxHp * 0.1) + 2}, Attack: +1, Defense: +1`);
                
                // Check for specialization eligibility
                const classData = gameState.classes.find(c => c.id === character.baseClass);
                if (character.level >= classData.specializationLevel && !character.specialization) {
                    addText(`<span class='specialization'>${character.name} can now specialize! Type SPECIALIZE ${character.name} to choose.</span>`);
                    addText(`Options: ${classData.specializations.join(' or ')}`);
                }
            }
            updatePartyDisplay();
        }

        // Show XP for party
        function showXP() {
            addText("<strong>Party Experience:</strong>");
            gameState.party.forEach(char => {
                const xpPercent = Math.floor((char.xp / char.xpToNext) * 100);
                addText(`${char.name} - Level ${char.level}: ${char.xp}/${char.xpToNext} XP (${xpPercent}%)`);
                if (char.specialization) {
                    addText(`  Specialization: <span class='specialization'>${char.specialization}</span>`);
                }
            });
        }

        // Specialize a character
        function specializeCharacter(charName) {
            if (!charName) {
                addText("Specialize which character? Type SPECIALIZE [character name].");
                return;
            }
            
            const character = gameState.party.find(char => 
                char.name.toLowerCase().includes(charName.toLowerCase())
            );
            
            if (!character) {
                addText(`<span class='error'>No character named '${charName}' in party.</span>`);
                return;
            }
            
            const classData = gameState.classes.find(c => c.id === character.baseClass);
            
            if (character.level < classData.specializationLevel) {
                addText(`<span class='error'>${character.name} must reach level ${classData.specializationLevel} to specialize.</span>`);
                return;
            }
            
            if (character.specialization) {
                addText(`<span class='error'>${character.name} is already specialized as ${character.specialization}.</span>`);
                return;
            }
            
            addText(`<strong>Choose specialization for ${character.name}:</strong>`);
            addText(`1. ${classData.specializations[0]}`);
            addText(`2. ${classData.specializations[1]}`);
            addText("");
            addText(`Type <strong>SPECIALIZE ${character.name} [1 or 2]</strong> to choose.`);
            
            // Store pending specialization
            character.pendingSpecialization = true;
        }

        // Check set bonuses
        function checkSetBonuses() {
            addText("<strong>Active Set Bonuses:</strong>");
            
            // Check each character for set items
            gameState.party.forEach(char => {
                if (char.setItems.length > 0) {
                    addText(`${char.name} has ${char.setItems.length} set items: ${char.setItems.join(', ')}`);
                    
                    // Check for specific sets
                    const forestStalkerItems = char.setItems.filter(item => item.includes('Forest Stalker')).length;
                    const knightItems = char.setItems.filter(item => item.includes('Knight')).length;
                    
                    if (forestStalkerItems >= 2) {
                        addText(`  Forest Stalker (2/4): Backstab does double damage`);
                    }
                    if (knightItems >= 2) {
                        addText(`  Knight's Armor (2/4): +2 defense`);
                    }
                }
            });
            
            if (!gameState.party.some(char => char.setItems.length > 0)) {
                addText("No set bonuses active. Find matching set items for bonuses!");
            }
        }

        // Travel to a location
        function travel(locationName) {
            if (!locationName) {
                addText("Travel where? Type TRAVEL [location] or click a destination in the Travel Panel.");
                if (gameState.location === 'start') {
                    addText("From here you can travel to: <strong>RIVERTOWN</strong>");
                } else {
                    const loc = gameState.locations[gameState.location];
                    addText("From here you can travel to: " + loc.connections.map(c => `<strong>${gameState.locations[c].name.toUpperCase().replace(' ', '')}</strong>`).join(', '));
                }
                return;
            }
            
            // Find location by name or partial match
            const currentLoc = gameState.locations[gameState.location];
            const targetLocKey = currentLoc.connections.find(conn => 
                gameState.locations[conn].name.toLowerCase().includes(locationName.toLowerCase()) ||
                conn.toLowerCase().includes(locationName.toLowerCase())
            );
            
            if (!targetLocKey) {
                addText(`<span class='error'>You cannot travel to ${locationName} from here.</span>`);
                addText("Available destinations: " + currentLoc.connections.map(c => gameState.locations[c].name).join(', '));
                addText("<em>Try clicking a destination in the Travel Panel instead.</em>");
                return;
            }
            
            const targetLoc = gameState.locations[targetLocKey];
            
            // First, update the location
            gameState.location = targetLocKey;
            
            // Then describe the journey
            addText(`You journey from ${currentLoc.name} to ${targetLoc.name}...`);
            
            // Check if traveling to wilderness
            if (targetLoc.type === 'wilderness') {
                // Chance of random encounter at destination
                const encounterChance = targetLoc.danger ? targetLoc.danger * 0.2 : 0.3;
                if (Math.random() < encounterChance) {
                    addText("<span class='enemy'>As you arrive, enemies ambush you!</span>");
                    randomEncounter(); // This will start combat at the destination
                } else {
                    addText("The journey passes without incident.");
                }
                
                // Increase day counter for travel
                gameState.day++;
            } else {
                addText("You arrive safely.");
            }
            
            addText(`You are now at <span class='location'>${targetLoc.name}</span>.`);
            
            // Clear shop context when changing locations
            gameState.shopContext = null;
            
            // If not in combat, describe the location
            if (!gameState.inCombat) {
                lookAround();
            }
            
            // NEW: Check for skill challenges in new location
            checkLocationSkillChallenges();
            
            // Update stats and travel buttons
            updateStats();
            updateTravelButtons();
        }

        function completeQuest() {
            if (!gameState.currentQuest) return;
            
            const reward = gameState.currentQuest.reward;
            const xpReward = gameState.currentQuest.xpReward || 100;
            
            gameState.gold += reward;
            
            addText(`<span class='success'>Quest completed: ${gameState.currentQuest.name}!</span>`);
            addText(`You receive <span class='gold'>${reward} gold</span> as reward.`);
            
            // Award XP
            gameState.party.forEach(char => {
                char.xp += xpReward;
                checkLevelUp(char);
            });
            addText(`<span class='xp'>Party gains ${xpReward} XP!</span>`);
            
            const quest = gameState.quests.find(q => q.id === gameState.currentQuest.id);
            if (quest) quest.status = 'completed';
            
            gameState.currentQuest = null;
            gameState.questCompleted = true;
            
            updateStats();
        }

        // Update party display with level, XP, and skills
        function updatePartyDisplay() {
            partyDisplay.innerHTML = "";
            
            if (gameState.party.length === 0) {
                partyDisplay.innerHTML = "<p>No party members yet.</p>";
                return;
            }
            
            gameState.party.forEach(char => {
                const charDiv = document.createElement('div');
                charDiv.className = 'character';
                
                const hpPercent = Math.floor((char.hp / char.maxHp) * 100);
                const mpPercent = char.maxMp > 0 ? Math.floor((char.mp / char.maxMp) * 100) : 0;
                const xpPercent = Math.floor((char.xp / char.xpToNext) * 100);
                
                // Format skills with levels
                const skillsDisplay = char.explorationSkills.map(skill => 
                    `${skill}: ${char.skillLevels[skill] || 0}`
                ).join(', ');
                
                charDiv.innerHTML = `
                    <div class="character-name">${char.name} - Level ${char.level}</div>
                    <div class="character-class">${char.class}${char.specialization ? ` (${char.specialization})` : ''}</div>
                    <div class="health">HP: ${char.hp}/${char.maxHp} (${hpPercent}%)</div>
                    ${char.maxMp > 0 ? `<div class="mana">MP: ${char.mp}/${char.maxMp} (${mpPercent}%)</div>` : ''}
                    <div class="xp">XP: ${char.xp}/${char.xpToNext} (${xpPercent}%)</div>
                    <div>Attack: ${char.attack}, Defense: ${char.defense}</div>
                    <div>Weapon: ${char.weapon} <span class="damage-${char.damageType}">(${char.damageType})</span></div>
                    <div>Armor: ${char.armor}</div>
                    <div>Skills: ${skillsDisplay}</div>
                    ${char.setItems.length > 0 ? `<div class="set-item">Set Items: ${char.setItems.length}</div>` : ''}
                `;
                
                partyDisplay.appendChild(charDiv);
            });
        }

        // Update game stats display
        function updateStats() {
            locationValue.textContent = gameState.locations[gameState.location].name;
            goldValue.textContent = gameState.gold;
            dayValue.textContent = gameState.day;
            questValue.textContent = gameState.currentQuest ? gameState.currentQuest.name : "None";
        }

        // Initialize the game when page loads
        window.onload = initGame;
        
        // Keep other existing functions (visitInn, rest, talkTo, checkQuests, acceptQuest, showMap, showStatus, showParty, shop functions)
        // They should work as before but we've added the new features above
        
        // Placeholder for other functions that remain unchanged
        function visitInn() {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.shops || !loc.shops.includes('inn')) {
                addText("<span class='error'>There is no inn here.</span>");
                return;
            }
            
            const cost = 10;
            
            addText(`<strong>Welcome to the inn!</strong>`);
            addText(`A night's rest costs <span class='gold'>${cost} gold</span>.`);
            addText("Type <strong>REST</strong> to stay the night and recover your party.");
            addText(`You have <span class='gold'>${gameState.gold} gold</span>.`);
        }

        function rest() {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.shops || !loc.shops.includes('inn')) {
                addText("<span class='error'>You cannot rest here. Find an inn.</span>");
                return;
            }
            
            const cost = 10;
            
            if (gameState.gold < cost) {
                addText(`<span class='error'>You need ${cost} gold to rest at the inn, but you only have ${gameState.gold} gold.</span>`);
                return;
            }
            
            gameState.gold -= cost;
            gameState.day++;
            
            gameState.party.forEach(char => {
                char.hp = char.maxHp;
                char.mp = char.maxMp;
            });
            
            addText(`<span class='success'>You rest at the inn for ${cost} gold.</span>`);
            addText("Your party is fully healed!");
            addText(`A new day dawns. It is now day ${gameState.day}.`);
            
            updatePartyDisplay();
            updateStats();
        }

        function showStatus() {
            addText("<strong>Party Status:</strong>");
            
            gameState.party.forEach(char => {
                const hpPercent = Math.floor((char.hp / char.maxHp) * 100);
                const mpPercent = char.maxMp > 0 ? Math.floor((char.mp / char.maxMp) * 100) : 0;
                
                addText(`${char.name} - <span class='health'>HP: ${char.hp}/${char.maxHp} (${hpPercent}%)</span>, <span class='mana'>MP: ${char.mp}/${char.maxMp} (${mpPercent}%)</span>`);
            });
            
            addText(`<span class='gold'>Gold: ${gameState.gold}</span>`);
            addText(`Day: ${gameState.day}`);
            
            if (gameState.currentQuest) {
                addText(`<span class='quest'>Current Quest: ${gameState.currentQuest.name}</span>`);
            }
        }

        function showParty() {
            addText("<strong>Party Details:</strong>");
            
            gameState.party.forEach(char => {
                addText(`<strong>${char.name}</strong> the ${char.class}${char.specialization ? ` (${char.specialization})` : ''} - Level ${char.level}`);
                addText(`  HP: ${char.hp}/${char.maxHp}, MP: ${char.mp}/${char.maxMp}`);
                addText(`  Attack: ${char.attack}, Defense: ${char.defense}`);
                addText(`  Weapon: ${char.weapon} (${char.damageType} damage)`);
                addText(`  Armor: ${char.armor}`);
                addText(`  Combat Skills: ${char.skills.join(', ')}`);
                
                // NEW: Show exploration skills
                const skillsDisplay = char.explorationSkills.map(skill => 
                    `${skill}: ${char.skillLevels[skill] || 0}`
                ).join(', ');
                addText(`  Exploration Skills: ${skillsDisplay}`);
                
                addText(`  XP: ${char.xp}/${char.xpToNext}`);
                if (char.setItems.length > 0) {
                    addText(`  Set Items: ${char.setItems.join(', ')}`);
                }
                addText("");
            });
        }

        function talkTo(npcName) {
            if (!npcName) {
                addText("Talk to whom? Type TALK [npc name].");
                return;
            }
            
            const loc = gameState.locations[gameState.location];
            
            if (!loc.npcs || loc.npcs.length === 0) {
                addText("<span class='error'>There are no NPCs here to talk to.</span>");
                return;
            }
            
            const npc = loc.npcs.find(n => {
                const npcMap = {
                    'elder': 'village elder',
                    'merchant': 'merchant',
                    'guard': 'town guard',
                    'witch': 'swamp witch',
                    'hunter': 'marsh hunter',
                    'hermit': 'hermit',
                    'wizard': 'archmage',
                    'dwarfking': 'dwarf king',
                    'smith': 'blacksmith',
                    'miner': 'miner'
                };
                
                const npcDisplayName = npcMap[n] || n;
                return npcDisplayName.includes(npcName.toLowerCase()) || n.includes(npcName.toLowerCase());
            });
            
            if (!npc) {
                addText(`<span class='error'>There is no '${npcName}' here. Available NPCs: ${loc.npcs.map(n => {
                    if (n === 'elder') return 'Village Elder';
                    if (n === 'merchant') return 'Merchant';
                    if (n === 'guard') return 'Town Guard';
                    if (n === 'witch') return 'Swamp Witch';
                    if (n === 'hunter') return 'Marsh Hunter';
                    if (n === 'hermit') return 'Hermit';
                    if (n === 'wizard') return 'Archmage';
                    if (n === 'dwarfking') return 'Dwarf King';
                    if (n === 'smith') return 'Blacksmith';
                    if (n === 'miner') return 'Miner';
                    return n;
                }).join(', ')}</span>`);
                return;
            }
            
            const dialogues = {
                elder: [
                    "<em>'Welcome to our village, travelers. We've been having trouble with goblins in the forest.'</em>",
                    "<em>'If you clear them out, we would reward you handsomely.'</em>"
                ],
                merchant: [
                    "<em>'I have the finest goods in all the land! Visit my shop if you need supplies.'</em>"
                ],
                guard: [
                    "<em>'Stay safe out there. The roads are dangerous these days.'</em>"
                ],
                witch: [
                    "<em>'The swamp holds many secrets... and many dangers.'</em>",
                    "<em>'I seek an ancient tome lost in the marsh. Bring it to me and I'll reward you.'</em>"
                ],
                hunter: [
                    "<em>'I've seen strange creatures deeper in the swamp. Take care if you go that way.'</em>"
                ],
                hermit: [
                    "<em>'Leave me alone! I have no business with outsiders.'</em>"
                ],
                wizard: [
                    "<em>'Ah, adventurers! I have a task for those brave enough.'</em>",
                    "<em>'Retrieve the Tome of Ages from the Darkmarsh and I shall grant you powerful magic.'</em>"
                ],
                dwarfking: [
                    "<em>'Greetings, surface-dwellers. One of our miners is missing in the mountains.'</em>",
                    "<em>'Find him and bring him back, and the dwarves will be in your debt.'</em>"
                ],
                smith: [
                    "<em>'I forge the finest weapons this side of the mountains. Check my wares!'</em>"
                ],
                miner: [
                    "<em>'I heard there's valuable ore in the deepest caves, but it's too dangerous for me.'</em>"
                ]
            };
            
            const npcDisplayName = {
                elder: 'Village Elder',
                merchant: 'Merchant',
                guard: 'Town Guard',
                witch: 'Swamp Witch',
                hunter: 'Marsh Hunter',
                hermit: 'Hermit',
                wizard: 'Archmage',
                dwarfking: 'Dwarf King',
                smith: 'Blacksmith',
                miner: 'Miner'
            }[npc] || npc;
            
            addText(`You talk to <span class='npc'>${npcDisplayName}</span>:`);
            
            if (dialogues[npc]) {
                dialogues[npc].forEach(line => addText(line));
                
                if (npc === 'elder' && !gameState.currentQuest) {
                    addText("<span class='quest'>Quest available: GOBLIN MENACE (type QUEST to learn more)</span>");
                } else if (npc === 'wizard' && !gameState.currentQuest) {
                    addText("<span class='quest'>Quest available: WIZARD'S REQUEST (type QUEST to learn more)</span>");
                } else if (npc === 'dwarfking' && !gameState.currentQuest) {
                    addText("<span class='quest'>Quest available: MISSING MINER (type QUEST to learn more)</span>");
                }
            } else {
                addText("<em>'I have nothing to say to you.'</em>");
            }
        }

        function checkQuests() {
            const loc = gameState.locations[gameState.location];
            
            addText("<strong>Available Quests:</strong>");
            
            const availableQuests = gameState.quests.filter(q => q.status === 'available');
            
            if (availableQuests.length === 0) {
                addText("No quests available at this time.");
                return;
            }
            
            availableQuests.forEach(quest => {
                addText(`<span class='quest'>${quest.name}</span>: ${quest.description}`);
                addText(`  Location: ${gameState.locations[quest.location].name}`);
                addText(`  Reward: <span class='gold'>${quest.reward} gold</span> and <span class='xp'>${quest.xpReward} XP</span>`);
                addText(`  Type <strong>ACCEPT ${quest.name.toUpperCase().replace(' ', '')}</strong> to accept this quest.`);
                addText("");
            });
            
            if (gameState.currentQuest) {
                addText("");
                addText("<strong>Current Quest:</strong>");
                addText(`${gameState.currentQuest.name}: ${gameState.currentQuest.description}`);
            }
        }

        function acceptQuest(questName) {
            if (!questName) {
                addText("Accept which quest? Type ACCEPT [quest name].");
                return;
            }
            
            if (gameState.currentQuest) {
                addText(`<span class='error'>You already have an active quest: ${gameState.currentQuest.name}. Complete it first.</span>`);
                return;
            }
            
            const quest = gameState.quests.find(q => 
                q.name.toLowerCase().includes(questName.toLowerCase()) ||
                q.id.toLowerCase().includes(questName.toLowerCase())
            );
            
            if (!quest) {
                addText(`<span class='error'>No quest named '${questName}'. Type QUEST to see available quests.</span>`);
                return;
            }
            
            if (quest.status !== 'available') {
                addText(`<span class='error'>This quest is not available.</span>`);
                return;
            }
            
            gameState.currentQuest = quest;
            quest.status = 'active';
            
            addText(`<span class='success'>Quest accepted: ${quest.name}!</span>`);
            addText(`${quest.description}`);
            addText(`Travel to <span class='location'>${gameState.locations[quest.location].name}</span> to complete it.`);
            
            updateStats();
        }

        function showMap() {
            addText("<strong>World Map:</strong>");
            addText("  [Start] --> Rivertown");
            addText("  Rivertown --> Deepwood Forest --> Moon Hills");
            addText("  Moon Hills --> Darkmarsh --> Shadowfen Village");
            addText("  Moon Hills --> Stone Tower");
            addText("  Rivertown --> Trader's Path --> Frostpeak Mountains");
            addText("  Frostpeak Mountains --> Dwarven Fortress");
            if (gameState.foundLoreBooks.includes('Moons of Legend')) {
                addText("  Moon Hills --> [SECRET] Moon Temple");
            }
            addText("");
            addText("Your location: <span class='location'>" + gameState.locations[gameState.location].name + "</span>");
        }

        // ITEMS & ECONOMY: Shop functions (unchanged but kept for completeness)
        function visitShop(shopType) {
            const loc = gameState.locations[gameState.location];
            
            if (!loc.shops || loc.shops.length === 0) {
                addText("<span class='error'>There are no shops here.</span>");
                return;
            }
            
            if (!shopType) {
                addText("Which shop? Available: " + loc.shops.map(s => {
                    if (s === 'weapons') return 'WEAPONS';
                    if (s === 'items') return 'ITEMS';
                    if (s === 'magic') return 'MAGIC';
                    if (s === 'inn') return 'INN';
                    return s.toUpperCase();
                }).join(', '));
                addText("Type <strong>SHOP [type]</strong> or just type the shop name.");
                return;
            }
            
            if (shopType === 'inn') {
                visitInn();
                return;
            }
            
            if (!loc.shops.includes(shopType)) {
                addText(`<span class='error'>There is no ${shopType} shop here.</span>`);
                return;
            }
            
            gameState.shopContext = shopType;
            
            addText(`<strong>${shopType.charAt(0).toUpperCase() + shopType.slice(1)} Shop</strong>`);
            addText(`You have <span class='gold'>${gameState.gold} gold</span>.`);
            addText("");
            
            showShopItems(shopType);
        }
        
        function showShopItems(shopType) {
            if (shopType === 'weapons') {
                addText("<strong>Weapons for sale:</strong>");
                gameState.items.weapons.forEach(item => {
                    let rarityColor = '';
                    if (item.rarity === 'rare') rarityColor = 'color:#00ff00';
                    if (item.rarity === 'epic') rarityColor = 'color:#ff00ff';
                    if (item.rarity === 'legendary') rarityColor = 'color:#ff4500;text-shadow:0 0 3px #ff4500';
                    if (item.rarity === 'set') rarityColor = 'color:#00ff00;font-weight:bold';
                    
                    addText(`  <span style="${rarityColor}" class='item'>${item.name}</span> - <span class='gold'>${item.cost} gold</span> (Attack: +${item.attack}, Type: <span class='damage-${item.damageType}'>${item.damageType}</span>${item.special ? `, ${item.special}` : ''})`);
                });
                addText("");
                addText("Type <strong>BUY [item name]</strong> to purchase.");
                addText("Type <strong>BACK</strong> or <strong>EXIT</strong> to leave the shop.");
            } else if (shopType === 'items') {
                addText("<strong>Items for sale:</strong>");
                gameState.items.armor.forEach(item => {
                    let rarityColor = '';
                    if (item.rarity === 'rare') rarityColor = 'color:#00ff00';
                    if (item.rarity === 'epic') rarityColor = 'color:#ff00ff';
                    if (item.rarity === 'legendary') rarityColor = 'color:#ff4500;text-shadow:0 0 3px #ff4500';
                    if (item.rarity === 'set') rarityColor = 'color:#00ff00;font-weight:bold';
                    
                    addText(`  <span style="${rarityColor}" class='item'>${item.name}</span> - <span class='gold'>${item.cost} gold</span> (Defense: +${item.defense}${item.special ? `, ${item.special}` : ''})`);
                });
                addText("");
                gameState.items.potions.forEach(item => {
                    let rarityColor = '';
                    if (item.rarity === 'rare') rarityColor = 'color:#00ff00';
                    
                    addText(`  <span style="${rarityColor}" class='item'>${item.name}</span> - <span class='gold'>${item.cost} gold</span> (${item.effect === 'heal' ? 'Restores 10 HP' : item.effect === 'mana' ? 'Restores 10 MP' : item.special || 'Special effect'})`);
                });
                addText("");
                gameState.items.scrolls.forEach(item => {
                    addText(`  <span style="color:#00ff00" class='item'>${item.name}</span> - <span class='gold'>${item.cost} gold</span> (${item.effect === 'spell' ? 'Casts ' + item.value : 'Teleports to ' + item.value})`);
                });
                addText("");
                gameState.items.poisons.forEach(item => {
                    addText(`  <span class='item'>${item.name}</span> - <span class='gold'>${item.cost} gold</span> (Poisons weapon: ${item.value} damage for ${item.duration} turns)`);
                });
                addText("");
                addText("Type <strong>BUY [item name]</strong> to purchase.");
                addText("Type <strong>BACK</strong> or <strong>EXIT</strong> to leave the shop.");
            } else if (shopType === 'magic') {
                addText("<strong>Magic items for sale:</strong>");
                addText("  <span style='color:#ff00ff' class='item'>Mystic Wand</span> - <span class='gold'>100 gold</span> (Attack: +3, MP: +10, Type: <span class='damage-elemental'>elemental</span>)");
                addText("  <span class='item'>Robe</span> - <span class='gold'>25 gold</span> (Defense: +1, MP: +3)");
                addText("  <span class='item'>Mana Potion</span> - <span class='gold'>20 gold</span> (Restores 10 MP)");
                addText("  <span style='color:#00ff00' class='item'>Scroll of Fireball</span> - <span class='gold'>50 gold</span> (Casts Fireball spell)");
                addText("");
                addText("Type <strong>BUY [item name]</strong> to purchase.");
                addText("Type <strong>BACK</strong> or <strong>EXIT</strong> to leave the shop.");
            }
        }

        function buyItem(itemName) {
            if (!itemName) {
                addText("Buy what? Type BUY [item name] or just type the item name.");
                return;
            }
            
            if (!gameState.shopContext) {
                addText("<span class='error'>You're not in a shop. Visit a shop first with SHOP command.</span>");
                return;
            }
            
            let item = null;
            let category = null;
            
            // Search all item categories
            const searchCategories = ['weapons', 'armor', 'potions', 'scrolls', 'poisons'];
            for (const cat of searchCategories) {
                if (gameState.items[cat]) {
                    item = gameState.items[cat].find(i => i.name.toLowerCase().includes(itemName.toLowerCase()));
                    if (item) {
                        category = cat;
                        break;
                    }
                }
            }
            
            // Special case for magic shop items
            if (!item && gameState.shopContext === 'magic') {
                if (itemName.toLowerCase().includes('mystic wand')) {
                    item = { name: 'Mystic Wand', cost: 100, attack: 3, mp: 10, damageType: 'elemental' };
                    category = 'weapons';
                } else if (itemName.toLowerCase().includes('robe')) {
                    item = { name: 'Robe', cost: 25, defense: 1, mp: 3 };
                    category = 'armor';
                } else if (itemName.toLowerCase().includes('mana potion')) {
                    item = { name: 'Mana Potion', cost: 20, effect: 'mana', value: 10 };
                    category = 'potions';
                } else if (itemName.toLowerCase().includes('scroll')) {
                    item = gameState.items.scrolls.find(i => i.name.toLowerCase().includes(itemName.toLowerCase()));
                    if (item) category = 'scrolls';
                }
            }
            
            if (!item) {
                addText(`<span class='error'>No item named '${itemName}' available in this shop.</span>`);
                showShopItems(gameState.shopContext);
                return;
            }
            
            if (gameState.gold < item.cost) {
                addText(`<span class='error'>You need ${item.cost} gold to buy ${item.name}, but you only have ${gameState.gold} gold.</span>`);
                return;
            }
            
            gameState.gold -= item.cost;
            
            if (category === 'potions' || category === 'scrolls' || category === 'poisons') {
                addText(`<span class='success'>You bought a ${item.name} for ${item.cost} gold.</span>`);
                if (category === 'scrolls') {
                    addText("Scrolls can be used once to cast their spell.");
                } else if (category === 'poisons') {
                    addText("Poisons can be applied to weapons before combat.");
                }
            } else {
                let equipped = false;
                
                for (const char of gameState.party) {
                    if (category === 'weapons' && !equipped) {
                        const oldWeapon = char.weapon;
                        char.weapon = item.name;
                        char.attack += item.attack;
                        if (item.mp) char.maxMp += item.mp;
                        if (item.damageType) char.damageType = item.damageType;
                        
                        // Check if set item
                        if (item.set) {
                            char.setItems.push(item.name);
                            addText(`<span class='set-item'>${char.name} equips ${item.name} - part of the ${item.set} set!</span>`);
                            checkSetBonuses();
                        } else {
                            addText(`<span class='success'>${char.name} equips ${item.name} (replacing ${oldWeapon}) for ${item.cost} gold.</span>`);
                        }
                        equipped = true;
                    } else if (category === 'armor' && !equipped) {
                        const oldArmor = char.armor;
                        char.armor = item.name;
                        char.defense += item.defense;
                        if (item.mp) char.maxMp += item.mp;
                        
                        if (item.set) {
                            char.setItems.push(item.name);
                            addText(`<span class='set-item'>${char.name} equips ${item.name} - part of the ${item.set} set!</span>`);
                            checkSetBonuses();
                        } else {
                            addText(`<span class='success'>${char.name} equips ${item.name} (replacing ${oldArmor}) for ${item.cost} gold.</span>`);
                        }
                        equipped = true;
                    }
                }
                
                if (!equipped) {
                    addText(`<span class='error'>No party member can equip this item.</span>`);
                    gameState.gold += item.cost;
                }
            }
            
            updatePartyDisplay();
            updateStats();
            addText(`You have <span class='gold'>${gameState.gold} gold</span> remaining.`);
        }
    </script>
</body>
</html>
