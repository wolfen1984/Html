<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>Might & Magic: Dungeon Delver (Complete)</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background-color: #000; color: #fff; line-height: 1.3; padding: 8px;
            max-width: 500px; margin: 0 auto; font-family: 'Press Start 2P', cursive;
            font-size: 12px; background-image: radial-gradient(circle at 10% 20%, rgba(40,0,0,0.9) 0%, transparent 20%),
                              radial-gradient(circle at 90% 80%, rgba(0,20,40,0.9) 0%, transparent 20%);
            image-rendering: pixelated;
        }
        .game-container {
            border: 4px double #fff; padding: 12px; margin-bottom: 10px;
            background-color: rgba(0,0,0,0.85); box-shadow: 0 0 0 1px #333, 0 0 20px rgba(255,255,255,0.1);
            position: relative; overflow: hidden;
        }
        .game-container::before {
            content: ""; position: absolute; top:0; left:0; right:0; bottom:0;
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%);
            background-size: 100% 4px; z-index:2; pointer-events:none;
        }
        h1 { color:#ff3355; text-align:center; margin-bottom:12px; text-shadow:3px 3px 0 #000; font-size:1.5rem; border-bottom:2px dotted #666; padding-bottom:10px; letter-spacing:1px; text-transform:uppercase; }
        h2 { color:#ff3355; margin:12px 0 8px; padding-bottom:6px; border-bottom:1px dashed #666; font-size:1rem; }
        .screen { display: none; min-height: 450px; }
        .active-screen { display: block; }
        .status-bar {
            display: flex; flex-wrap: wrap; justify-content: space-between; background-color: #222;
            padding: 8px 6px; border: 2px solid #fff; margin-bottom: 12px; font-size: 9px;
        }
        .status-item { margin:2px 5px; color:#ff3355; min-width:70px; }
        .status-value { color:#fff; display:block; margin-top:2px; font-size:11px; }
        .direction-bar {
            background-color:#1a1a1a; border:2px solid #ffaa00; padding:8px 10px; margin-bottom:12px;
            display:flex; justify-content:space-between; align-items:center; font-size:11px; text-transform:uppercase;
        }
        .direction { color:#ffaa00; background:#000; padding:4px 8px; border:1px solid #666; }
        .dungeon-quickinfo { color:#aaa; display:flex; gap:10px; }
        .automap-container {
            background-color:#111; border:3px solid #fff; padding:15px 5px; margin-bottom:15px;
            display:flex; flex-direction:column; align-items:center;
        }
        .automap-grid {
            display:inline-grid; grid-template-columns:repeat(9, minmax(28px, 8vw)); gap:3px;
            justify-content:center; margin:5px 0; border:2px solid #444; padding:8px; background-color:#000;
        }
        .map-cell { width:100%; aspect-ratio:1/1; border:1px solid #333; font-size:16px; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:bold; }
        .map-wall { background-color:#444; }
        .map-floor { background-color:#222; }
        .map-player { background-color:#44aaff; color:#000; }
        .map-monster { background-color:#ff3355; color:#000; }
        .map-treasure { background-color:#ffaa00; color:#000; }
        .map-exit { background-color:#44ff88; color:#000; }
        .map-door { background-color:#664400; color:#ffaa00; }
        .map-legend { font-size:9px; color:#aaa; margin-top:6px; text-align:center; }
        .party-container {
            display: flex; overflow-x: auto; gap: 10px; margin: 15px 0; padding-bottom: 8px;
        }
        .party-container::-webkit-scrollbar { height: 6px; }
        .party-container::-webkit-scrollbar-thumb { background: #ff3355; border-radius: 10px; }
        .party-member {
            flex: 0 0 150px; background-color: #222; border: 2px solid #fff; padding: 10px; font-size: 9px;
        }
        .party-member.active { border-color: #ffaa00; }
        .member-name { color:#ff3355; font-size:10px; margin-bottom:5px; white-space: nowrap; overflow:hidden; text-overflow:ellipsis; }
        .member-class { color:#44aaff; font-size:8px; margin-bottom:6px; }
        .member-health { height:6px; background-color:#333; margin:4px 0; }
        .member-health-fill { height:100%; background-color:#ff3355; }
        .member-mana { height:6px; background-color:#333; margin:4px 0; }
        .member-mana-fill { height:100%; background-color:#44aaff; }
        .member-status { font-size:8px; color:#aaa; }
        .dungeon-controls {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin: 15px 0;
        }
        .dungeon-btn {
            background-color: #333; color: #ffaa00; border: 2px solid #fff; padding: 16px 4px;
            font-family: 'Press Start 2P', cursive; font-size: 11px; text-align: center;
            touch-action: manipulation; min-height: 60px; display: flex; align-items: center; justify-content: center;
        }
        .dungeon-btn:active { background-color: #444; border-color: #ffaa00; transform: translateY(1px); }
        .combat-log {
            background-color: #111; border: 2px solid #fff; padding: 10px; height: 120px;
            overflow-y: auto; margin: 15px 0; font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.4;
        }
        .action-buttons {
            display: flex; justify-content: space-around; gap: 10px; margin: 15px 0;
        }
        .action-btn {
            background-color: #333; color: #ffaa00; border: 2px solid #fff; padding: 12px 5px;
            font-family: 'Press Start 2P', cursive; font-size: 10px; flex: 1; text-align: center;
        }
        .action-btn:active { background-color: #444; border-color: #ffaa00; }
        .menu, .town-locations, .shop-items { display: grid; grid-template-columns: 1fr; gap: 8px; }
        .menu-option, .town-location, .shop-item {
            background-color: #333; border: 2px solid #fff; padding: 15px; text-align: center; font-size: 12px;
        }
        .town-location { border-color: #666; }
        .character-detail, .inventory-grid, .equipment-slot {
            background: #1a1a1a; border: 2px solid #444; padding: 8px; margin: 8px 0;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 10px; }
        .equipment-slot { display: flex; justify-content: space-between; align-items: center; }
        .item-btn { background: #333; border: 1px solid #ffaa00; color: #ffaa00; padding: 4px 8px; font-size: 8px; cursor: pointer; }
        .item-btn:active { background: #444; }
        .divider {
            height: 2px; background-color: #fff; margin: 15px 0; position: relative;
        }
        .divider::before, .divider::after {
            content: "‚óÜ"; position: absolute; top: -10px; color: #ffaa00;
            font-size: 16px; background-color: #000; padding: 0 8px;
        }
        .divider::before { left: 10px; }
        .divider::after { right: 10px; }
        .footer { text-align: center; margin-top: 15px; color: #666; font-size: 8px; }
        .crt-curve {
            position: fixed; top:0; left:0; right:0; bottom:0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.3) 100%);
            z-index: 100;
        }
        .turn-indicator { background: #ffaa00; color: #000; padding: 8px; text-align: center; margin-bottom: 8px; }

        /* In-game notification (replaces alerts) */
        .notification-area {
            position: fixed; top: 20px; left: 10%; right: 10%; width: 80%; background: #222; border: 3px solid #ffaa00;
            color: #fff; padding: 15px; text-align: center; z-index: 200; font-size: 12px;
            box-shadow: 0 0 20px black; display: none;
        }
        .notification-area button { margin-top: 10px; background: #333; border: 1px solid #ffaa00; color: #ffaa00; padding: 5px 15px; font-family: inherit; cursor: pointer; }
        /* Simple confirmation modal (replaces confirm) */
        .confirm-modal {
            position: fixed; top: 30%; left: 10%; right: 10%; width: 80%; background: #111; border: 4px solid #ff3355;
            color: #fff; padding: 20px; text-align: center; z-index: 250; font-size: 12px; display: none;
            flex-direction: column; gap: 15px;
        }
        .confirm-buttons { display: flex; gap: 20px; justify-content: center; }
        .confirm-buttons button { background: #333; border: 2px solid #fff; color: #ffaa00; padding: 10px 20px; font-family: inherit; cursor: pointer; }
        /* Spell selection in combat */
        .spell-list { display: grid; grid-template-columns: repeat(2,1fr); gap: 5px; margin: 10px 0; }
        .spell-item { background: #333; border: 1px solid #44aaff; color: #44aaff; padding: 8px; font-size: 9px; cursor: pointer; text-align: center; }
    </style>
</head>
<body>
<div class="crt-curve"></div>
<!-- In-game notification (replaces alert) -->
<div id="notification" class="notification-area">
    <span id="notificationMessage"></span>
    <button onclick="hideNotification()">OK</button>
</div>
<!-- Custom confirmation modal (replaces confirm) -->
<div id="confirmModal" class="confirm-modal">
    <div id="confirmMessage"></div>
    <div class="confirm-buttons">
        <button id="confirmYes">YES</button>
        <button id="confirmNo">NO</button>
    </div>
</div>

<div class="game-container">
    <h1>MIGHT & MAGIC: DUNGEON DELVER</h1>
    <div class="divider"></div>

    <!-- Status bar (always visible) -->
    <div class="status-bar">
        <div class="status-item">DUNGEON: <span class="status-value" id="currentDungeon">-</span></div>
        <div class="status-item">FLOOR: <span class="status-value" id="currentFloor">1</span></div>
        <div class="status-item">HP: <span class="status-value" id="partyHealth">100</span>/<span class="status-value" id="partyMaxHealth">100</span></div>
        <div class="status-item">GOLD: <span class="status-value" id="gold">500</span></div>
        <div class="status-item">TORCHES: <span class="status-value" id="torches">10</span></div>
        <div class="status-item">MAP: <span class="status-value" id="mapProgress">0</span>%</div>
    </div>

    <!-- Character Creation Screen -->
    <div id="creationScreen" class="screen active-screen">
        <h2>PARTY CREATION</h2>
        <p>FORM YOUR PARTY OF FOUR.</p>
        <div id="partyCreation" style="margin:20px 0;"></div>
        <div style="text-align:center;"><button onclick="completePartyCreation()">BEGIN ADVENTURE</button></div>
    </div>

    <!-- Town Screen -->
    <div id="townScreen" class="screen">
        <h2>TOWN OF RIVERWOOD</h2>
        <div class="town-interface">
            <div class="town-locations">
                <div class="town-location" onclick="goToInn()"><div class="location-name">INN</div><div class="location-desc">REST & HEAL (40G)</div></div>
                <div class="town-location" onclick="goToShop()"><div class="location-name">BLACKSMITH</div><div class="location-desc">BUY/SELL ITEMS</div></div>
                <div class="town-location" onclick="goToMagicShop()"><div class="location-name">MAGIC SHOP</div><div class="location-desc">BUY SPELLS</div></div>
                <div class="town-location" onclick="goToGuild()"><div class="location-name">GUILD</div><div class="location-desc">QUESTS</div></div>
                <div class="town-location" onclick="goToTemple()"><div class="location-name">TEMPLE</div><div class="location-desc">CURES (30G)</div></div>
                <div class="town-location" onclick="goToDungeonSelect()"><div class="location-name">DUNGEON GATE</div><div class="location-desc">ENTER</div></div>
                <div class="town-location" onclick="showPartyScreen()"><div class="location-name">PARTY</div><div class="location-desc">VIEW/EQUIP</div></div>
            </div>
        </div>
        <div id="townMessage" style="margin-top:15px; padding:10px; background:#222;"></div>
    </div>

    <!-- Dungeon Selection Screen -->
    <div id="dungeonSelectScreen" class="screen">
        <h2>SELECT DUNGEON</h2>
        <div class="menu">
            <div class="menu-option" onclick="enterDungeon('catacombs')">CATACOMBS (L1-3)</div>
            <div class="menu-option" onclick="enterDungeon('crystal')">CRYSTAL CAVERNS (L2-4)</div>
            <div class="menu-option" onclick="enterDungeon('fortress')">FORGOTTEN FORTRESS (L3-5)</div>
            <div class="menu-option" onclick="enterDungeon('labyrinth')">MINOTAUR (L4-6)</div>
            <div class="menu-option" onclick="enterDungeon('void')">VOID TEMPLE (L5+)</div>
        </div>
        <button onclick="goToTown()">BACK</button>
    </div>

    <!-- DUNGEON SCREEN -->
    <div id="dungeonScreen" class="screen">
        <h2 id="dungeonTitle">DUNGEON - FLOOR 1</h2>
        <div class="direction-bar">
            <span class="direction" id="infoDirection">NORTH</span>
            <div class="dungeon-quickinfo">
                <span id="infoPos">(5,5)</span>
                <span>üëæ <span id="infoMonsters">0</span></span>
                <span>‚ö†Ô∏è <span id="infoTraps">0</span></span>
            </div>
        </div>
        <div class="automap-container">
            <div id="automapGrid" class="automap-grid"></div>
            <div class="map-legend">‚ñà=WALL ‚ñë=FLOOR P=YOU M=MONSTER T=TREASURE E=EXIT D=DOOR</div>
        </div>
        <div class="party-container" id="partyContainer"></div>
        <div class="dungeon-controls">
            <div class="dungeon-btn" onclick="moveForward()">‚Üë MOVE</div>
            <div class="dungeon-btn" onclick="turnLeft()">‚Ü∞ LEFT</div>
            <div class="dungeon-btn" onclick="turnRight()">‚Ü± RIGHT</div>
            <div class="dungeon-btn" onclick="moveBackward()">‚Üì BACK</div>
            <div class="dungeon-btn" onclick="searchArea()">üîç SEARCH</div>
            <div class="dungeon-btn" onclick="restInDungeon()">üí§ REST</div>
            <div class="dungeon-btn" onclick="useSkill('detect_traps')">‚ö†Ô∏è DETECT</div>
            <div class="dungeon-btn" onclick="useSkill('detect_secret')">üîì SECRET</div>
        </div>
        <div id="combatLog" class="combat-log"></div>
        <div class="action-buttons">
            <div class="action-btn" onclick="fleeToTown()">FLEE</div>
            <div class="action-btn" onclick="useTorch()" id="torchButton">TORCH (<span id="torchCount">10</span>)</div>
            <div class="action-btn" onclick="showInventoryScreen()">INV</div>
            <div class="action-btn" onclick="showPartyScreen()">PARTY</div>
        </div>
    </div>

    <!-- Combat Screen (with spell integration) -->
    <div id="combatScreen" class="screen">
        <h2>ENCOUNTER!</h2>
        <div id="combatTurnIndicator" class="turn-indicator"></div>
        <div id="combatEnemyDisplay" style="text-align:center; margin:10px 0;"></div>
        <div class="combat-log" id="battleLog" style="height:150px;"></div>
        <div id="combatActions" style="display:grid; grid-template-columns:repeat(2,1fr); gap:8px; margin:15px 0;">
            <!-- Filled dynamically -->
        </div>
        <!-- Spell selection overlay (hidden initially) -->
        <div id="combatSpellSelection" style="display:none; background:#111; border:2px solid #44aaff; padding:10px; margin:10px 0;">
            <h3 style="color:#44aaff;">CHOOSE SPELL</h3>
            <div id="spellList" class="spell-list"></div>
            <button onclick="cancelSpellSelection()">CANCEL</button>
        </div>
        <div class="party-container" id="combatParty"></div>
        <button onclick="fleeCombat()">FLEE (if available)</button>
    </div>

    <!-- Party / Inventory Screen -->
    <div id="partyScreen" class="screen">
        <h2>PARTY STATUS</h2>
        <div id="partyMemberList"></div>
        <button onclick="goToTown()">BACK</button>
    </div>

    <!-- Character Detail / Equipment Screen -->
    <div id="characterScreen" class="screen">
        <h2 id="charName">CHARACTER</h2>
        <div class="character-detail">
            <div class="stat-row">HP: <span id="charHP"></span>/<span id="charMaxHP"></span></div>
            <div class="stat-row">MP: <span id="charMP"></span>/<span id="charMaxMP"></span></div>
            <div class="stat-row">STR: <span id="charStr"></span> | DEX: <span id="charDex"></span></div>
            <div class="stat-row">INT: <span id="charInt"></span> | VIT: <span id="charVit"></span></div>
            <div class="stat-row">XP: <span id="charXP"></span>/<span id="charNextXP"></span></div>
        </div>
        <h3>EQUIPMENT</h3>
        <div id="equipmentSlots"></div>
        <h3>INVENTORY</h3>
        <div id="charInventory" class="inventory-grid"></div>
        <div id="charMessage" style="margin:10px 0; background:#222; padding:5px;"></div>
        <button onclick="showPartyScreen()">BACK</button>
    </div>

    <!-- Level Up Screen -->
    <div id="levelUpScreen" class="screen">
        <h2>LEVEL UP!</h2>
        <p id="levelUpChar"></p>
        <p>Choose a stat to increase:</p>
        <div style="display:grid; gap:8px;">
            <button onclick="levelUpStat('strength')">STRENGTH +2</button>
            <button onclick="levelUpStat('dexterity')">DEXTERITY +2</button>
            <button onclick="levelUpStat('intelligence')">INTELLIGENCE +2</button>
            <button onclick="levelUpStat('vitality')">VITALITY +2</button>
        </div>
        <button onclick="cancelLevelUp()">LATER</button>
    </div>

    <!-- Shop Screen -->
    <div id="shopScreen" class="screen">
        <h2>BLACKSMITH</h2>
        <div class="shop-items" id="shopItems"></div>
        <div style="margin:10px 0;"><button onclick="sellMode()">SELL MODE</button></div>
        <button onclick="goToTown()">LEAVE</button>
        <div id="shopMessage" style="margin-top:15px;"></div>
    </div>

    <!-- Magic Shop -->
    <div id="magicShopScreen" class="screen">
        <h2>MAGIC EMPORIUM</h2>
        <div class="shop-items" id="magicShopItems"></div>
        <button onclick="goToTown()">LEAVE</button>
        <div id="magicShopMessage" style="margin-top:15px;"></div>
    </div>

    <!-- Guild (Quests) -->
    <div id="guildScreen" class="screen">
        <h2>ADVENTURER'S GUILD</h2>
        <div id="questList"></div>
        <button onclick="goToTown()">BACK</button>
        <div id="guildMessage"></div>
    </div>

    <!-- Temple -->
    <div id="templeScreen" class="screen">
        <h2>TEMPLE OF LIGHT</h2>
        <p>Cure all ailments for 30G?</p>
        <button onclick="templeCure()">CURE (30G)</button>
        <button onclick="goToTown()">LEAVE</button>
        <div id="templeMessage"></div>
    </div>

    <!-- Puzzle Screen -->
    <div id="puzzleScreen" class="screen">
        <h2>PUZZLE</h2>
        <div class="puzzle-container" style="background:#1a1a2a; border:2px solid #44aaff; padding:20px;">
            <div id="puzzleElements" style="display:flex; justify-content:center; gap:10px;"></div>
            <button onclick="checkPuzzle()">ACTIVATE</button>
            <button onclick="skipPuzzle()">FORCE</button>
            <div id="puzzleResult" style="margin-top:20px;"></div>
        </div>
    </div>

    <!-- Game Over & Victory -->
    <div id="gameOverScreen" class="screen">
        <h2 style="color:#ff3355; text-align:center;">PARTY DEFEATED</h2>
        <p>FLOORS EXPLORED: <span id="finalFloors">0</span></p>
        <p>MONSTERS SLAIN: <span id="finalMonsters">0</span></p>
        <p>TREASURE FOUND: <span id="finalTreasure">0</span> GOLD</p>
        <button onclick="restartGame()">NEW GAME</button>
    </div>
    <div id="victoryScreen" class="screen">
        <h2 style="color:#ffaa00; text-align:center;">DUNGEON CONQUERED!</h2>
        <p>FLOORS CLEARED: <span id="victoryFloors">0</span></p>
        <p>MONSTERS SLAIN: <span id="victoryMonsters">0</span></p>
        <p>TREASURE ACQUIRED: <span id="victoryTreasure">0</span> GOLD</p>
        <button onclick="goToTown()">TOWN</button>
        <button onclick="restartGame()">NEW ADVENTURE</button>
    </div>
</div>
<div class="footer">MIGHT & MAGIC: DUNGEON DELVER ‚Ä¢ COMPLETE</div>

<script>
    // ==================== GAME STATE ====================
    const gameState = {
        party: [],
        gold: 500,
        torches: 10,
        currentDungeon: null,
        currentFloor: 1,
        dungeonGrid: [],
        playerX: 5,
        playerY: 5,
        playerDirection: 0,
        exploredTiles: new Set(),
        discoveredSecrets: new Set(),
        discoveredTraps: new Set(),
        monstersSlain: 0,
        treasureFound: 0,
        totalTurns: 0,
        inCombat: false,
        combatQueue: [],
        currentTurnIndex: 0,
        currentEnemy: null,
        inPuzzle: false,
        currentPuzzle: null,
        inventory: {
            keys: { iron: 0, silver: 0, gold: 0 },
            potions: { healing: 3, mana: 1, antidote: 1 },
            scrolls: { identify: 1, mapping: 0 },
            special: []
        },
        spells: ['light'], // known spells
        dungeonsCompleted: [],
        quests: [
            { id: 1, name: "Slime Extermination", objective: "kill 5 slimes", progress: 0, target: 5, reward: 200, type: 'kill', monster: 'SLIME' },
            { id: 2, name: "Goblin Menace", objective: "kill 3 goblins", progress: 0, target: 3, reward: 150, type: 'kill', monster: 'GOBLIN' }
        ],
        selectedCharacter: null,
        levelUpQueue: [],
        awaitingConfirmation: null // for custom confirm callback
    };

    const directions = [
        { x: 0, y: -1, name: "NORTH" },
        { x: 1, y: 0, name: "EAST" },
        { x: 0, y: 1, name: "SOUTH" },
        { x: -1, y: 0, name: "WEST" }
    ];

    const TILE = {
        WALL: '#', FLOOR: '.', DOOR: 'D', SECRET_DOOR: 'S',
        STAIRS_UP: 'U', STAIRS_DOWN: 'V', TREASURE: 'T',
        MONSTER: 'M', TRAP: 'X', PUZZLE: 'P', EXIT: 'E'
    };

    const classes = {
        warrior: { name: "WARRIOR", hpPerLevel: 12, mpPerLevel: 2, skills: ["SWORD","SHIELD","HEAVY_ARMOR"], startingEquipment: ["LONG_SWORD","CHAIN_MAIL"] },
        rogue: { name: "ROGUE", hpPerLevel: 8, mpPerLevel: 4, skills: ["DAGGER","LOCKPICK","TRAP_DISARM","STEALTH"], startingEquipment: ["DAGGER","LEATHER_ARMOR"] },
        mage: { name: "MAGE", hpPerLevel: 6, mpPerLevel: 10, skills: ["STAFF","SPELLCAST","IDENTIFY","ENCHANT"], startingEquipment: ["STAFF","ROBE"] },
        cleric: { name: "CLERIC", hpPerLevel: 10, mpPerLevel: 6, skills: ["MACE","HEAL","TURN_UNDEAD","PROTECTION"], startingEquipment: ["MACE","CHAIN_MAIL"] }
    };

    const dungeons = {
        catacombs: { name: "CATACOMBS OF RIVERWOOD", floors: 3, monsters: ["SKELETON","ZOMBIE","GOBLIN"], treasures: [50,200] },
        crystal: { name: "CRYSTAL CAVERNS", floors: 4, monsters: ["CRYSTAL_GOLEM","EARTH_ELEMENTAL","BAT_SWARM"], treasures: [100,300] },
        fortress: { name: "FORGOTTEN FORTRESS", floors: 5, monsters: ["ORC","ORC_WARLORD","WAR_GOLEM"], treasures: [150,400] },
        labyrinth: { name: "MINOTAUR'S LABYRINTH", floors: 6, monsters: ["MINOTAUR","HARPIE","CYCLOPS"], treasures: [200,500] },
        void: { name: "VOID TEMPLE", floors: 7, monsters: ["DEMON","VOID_WALKER","SHADOW"], treasures: [300,750] }
    };

    const monsters = {
        SKELETON: { name: "SKELETON", health: 30, damage: [3,8], xp: 25, gold: [5,15], level: 1, speed: 8 },
        ZOMBIE: { name: "ZOMBIE", health: 40, damage: [4,10], xp: 30, gold: [8,20], level: 1, speed: 4 },
        GOBLIN: { name: "GOBLIN", health: 25, damage: [2,6], xp: 20, gold: [3,12], level: 1, speed: 10 },
        CRYSTAL_GOLEM: { name: "CRYSTAL GOLEM", health: 60, damage: [6,14], xp: 50, gold: [20,40], level: 2, speed: 5 },
        EARTH_ELEMENTAL: { name: "EARTH ELEMENTAL", health: 80, damage: [8,16], xp: 70, gold: [25,50], level: 3, speed: 3 },
        ORC: { name: "ORC", health: 45, damage: [5,12], xp: 35, gold: [10,25], level: 2, speed: 7 },
        ORC_WARLORD: { name: "ORC WARLORD", health: 100, damage: [10,20], xp: 100, gold: [50,100], level: 4, speed: 9 },
        MINOTAUR: { name: "MINOTAUR", health: 120, damage: [12,24], xp: 150, gold: [75,150], level: 5, speed: 8 },
        DEMON: { name: "DEMON", health: 150, damage: [15,30], xp: 200, gold: [100,200], level: 6, speed: 10 },
        VOID_WALKER: { name: "VOID WALKER", health: 100, damage: [10,25], xp: 180, gold: [80,180], level: 6, speed: 12 },
        BAT_SWARM: { name: "BAT SWARM", health: 20, damage: [2,5], xp: 15, gold: [2,8], level: 1, speed: 15 },
        HARPIE: { name: "HARPIE", health: 35, damage: [4,9], xp: 30, gold: [10,20], level: 2, speed: 14 },
        CYCLOPS: { name: "CYCLOPS", health: 90, damage: [10,18], xp: 80, gold: [40,80], level: 4, speed: 6 },
        WAR_GOLEM: { name: "WAR GOLEM", health: 110, damage: [12,22], xp: 120, gold: [60,120], level: 5, speed: 5 },
        SHADOW: { name: "SHADOW", health: 50, damage: [6,12], xp: 60, gold: [20,40], level: 3, speed: 13 }
    };

    const items = {
        "LONG_SWORD": { name: "Long Sword", type: "weapon", damage: 6, value: 100, statBonus: { strength: 2 } },
        "DAGGER": { name: "Dagger", type: "weapon", damage: 3, value: 30, statBonus: { dexterity: 1 } },
        "STAFF": { name: "Staff", type: "weapon", damage: 2, value: 20, statBonus: { intelligence: 2 } },
        "MACE": { name: "Mace", type: "weapon", damage: 5, value: 70, statBonus: { strength: 1 } },
        "BOW": { name: "Bow", type: "weapon", damage: 4, value: 60, statBonus: { dexterity: 2 } },
        "CHAIN_MAIL": { name: "Chain Mail", type: "armor", defense: 4, value: 150, statBonus: { vitality: 1 } },
        "LEATHER_ARMOR": { name: "Leather Armor", type: "armor", defense: 2, value: 50, statBonus: { dexterity: 1 } },
        "ROBE": { name: "Robe", type: "armor", defense: 1, value: 20, statBonus: { intelligence: 1 } },
        "PLATE_ARMOR": { name: "Plate Armor", type: "armor", defense: 6, value: 300, statBonus: { strength: 1, vitality: 2 } },
        "RING_OF_STRENGTH": { name: "Ring of Strength", type: "accessory", value: 200, statBonus: { strength: 3 } },
        "AMULET_OF_WISDOM": { name: "Amulet of Wisdom", type: "accessory", value: 200, statBonus: { intelligence: 3 } },
        "CLOAK_OF_AGILITY": { name: "Cloak of Agility", type: "accessory", value: 180, statBonus: { dexterity: 3 } }
    };

    const spellsDB = {
        light: { name: "Light", cost: 5, target: "self", effect: (caster) => { revealArea(); logMessage("LIGHT REVEALS AREA"); } },
        detect_traps: { name: "Detect Traps", cost: 8, target: "self", effect: (caster) => { discoverTraps(); } },
        detect_secret: { name: "Secret Sense", cost: 8, target: "self", effect: (caster) => { logMessage("You sense something..."); } },
        heal: { name: "Heal", cost: 10, target: "ally", effect: (caster, target) => { target.health = Math.min(target.maxHealth, target.health + 25); logMessage(`${caster.name} heals ${target.name}`); } },
        fireball: { name: "Fireball", cost: 15, target: "enemy", effect: (caster, enemy) => { let dmg = 20 + Math.floor(caster.intelligence/2); enemy.health -= dmg; logMessage(`Fireball hits for ${dmg}`); } }
    };

    // ========== Notification / Confirm (replace alerts) ==========
    function showNotification(msg) {
        document.getElementById('notificationMessage').innerText = msg;
        document.getElementById('notification').style.display = 'block';
    }
    function hideNotification() {
        document.getElementById('notification').style.display = 'none';
    }
    // Custom confirm
    function showConfirm(msg, onYes, onNo) {
        document.getElementById('confirmMessage').innerText = msg;
        document.getElementById('confirmModal').style.display = 'flex';
        gameState.awaitingConfirmation = { onYes, onNo };
    }
    document.getElementById('confirmYes').onclick = () => {
        document.getElementById('confirmModal').style.display = 'none';
        if (gameState.awaitingConfirmation?.onYes) gameState.awaitingConfirmation.onYes();
        gameState.awaitingConfirmation = null;
    };
    document.getElementById('confirmNo').onclick = () => {
        document.getElementById('confirmModal').style.display = 'none';
        if (gameState.awaitingConfirmation?.onNo) gameState.awaitingConfirmation.onNo();
        gameState.awaitingConfirmation = null;
    };

    // ========== Existing functions (condensed but key) ==========
    window.onload = function() { initGame(); };
    function initGame() { initPartyCreation(); showScreen('creationScreen'); }
    function initPartyCreation() { /* same as before */ 
        const pc = document.getElementById('partyCreation');
        pc.innerHTML = '';
        for (let i=0;i<4;i++) {
            pc.innerHTML += `
                <div class="party-member">
                    <h3>MEMBER ${i+1}</h3>
                    <input type="text" id="memberName${i}" value="ADVENTURER ${i+1}" style="width:100%; margin:5px 0;">
                    <select id="memberClass${i}" style="width:100%;">
                        <option value="warrior">WARRIOR</option>
                        <option value="rogue">ROGUE</option>
                        <option value="mage">MAGE</option>
                        <option value="cleric">CLERIC</option>
                    </select>
                    <div>STR <span id="str${i}">10</span> <button onclick="adjStat(${i},'str',1)">+</button><button onclick="adjStat(${i},'str',-1)">-</button></div>
                    <div>DEX <span id="dex${i}">10</span> <button onclick="adjStat(${i},'dex',1)">+</button><button onclick="adjStat(${i},'dex',-1)">-</button></div>
                    <div>INT <span id="int${i}">10</span> <button onclick="adjStat(${i},'int',1)">+</button><button onclick="adjStat(${i},'int',-1)">-</button></div>
                    <div>VIT <span id="vit${i}">10</span> <button onclick="adjStat(${i},'vit',1)">+</button><button onclick="adjStat(${i},'vit',-1)">-</button></div>
                </div>
            `;
        }
    }
    window.adjStat = function(i,s,a) { let e=document.getElementById(s+i); let v=parseInt(e.textContent)+a; if(v>=5&&v<=18) e.textContent=v; };
    function completePartyCreation() {
        gameState.party = [];
        for(let i=0;i<4;i++) {
            let c = document.getElementById(`memberClass${i}`).value;
            let vit = parseInt(document.getElementById(`vit${i}`).textContent);
            let maxHP = 20 + vit * 2;
            let maxMP = (c==='mage'?30 : c==='cleric'?20 : 10);
            gameState.party.push({
                id:i,
                name:document.getElementById(`memberName${i}`).value.toUpperCase() || `ADVENTURER ${i+1}`,
                class:c,
                className:classes[c].name,
                level:1,
                xp:0,
                nextLevelXP:100,
                health:maxHP,
                maxHealth:maxHP,
                mana:maxMP,
                maxMana:maxMP,
                strength:parseInt(document.getElementById(`str${i}`).textContent),
                dexterity:parseInt(document.getElementById(`dex${i}`).textContent),
                intelligence:parseInt(document.getElementById(`int${i}`).textContent),
                vitality:vit,
                skills:[...classes[c].skills],
                equipment: { weapon: null, armor: null, accessory: null },
                status:[],
                active:true
            });
        }
        gameState.party.forEach(m => {
            if (m.class === 'warrior') { m.equipment.weapon = 'LONG_SWORD'; m.equipment.armor = 'CHAIN_MAIL'; }
            else if (m.class === 'rogue') { m.equipment.weapon = 'DAGGER'; m.equipment.armor = 'LEATHER_ARMOR'; }
            else if (m.class === 'mage') { m.equipment.weapon = 'STAFF'; m.equipment.armor = 'ROBE'; }
            else if (m.class === 'cleric') { m.equipment.weapon = 'MACE'; m.equipment.armor = 'CHAIN_MAIL'; }
        });
        updateStatusBar(); updatePartyDisplay(); showScreen('townScreen');
        document.getElementById('townMessage').innerHTML = 'WELCOME TO RIVERWOOD!';
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active-screen'));
        document.getElementById(id).classList.add('active-screen');
        if (id === 'dungeonScreen') { updateDungeonView(); updatePartyDisplay(); updateAutoMap(); }
        if (id === 'partyScreen') renderPartyList();
        if (id === 'characterScreen' && gameState.selectedCharacter !== null) renderCharacterScreen(gameState.selectedCharacter);
    }

    function updateStatusBar() {
        let th=0, tm=0;
        gameState.party.forEach(m=>{ if(m.active){ th+=m.health; tm+=m.maxHealth; } });
        document.getElementById('partyHealth').textContent=th;
        document.getElementById('partyMaxHealth').textContent=tm;
        document.getElementById('gold').textContent=gameState.gold;
        document.getElementById('torches').textContent=gameState.torches;
        document.getElementById('torchCount').textContent=gameState.torches;
        if(gameState.currentDungeon) {
            document.getElementById('currentDungeon').textContent=dungeons[gameState.currentDungeon].name;
            document.getElementById('currentFloor').textContent=gameState.currentFloor;
            let total=gameState.dungeonGrid.length*gameState.dungeonGrid[0].length;
            let pct=total?Math.round(gameState.exploredTiles.size/total*100):0;
            document.getElementById('mapProgress').textContent=pct;
        } else { document.getElementById('currentDungeon').textContent='-'; }
    }

    function updatePartyDisplay() { /* same */ 
        let pc=document.getElementById('partyContainer');
        if(!pc) return;
        pc.innerHTML='';
        gameState.party.forEach(m=>{
            pc.innerHTML+=`<div class="party-member ${m.active?'active':''}" onclick="selectCharacter(${m.id})">
                <div class="member-name">${m.name}</div><div class="member-class">${m.className} L${m.level}</div>
                <div>HP ${m.health}/${m.maxHealth}</div><div class="member-health"><div class="member-health-fill" style="width:${m.health/m.maxHealth*100}%"></div></div>
                <div>MP ${m.mana}/${m.maxMana}</div><div class="member-mana"><div class="member-mana-fill" style="width:${m.mana/m.maxMana*100}%"></div></div>
                <div class="member-status">${m.status.length?m.status.join(','):'HEALTHY'}</div>
            </div>`;
        });
    }

    function updateAutoMap() { /* same */ 
        let grid=document.getElementById('automapGrid');
        if(!grid) return;
        grid.innerHTML='';
        let size=gameState.dungeonGrid.length;
        for(let y=-4;y<=4;y++) {
            for(let x=-4;x<=4;x++) {
                let mx=gameState.playerX+x, my=gameState.playerY+y;
                let cell=document.createElement('div');
                cell.className='map-cell';
                if(mx>=0&&my>=0&&my<size&&mx<size) {
                    let explored=gameState.exploredTiles.has(mx+','+my);
                    let tile=gameState.dungeonGrid[my][mx];
                    if(mx===gameState.playerX&&my===gameState.playerY) { cell.classList.add('map-player'); cell.textContent='P'; }
                    else if(!explored) cell.classList.add('map-wall');
                    else {
                        if(tile===TILE.WALL) { cell.classList.add('map-wall'); cell.textContent='‚ñà'; }
                        else if(tile===TILE.DOOR) { cell.classList.add('map-door'); cell.textContent='D'; }
                        else if(tile===TILE.MONSTER) { cell.classList.add('map-monster'); cell.textContent='M'; }
                        else if(tile===TILE.TREASURE) { cell.classList.add('map-treasure'); cell.textContent='T'; }
                        else if(tile===TILE.EXIT||tile===TILE.STAIRS_DOWN) { cell.classList.add('map-exit'); cell.textContent='E'; }
                        else if(tile===TILE.TRAP) {
                            if(gameState.discoveredTraps.has(mx+','+my)) { cell.classList.add('map-treasure'); cell.textContent='X'; }
                            else { cell.classList.add('map-floor'); cell.textContent='.'; }
                        }
                        else { cell.classList.add('map-floor'); cell.textContent='.'; }
                    }
                } else cell.classList.add('map-wall');
                grid.appendChild(cell);
            }
        }
        grid.style.gridTemplateColumns='repeat(9, minmax(28px, 8vw))';
    }

    function updateDungeonView() { /* same */ 
        let d=directions[gameState.playerDirection];
        document.getElementById('infoDirection').textContent=d.name;
        document.getElementById('infoPos').textContent=`(${gameState.playerX},${gameState.playerY})`;
        document.getElementById('infoMonsters').textContent=countNearbyMonsters();
        document.getElementById('infoTraps').textContent=gameState.discoveredTraps.size;
        document.getElementById('dungeonTitle').textContent=gameState.currentDungeon?`${dungeons[gameState.currentDungeon].name} - FLOOR ${gameState.currentFloor}`:`DUNGEON - FLOOR ${gameState.currentFloor}`;
        updateStatusBar();
    }
    function countNearbyMonsters() { let c=0; for(let dy=-3;dy<=3;dy++) for(let dx=-3;dx<=3;dx++) { let x=gameState.playerX+dx, y=gameState.playerY+dy; if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length&&gameState.dungeonGrid[y][x]===TILE.MONSTER) c++; } return c; }

    function generateDungeonFloor() { /* same */ 
        let s=11;
        gameState.dungeonGrid=[];
        for(let y=0;y<s;y++) {
            gameState.dungeonGrid[y]=[];
            for(let x=0;x<s;x++) {
                if(x===0||y===0||x===s-1||y===s-1) gameState.dungeonGrid[y][x]=TILE.WALL;
                else gameState.dungeonGrid[y][x]=Math.random()>0.3?TILE.FLOOR:TILE.WALL;
            }
        }
        gameState.dungeonGrid[gameState.playerY][gameState.playerX]=TILE.FLOOR;
        for(let i=0;i<3;i++) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR) gameState.dungeonGrid[y][x]=TILE.DOOR; }
        if(gameState.currentFloor<dungeons[gameState.currentDungeon].floors) { let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>3||Math.abs(y-5)>3)) { gameState.dungeonGrid[y][x]=TILE.STAIRS_DOWN; placed=true; } } }
        else { let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>3||Math.abs(y-5)>3)) { gameState.dungeonGrid[y][x]=TILE.EXIT; placed=true; } } }
        for(let i=0;i<5+gameState.currentFloor*2;i++) { let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>2||Math.abs(y-5)>2)) { gameState.dungeonGrid[y][x]=TILE.MONSTER; placed=true; } } }
        for(let i=0;i<3+Math.floor(gameState.currentFloor/2);i++) { let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR) { gameState.dungeonGrid[y][x]=TILE.TREASURE; placed=true; } } }
        for(let i=0;i<2+gameState.currentFloor;i++) { let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR) { gameState.dungeonGrid[y][x]=TILE.TRAP; placed=true; } } }
        let placed=false; while(!placed) { let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1; if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>2||Math.abs(y-5)>2)) { gameState.dungeonGrid[y][x]=TILE.PUZZLE; placed=true; } }
        gameState.exploredTiles.add(`${gameState.playerX},${gameState.playerY}`);
    }

    // ========== Movement & Actions ==========
    function moveForward() { let d=directions[gameState.playerDirection]; let nx=gameState.playerX+d.x, ny=gameState.playerY+d.y; if(nx<0||ny<0||ny>=gameState.dungeonGrid.length||nx>=gameState.dungeonGrid[0].length) { logMessage("WALL"); return; } let tile=gameState.dungeonGrid[ny][nx]; if(tile===TILE.WALL) logMessage("WALL"); else if(tile===TILE.DOOR) { if(gameState.inventory.keys.iron>0) { gameState.inventory.keys.iron--; gameState.dungeonGrid[ny][nx]=TILE.FLOOR; moveTo(nx,ny); logMessage("UNLOCKED DOOR"); } else logMessage("LOCKED"); } else if(tile===TILE.MONSTER) startCombat(nx,ny); else if(tile===TILE.TREASURE) { collectTreasure(nx,ny); moveTo(nx,ny); } else if(tile===TILE.TRAP) triggerTrap(nx,ny); else if(tile===TILE.STAIRS_DOWN) descendFloor(); else if(tile===TILE.EXIT) completeDungeon(); else if(tile===TILE.PUZZLE) startPuzzle(nx,ny); else moveTo(nx,ny); gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function moveTo(x,y) { gameState.playerX=x; gameState.playerY=y; gameState.exploredTiles.add(x+','+y); if(gameState.dungeonGrid[y][x]===TILE.TRAP&&!gameState.discoveredTraps.has(x+','+y)) triggerTrap(x,y); }
    function turnLeft() { gameState.playerDirection=(gameState.playerDirection+3)%4; gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function turnRight() { gameState.playerDirection=(gameState.playerDirection+1)%4; gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function moveBackward() { gameState.playerDirection=(gameState.playerDirection+2)%4; moveForward(); }
    function searchArea() { logMessage("SEARCHING..."); if(Math.random()<0.3) { let r=Math.random(); if(r<0.4) { let g=Math.floor(Math.random()*50)+10; gameState.gold+=g; logMessage(`FOUND ${g} GOLD`); } else if(r<0.7) logMessage("HIDDEN DOOR?"); else discoverTraps(); } else logMessage("NOTHING."); gameState.totalTurns++; updateStatusBar(); }
    function discoverTraps() { let f=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) { let x=gameState.playerX+dx, y=gameState.playerY+dy; if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length&&gameState.dungeonGrid[y][x]===TILE.TRAP) { let k=x+','+y; if(!gameState.discoveredTraps.has(k)) { gameState.discoveredTraps.add(k); f++; } } } if(f) logMessage(`DISCOVERED ${f} TRAPS`); else logMessage("NO TRAPS"); }
    function restInDungeon() { logMessage("REST..."); gameState.party.forEach(m=>{ if(m.active) { m.health=Math.min(m.maxHealth, m.health+Math.floor(m.maxHealth*0.1)); m.mana=Math.min(m.maxMana, m.mana+Math.floor(m.maxMana*0.2)); } }); if(Math.random()<0.3) { logMessage("AMBUSH!"); startRandomCombat(); } gameState.totalTurns+=3; updatePartyDisplay(); updateStatusBar(); }
    function useSkill(s) { if(!gameState.spells.includes(s)) { logMessage("DON'T KNOW THAT SPELL"); return; } let caster=gameState.party.find(m=>m.active&&(m.class==='mage'||m.class==='cleric')&&m.mana>= (spellsDB[s]?.cost||10)); if(!caster) { logMessage("NO CASTER WITH MANA"); return; } caster.mana -= (spellsDB[s]?.cost||10); if(s==='detect_traps') discoverTraps(); else if(s==='light') { revealArea(); logMessage("LIGHT"); } else if(s==='heal') { gameState.party.forEach(m=>{ if(m.active) m.health=Math.min(m.maxHealth, m.health+20); }); logMessage("HEAL"); updatePartyDisplay(); } else if(s==='fireball') { logMessage("Can't cast fireball here"); } else logMessage("SPELL USED"); gameState.totalTurns++; updateStatusBar(); }
    function revealArea() { for(let dy=-2;dy<=2;dy++) for(let dx=-2;dx<=2;dx++) { let x=gameState.playerX+dx, y=gameState.playerY+dy; if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length) gameState.exploredTiles.add(x+','+y); } updateAutoMap(); }
    function useTorch() { if(gameState.torches>0) { gameState.torches--; revealArea(); logMessage("LIT TORCH"); } else logMessage("NO TORCHES"); updateStatusBar(); document.getElementById('torchCount').textContent=gameState.torches; }
    function fleeToTown() { showConfirm("Flee dungeon? Lose 10% gold.", () => { gameState.gold-=Math.floor(gameState.gold*0.1); goToTown(); }, ()=>{}); }

    function enterDungeon(id) { gameState.currentDungeon=id; gameState.currentFloor=1; gameState.playerX=5; gameState.playerY=5; gameState.playerDirection=0; gameState.exploredTiles.clear(); gameState.discoveredSecrets.clear(); gameState.discoveredTraps.clear(); gameState.totalTurns=0; generateDungeonFloor(); showScreen('dungeonScreen'); updateDungeonView(); updateAutoMap(); logMessage(`ENTERED ${dungeons[id].name}`); }

    // ========== COMBAT with spell selection ==========
    function startCombat(x,y) {
        let d=dungeons[gameState.currentDungeon];
        let mt=d.monsters[Math.floor(Math.random()*d.monsters.length)];
        gameState.currentEnemy = { ...monsters[mt], x, y, health: monsters[mt].health };
        gameState.inCombat = true;
        gameState.dungeonGrid[y][x] = TILE.FLOOR;
        gameState.combatQueue = [];
        gameState.party.forEach((m, index) => { if (m.active && m.health > 0) { let stats = getCharacterStats(m); gameState.combatQueue.push({ type: 'party', index, speed: stats.dex, entity: m }); } });
        gameState.combatQueue.push({ type: 'enemy', speed: gameState.currentEnemy.speed || 10, entity: gameState.currentEnemy });
        gameState.combatQueue.sort((a,b) => b.speed - a.speed);
        gameState.currentTurnIndex = 0;
        updateCombatScreen();
        showScreen('combatScreen');
    }
    function startRandomCombat() { let d=dungeons[gameState.currentDungeon]; let mt=d.monsters[Math.floor(Math.random()*d.monsters.length)]; gameState.currentEnemy = { ...monsters[mt], x: gameState.playerX, y: gameState.playerY, health: monsters[mt].health }; gameState.inCombat = true; gameState.combatQueue = []; gameState.party.forEach((m, index) => { if (m.active && m.health > 0) { let stats = getCharacterStats(m); gameState.combatQueue.push({ type: 'party', index, speed: stats.dex, entity: m }); } }); gameState.combatQueue.push({ type: 'enemy', speed: gameState.currentEnemy.speed || 10, entity: gameState.currentEnemy }); gameState.combatQueue.sort((a,b) => b.speed - a.speed); gameState.currentTurnIndex = 0; updateCombatScreen(); showScreen('combatScreen'); }
    function getCharacterStats(m) { let str=m.strength, dex=m.dexterity, int=m.intelligence, vit=m.vitality; [m.equipment.weapon, m.equipment.armor, m.equipment.accessory].forEach(eq=>{ if(eq && items[eq]) { let bonus=items[eq].statBonus||{}; str+=bonus.strength||0; dex+=bonus.dexterity||0; int+=bonus.intelligence||0; vit+=bonus.vitality||0; } }); return {str,dex,int,vit}; }
    function updateCombatScreen() {
        let enemyDiv = document.getElementById('combatEnemyDisplay');
        enemyDiv.innerHTML = `<div style="color:#f35">${gameState.currentEnemy.name}</div><div>HP: ${gameState.currentEnemy.health}</div>`;
        let turnIndicator = document.getElementById('combatTurnIndicator');
        let current = gameState.combatQueue[gameState.currentTurnIndex];
        if (current.type === 'party') {
            turnIndicator.innerHTML = `Turn: ${current.entity.name}`;
            renderCombatActions(current.index);
        } else {
            turnIndicator.innerHTML = `Turn: ${gameState.currentEnemy.name}`;
            document.getElementById('combatActions').innerHTML = '';
            setTimeout(() => enemyTurn(), 500);
        }
        let cp = document.getElementById('combatParty');
        cp.innerHTML = '';
        gameState.party.forEach(m => { if (m.health > 0) cp.innerHTML += `<div class="party-member ${m.active?'active':''}"><div>${m.name}</div><div>HP ${m.health}</div></div>`; });
    }
    function renderCombatActions(partyIndex) {
        let actionsDiv = document.getElementById('combatActions');
        actionsDiv.innerHTML = `
            <button onclick="combatAction(${partyIndex}, 'attack')">ATTACK</button>
            <button onclick="showSpellSelection(${partyIndex})">SPELL</button>
            <button onclick="combatAction(${partyIndex}, 'item')">ITEM</button>
            <button onclick="combatAction(${partyIndex}, 'defend')">DEFEND</button>
        `;
    }
    function showSpellSelection(partyIndex) {
        let member = gameState.party[partyIndex];
        let known = gameState.spells.filter(s => spellsDB[s] && (member.mana >= spellsDB[s].cost));
        let listDiv = document.getElementById('spellList');
        listDiv.innerHTML = '';
        known.forEach(s => {
            let spell = spellsDB[s];
            listDiv.innerHTML += `<div class="spell-item" onclick="castSpell(${partyIndex}, '${s}')">${spell.name} (${spell.cost} MP)</div>`;
        });
        document.getElementById('combatSpellSelection').style.display = 'block';
        document.getElementById('combatActions').style.display = 'none';
        window.currentCasterIndex = partyIndex;
    }
    function cancelSpellSelection() {
        document.getElementById('combatSpellSelection').style.display = 'none';
        document.getElementById('combatActions').style.display = 'grid';
    }
    function castSpell(partyIndex, spellKey) {
        let member = gameState.party[partyIndex];
        let spell = spellsDB[spellKey];
        if (!member || member.mana < spell.cost) { logMessage("Not enough mana"); cancelSpellSelection(); return; }
        member.mana -= spell.cost;
        if (spell.target === 'enemy') {
            spell.effect(member, gameState.currentEnemy);
        } else if (spell.target === 'ally') {
            // simple: target self or first injured
            let target = gameState.party.find(m => m.health < m.maxHealth) || member;
            spell.effect(member, target);
        } else {
            spell.effect(member);
        }
        cancelSpellSelection();
        if (gameState.currentEnemy.health <= 0) { enemyDefeated(); return; }
        nextCombatTurn();
    }
    function combatAction(partyIndex, action) {
        let member = gameState.party[partyIndex];
        if (!member || member.health <= 0) return;
        let log = document.getElementById('battleLog');
        if (action === 'attack') {
            let stats = getCharacterStats(member);
            let dmg = Math.floor(Math.random() * 8) + 4 + Math.floor(stats.str / 2);
            gameState.currentEnemy.health -= dmg;
            log.innerHTML += `<p>${member.name} hits for ${dmg}</p>`;
            if (gameState.currentEnemy.health <= 0) { enemyDefeated(); return; }
        } else if (action === 'defend') {
            member.status.push('DEFENDING');
            log.innerHTML += `<p>${member.name} defends</p>`;
        } else {
            log.innerHTML += `<p>Not implemented</p>`;
        }
        nextCombatTurn();
    }
    function enemyTurn() {
        if (!gameState.currentEnemy || gameState.currentEnemy.health <= 0) return;
        let log = document.getElementById('battleLog');
        let aliveParty = gameState.party.filter(m => m.active && m.health > 0);
        if (aliveParty.length === 0) { gameOver(); return; }
        let target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
        let dmg = Math.floor(Math.random() * (gameState.currentEnemy.damage[1] - gameState.currentEnemy.damage[0] + 1)) + gameState.currentEnemy.damage[0];
        if (target.status.includes('DEFENDING')) dmg = Math.floor(dmg / 2);
        target.health -= dmg;
        log.innerHTML += `<p>${gameState.currentEnemy.name} hits ${target.name} for ${dmg}</p>`;
        target.status = target.status.filter(s => s !== 'DEFENDING');
        if (target.health <= 0) { target.health = 0; log.innerHTML += `<p>${target.name} KO!</p>`; }
        if (gameState.party.filter(m => m.active && m.health > 0).length === 0) { gameOver(); return; }
        nextCombatTurn();
    }
    function nextCombatTurn() {
        gameState.combatQueue = gameState.combatQueue.filter(entry => entry.type==='party' ? entry.entity.health>0 : entry.entity.health>0);
        if (gameState.combatQueue.length === 0) return;
        gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.combatQueue.length;
        updateCombatScreen();
    }
    function enemyDefeated() {
        let log = document.getElementById('battleLog');
        let goldGain = Math.floor(Math.random() * 50) + 20;
        gameState.gold += goldGain;
        gameState.monstersSlain++;
        let xpGain = gameState.currentEnemy.xp || 30;
        log.innerHTML += `<p>VICTORY! GOLD +${goldGain}, XP +${xpGain}</p>`;
        gameState.party.forEach(m => { if (m.active && m.health > 0) { m.xp += xpGain; while (m.xp >= m.nextLevelXP) { m.level++; m.xp -= m.nextLevelXP; m.nextLevelXP = Math.floor(m.nextLevelXP * 1.5); gameState.levelUpQueue.push(m.id); } } });
        gameState.quests.forEach(q => { if (q.type === 'kill' && q.monster === gameState.currentEnemy.name) q.progress++; });
        setTimeout(() => {
            gameState.inCombat = false; gameState.currentEnemy = null; gameState.combatQueue = [];
            if (gameState.levelUpQueue.length > 0) showLevelUp(); else showScreen('dungeonScreen');
            updateStatusBar(); updatePartyDisplay();
        }, 1500);
    }
    function fleeCombat() { if (Math.random() < 0.5) { document.getElementById('battleLog').innerHTML += '<p>FLED!</p>'; setTimeout(() => { gameState.inCombat = false; gameState.currentEnemy = null; gameState.combatQueue = []; showScreen('dungeonScreen'); }, 1000); } else { document.getElementById('battleLog').innerHTML += '<p>CANNOT FLEE!</p>'; enemyTurn(); } }

    // ========== Inventory, Equipment, Level Up ==========
    function showInventoryScreen() { showNotification(`Keys: Iron ${gameState.inventory.keys.iron}, Silver ${gameState.inventory.keys.silver}, Gold ${gameState.inventory.keys.gold}\nPotions: Healing ${gameState.inventory.potions.healing}, Mana ${gameState.inventory.potions.mana}, Antidote ${gameState.inventory.potions.antidote}\nScrolls: Identify ${gameState.inventory.scrolls.identify}, Mapping ${gameState.inventory.scrolls.mapping}`); }
    function selectCharacter(id) { gameState.selectedCharacter = id; renderCharacterScreen(id); showScreen('characterScreen'); }
    function renderCharacterScreen(id) { let m = gameState.party.find(c => c.id === id); if (!m) return; document.getElementById('charName').textContent = m.name; document.getElementById('charHP').textContent = m.health; document.getElementById('charMaxHP').textContent = m.maxHealth; document.getElementById('charMP').textContent = m.mana; document.getElementById('charMaxMP').textContent = m.maxMana; let stats = getCharacterStats(m); document.getElementById('charStr').textContent = stats.str; document.getElementById('charDex').textContent = stats.dex; document.getElementById('charInt').textContent = stats.int; document.getElementById('charVit').textContent = stats.vit; document.getElementById('charXP').textContent = m.xp; document.getElementById('charNextXP').textContent = m.nextLevelXP; let eqDiv = document.getElementById('equipmentSlots'); eqDiv.innerHTML = `<div class="equipment-slot">Weapon: ${m.equipment.weapon ? items[m.equipment.weapon].name : 'None'} <button class="item-btn" onclick="unequip(${id}, 'weapon')">Unequip</button></div><div class="equipment-slot">Armor: ${m.equipment.armor ? items[m.equipment.armor].name : 'None'} <button class="item-btn" onclick="unequip(${id}, 'armor')">Unequip</button></div><div class="equipment-slot">Accessory: ${m.equipment.accessory ? items[m.equipment.accessory].name : 'None'} <button class="item-btn" onclick="unequip(${id}, 'accessory')">Unequip</button></div>`; let invDiv = document.getElementById('charInventory'); invDiv.innerHTML = '<h4>Equippable Items (click to equip)</h4><button class="item-btn" onclick="equipItem('+id+', \'LONG_SWORD\')">Equip Long Sword</button><button class="item-btn" onclick="equipItem('+id+', \'CHAIN_MAIL\')">Equip Chain Mail</button>'; }
    function unequip(charId, slot) { let m = gameState.party.find(c => c.id === charId); if (m && m.equipment[slot]) { gameState.inventory.special.push(m.equipment[slot]); m.equipment[slot] = null; renderCharacterScreen(charId); } }
    function equipItem(charId, itemKey) { let m = gameState.party.find(c => c.id === charId); let item = items[itemKey]; if (!m || !item) return; if (m.equipment[item.type]) { showNotification(`Already have ${item.type} equipped`); return; } m.equipment[item.type] = itemKey; let idx = gameState.inventory.special.indexOf(itemKey); if (idx > -1) gameState.inventory.special.splice(idx, 1); renderCharacterScreen(charId); }
    function showLevelUp() { if (gameState.levelUpQueue.length === 0) return; gameState.selectedCharacter = gameState.levelUpQueue[0]; renderLevelUp(); showScreen('levelUpScreen'); }
    function renderLevelUp() { let char = gameState.party.find(c => c.id === gameState.selectedCharacter); if (!char) return; document.getElementById('levelUpChar').innerHTML = `${char.name} (Level ${char.level})`; }
    function levelUpStat(stat) { let char = gameState.party.find(c => c.id === gameState.selectedCharacter); if (!char) return; char[stat] += 2; if (stat === 'vitality') { char.maxHealth = 20 + char.vitality * 2; char.health = char.maxHealth; } if (stat === 'intelligence' && (char.class === 'mage' || char.class === 'cleric')) { char.maxMana = (char.class === 'mage' ? 30 : 20) + Math.floor(char.intelligence / 2); char.mana = char.maxMana; } gameState.levelUpQueue = gameState.levelUpQueue.filter(id => id !== char.id); if (gameState.levelUpQueue.length > 0) { gameState.selectedCharacter = gameState.levelUpQueue[0]; renderLevelUp(); } else { showScreen('dungeonScreen'); } updatePartyDisplay(); updateStatusBar(); }
    function cancelLevelUp() { showScreen('dungeonScreen'); }
    function showPartyScreen() { renderPartyList(); showScreen('partyScreen'); }
    function renderPartyList() { let div = document.getElementById('partyMemberList'); div.innerHTML = ''; gameState.party.forEach(m => { div.innerHTML += `<div class="party-member" onclick="selectCharacter(${m.id})"><div class="member-name">${m.name}</div><div class="member-class">L${m.level} ${m.className}</div><div>HP ${m.health}/${m.maxHealth} MP ${m.mana}/${m.maxMana}</div><div>STR ${m.strength} DEX ${m.dexterity} INT ${m.intelligence} VIT ${m.vitality}</div></div>`; }); }

    // ========== Town, Shops, etc. ==========
    function goToTown() { gameState.currentDungeon = null; gameState.inCombat = false; gameState.inPuzzle = false; showScreen('townScreen'); }
    function goToDungeonSelect() { showScreen('dungeonSelectScreen'); }
    function goToInn() { if (gameState.gold >= 40) { gameState.gold -= 40; gameState.party.forEach(m => { m.health = m.maxHealth; m.mana = m.maxMana; m.status = []; }); document.getElementById('townMessage').innerHTML = 'RESTED AND HEALED'; } else { document.getElementById('townMessage').innerHTML = 'NOT ENOUGH GOLD'; } updateStatusBar(); }
    function goToTemple() { showScreen('templeScreen'); }
    function templeCure() { if (gameState.gold >= 30) { gameState.gold -= 30; gameState.party.forEach(m => m.status = []); document.getElementById('templeMessage').innerHTML = 'AILMENTS CURED'; } else { document.getElementById('templeMessage').innerHTML = 'NOT ENOUGH GOLD'; } updateStatusBar(); }
    function goToShop() { renderShop(); showScreen('shopScreen'); }
    function renderShop() { let div = document.getElementById('shopItems'); div.innerHTML = ''; let itemsForSale = ['torch', 'healing_potion', 'antidote', 'iron_key', 'trap_kit', 'map_scroll']; itemsForSale.forEach(item => { let cost = { torch:5, healing_potion:25, antidote:20, iron_key:50, trap_kit:75, map_scroll:100 }[item]; div.innerHTML += `<div class="shop-item" onclick="buyItem('${item}',${cost})">${item.toUpperCase()} - ${cost}G</div>`; }); }
    function buyItem(item, cost) { if (gameState.gold >= cost) { gameState.gold -= cost; if (item === 'torch') gameState.torches++; else if (item === 'healing_potion') gameState.inventory.potions.healing++; else if (item === 'antidote') gameState.inventory.potions.antidote++; else if (item === 'iron_key') gameState.inventory.keys.iron++; else if (item === 'trap_kit') gameState.inventory.special.push('trap_kit'); else if (item === 'map_scroll') gameState.inventory.scrolls.mapping++; document.getElementById('shopMessage').innerHTML = 'PURCHASED'; } else { document.getElementById('shopMessage').innerHTML = 'NOT ENOUGH'; } updateStatusBar(); }
    function goToMagicShop() { renderMagicShop(); showScreen('magicShopScreen'); }
    function renderMagicShop() { let div = document.getElementById('magicShopItems'); div.innerHTML = ''; let spells = ['light', 'detect_traps', 'detect_secret', 'heal', 'fireball']; spells.forEach(s => { let cost = { light:100, detect_traps:150, detect_secret:200, heal:250, fireball:300 }[s]; div.innerHTML += `<div class="shop-item" onclick="buySpell('${s}')">${s.toUpperCase()} - ${cost}G</div>`; }); }
    function buySpell(s) { let cost = { light:100, detect_traps:150, detect_secret:200, heal:250, fireball:300 }[s]; if (gameState.gold >= cost && !gameState.spells.includes(s)) { gameState.gold -= cost; gameState.spells.push(s); document.getElementById('magicShopMessage').innerHTML = 'LEARNED'; } else { document.getElementById('magicShopMessage').innerHTML = 'CANNOT BUY'; } updateStatusBar(); }
    function goToGuild() { renderGuild(); showScreen('guildScreen'); }
    function renderGuild() { let div = document.getElementById('questList'); div.innerHTML = ''; gameState.quests.forEach(q => { div.innerHTML += `<div class="town-location">${q.name} (${q.progress}/${q.target}) - Reward: ${q.reward}G</div>`; }); }

    // ========== Treasure, traps, puzzles ==========
    function collectTreasure(x,y) { let g=Math.floor(Math.random()*200)+50; gameState.gold+=g; gameState.dungeonGrid[y][x]=TILE.FLOOR; logMessage(`FOUND ${g} GOLD`); updateStatusBar(); }
    function triggerTrap(x,y) { let k=x+','+y; if(gameState.discoveredTraps.has(k)) { logMessage("DISARMED"); gameState.dungeonGrid[y][x]=TILE.FLOOR; return; } gameState.discoveredTraps.add(k); let dmg=Math.floor(Math.random()*20)+5; gameState.party.forEach(m=>{ if(m.active) m.health=Math.max(1,m.health-dmg); }); gameState.dungeonGrid[y][x]=TILE.FLOOR; logMessage(`TRAP! ${dmg} DAMAGE`); updatePartyDisplay(); if(gameState.party.filter(m=>m.active&&m.health>0).length===0) gameOver(); }
    function startPuzzle(x,y) { gameState.inPuzzle=true; gameState.currentPuzzle={x,y}; document.getElementById('puzzleElements').innerHTML='FIRE WATER EARTH AIR'.split(' ').map(e=>`<div class="puzzle-element" onclick="cycleElement(this)" data-element="${e}">${e[0]}</div>`).join(''); showScreen('puzzleScreen'); }
    window.cycleElement=function(el){ let els=['FIRE','WATER','EARTH','AIR']; let cur=el.dataset.element; let nxt=els[(els.indexOf(cur)+1)%4]; el.dataset.element=nxt; el.textContent=nxt[0]; };
    function checkPuzzle() { let order=[...document.querySelectorAll('#puzzleElements .puzzle-element')].map(e=>e.dataset.element); if(order.join()==='FIRE,WATER,EARTH,AIR') { document.getElementById('puzzleResult').innerHTML='<p class="heal">SOLVED! +100G</p>'; gameState.gold+=100; gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x]=TILE.FLOOR; setTimeout(()=>{ gameState.inPuzzle=false; showScreen('dungeonScreen'); },2000); } else { document.getElementById('puzzleResult').innerHTML='<p>WRONG -5HP</p>'; gameState.party.forEach(m=>m.health=Math.max(1,m.health-5)); updatePartyDisplay(); } }
    function skipPuzzle() { if(confirm("FORCE?")) { if(Math.random()<0.5) { document.getElementById('puzzleResult').innerHTML='SUCCESS'; gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x]=TILE.FLOOR; } else { document.getElementById('puzzleResult').innerHTML='FAIL -15HP'; gameState.party.forEach(m=>m.health=Math.max(1,m.health-15)); } setTimeout(()=>{ gameState.inPuzzle=false; showScreen('dungeonScreen'); },2000); } }
    function descendFloor() { if(gameState.currentFloor<dungeons[gameState.currentDungeon].floors) { gameState.currentFloor++; gameState.playerX=5; gameState.playerY=5; gameState.playerDirection=0; gameState.exploredTiles.clear(); gameState.discoveredSecrets.clear(); gameState.discoveredTraps.clear(); generateDungeonFloor(); logMessage(`FLOOR ${gameState.currentFloor}`); updateDungeonView(); updateAutoMap(); } }
    function completeDungeon() { gameState.gold+=1000*gameState.currentFloor; gameState.dungeonsCompleted.push(gameState.currentDungeon); document.getElementById('victoryFloors').textContent=gameState.currentFloor; document.getElementById('victoryMonsters').textContent=gameState.monstersSlain; document.getElementById('victoryTreasure').textContent=gameState.gold; showScreen('victoryScreen'); }
    function gameOver() { document.getElementById('finalFloors').textContent=gameState.currentFloor; document.getElementById('finalMonsters').textContent=gameState.monstersSlain; document.getElementById('finalTreasure').textContent=gameState.gold; showScreen('gameOverScreen'); }
    function restartGame() { location.reload(); }
    function logMessage(m) { let l=document.getElementById('combatLog'); if(l) { l.innerHTML+=`<p>${m}</p>`; l.scrollTop=l.scrollHeight; } }
    function sellMode() { showNotification("Sell mode not fully implemented"); }
</script>
</body>
</html>
