<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Journey into Darkness - Procedural Dungeon Crawler</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            font-family: 'VT323', monospace;
            background-color: #0a0a1a;
            color: #8af;
            line-height: 1.4;
            height: 100vh;
            overflow: hidden;
            touch-action: pan-x pan-y;
            padding: 5px;
        }
        
        .container {
            max-width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            border: 2px solid #48f;
            background-color: #111122;
            padding: 8px;
            gap: 8px;
            position: relative;
        }
        
        .header {
            text-align: center;
            padding: 8px 5px;
            border-bottom: 1px dashed #48f;
            flex-shrink: 0;
            background: linear-gradient(to right, #111122, #1a1a33, #111122);
        }
        
        .game-title {
            font-size: 1.8rem;
            color: #8af;
            text-shadow: 0 0 8px #48f;
            margin-bottom: 5px;
            letter-spacing: 2px;
        }
        
        .level-title {
            font-size: 1.2rem;
            color: #6cf;
        }
        
        .screen {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #48f;
            padding: 12px;
            background-color: #0a0a1a;
            font-size: 1.3rem;
            line-height: 1.6;
            min-height: 0;
            scroll-behavior: smooth;
            box-shadow: inset 0 0 10px rgba(0, 100, 255, 0.2);
        }
        
        .screen::-webkit-scrollbar {
            width: 8px;
        }
        
        .screen::-webkit-scrollbar-thumb {
            background-color: #48f;
        }
        
        .output-text {
            margin-bottom: 10px;
            animation: typing 0.05s steps(1, end);
            word-wrap: break-word;
        }
        
        .enemy-text {
            color: #f88;
        }
        
        .combat-text {
            color: #f66;
            font-weight: bold;
        }
        
        .damage-text {
            color: #f44;
            text-shadow: 0 0 3px #f44;
        }
        
        .heal-text {
            color: #8f8;
        }
        
        .loot-text {
            color: #fd8;
        }
        
        .player-text {
            color: #aaf;
        }
        
        .important-text {
            color: #ff8;
            font-weight: bold;
        }
        
        .danger-text {
            color: #f44;
        }
        
        .success-text {
            color: #4f4;
        }
        
        .gold-text {
            color: #fd0;
            text-shadow: 0 0 3px #fd0;
        }
        
        .npc-text {
            color: #6cf;
        }
        
        .merchant-text {
            color: #fa8;
        }
        
        .mystic-text {
            color: #c8f;
        }
        
        .secret-text {
            color: #f8f;
            text-shadow: 0 0 3px #f8f;
        }
        
        .action-panel {
            display: none;
            border: 1px solid #48f;
            padding: 10px;
            background-color: #111122;
            flex-shrink: 0;
            box-shadow: 0 0 10px rgba(0, 100, 255, 0.3);
        }
        
        .action-title {
            color: #8af;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .action-choices {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }
        
        .button {
            background-color: #0a0a1a;
            color: #8af;
            border: 1px solid #48f;
            padding: 14px 8px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
            touch-action: manipulation;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }
        
        .button:hover, .button:active {
            background-color: #48f;
            color: #0a0a1a;
        }
        
        .command-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            flex-shrink: 0;
        }
        
        .command-button {
            background-color: #0a0a1a;
            color: #8af;
            border: 1px solid #48f;
            padding: 14px 5px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.1s;
            touch-action: manipulation;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .command-button:hover, .command-button:active {
            background-color: #48f;
            color: #0a0a1a;
        }
        
        .combat-panel {
            display: none;
            border: 1px solid #48f;
            padding: 10px;
            background-color: #111122;
            flex-shrink: 0;
        }
        
        .combat-title {
            color: #f66;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .combat-choices {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .combat-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px dashed #48f;
            background-color: #0a0a1a;
            font-size: 1.1rem;
        }
        
        .player-stats, .enemy-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-bar {
            width: 100px;
            height: 10px;
            background-color: #222233;
            margin: 2px 0;
            overflow: hidden;
        }
        
        .health-bar {
            height: 100%;
            background-color: #f44;
            width: 100%;
        }
        
        .mana-bar {
            height: 100%;
            background-color: #66f;
            width: 100%;
        }
        
        .inventory-panel {
            display: none;
            border: 1px solid #48f;
            padding: 10px;
            background-color: #111122;
            flex-shrink: 0;
        }
        
        .inventory-title {
            color: #8af;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .inventory-item {
            border: 1px dashed #48f;
            padding: 8px 10px;
            font-size: 1.1rem;
            min-width: 100px;
            text-align: center;
            background-color: #0a0a1a;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 8px 5px;
            border-top: 1px dashed #48f;
            flex-shrink: 0;
            font-size: 1rem;
            background: linear-gradient(to right, #111122, #1a1a33, #111122);
        }
        
        .equipment-panel {
            display: none;
            border: 1px solid #48f;
            padding: 10px;
            background-color: #111122;
            flex-shrink: 0;
            margin-top: 8px;
        }
        
        .equipment-title {
            color: #8af;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .equipment-slots {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .equipment-slot {
            border: 1px dashed #48f;
            padding: 8px;
            text-align: center;
            font-size: 1.1rem;
            background-color: #0a0a1a;
        }
        
        .map-panel {
            display: none;
            border: 1px solid #48f;
            padding: 10px;
            background-color: #111122;
            flex-shrink: 0;
            margin-top: 8px;
        }
        
        .map-title {
            color: #8af;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-align: center;
        }
        
        .map-display {
            font-family: monospace;
            white-space: pre;
            font-size: 0.9rem;
            line-height: 1.2;
            background-color: #0a0a1a;
            padding: 10px;
            border: 1px dashed #48f;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .class-select-panel {
            display: none;
            border: 1px solid #48f;
            padding: 20px;
            background-color: #111122;
            flex-shrink: 0;
            margin-top: 8px;
            text-align: center;
        }
        
        .class-title {
            color: #8af;
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-shadow: 0 0 8px #48f;
        }
        
        .class-choices {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .class-button {
            background-color: #0a0a1a;
            color: #8af;
            border: 2px solid #48f;
            padding: 15px 10px;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .class-button:hover, .class-button.selected {
            background-color: #48f;
            color: #0a0a1a;
            transform: scale(1.05);
        }
        
        .class-description {
            margin-top: 5px;
            font-size: 0.9rem;
            color: #aaf;
        }
        
        .permadeath-notice {
            color: #f44;
            font-size: 1.1rem;
            margin-top: 10px;
            text-align: center;
        }
        
        .unlock-notice {
            color: #ff8;
            font-size: 1rem;
            margin-top: 5px;
            text-align: center;
        }
        
        .run-stats {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #aaf;
            font-size: 0.9rem;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border: 1px solid #48f;
            border-radius: 4px;
        }
        
        .floor-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fd8;
            font-size: 0.9rem;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border: 1px solid #48f;
            border-radius: 4px;
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        @keyframes typing {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Responsive adjustments */
        @media (max-height: 700px) {
            .button, .command-button {
                padding: 10px 5px;
                font-size: 1.1rem;
                min-height: 40px;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            .level-title {
                font-size: 1rem;
            }
            
            .screen {
                font-size: 1.2rem;
            }
            
            .class-button {
                padding: 10px 5px;
                min-height: 60px;
            }
        }
        
        @media (max-height: 600px) {
            .screen {
                font-size: 1.1rem;
                padding: 8px;
            }
            
            .button, .command-button {
                padding: 8px 4px;
                min-height: 36px;
                font-size: 1rem;
            }
        }
        
        .procedural-notice {
            color: #8f8;
            font-size: 1.1rem;
            text-align: center;
            margin-top: 10px;
        }
        
        .room-grid {
            display: inline-block;
            font-family: monospace;
            margin: 10px 0;
            padding: 5px;
            background-color: #000;
            border: 1px solid #48f;
        }
        
        .grid-cell {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin: 1px;
            text-align: center;
            line-height: 12px;
            font-size: 8px;
        }
        
        .cell-empty { background-color: #222; color: #222; }
        .cell-wall { background-color: #444; color: #444; }
        .cell-player { background-color: #8af; color: #8af; font-weight: bold; }
        .cell-enemy { background-color: #f44; color: #f44; }
        .cell-exit { background-color: #fd8; color: #fd8; }
        .cell-loot { background-color: #8f8; color: #8f8; }
        .cell-explored { background-color: #333; color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <div class="floor-indicator" id="floorIndicator">Depth: 1</div>
        <div class="run-stats" id="runStats">Best: 0 | Unlocks: 0</div>
        
        <div class="header">
            <div class="game-title">JOURNEY INTO DARKNESS</div>
            <div class="level-title" id="levelTitle">PROCEDURAL DUNGEON CRAWLER</div>
        </div>
        
        <div class="screen" id="gameScreen">
            <div class="output-text">JOURNEY INTO DARKNESS v1.0</div>
            <div class="output-text">Procedural Dungeon Crawler</div>
            <div class="output-text">Each run is unique. Death is permanent.</div>
            <div class="output-text">Reach deeper floors to unlock new classes!</div>
            <div class="output-text">----------------------------------------</div>
            <div class="output-text" id="currentOutput">The void calls. Choose your fate...</div>
        </div>
        
        <!-- Class Selection Panel -->
        <div class="class-select-panel" id="classSelectPanel">
            <div class="class-title">SELECT YOUR PATH</div>
            <div class="class-choices" id="classChoices">
                <!-- Dynamic class buttons will be inserted here -->
            </div>
            <div class="permadeath-notice">⚠ PERMADEATH ENABLED ⚠</div>
            <div class="unlock-notice" id="unlockNotice">Unlock new classes by reaching deeper floors!</div>
        </div>
        
        <!-- Action Panel for choices -->
        <div class="action-panel" id="actionPanel">
            <div class="action-title" id="actionTitle">Select Action</div>
            <div class="action-choices" id="actionChoices">
                <!-- Dynamic buttons will be inserted here -->
            </div>
        </div>
        
        <!-- Combat Panel -->
        <div class="combat-panel" id="combatPanel">
            <div class="combat-title" id="combatTitle">ENCOUNTER</div>
            <div class="combat-info" id="combatInfo">
                <div class="player-stats">
                    <div>YOU</div>
                    <div>HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span></div>
                    <div class="stat-bar">
                        <div class="health-bar" id="playerHealthBar"></div>
                    </div>
                    <div>MP: <span id="playerMP">30</span>/<span id="playerMaxMP">30</span></div>
                    <div class="stat-bar">
                        <div class="mana-bar" id="playerManaBar"></div>
                    </div>
                </div>
                <div class="enemy-stats">
                    <div id="enemyName">ENEMY</div>
                    <div>HP: <span id="enemyHP">50</span>/<span id="enemyMaxHP">50</span></div>
                    <div class="stat-bar">
                        <div class="health-bar" id="enemyHealthBar"></div>
                    </div>
                    <div id="enemyStatus">Status: Normal</div>
                </div>
            </div>
            <div class="combat-choices" id="combatChoices">
                <!-- Dynamic combat buttons will be inserted here -->
            </div>
        </div>
        
        <!-- Main Command Buttons -->
        <div class="command-buttons" id="commandButtons" style="display: none;">
            <button class="command-button" id="lookBtn">EXAMINE</button>
            <button class="command-button" id="exploreBtn">SEARCH</button>
            <button class="command-button" id="inventoryBtn">INVENTORY</button>
            <button class="command-button" id="equipmentBtn">EQUIP</button>
            <button class="command-button" id="useBtn">USE</button>
            <button class="command-button" id="restBtn">REST</button>
            <button class="command-button" id="moveBtn">MOVE</button>
            <button class="command-button" id="mapBtn">MAP</button>
        </div>
        
        <!-- Inventory Panel -->
        <div class="inventory-panel" id="inventoryPanel">
            <div class="inventory-title">INVENTORY</div>
            <div class="inventory-items" id="inventoryItems">
                <div class="inventory-item">Empty</div>
            </div>
        </div>
        
        <!-- Equipment Panel -->
        <div class="equipment-panel" id="equipmentPanel">
            <div class="equipment-title">EQUIPMENT</div>
            <div class="equipment-slots" id="equipmentSlots">
                <!-- Equipment slots will be inserted here -->
            </div>
        </div>
        
        <!-- Map Panel -->
        <div class="map-panel" id="mapPanel">
            <div class="map-title">DUNGEON MAP</div>
            <div class="map-display" id="mapDisplay">
                <!-- Map will be displayed here -->
            </div>
        </div>
        
        <div class="status-bar" id="statusBar" style="display: none;">
            <div>Depth: <span id="floorValue">1</span> | Room: <span id="roomValue">Entrance</span></div>
            <div>HP: <span id="healthValue">100</span>/<span id="maxHealthValue">100</span></div>
            <div>MP: <span id="manaValue">30</span>/<span id="maxManaValue">30</span></div>
            <div>Gold: <span class="gold-text" id="goldValue">0</span></div>
            <div>Score: <span id="scoreValue">0</span></div>
        </div>
    </div>

    <!-- Replace the entire script section with this corrected version -->

<script>
        // ============================================
        // GAME SAVE DATA (Persistent between runs)
        // ============================================
        let gameSave = {
            // Persistent unlocks
            unlockedClasses: ["warrior", "rogue", "mage"],
            deepestFloor: 0,
            totalRuns: 0,
            totalKills: 0,
            bestScore: 0,
            
            // Achievement tracking
            achievements: {
                firstDeath: false,
                floor5: false,
                floor10: false,
                floor20: false,
                allClasses: false,
                bossKiller: false
            }
        };
        
        // Load save data from localStorage
        function loadGameSave() {
            const saved = localStorage.getItem('journeyIntoDarknessSave');
            if (saved) {
                try {
                    gameSave = JSON.parse(saved);
                } catch (e) {
                    console.log("Could not load save data, starting fresh");
                }
            }
        }
        
        // Save game data to localStorage
        function saveGameSave() {
            localStorage.setItem('journeyIntoDarknessSave', JSON.stringify(gameSave));
        }
        
        // ============================================
        // PROCEDURAL GENERATION SYSTEM
        // ============================================
        const dungeonGenerator = {
            // Room types with weights
            roomTypes: [
                { type: "empty", weight: 30, minSize: 3, maxSize: 8 },
                { type: "corridor", weight: 25, minSize: 1, maxSize: 12 },
                { type: "chamber", weight: 20, minSize: 4, maxSize: 10 },
                { type: "hall", weight: 15, minSize: 6, maxSize: 15 },
                { type: "cave", weight: 10, minSize: 5, maxSize: 12 }
            ],
            
            // Room contents
            roomContents: [
                { type: "empty", weight: 40 },
                { type: "enemy", weight: 30 },
                { type: "loot", weight: 15 },
                { type: "trap", weight: 10 },
                { type: "shrine", weight: 5 }
            ],
            
            // Generate a random seed for this run
            generateSeed() {
                return Date.now().toString(36) + Math.random().toString(36).substr(2);
            },
            
            // Simple seeded random
            seededRandom(seed, index) {
                let hash = 0;
                for (let i = 0; i < seed.length; i++) {
                    hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs((Math.sin(hash + index) * 10000) % 1);
            },
            
            // Generate a procedural dungeon floor
            generateFloor(floorNumber, seed) {
                const floor = {
                    rooms: {},
                    grid: [],
                    playerStart: { x: 0, y: 0 },
                    stairsDown: { x: 0, y: 0 },
                    roomCount: 0,
                    seed: seed
                };
                
                // Determine floor size based on depth
                const baseSize = 15 + Math.min(floorNumber, 20); // Cap at 35x35
                const gridSize = baseSize + Math.floor(this.seededRandom(seed, 0) * 10);
                
                // Initialize empty grid
                for (let y = 0; y < gridSize; y++) {
                    floor.grid[y] = [];
                    for (let x = 0; x < gridSize; x++) {
                        floor.grid[y][x] = { type: 'wall', explored: false, roomId: null };
                    }
                }
                
                // Generate rooms
                const maxRooms = Math.floor(5 + floorNumber * 0.5);
                const rooms = [];
                
                for (let i = 0; i < maxRooms; i++) {
                    // Pick random room type
                    let roomType = this.pickWeighted(this.roomTypes, this.seededRandom(seed, i * 2));
                    
                    // Generate room size
                    const width = roomType.minSize + Math.floor(this.seededRandom(seed, i * 3) * (roomType.maxSize - roomType.minSize));
                    const height = roomType.minSize + Math.floor(this.seededRandom(seed, i * 4) * (roomType.maxSize - roomType.minSize));
                    
                    // Try to place room
                    for (let attempt = 0; attempt < 100; attempt++) {
                        const x = 1 + Math.floor(this.seededRandom(seed, i * 5 + attempt) * (gridSize - width - 2));
                        const y = 1 + Math.floor(this.seededRandom(seed, i * 6 + attempt) * (gridSize - height - 2));
                        
                        // Check if room overlaps with others
                        let canPlace = true;
                        for (let checkY = y - 1; checkY < y + height + 1; checkY++) {
                            for (let checkX = x - 1; checkX < x + width + 1; checkX++) {
                                if (floor.grid[checkY] && floor.grid[checkY][checkX] && 
                                    floor.grid[checkY][checkX].type !== 'wall') {
                                    canPlace = false;
                                    break;
                                }
                            }
                            if (!canPlace) break;
                        }
                        
                        if (canPlace) {
                            // Create room
                            const roomId = `room_${i}`;
                            const roomContent = this.pickWeighted(this.roomContents, this.seededRandom(seed, i * 7));
                            
                            // Carve out room in grid
                            for (let roomY = y; roomY < y + height; roomY++) {
                                for (let roomX = x; roomX < x + width; roomX++) {
                                    floor.grid[roomY][roomX] = { 
                                        type: 'floor', 
                                        explored: false,
                                        roomId: roomId,
                                        content: roomContent.type,
                                        position: { x: roomX, y: roomY }
                                    };
                                }
                            }
                            
                            // Add to rooms list
                            rooms.push({
                                id: roomId,
                                x: x,
                                y: y,
                                width: width,
                                height: height,
                                centerX: Math.floor(x + width / 2),
                                centerY: Math.floor(y + height / 2),
                                type: roomType.type,
                                content: roomContent.type
                            });
                            
                            break;
                        }
                    }
                }
                
                // Connect rooms with corridors
                for (let i = 1; i < rooms.length; i++) {
                    const prevRoom = rooms[i - 1];
                    const currRoom = rooms[i];
                    
                    // Randomly decide start point
                    const startX = prevRoom.centerX;
                    const startY = prevRoom.centerY;
                    const endX = currRoom.centerX;
                    const endY = currRoom.centerY;
                    
                    // Create L-shaped corridor
                    if (this.seededRandom(seed, i * 8) < 0.5) {
                        // Horizontal then vertical
                        this.createCorridor(floor, startX, endX, startY, 'horizontal');
                        this.createCorridor(floor, startY, endY, endX, 'vertical');
                    } else {
                        // Vertical then horizontal
                        this.createCorridor(floor, startY, endY, startX, 'vertical');
                        this.createCorridor(floor, startX, endX, endY, 'horizontal');
                    }
                }
                
                // Add extra random corridors for complexity
                const extraCorridors = Math.floor(this.seededRandom(seed, 99) * 3) + 1;
                for (let i = 0; i < extraCorridors; i++) {
                    const room1 = rooms[Math.floor(this.seededRandom(seed, i * 9) * rooms.length)];
                    const room2 = rooms[Math.floor(this.seededRandom(seed, i * 10) * rooms.length)];
                    
                    if (room1 && room2 && room1 !== room2) {
                        this.createCorridor(floor, room1.centerX, room2.centerX, room1.centerY, 'horizontal');
                        this.createCorridor(floor, room1.centerY, room2.centerY, room2.centerX, 'vertical');
                    }
                }
                
                // Set player start in first room
                if (rooms.length > 0) {
                    floor.playerStart = {
                        x: rooms[0].centerX,
                        y: rooms[0].centerY
                    };
                    
                    // Mark starting room as explored
                    const startX = floor.playerStart.x;
                    const startY = floor.playerStart.y;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (floor.grid[startY + dy] && floor.grid[startY + dy][startX + dx]) {
                                floor.grid[startY + dy][startX + dx].explored = true;
                            }
                        }
                    }
                }
                
                // Set stairs down in last room
                if (rooms.length > 1) {
                    const lastRoom = rooms[rooms.length - 1];
                    floor.stairsDown = {
                        x: lastRoom.centerX,
                        y: lastRoom.centerY
                    };
                    // Mark stairs position
                    floor.grid[floor.stairsDown.y][floor.stairsDown.x].stairs = true;
                }
                
                // Store room data
                rooms.forEach(room => {
                    floor.rooms[room.id] = room;
                });
                floor.roomCount = rooms.length;
                
                return floor;
            },
            
            // Helper function to create corridors
            createCorridor(floor, start, end, fixed, direction) {
                const min = Math.min(start, end);
                const max = Math.max(start, end);
                
                for (let pos = min; pos <= max; pos++) {
                    if (direction === 'horizontal') {
                        if (floor.grid[fixed] && floor.grid[fixed][pos]) {
                            if (floor.grid[fixed][pos].type === 'wall') {
                                floor.grid[fixed][pos] = { 
                                    type: 'floor', 
                                    explored: false,
                                    roomId: 'corridor',
                                    content: 'empty',
                                    position: { x: pos, y: fixed }
                                };
                            }
                        }
                    } else { // vertical
                        if (floor.grid[pos] && floor.grid[pos][fixed]) {
                            if (floor.grid[pos][fixed].type === 'wall') {
                                floor.grid[pos][fixed] = { 
                                    type: 'floor', 
                                    explored: false,
                                    roomId: 'corridor',
                                    content: 'empty',
                                    position: { x: fixed, y: pos }
                                };
                            }
                        }
                    }
                }
            },
            
            // Weighted random selection
            pickWeighted(items, randomValue) {
                let totalWeight = 0;
                items.forEach(item => totalWeight += item.weight);
                
                let random = randomValue * totalWeight;
                for (let i = 0; i < items.length; i++) {
                    random -= items[i].weight;
                    if (random <= 0) {
                        return items[i];
                    }
                }
                return items[0];
            },
            
            // Generate room description
            generateRoomDescription(roomData, floorNumber) {
                const descriptors = [
                    "A dark chamber echoes with dripping water.",
                    "The air here feels heavy and stale.",
                    "Strange carvings cover the walls.",
                    "Faint whispers seem to come from the shadows.",
                    "The ground is littered with ancient debris.",
                    "A chill wind blows through the chamber.",
                    "Flickering light dances across the walls.",
                    "The room smells of damp earth and decay.",
                    "Ancient pillars support the crumbling ceiling.",
                    "Something glints in the darkness."
                ];
                
                const descriptor = descriptors[Math.floor(Math.random() * descriptors.length)];
                
                let contentDesc = "";
                switch(roomData.content) {
                    case "enemy":
                        const enemyTypes = ["growls", "scuttling", "hissing", "guttural sounds"];
                        contentDesc = `You hear ${enemyTypes[Math.floor(Math.random() * enemyTypes.length)]} in the darkness.`;
                        break;
                    case "loot":
                        contentDesc = "Something valuable might be hidden here.";
                        break;
                    case "trap":
                        contentDesc = "The floor looks suspicious...";
                        break;
                    case "shrine":
                        contentDesc = "An ancient altar stands in the center.";
                        break;
                    default:
                        contentDesc = "The room appears empty.";
                }
                
                return `${descriptor} ${contentDesc}`;
            }
        };
        
        // ============================================
        // PLAYER CLASS SYSTEM
        // ============================================
        const playerClasses = {
            warrior: {
                name: "Warrior",
                description: "A sturdy fighter with high health and defense.",
                stats: {
                    health: 120,
                    mana: 20,
                    attack: 15,
                    defense: 10,
                    speed: 3
                },
                abilities: [
                    { name: "Heavy Strike", cost: 0, damageMultiplier: 1.8, description: "A powerful attack" },
                    { name: "Shield Bash", cost: 5, damageMultiplier: 1.2, stunChance: 0.3, description: "Chance to stun" },
                    { name: "Battle Cry", cost: 10, effect: "buff", defenseBonus: 5, duration: 3, description: "Increase defense" }
                ],
                startingItems: ["sword", "shield", "healthPotion", "healthPotion"],
                color: "#f88",
                unlockRequirement: 0 // Always unlocked
            },
            
            rogue: {
                name: "Rogue",
                description: "Quick and stealthy with high critical chance.",
                stats: {
                    health: 80,
                    mana: 30,
                    attack: 18,
                    defense: 5,
                    speed: 8,
                    critChance: 0.2
                },
                abilities: [
                    { name: "Backstab", cost: 0, damageMultiplier: 2.5, requiresFlank: true, description: "Massive damage from behind" },
                    { name: "Poison Dart", cost: 8, damageMultiplier: 1.5, poisonEffect: true, description: "Poisons the enemy" },
                    { name: "Shadow Step", cost: 12, effect: "dodge", dodgeBonus: 0.5, duration: 2, description: "Increased dodge chance" }
                ],
                startingItems: ["dagger", "leather", "smoke bomb", "lockpick"],
                color: "#8f8",
                unlockRequirement: 3 // Reach floor 3
            },
            
            mage: {
                name: "Mage",
                description: "Powerful spellcaster with elemental magic.",
                stats: {
                    health: 70,
                    mana: 60,
                    attack: 12,
                    defense: 3,
                    speed: 4
                },
                abilities: [
                    { name: "Fire Bolt", cost: 8, damageMultiplier: 2.2, description: "Launch a bolt of fire" },
                    { name: "Ice Shard", cost: 6, damageMultiplier: 1.8, slowEffect: true, description: "Slows the enemy" },
                    { name: "Arcane Shield", cost: 15, effect: "shield", absorbAmount: 30, duration: 3, description: "Creates a protective shield" }
                ],
                startingItems: ["staff", "robe", "manaPotion", "manaPotion", "scroll"],
                color: "#88f",
                unlockRequirement: 5 // Reach floor 5
            },
            
            paladin: {
                name: "Paladin",
                description: "Holy warrior with healing abilities.",
                stats: {
                    health: 100,
                    mana: 40,
                    attack: 14,
                    defense: 8,
                    speed: 4
                },
                abilities: [
                    { name: "Smite", cost: 10, damageMultiplier: 2.0, undeadBonus: 0.5, description: "Extra damage to undead" },
                    { name: "Lay on Hands", cost: 20, healAmount: 50, description: "Heal yourself or others" },
                    { name: "Divine Protection", cost: 15, effect: "protect", damageReduction: 0.3, duration: 3, description: "Reduce incoming damage" }
                ],
                startingItems: ["mace", "chainmail", "ring", "healthPotion"],
                color: "#ff8",
                unlockRequirement: 8 // Reach floor 8
            },
            
            ranger: {
                name: "Ranger",
                description: "Expert tracker with ranged attacks.",
                stats: {
                    health: 90,
                    mana: 25,
                    attack: 16,
                    defense: 6,
                    speed: 6,
                    rangeBonus: 2
                },
                abilities: [
                    { name: "Precise Shot", cost: 0, damageMultiplier: 2.0, description: "Accurate ranged attack" },
                    { name: "Trap", cost: 8, effect: "trap", damage: 20, duration: 3, description: "Set a damaging trap" },
                    { name: "Beast Companion", cost: 15, effect: "companion", damage: 10, duration: 5, description: "Summon a beast to fight" }
                ],
                startingItems: ["bow", "leather", "arrow", "herb", "torch"],
                color: "#8af",
                unlockRequirement: 12 // Reach floor 12
            },
            
            necromancer: {
                name: "Necromancer",
                description: "Master of death and undeath.",
                stats: {
                    health: 60,
                    mana: 80,
                    attack: 10,
                    defense: 4,
                    speed: 3
                },
                abilities: [
                    { name: "Life Drain", cost: 12, damageMultiplier: 1.5, lifesteal: 0.5, description: "Steal health from enemy" },
                    { name: "Raise Dead", cost: 25, effect: "summon", summonType: "skeleton", duration: 5, description: "Raise a skeleton minion" },
                    { name: "Death Curse", cost: 30, effect: "curse", damageOverTime: 10, duration: 4, description: "Curse enemy with rotting" }
                ],
                startingItems: ["darkStaff", "shadowRobe", "bone", "scroll"],
                color: "#a8f",
                unlockRequirement: 15 // Reach floor 15
            }
        };
        
        // ============================================
        // GAME STATE (Resets on death)
        // ============================================
        let gameState = {
            // Core state
            currentFloor: 1,
            currentSeed: "",
            playerPosition: { x: 0, y: 0 },
            floorData: null,
            playerClass: "",
            inCombat: false,
            currentEnemy: null,
            playerTurn: true,
            
            // Player stats
            health: 100,
            maxHealth: 100,
            mana: 30,
            maxMana: 30,
            attack: 12,
            defense: 5,
            speed: 5,
            gold: 0,
            score: 0,
            kills: 0,
            
            // Inventory
            inventory: [],
            equipment: {
                weapon: null,
                armor: null,
                accessory: null,
                shield: null
            },
            
            // Run statistics
            roomsExplored: 0,
            turnsTaken: 0,
            damageDealt: 0,
            damageTaken: 0,
            itemsFound: 0,
            
            // Buffs/debuffs
            effects: [],
            
            // Discovered rooms (for mapping)
            discoveredRooms: []
        };
        
        // ============================================
        // ENEMY SYSTEM
        // ============================================
        const enemyTemplates = {
            // Floor 1-3
            rat: { name: "Giant Rat", health: 30, attack: 8, defense: 1, speed: 6, gold: 5, xp: 15 },
            spider: { name: "Cave Spider", health: 25, attack: 10, defense: 2, speed: 8, gold: 8, xp: 20, poison: true },
            skeleton: { name: "Skeleton", health: 40, attack: 12, defense: 4, speed: 3, gold: 15, xp: 30 },
            
            // Floor 4-6
            zombie: { name: "Zombie", health: 60, attack: 14, defense: 3, speed: 2, gold: 20, xp: 40 },
            goblin: { name: "Goblin", health: 35, attack: 16, defense: 2, speed: 7, gold: 25, xp: 35 },
            bat: { name: "Giant Bat", health: 20, attack: 18, defense: 1, speed: 9, gold: 12, xp: 25 },
            
            // Floor 7-9
            orc: { name: "Orc Warrior", health: 80, attack: 20, defense: 6, speed: 4, gold: 40, xp: 60 },
            wraith: { name: "Wraith", health: 50, attack: 25, defense: 3, speed: 5, gold: 35, xp: 55, ethereal: true },
            troll: { name: "Cave Troll", health: 120, attack: 22, defense: 8, speed: 2, gold: 50, xp: 70, regen: true },
            
            // Floor 10-12
            mage: { name: "Dark Mage", health: 60, attack: 30, defense: 4, speed: 4, gold: 60, xp: 80, spells: true },
            knight: { name: "Fallen Knight", health: 100, attack: 24, defense: 10, speed: 3, gold: 65, xp: 85 },
            elemental: { name: "Fire Elemental", health: 70, attack: 28, defense: 5, speed: 5, gold: 55, xp: 75, fire: true },
            
            // Floor 13-15
            demon: { name: "Lesser Demon", health: 150, attack: 35, defense: 12, speed: 6, gold: 100, xp: 120 },
            lich: { name: "Lich", health: 90, attack: 40, defense: 8, speed: 4, gold: 110, xp: 130, undead: true },
            dragon: { name: "Young Dragon", health: 200, attack: 45, defense: 15, speed: 5, gold: 150, xp: 180, dragon: true },
            
            // Floor 16+
            behemoth: { name: "Ancient Behemoth", health: 300, attack: 50, defense: 20, speed: 3, gold: 200, xp: 250 },
            horror: { name: "Eldritch Horror", health: 180, attack: 55, defense: 10, speed: 7, gold: 180, xp: 220 },
            
            // Bosses (every 5 floors)
            boss: { name: "Dungeon Guardian", health: 500, attack: 60, defense: 25, speed: 5, gold: 500, xp: 500, boss: true }
        };
        
        function generateEnemy(floorNumber) {
            let enemyPool = [];
            
            if (floorNumber <= 3) {
                enemyPool = ["rat", "spider", "skeleton"];
            } else if (floorNumber <= 6) {
                enemyPool = ["zombie", "goblin", "bat", "skeleton"];
            } else if (floorNumber <= 9) {
                enemyPool = ["orc", "wraith", "troll", "zombie"];
            } else if (floorNumber <= 12) {
                enemyPool = ["mage", "knight", "elemental", "orc"];
            } else if (floorNumber <= 15) {
                enemyPool = ["demon", "lich", "dragon", "mage"];
            } else {
                enemyPool = ["behemoth", "horror", "demon", "dragon"];
            }
            
            // Every 5th floor has a boss
            if (floorNumber % 5 === 0) {
                const bossTemplate = { ...enemyTemplates.boss };
                bossTemplate.name = `Floor ${floorNumber} Guardian`;
                bossTemplate.health = Math.floor(bossTemplate.health * (1 + (floorNumber / 10)));
                bossTemplate.attack = Math.floor(bossTemplate.attack * (1 + (floorNumber / 20)));
                return bossTemplate;
            }
            
            const enemyType = enemyPool[Math.floor(Math.random() * enemyPool.length)];
            const template = enemyTemplates[enemyType];
            
            // Scale enemy stats with floor depth
            const scale = 1 + ((floorNumber - 1) * 0.1);
            
            return {
                name: template.name,
                health: Math.floor(template.health * scale),
                maxHealth: Math.floor(template.health * scale),
                attack: Math.floor(template.attack * scale),
                defense: Math.floor(template.defense * scale),
                speed: template.speed,
                gold: Math.floor(template.gold * scale),
                xp: Math.floor(template.xp * scale),
                special: template
            };
        }
        
        // ============================================
        // ITEM SYSTEM - FIXED WITH PROPER NAMES
        // ============================================
        const itemTemplates = {
            // Weapons
            dagger: { type: "weapon", attack: 4, value: 10, tier: 1, name: "Dagger" },
            sword: { type: "weapon", attack: 8, value: 25, tier: 1, name: "Sword" },
            mace: { type: "weapon", attack: 10, value: 35, tier: 2, armorPen: 2, name: "Mace" },
            bow: { type: "weapon", attack: 7, value: 30, tier: 2, ranged: true, name: "Bow" },
            staff: { type: "weapon", attack: 5, value: 20, tier: 1, manaBonus: 10, name: "Staff" },
            darkStaff: { type: "weapon", attack: 8, value: 40, tier: 2, manaBonus: 20, name: "Dark Staff" },
            
            // Armor
            robe: { type: "armor", defense: 2, value: 15, tier: 1, manaBonus: 5, name: "Robe" },
            leather: { type: "armor", defense: 4, value: 25, tier: 1, name: "Leather Armor" },
            chainmail: { type: "armor", defense: 8, value: 50, tier: 2, name: "Chainmail" },
            plate: { type: "armor", defense: 12, value: 80, tier: 3, name: "Plate Armor" },
            shadowRobe: { type: "armor", defense: 6, value: 60, tier: 2, manaBonus: 15, name: "Shadow Robe" },
            
            // Shields
            shield: { type: "shield", defense: 5, value: 30, tier: 2, blockChance: 0.15, name: "Shield" },
            
            // Accessories
            ring: { type: "accessory", value: 40, healthBonus: 10, tier: 2, name: "Health Ring" },
            amulet: { type: "accessory", value: 50, manaBonus: 15, tier: 2, name: "Mana Amulet" },
            bone: { type: "accessory", value: 30, attack: 2, tier: 1, name: "Bone Charm" },
            
            // Consumables
            healthPotion: { type: "consumable", healthRestore: 40, value: 15, name: "Health Potion" },
            manaPotion: { type: "consumable", manaRestore: 30, value: 20, name: "Mana Potion" },
            antidote: { type: "consumable", curePoison: true, value: 25, name: "Antidote" },
            torch: { type: "utility", value: 5, name: "Torch" },
            lockpick: { type: "utility", value: 20, name: "Lockpick" },
            bomb: { type: "combat", damage: 50, value: 40, name: "Bomb" },
            scroll: { type: "combat", damage: 30, value: 25, name: "Scroll" },
            smokeBomb: { type: "combat", fleeBonus: 0.3, value: 30, name: "Smoke Bomb" },
            arrow: { type: "ammo", value: 1, name: "Arrow" },
            herb: { type: "consumable", healthRestore: 20, value: 8, name: "Healing Herb" }
        };
        
        // Friendly names for display
        const itemDisplayNames = {
            dagger: "Dagger",
            sword: "Sword",
            mace: "Mace",
            bow: "Bow",
            staff: "Staff",
            darkStaff: "Dark Staff",
            robe: "Robe",
            leather: "Leather Armor",
            chainmail: "Chainmail",
            plate: "Plate Armor",
            shadowRobe: "Shadow Robe",
            shield: "Shield",
            ring: "Health Ring",
            amulet: "Mana Amulet",
            bone: "Bone Charm",
            healthPotion: "Health Potion",
            manaPotion: "Mana Potion",
            antidote: "Antidote",
            torch: "Torch",
            lockpick: "Lockpick",
            bomb: "Bomb",
            scroll: "Scroll",
            smokeBomb: "Smoke Bomb",
            arrow: "Arrow",
            herb: "Healing Herb"
        };
        
        function generateLoot(floorNumber) {
            const lootPool = [];
            
            // Weapons and armor based on floor
            if (floorNumber <= 3) {
                lootPool.push("dagger", "sword", "robe", "leather", "healthPotion", "torch");
            } else if (floorNumber <= 6) {
                lootPool.push("mace", "bow", "staff", "chainmail", "shield", "manaPotion", "lockpick");
            } else if (floorNumber <= 9) {
                lootPool.push("plate", "ring", "amulet", "bomb", "healthPotion", "manaPotion");
            } else {
                lootPool.push("plate", "ring", "amulet", "bomb", "antidote", "darkStaff", "shadowRobe");
            }
            
            const itemType = lootPool[Math.floor(Math.random() * lootPool.length)];
            return itemType;
        }
        
        // ============================================
        // DOM ELEMENTS
        // ============================================
        const gameScreen = document.getElementById('gameScreen');
        const actionPanel = document.getElementById('actionPanel');
        const actionTitle = document.getElementById('actionTitle');
        const actionChoices = document.getElementById('actionChoices');
        const combatPanel = document.getElementById('combatPanel');
        const combatTitle = document.getElementById('combatTitle');
        const combatInfo = document.getElementById('combatInfo');
        const combatChoices = document.getElementById('combatChoices');
        const inventoryPanel = document.getElementById('inventoryPanel');
        const inventoryItems = document.getElementById('inventoryItems');
        const equipmentPanel = document.getElementById('equipmentPanel');
        const equipmentSlots = document.getElementById('equipmentSlots');
        const mapPanel = document.getElementById('mapPanel');
        const mapDisplay = document.getElementById('mapDisplay');
        const classSelectPanel = document.getElementById('classSelectPanel');
        const classChoices = document.getElementById('classChoices');
        const unlockNotice = document.getElementById('unlockNotice');
        const commandButtons = document.getElementById('commandButtons');
        const statusBar = document.getElementById('statusBar');
        const floorIndicator = document.getElementById('floorIndicator');
        const runStats = document.getElementById('runStats');
        
        // Status elements
        const healthValue = document.getElementById('healthValue');
        const maxHealthValue = document.getElementById('maxHealthValue');
        const manaValue = document.getElementById('manaValue');
        const maxManaValue = document.getElementById('maxManaValue');
        const scoreValue = document.getElementById('scoreValue');
        const goldValue = document.getElementById('goldValue');
        const floorValue = document.getElementById('floorValue');
        const roomValue = document.getElementById('roomValue');
        const levelTitle = document.getElementById('levelTitle');
        
        // Combat UI elements
        const playerHP = document.getElementById('playerHP');
        const playerMaxHP = document.getElementById('playerMaxHP');
        const playerMP = document.getElementById('playerMP');
        const playerMaxMP = document.getElementById('playerMaxMP');
        const enemyName = document.getElementById('enemyName');
        const enemyHP = document.getElementById('enemyHP');
        const enemyMaxHP = document.getElementById('enemyMaxHP');
        const playerHealthBar = document.getElementById('playerHealthBar');
        const playerManaBar = document.getElementById('playerManaBar');
        const enemyHealthBar = document.getElementById('enemyHealthBar');
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function addToOutput(text, className = "") {
            const newLine = document.createElement("div");
            newLine.className = `output-text ${className}`;
            newLine.textContent = text;
            gameScreen.appendChild(newLine);
            autoScrollToBottom();
        }
        
        function autoScrollToBottom() {
            setTimeout(() => {
                gameScreen.scrollTop = gameScreen.scrollHeight;
            }, 50);
        }
        
        function updateStatus() {
            healthValue.textContent = gameState.health;
            maxHealthValue.textContent = gameState.maxHealth;
            manaValue.textContent = gameState.mana;
            maxManaValue.textContent = gameState.maxMana;
            scoreValue.textContent = gameState.score;
            goldValue.textContent = gameState.gold;
            floorValue.textContent = gameState.currentFloor;
            
            // Update room name
            const currentCell = gameState.floorData.grid[gameState.playerPosition.y][gameState.playerPosition.x];
            if (currentCell.roomId && currentCell.roomId !== 'corridor') {
                roomValue.textContent = `Room ${currentCell.roomId.split('_')[1]}`;
            } else {
                roomValue.textContent = "Corridor";
            }
            
            // Update floor indicator
            floorIndicator.textContent = `Depth: ${gameState.currentFloor}`;
            
            // Update run stats
            runStats.textContent = `Best: ${gameSave.deepestFloor} | Unlocks: ${gameSave.unlockedClasses.length}`;
            
            // Update combat UI if in combat
            if (gameState.inCombat) {
                updateCombatUI();
            }
        }
        
        function updateCombatUI() {
            playerHP.textContent = gameState.health;
            playerMaxHP.textContent = gameState.maxHealth;
            playerMP.textContent = gameState.mana;
            playerMaxMP.textContent = gameState.maxMana;
            
            const playerHealthPercent = (gameState.health / gameState.maxHealth) * 100;
            playerHealthBar.style.width = `${playerHealthPercent}%`;
            
            const playerManaPercent = (gameState.mana / gameState.maxMana) * 100;
            playerManaBar.style.width = `${playerManaPercent}%`;
            
            if (gameState.currentEnemy) {
                enemyName.textContent = gameState.currentEnemy.name;
                enemyHP.textContent = gameState.currentEnemy.health;
                enemyMaxHP.textContent = gameState.currentEnemy.maxHealth;
                
                const enemyHealthPercent = (gameState.currentEnemy.health / gameState.currentEnemy.maxHealth) * 100;
                enemyHealthBar.style.width = `${enemyHealthPercent}%`;
            }
        }
        
        // ============================================
        // CLASS SELECTION
        // ============================================
        function showClassSelection() {
            classSelectPanel.style.display = "block";
            commandButtons.style.display = "none";
            statusBar.style.display = "none";
            
            classChoices.innerHTML = "";
            
            // Show available classes
            Object.entries(playerClasses).forEach(([id, cls]) => {
                if (gameSave.unlockedClasses.includes(id)) {
                    const classButton = document.createElement("div");
                    classButton.className = "class-button";
                    classButton.innerHTML = `
                        <strong>${cls.name}</strong>
                        <div class="class-description">${cls.description}</div>
                    `;
                    classButton.style.borderColor = cls.color;
                    
                    classButton.addEventListener('click', () => selectClass(id));
                    classChoices.appendChild(classButton);
                }
            });
            
            updateUnlockNotice();
        }
        
        function selectClass(classId) {
            const cls = playerClasses[classId];
            gameState.playerClass = classId;
            
            // Apply class stats
            gameState.maxHealth = cls.stats.health;
            gameState.health = cls.stats.health;
            gameState.maxMana = cls.stats.mana;
            gameState.mana = cls.stats.mana;
            gameState.attack = cls.stats.attack;
            gameState.defense = cls.stats.defense;
            gameState.speed = cls.stats.speed;
            
            // Add starting items
            gameState.inventory = [...cls.startingItems];
            
            // Start new run
            startNewRun();
        }
        
        function updateUnlockNotice() {
            const lockedClasses = Object.keys(playerClasses).filter(id => 
                !gameSave.unlockedClasses.includes(id)
            );
            
            if (lockedClasses.length > 0) {
                const nextClass = lockedClasses[0];
                const requirement = playerClasses[nextClass].unlockRequirement;
                unlockNotice.textContent = `Reach floor ${requirement} to unlock the ${playerClasses[nextClass].name}!`;
            } else {
                unlockNotice.textContent = "All classes unlocked! Great job!";
            }
        }
        
        // ============================================
        // RUN MANAGEMENT
        // ============================================
        function startNewRun() {
            // Clear output
            gameScreen.innerHTML = '';
            
            // Generate new seed
            gameState.currentSeed = dungeonGenerator.generateSeed();
            gameState.currentFloor = 1;
            
            // Generate first floor
            generateNewFloor();
            
            // Hide class selection
            classSelectPanel.style.display = "none";
            commandButtons.style.display = "grid";
            statusBar.style.display = "flex";
            
            // Update run stats
            gameSave.totalRuns++;
            
            // Show starting message
            addToOutput(`You begin your descent into the darkness as a ${playerClasses[gameState.playerClass].name}...`, "important-text");
            addToOutput("Each floor is procedurally generated. Death is permanent.", "procedural-notice");
            addToOutput("Find the stairs to descend deeper. Good luck!", "important-text");
            
            // Describe starting room
            describeCurrentRoom();
            
            updateStatus();
            saveGameSave();
        }
        
        function generateNewFloor() {
            gameState.floorData = dungeonGenerator.generateFloor(
                gameState.currentFloor, 
                gameState.currentSeed + "_floor_" + gameState.currentFloor
            );
            
            gameState.playerPosition = { ...gameState.floorData.playerStart };
            exploreAroundPlayer();
        }
        
        function exploreAroundPlayer() {
            const px = gameState.playerPosition.x;
            const py = gameState.playerPosition.y;
            
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const x = px + dx;
                    const y = py + dy;
                    
                    if (gameState.floorData.grid[y] && gameState.floorData.grid[y][x]) {
                        gameState.floorData.grid[y][x].explored = true;
                        
                        // Add to discovered rooms
                        const cell = gameState.floorData.grid[y][x];
                        if (cell.roomId && !gameState.discoveredRooms.includes(cell.roomId)) {
                            gameState.discoveredRooms.push(cell.roomId);
                            gameState.roomsExplored++;
                        }
                    }
                }
            }
        }
        
        // ============================================
        // ROOM INTERACTION
        // ============================================
        function describeCurrentRoom() {
            const cell = gameState.floorData.grid[gameState.playerPosition.y][gameState.playerPosition.x];
            
            let description = "";
            
            if (cell.stairs) {
                description = "You stand before a staircase descending deeper into the darkness. ";
                description += "The air grows colder as you contemplate the descent.";
                addToOutput(description, "important-text");
                addToOutput("STAIRS DOWN are here. Use MOVE to descend.", "success-text");
                return;
            }
            
            if (cell.roomId && cell.roomId !== 'corridor') {
                const room = gameState.floorData.rooms[cell.roomId];
                description = dungeonGenerator.generateRoomDescription(room, gameState.currentFloor);
            } else {
                const corridorDescs = [
                    "A narrow corridor stretches before you.",
                    "The passageway twists and turns in the darkness.",
                    "Damp walls press close in the tight corridor.",
                    "Your footsteps echo in the empty passage."
                ];
                description = corridorDescs[Math.floor(Math.random() * corridorDescs.length)];
            }
            
            addToOutput(description);
            
            // Check for room content
            if (cell.content && cell.content !== 'empty') {
                handleRoomContent(cell);
            }
        }
        
        function handleRoomContent(cell) {
            switch(cell.content) {
                case "enemy":
                    if (!gameState.inCombat) {
                        const enemy = generateEnemy(gameState.currentFloor);
                        startCombat(enemy);
                    }
                    break;
                    
                case "loot":
                    const lootType = generateLoot(gameState.currentFloor);
                    const lootName = itemDisplayNames[lootType] || lootType;
                    
                    addToOutput(`You find a ${lootName}!`, "loot-text");
                    gameState.inventory.push(lootType);
                    gameState.itemsFound++;
                    updateInventory();
                    
                    // Clear the loot from the room
                    cell.content = 'empty';
                    break;
                    
                case "trap":
                    const trapDamage = Math.floor(10 + gameState.currentFloor * 2);
                    addToOutput("A hidden trap springs!", "danger-text");
                    addToOutput(`You take ${trapDamage} damage.`, "damage-text");
                    
                    gameState.health -= trapDamage;
                    gameState.damageTaken += trapDamage;
                    
                    if (gameState.health <= 0) {
                        playerDefeated("triggered a deadly trap");
                    }
                    
                    // Disarm the trap
                    cell.content = 'empty';
                    updateStatus();
                    break;
                    
                case "shrine":
                    addToOutput("You find an ancient shrine.", "mystic-text");
                    
                    const shrineEffects = [
                        { text: "The shrine heals your wounds.", effect: () => {
                            const heal = Math.floor(gameState.maxHealth * 0.5);
                            gameState.health = Math.min(gameState.maxHealth, gameState.health + heal);
                            addToOutput(`You are healed for ${heal} health.`, "heal-text");
                        }},
                        { text: "The shrine restores your mana.", effect: () => {
                            const restore = Math.floor(gameState.maxMana * 0.5);
                            gameState.mana = Math.min(gameState.maxMana, gameState.mana + restore);
                            addToOutput(`Your mana is restored by ${restore}.`, "heal-text");
                        }},
                        { text: "The shrine blesses you with strength.", effect: () => {
                            gameState.attack += 2;
                            addToOutput("Your attack power increases!", "success-text");
                        }},
                        { text: "The shrine grants protective magic.", effect: () => {
                            gameState.defense += 2;
                            addToOutput("Your defense increases!", "success-text");
                        }}
                    ];
                    
                    const effect = shrineEffects[Math.floor(Math.random() * shrineEffects.length)];
                    addToOutput(effect.text, "mystic-text");
                    effect.effect();
                    
                    // Use up the shrine
                    cell.content = 'empty';
                    updateStatus();
                    break;
            }
        }
        
        // ============================================
        // MOVEMENT SYSTEM
        // ============================================
        function handleMove() {
            if (gameState.inCombat) {
                addToOutput("You can't move during combat!", "combat-text");
                return;
            }
            
            const directions = [
                { text: "NORTH", dx: 0, dy: -1 },
                { text: "SOUTH", dx: 0, dy: 1 },
                { text: "EAST", dx: 1, dy: 0 },
                { text: "WEST", dx: -1, dy: 0 },
                { text: "WAIT", dx: 0, dy: 0 }
            ];
            
            // Check for stairs
            const currentCell = gameState.floorData.grid[gameState.playerPosition.y][gameState.playerPosition.x];
            if (currentCell.stairs) {
                directions.push({ text: "DESCEND", dx: 0, dy: 0, special: "descend" });
            }
            
            showActionPanel("MOVE WHERE?", directions, handleMoveChoice);
        }
        
        function handleMoveChoice(choice) {
            gameState.turnsTaken++;
            
            if (choice.special === "descend") {
                descendStairs();
                return;
            }
            
            if (choice.dx === 0 && choice.dy === 0) {
                addToOutput("You wait a moment...", "important-text");
                // Chance for random event while waiting
                if (Math.random() < 0.1) {
                    const events = [
                        "You hear distant footsteps...",
                        "Something scuttles in the darkness.",
                        "The torchlight flickers ominously.",
                        "A cold wind blows through the dungeon."
                    ];
                    addToOutput(events[Math.floor(Math.random() * events.length)]);
                }
                return;
            }
            
            const newX = gameState.playerPosition.x + choice.dx;
            const newY = gameState.playerPosition.y + choice.dy;
            
            // Check bounds
            if (!gameState.floorData.grid[newY] || !gameState.floorData.grid[newY][newX]) {
                addToOutput("You can't move that way.", "important-text");
                return;
            }
            
            const targetCell = gameState.floorData.grid[newY][newX];
            
            // Check if it's walkable
            if (targetCell.type !== 'floor') {
                addToOutput("You can't move through walls.", "important-text");
                return;
            }
            
            // Move player
            gameState.playerPosition.x = newX;
            gameState.playerPosition.y = newY;
            
            // Explore around new position
            exploreAroundPlayer();
            
            // Describe new location
            addToOutput(`You move ${choice.text.toLowerCase()}.`, "important-text");
            describeCurrentRoom();
            
            updateStatus();
            generateMap();
        }
        
        function descendStairs() {
            gameState.currentFloor++;
            gameState.score += gameState.currentFloor * 100; // Bonus for descending
            
            // Update deepest floor
            if (gameState.currentFloor > gameSave.deepestFloor) {
                gameSave.deepestFloor = gameState.currentFloor;
                
                // Check for new class unlocks
                Object.entries(playerClasses).forEach(([id, cls]) => {
                    if (!gameSave.unlockedClasses.includes(id) && gameState.currentFloor >= cls.unlockRequirement) {
                        gameSave.unlockedClasses.push(id);
                        addToOutput(`NEW CLASS UNLOCKED: ${cls.name}!`, "success-text");
                        addToOutput(cls.description, "important-text");
                    }
                });
                
                // Check achievements
                if (gameState.currentFloor >= 5 && !gameSave.achievements.floor5) {
                    gameSave.achievements.floor5 = true;
                    addToOutput("ACHIEVEMENT: Reached Depth 5!", "gold-text");
                }
                if (gameState.currentFloor >= 10 && !gameSave.achievements.floor10) {
                    gameSave.achievements.floor10 = true;
                    addToOutput("ACHIEVEMENT: Reached Depth 10!", "gold-text");
                }
            }
            
            addToOutput(`You descend to floor ${gameState.currentFloor}...`, "important-text");
            addToOutput("The dungeon shifts and reforms around you.", "procedural-notice");
            
            // Generate new floor
            generateNewFloor();
            
            // Describe starting room
            describeCurrentRoom();
            
            updateStatus();
            saveGameSave();
        }
        
        // ============================================
        // COMBAT SYSTEM
        // ============================================
        function startCombat(enemy) {
            gameState.inCombat = true;
            gameState.currentEnemy = enemy;
            gameState.playerTurn = true;
            
            addToOutput(`A ${enemy.name} appears!`, "enemy-text");
            addToOutput("COMBAT INITIATED!", "combat-text");
            
            showCombatPanel();
            updateCombatChoices();
        }
        
        function updateCombatChoices() {
            combatChoices.innerHTML = '';
            
            // Basic attack
            const attackButton = document.createElement('button');
            attackButton.className = 'button';
            attackButton.textContent = 'ATTACK';
            attackButton.addEventListener('click', () => {
                playerAttack('normal');
            });
            combatChoices.appendChild(attackButton);
            
            // Class abilities
            const cls = playerClasses[gameState.playerClass];
            cls.abilities.forEach(ability => {
                const abilityButton = document.createElement('button');
                abilityButton.className = 'button';
                abilityButton.textContent = ability.name;
                
                if (ability.cost > gameState.mana) {
                    abilityButton.disabled = true;
                    abilityButton.style.opacity = '0.5';
                }
                
                abilityButton.addEventListener('click', () => {
                    if (ability.name === "Heal" || ability.name === "Lay on Hands") {
                        playerHeal(ability);
                    } else {
                        playerAttack(ability.name.toLowerCase());
                    }
                });
                combatChoices.appendChild(abilityButton);
            });
            
            // Item button
            const itemButton = document.createElement('button');
            itemButton.className = 'button';
            itemButton.textContent = 'USE ITEM';
            itemButton.addEventListener('click', () => {
                showCombatItems();
            });
            combatChoices.appendChild(itemButton);
            
            // Flee button
            const fleeButton = document.createElement('button');
            fleeButton.className = 'button';
            fleeButton.textContent = 'FLEE';
            fleeButton.addEventListener('click', () => {
                attemptFlee();
            });
            combatChoices.appendChild(fleeButton);
        }
        
        function playerAttack(attackType) {
            if (!gameState.playerTurn || !gameState.inCombat) return;
            
            const cls = playerClasses[gameState.playerClass];
            let ability = null;
            
            if (attackType !== 'normal') {
                ability = cls.abilities.find(a => a.name.toLowerCase() === attackType);
            }
            
            let damage = gameState.attack;
            let abilityCost = 0;
            let specialEffect = "";
            
            if (ability) {
                damage = Math.floor(damage * (ability.damageMultiplier || 1));
                abilityCost = ability.cost || 0;
                
                if (ability.stunChance) {
                    specialEffect = " The enemy is stunned!";
                }
                if (ability.poisonEffect) {
                    specialEffect = " The enemy is poisoned!";
                }
                if (ability.slowEffect) {
                    specialEffect = " The enemy is slowed!";
                }
                
                addToOutput(`You use ${ability.name}!`, "combat-text");
            } else {
                addToOutput("You attack!", "combat-text");
            }
            
            // Deduct mana if using ability
            if (abilityCost > 0) {
                if (gameState.mana >= abilityCost) {
                    gameState.mana -= abilityCost;
                    addToOutput(`You use ${abilityCost} mana.`, "important-text");
                } else {
                    addToOutput("Not enough mana! Using normal attack instead.", "danger-text");
                    damage = gameState.attack;
                    abilityCost = 0;
                    specialEffect = "";
                }
            }
            
            // Critical hit chance (rogue has higher)
            let critMultiplier = 1;
            if (cls.stats.critChance && Math.random() < cls.stats.critChance) {
                critMultiplier = 2;
                addToOutput("Critical hit!", "danger-text");
            } else if (Math.random() < 0.1) { // 10% base crit chance
                critMultiplier = 2;
                addToOutput("Critical hit!", "danger-text");
            }
            
            damage = Math.floor(damage * critMultiplier);
            
            // Calculate final damage (consider enemy defense)
            damage = Math.max(1, damage - gameState.currentEnemy.defense);
            gameState.currentEnemy.health -= damage;
            gameState.damageDealt += damage;
            
            addToOutput(`You hit the ${gameState.currentEnemy.name} for ${damage} damage!${specialEffect}`, "damage-text");
            
            updateCombatUI();
            
            // Check if enemy is defeated
            if (gameState.currentEnemy.health <= 0) {
                enemyDefeated();
                return;
            }
            
            // Enemy's turn
            gameState.playerTurn = false;
            setTimeout(enemyAttack, 1000);
        }
        
        function enemyAttack() {
            if (!gameState.inCombat) return;
            
            addToOutput(`The ${gameState.currentEnemy.name} attacks!`, "enemy-text");
            
            // Calculate damage (consider player defense)
            let damage = Math.max(1, gameState.currentEnemy.attack - gameState.defense);
            
            // Special enemy abilities
            if (gameState.currentEnemy.special) {
                if (gameState.currentEnemy.special.poison && Math.random() < 0.2) {
                    damage += 5;
                    addToOutput("The enemy's poison seeps into your wounds!", "poison-text");
                }
                if (gameState.currentEnemy.special.fire && Math.random() < 0.3) {
                    damage += 8;
                    addToOutput("The enemy's fire burns you!", "damage-text");
                }
                if (gameState.currentEnemy.special.regen && Math.random() < 0.25) {
                    const heal = Math.floor(gameState.currentEnemy.maxHealth * 0.1);
                    gameState.currentEnemy.health = Math.min(gameState.currentEnemy.maxHealth, gameState.currentEnemy.health + heal);
                    addToOutput(`The enemy regenerates ${heal} health!`, "enemy-text");
                }
            }
            
            // Dodge chance based on speed
            const dodgeChance = gameState.speed * 0.01;
            if (Math.random() < dodgeChance) {
                addToOutput("You dodge the attack!", "success-text");
                gameState.playerTurn = true;
                updateCombatChoices();
                return;
            }
            
            gameState.health -= damage;
            gameState.damageTaken += damage;
            
            addToOutput(`The ${gameState.currentEnemy.name} hits you for ${damage} damage!`, "damage-text");
            
            updateCombatUI();
            
            // Check if player is defeated
            if (gameState.health <= 0) {
                playerDefeated(`the ${gameState.currentEnemy.name}`);
                return;
            }
            
            // Player's turn again
            gameState.playerTurn = true;
            updateCombatChoices();
        }
        
        function enemyDefeated() {
            const enemy = gameState.currentEnemy;
            const isBoss = enemy.special && enemy.special.boss;
            
            if (isBoss) {
                addToOutput(`You have defeated the ${enemy.name}!`, "success-text");
                addToOutput("BOSS DEFEATED!", "important-text");
            } else {
                addToOutput(`You defeated the ${enemy.name}!`, "success-text");
            }
            
            // Award gold and score
            gameState.gold += enemy.gold;
            gameState.score += enemy.xp;
            gameState.kills++;
            gameSave.totalKills++;
            
            addToOutput(`You gain ${enemy.gold} gold and ${enemy.xp} score!`, "gold-text");
            
            // Chance to drop loot
            const dropChance = isBoss ? 1.0 : 0.3;
            if (Math.random() < dropChance) {
                const lootType = generateLoot(gameState.currentFloor);
                const lootName = itemDisplayNames[lootType] || lootType;
                
                addToOutput(`The enemy drops a ${lootName}!`, "loot-text");
                gameState.inventory.push(lootType);
                gameState.itemsFound++;
                updateInventory();
            }
            
            // End combat
            gameState.inCombat = false;
            gameState.currentEnemy = null;
            
            hideCombatPanel();
            updateStatus();
            saveGameSave();
        }
        
        function playerDefeated(killedBy) {
            addToOutput(`You have been defeated by ${killedBy}!`, "danger-text");
            addToOutput("PERMADEATH - RUN ENDED", "combat-text");
            
            // Calculate final score
            const roomBonus = gameState.roomsExplored * 10;
            const killBonus = gameState.kills * 25;
            const depthBonus = gameState.currentFloor * 100;
            const goldBonus = Math.floor(gameState.gold / 2);
            
            gameState.score += roomBonus + killBonus + depthBonus + goldBonus;
            
            // Update best score
            if (gameState.score > gameSave.bestScore) {
                gameSave.bestScore = gameState.score;
            }
            
            // Show run summary
            addToOutput("", "important-text");
            addToOutput("=== RUN SUMMARY ===", "important-text");
            addToOutput(`Depth Reached: ${gameState.currentFloor}`, "important-text");
            addToOutput(`Rooms Explored: ${gameState.roomsExplored}`, "important-text");
            addToOutput(`Enemies Slain: ${gameState.kills}`, "important-text");
            addToOutput(`Gold Collected: ${gameState.gold}`, "gold-text");
            addToOutput(`Turns Taken: ${gameState.turnsTaken}`, "important-text");
            addToOutput(`Final Score: ${gameState.score}`, "important-text");
            addToOutput("", "important-text");
            addToOutput("The void claims another soul...", "secret-text");
            
            // Check for first death achievement
            if (!gameSave.achievements.firstDeath) {
                gameSave.achievements.firstDeath = true;
                addToOutput("ACHIEVEMENT: First Blood!", "gold-text");
            }
            
            // Disable all buttons
            document.querySelectorAll('.button, .command-button').forEach(btn => btn.disabled = true);
            
            // End combat
            gameState.inCombat = false;
            hideCombatPanel();
            
            // Show restart option after delay
            setTimeout(() => {
                addToOutput("", "important-text");
                addToOutput("Press any button to begin a new journey...", "blink important-text");
                
                // Re-enable buttons for restart
                document.querySelectorAll('.button, .command-button').forEach(btn => {
                    btn.disabled = false;
                    btn.addEventListener('click', restartGame, { once: true });
                });
            }, 3000);
            
            saveGameSave();
        }
        
        function restartGame() {
            // Reset game state but keep persistent unlocks
            gameState = {
                currentFloor: 1,
                currentSeed: "",
                playerPosition: { x: 0, y: 0 },
                floorData: null,
                playerClass: gameState.playerClass, // Keep same class
                inCombat: false,
                currentEnemy: null,
                playerTurn: true,
                
                // Reset stats
                health: 100,
                maxHealth: 100,
                mana: 30,
                maxMana: 30,
                attack: 12,
                defense: 5,
                speed: 5,
                gold: 0,
                score: 0,
                kills: 0,
                
                // Reset inventory
                inventory: [],
                equipment: {
                    weapon: null,
                    armor: null,
                    accessory: null,
                    shield: null
                },
                
                // Reset run statistics
                roomsExplored: 0,
                turnsTaken: 0,
                damageDealt: 0,
                damageTaken: 0,
                itemsFound: 0,
                
                // Reset effects
                effects: [],
                
                // Reset discovered rooms
                discoveredRooms: []
            };
            
            // Remove restart listeners
            document.querySelectorAll('.button, .command-button').forEach(btn => {
                btn.removeEventListener('click', restartGame);
            });
            
            // Start new run with same class
            const cls = playerClasses[gameState.playerClass];
            
            // Apply class stats
            gameState.maxHealth = cls.stats.health;
            gameState.health = cls.stats.health;
            gameState.maxMana = cls.stats.mana;
            gameState.mana = cls.stats.mana;
            gameState.attack = cls.stats.attack;
            gameState.defense = cls.stats.defense;
            gameState.speed = cls.stats.speed;
            
            // Add starting items
            gameState.inventory = [...cls.startingItems];
            
            // Clear output and start new run
            gameScreen.innerHTML = '';
            startNewRun();
        }
        
        function playerHeal(ability) {
            if (!gameState.playerTurn || !gameState.inCombat) return;
            
            if (gameState.mana < ability.cost) {
                addToOutput("Not enough mana!", "danger-text");
                return;
            }
            
            gameState.mana -= ability.cost;
            const oldHealth = gameState.health;
            gameState.health = Math.min(gameState.maxHealth, gameState.health + ability.healAmount);
            const healed = gameState.health - oldHealth;
            
            addToOutput(`You use ${ability.name} and restore ${healed} health.`, "heal-text");
            addToOutput(`You use ${ability.cost} mana.`, "important-text");
            
            updateCombatUI();
            
            // Enemy's turn
            gameState.playerTurn = false;
            setTimeout(enemyAttack, 1000);
        }
        
        function showCombatItems() {
            const combatItems = gameState.inventory.filter(item => 
                item.includes("Potion") || item === "bomb" || item === "scroll" || item === "smokeBomb"
            );
            
            if (combatItems.length === 0) {
                addToOutput("You have no usable items in combat.", "important-text");
                return;
            }
            
            const choices = combatItems.map(item => ({
                text: `${itemDisplayNames[item] || item.toUpperCase()}`,
                value: item
            }));
            
            choices.push({ text: "CANCEL", value: "cancel" });
            
            showActionPanel("USE ITEM IN COMBAT:", choices, handleCombatItemChoice);
        }
        
        function handleCombatItemChoice(item) {
            if (item === "cancel") {
                addToOutput("You decide not to use an item.");
                return;
            }
            
            // Remove from inventory
            const itemIndex = gameState.inventory.indexOf(item);
            if (itemIndex > -1) {
                gameState.inventory.splice(itemIndex, 1);
            }
            
            // Apply item effect
            if (item === "healthPotion") {
                const oldHealth = gameState.health;
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 40);
                const healed = gameState.health - oldHealth;
                addToOutput(`You drink a health potion and restore ${healed} health.`, "heal-text");
            }
            
            if (item === "manaPotion") {
                const oldMana = gameState.mana;
                gameState.mana = Math.min(gameState.maxMana, gameState.mana + 30);
                const restored = gameState.mana - oldMana;
                addToOutput(`You drink a mana potion and restore ${restored} mana.`, "heal-text");
            }
            
            if (item === "bomb" && gameState.currentEnemy) {
                const damage = 50;
                gameState.currentEnemy.health -= damage;
                addToOutput(`You throw a bomb and deal ${damage} damage to the ${gameState.currentEnemy.name}!`, "damage-text");
                
                if (gameState.currentEnemy.health <= 0) {
                    enemyDefeated();
                    return;
                }
            }
            
            if (item === "scroll" && gameState.currentEnemy) {
                const damage = 30;
                gameState.currentEnemy.health -= damage;
                addToOutput(`You cast a spell from the scroll and deal ${damage} damage!`, "damage-text");
                
                if (gameState.currentEnemy.health <= 0) {
                    enemyDefeated();
                    return;
                }
            }
            
            updateInventory();
            updateCombatUI();
            
            // Enemy's turn
            gameState.playerTurn = false;
            setTimeout(enemyAttack, 1000);
        }
        
        function attemptFlee() {
            if (!gameState.inCombat) return;
            
            let fleeChance = 0.6; // Base 60% chance to flee
            
            // Speed affects flee chance
            fleeChance += gameState.speed * 0.05;
            
            // Bosses are harder to flee from
            if (gameState.currentEnemy.special && gameState.currentEnemy.special.boss) {
                fleeChance *= 0.5;
            }
            
            if (Math.random() < fleeChance) {
                addToOutput("You successfully flee from combat!", "success-text");
                gameState.inCombat = false;
                gameState.currentEnemy = null;
                hideCombatPanel();
                
                // Take damage when fleeing
                const fleeDamage = Math.floor(Math.random() * 20) + 10;
                gameState.health -= fleeDamage;
                gameState.damageTaken += fleeDamage;
                addToOutput(`You take ${fleeDamage} damage while fleeing.`, "damage-text");
                
                updateStatus();
                
                if (gameState.health <= 0) {
                    playerDefeated("fleeing in panic");
                }
            } else {
                addToOutput("You failed to flee!", "danger-text");
                
                // Enemy gets a free attack
                gameState.playerTurn = false;
                setTimeout(enemyAttack, 1000);
            }
        }
        
        // ============================================
        // FIXED INVENTORY & EQUIPMENT SYSTEM
        // ============================================
        function handleInventory() {
            if (gameState.inCombat) {
                addToOutput("You can't access inventory during combat!", "combat-text");
                return;
            }
            
            if (inventoryPanel.style.display === "block") {
                inventoryPanel.style.display = "none";
            } else {
                inventoryPanel.style.display = "block";
                updateInventory();
            }
        }
        
        function updateInventory() {
            inventoryItems.innerHTML = "";
            
            if (gameState.inventory.length === 0) {
                const emptyItem = document.createElement("div");
                emptyItem.className = "inventory-item";
                emptyItem.textContent = "Empty";
                inventoryItems.appendChild(emptyItem);
            } else {
                // Group items by type
                const itemCounts = {};
                gameState.inventory.forEach(item => {
                    itemCounts[item] = (itemCounts[item] || 0) + 1;
                });
                
                Object.keys(itemCounts).forEach(item => {
                    const itemElement = document.createElement("div");
                    itemElement.className = "inventory-item";
                    const displayName = itemDisplayNames[item] || item.toUpperCase();
                    const count = itemCounts[item] > 1 ? ` (${itemCounts[item]})` : '';
                    itemElement.textContent = `${displayName}${count}`;
                    
                    // Make items clickable for use/equip
                    itemElement.style.cursor = "pointer";
                    itemElement.addEventListener('click', () => {
                        useOrEquipItem(item);
                    });
                    
                    // Add hover effect
                    itemElement.addEventListener('mouseenter', () => {
                        itemElement.style.backgroundColor = "#1a1a33";
                    });
                    itemElement.addEventListener('mouseleave', () => {
                        itemElement.style.backgroundColor = "#0a0a1a";
                    });
                    
                    inventoryItems.appendChild(itemElement);
                });
            }
        }
        
        function useOrEquipItem(item) {
            // Check if it's equipment
            if (itemTemplates[item] && itemTemplates[item].type !== "consumable" && 
                itemTemplates[item].type !== "utility" && itemTemplates[item].type !== "combat" &&
                itemTemplates[item].type !== "ammo") {
                equipItem(item);
            } else {
                useConsumable(item);
            }
        }
        
        function equipItem(item) {
            const itemData = itemTemplates[item];
            const slot = itemData.type;
            const displayName = itemDisplayNames[item] || item;
            
            // Check if player already has something equipped in this slot
            if (gameState.equipment[slot]) {
                // Unequip current item
                const oldItem = gameState.equipment[slot];
                gameState.inventory.push(oldItem);
                
                // Remove stats
                removeEquipmentStats(oldItem);
                
                addToOutput(`You unequip ${itemDisplayNames[oldItem] || oldItem}.`, "important-text");
            }
            
            // Equip new item
            gameState.equipment[slot] = item;
            
            // Remove from inventory
            const itemIndex = gameState.inventory.indexOf(item);
            if (itemIndex > -1) {
                gameState.inventory.splice(itemIndex, 1);
            }
            
            // Add stats
            applyEquipmentStats(item);
            
            addToOutput(`You equip ${displayName}.`, "success-text");
            
            updateInventory();
            updateEquipmentDisplay();
            updateStatus();
        }
        
        function applyEquipmentStats(item) {
            const itemData = itemTemplates[item];
            
            if (itemData.attack) gameState.attack += itemData.attack;
            if (itemData.defense) gameState.defense += itemData.defense;
            if (itemData.healthBonus) {
                gameState.maxHealth += itemData.healthBonus;
                gameState.health += itemData.healthBonus;
            }
            if (itemData.manaBonus) {
                gameState.maxMana += itemData.manaBonus;
                gameState.mana += itemData.manaBonus;
            }
        }
        
        function removeEquipmentStats(item) {
            const itemData = itemTemplates[item];
            
            if (itemData.attack) gameState.attack -= itemData.attack;
            if (itemData.defense) gameState.defense -= itemData.defense;
            if (itemData.healthBonus) {
                gameState.maxHealth -= itemData.healthBonus;
                // Don't reduce current health below 1
                gameState.health = Math.max(1, gameState.health - itemData.healthBonus);
            }
            if (itemData.manaBonus) {
                gameState.maxMana -= itemData.manaBonus;
                gameState.mana = Math.max(0, gameState.mana - itemData.manaBonus);
            }
        }
        
        function useConsumable(item) {
            const displayName = itemDisplayNames[item] || item;
            
            if (item === "healthPotion") {
                const oldHealth = gameState.health;
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 40);
                const healed = gameState.health - oldHealth;
                addToOutput(`You drink a ${displayName} and restore ${healed} health.`, "heal-text");
                
                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(item);
                if (itemIndex > -1) {
                    gameState.inventory.splice(itemIndex, 1);
                }
            }
            
            if (item === "manaPotion") {
                const oldMana = gameState.mana;
                gameState.mana = Math.min(gameState.maxMana, gameState.mana + 30);
                const restored = gameState.mana - oldMana;
                addToOutput(`You drink a ${displayName} and restore ${restored} mana.`, "heal-text");
                
                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(item);
                if (itemIndex > -1) {
                    gameState.inventory.splice(itemIndex, 1);
                }
            }
            
            if (item === "herb") {
                const oldHealth = gameState.health;
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 20);
                const healed = gameState.health - oldHealth;
                addToOutput(`You consume a ${displayName} and restore ${healed} health.`, "heal-text");
                
                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(item);
                if (itemIndex > -1) {
                    gameState.inventory.splice(itemIndex, 1);
                }
            }
            
            if (item === "torch") {
                addToOutput(`You light a ${displayName}. The area becomes brighter.`, "important-text");
                // Remove from inventory
                const itemIndex = gameState.inventory.indexOf(item);
                if (itemIndex > -1) {
                    gameState.inventory.splice(itemIndex, 1);
                }
            }
            
            updateInventory();
            updateStatus();
        }
        
        function handleEquipment() {
            if (gameState.inCombat) {
                addToOutput("You can't change equipment during combat!", "combat-text");
                return;
            }
            
            if (equipmentPanel.style.display === "block") {
                equipmentPanel.style.display = "none";
            } else {
                equipmentPanel.style.display = "block";
                updateEquipmentDisplay();
            }
        }
        
        function updateEquipmentDisplay() {
            equipmentSlots.innerHTML = '';
            
            // Weapon slot
            const weaponSlot = document.createElement("div");
            weaponSlot.className = "equipment-slot";
            const weaponName = gameState.equipment.weapon ? (itemDisplayNames[gameState.equipment.weapon] || gameState.equipment.weapon.toUpperCase()) : 'None';
            weaponSlot.innerHTML = `<strong>WEAPON</strong><br>${weaponName}`;
            equipmentSlots.appendChild(weaponSlot);
            
            // Armor slot
            const armorSlot = document.createElement("div");
            armorSlot.className = "equipment-slot";
            const armorName = gameState.equipment.armor ? (itemDisplayNames[gameState.equipment.armor] || gameState.equipment.armor.toUpperCase()) : 'None';
            armorSlot.innerHTML = `<strong>ARMOR</strong><br>${armorName}`;
            equipmentSlots.appendChild(armorSlot);
            
            // Shield slot
            const shieldSlot = document.createElement("div");
            shieldSlot.className = "equipment-slot";
            const shieldName = gameState.equipment.shield ? (itemDisplayNames[gameState.equipment.shield] || gameState.equipment.shield.toUpperCase()) : 'None';
            shieldSlot.innerHTML = `<strong>SHIELD</strong><br>${shieldName}`;
            equipmentSlots.appendChild(shieldSlot);
            
            // Accessory slot
            const accessorySlot = document.createElement("div");
            accessorySlot.className = "equipment-slot";
            const accessoryName = gameState.equipment.accessory ? (itemDisplayNames[gameState.equipment.accessory] || gameState.equipment.accessory.toUpperCase()) : 'None';
            accessorySlot.innerHTML = `<strong>ACCESSORY</strong><br>${accessoryName}`;
            equipmentSlots.appendChild(accessorySlot);
            
            // Stats display
            const statsSlot = document.createElement("div");
            statsSlot.className = "equipment-slot";
            statsSlot.innerHTML = `<strong>STATS</strong><br>ATK: ${gameState.attack}<br>DEF: ${gameState.defense}<br>HP: ${gameState.health}/${gameState.maxHealth}<br>MP: ${gameState.mana}/${gameState.maxMana}`;
            equipmentSlots.appendChild(statsSlot);
        }
        
        // ============================================
        // USE ITEM MENU (FIXED)
        // ============================================
        function handleUseItem() {
            if (gameState.inCombat) {
                addToOutput("Use the combat item button during combat!", "combat-text");
                return;
            }
            
            if (gameState.inventory.length === 0) {
                addToOutput("Your inventory is empty.", "important-text");
                return;
            }
            
            const choices = gameState.inventory.map(item => ({
                text: `${itemDisplayNames[item] || item.toUpperCase()}`,
                value: item
            }));
            
            choices.push({ text: "CANCEL", value: "cancel" });
            
            showActionPanel("USE OR EQUIP ITEM:", choices, (choice) => {
                if (choice.value === "cancel") {
                    addToOutput("Cancelled.");
                    return;
                }
                useOrEquipItem(choice.value);
            });
        }
        
        // ============================================
        // MAP SYSTEM
        // ============================================
        function handleMap() {
            if (gameState.inCombat) {
                addToOutput("You can't check the map during combat!", "combat-text");
                return;
            }
            
            generateMap();
            
            if (mapPanel.style.display === "block") {
                mapPanel.style.display = "none";
            } else {
                mapPanel.style.display = "block";
            }
        }
        
        function generateMap() {
            const grid = gameState.floorData.grid;
            let mapString = "";
            
            // Calculate viewport (show 11x11 area around player)
            const viewSize = 11;
            const halfView = Math.floor(viewSize / 2);
            
            const startY = Math.max(0, gameState.playerPosition.y - halfView);
            const endY = Math.min(grid.length, gameState.playerPosition.y + halfView + 1);
            
            const startX = Math.max(0, gameState.playerPosition.x - halfView);
            const endX = Math.min(grid[0].length, gameState.playerPosition.x + halfView + 1);
            
            mapString += `Floor ${gameState.currentFloor} - Depth Map\n`;
            mapString += "══════════════════════\n\n";
            
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const cell = grid[y][x];
                    
                    if (!cell.explored) {
                        mapString += "▓";
                    } else if (y === gameState.playerPosition.y && x === gameState.playerPosition.x) {
                        mapString += "@";
                    } else if (cell.stairs) {
                        mapString += ">";
                    } else if (cell.type === 'wall') {
                        mapString += "#";
                    } else if (cell.content === 'enemy' && gameState.inCombat && 
                               gameState.currentEnemy && y === gameState.playerPosition.y && 
                               Math.abs(x - gameState.playerPosition.x) <= 1) {
                        mapString += "E";
                    } else if (cell.type === 'floor') {
                        mapString += ".";
                    } else {
                        mapString += " ";
                    }
                    
                    mapString += " ";
                }
                mapString += "\n";
            }
            
            mapString += "\n══════════════════════\n";
            mapString += "Legend: @=You, #=Wall, .=Floor, >=Stairs, E=Enemy\n";
            mapString += `Rooms Explored: ${gameState.roomsExplored}/${gameState.floorData.roomCount}`;
            
            mapDisplay.textContent = mapString;
        }
        
        // ============================================
        // OTHER COMMANDS
        // ============================================
        function handleLook() {
            if (gameState.inCombat) {
                addToOutput("You're in combat! Focus on the enemy!", "combat-text");
                return;
            }
            
            describeCurrentRoom();
            
            // Check surroundings
            const px = gameState.playerPosition.x;
            const py = gameState.playerPosition.y;
            
            let exits = [];
            
            // Check cardinal directions
            const directions = [
                { name: "north", dx: 0, dy: -1 },
                { name: "south", dx: 0, dy: 1 },
                { name: "east", dx: 1, dy: 0 },
                { name: "west", dx: -1, dy: 0 }
            ];
            
            directions.forEach(dir => {
                const x = px + dir.dx;
                const y = py + dir.dy;
                
                if (gameState.floorData.grid[y] && gameState.floorData.grid[y][x] && 
                    gameState.floorData.grid[y][x].type === 'floor') {
                    exits.push(dir.name);
                }
            });
            
            if (exits.length > 0) {
                addToOutput(`Exits: ${exits.join(", ")}`, "important-text");
            }
        }
        
        function handleExplore() {
            if (gameState.inCombat) {
                addToOutput("You can't explore during combat!", "combat-text");
                return;
            }
            
            const cell = gameState.floorData.grid[gameState.playerPosition.y][gameState.playerPosition.x];
            
            if (cell.content && cell.content !== 'empty') {
                addToOutput("You've already investigated this area.", "important-text");
                return;
            }
            
            addToOutput("You search the area carefully...", "important-text");
            
            // Chance to find something
            const findChance = 0.3;
            if (Math.random() < findChance) {
                const finds = [
                    { text: "You find some loose coins.", action: () => {
                        const gold = Math.floor(Math.random() * 20) + 5;
                        gameState.gold += gold;
                        addToOutput(`You find ${gold} gold!`, "gold-text");
                    }},
                    { text: "You discover a hidden cache.", action: () => {
                        const lootType = generateLoot(gameState.currentFloor);
                        const lootName = itemDisplayNames[lootType] || lootType;
                        addToOutput(`You find a ${lootName}!`, "loot-text");
                        gameState.inventory.push(lootType);
                        gameState.itemsFound++;
                        updateInventory();
                    }},
                    { text: "You notice something strange about the wall...", action: () => {
                        addToOutput("It's just a strange marking. Nothing useful.", "important-text");
                    }}
                ];
                
                const find = finds[Math.floor(Math.random() * finds.length)];
                addToOutput(find.text);
                find.action();
            } else {
                addToOutput("You don't find anything of value.");
            }
            
            // Mark as explored
            cell.content = 'searched';
            
            updateStatus();
        }
        
        function handleRest() {
            if (gameState.inCombat) {
                addToOutput("You can't rest during combat!", "combat-text");
                return;
            }
            
            if (gameState.health >= gameState.maxHealth && gameState.mana >= gameState.maxMana) {
                addToOutput("You're already at full health and mana.");
                return;
            }
            
            addToOutput("You take a moment to rest...", "important-text");
            
            // Restore health and mana
            const healthRestored = Math.floor(gameState.maxHealth * 0.3);
            const manaRestored = Math.floor(gameState.maxMana * 0.4);
            
            gameState.health = Math.min(gameState.maxHealth, gameState.health + healthRestored);
            gameState.mana = Math.min(gameState.maxMana, gameState.mana + manaRestored);
            
            addToOutput(`You restore ${healthRestored} health and ${manaRestored} mana.`, "heal-text");
            
            // Chance of enemy encounter while resting
            if (Math.random() < 0.25) {
                addToOutput("An enemy discovers you while you're resting!", "danger-text");
                setTimeout(() => {
                    const enemy = generateEnemy(gameState.currentFloor);
                    startCombat(enemy);
                }, 1000);
            }
            
            updateStatus();
        }
        
        // ============================================
        // UI PANEL MANAGEMENT
        // ============================================
        function showActionPanel(title, choices, callback) {
            actionTitle.textContent = title;
            actionChoices.innerHTML = '';
            
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'button';
                button.textContent = choice.text;
                button.addEventListener('click', () => {
                    hideActionPanel();
                    callback(choice);
                });
                actionChoices.appendChild(button);
            });
            
            actionPanel.style.display = 'block';
        }
        
        function hideActionPanel() {
            actionPanel.style.display = 'none';
        }
        
        function showCombatPanel() {
            updateCombatUI();
            combatPanel.style.display = 'block';
        }
        
        function hideCombatPanel() {
            combatPanel.style.display = 'none';
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        function initGame() {
            // Load saved data
            loadGameSave();
            
            // Set up event listeners
            document.getElementById('lookBtn').addEventListener('click', handleLook);
            document.getElementById('exploreBtn').addEventListener('click', handleExplore);
            document.getElementById('inventoryBtn').addEventListener('click', handleInventory);
            document.getElementById('equipmentBtn').addEventListener('click', handleEquipment);
            document.getElementById('useBtn').addEventListener('click', handleUseItem);
            document.getElementById('restBtn').addEventListener('click', handleRest);
            document.getElementById('moveBtn').addEventListener('click', handleMove);
            document.getElementById('mapBtn').addEventListener('click', handleMap);
            
            // Show class selection
            showClassSelection();
            
            // Add some initial flavor text
            addToOutput("Welcome to JOURNEY INTO DARKNESS", "important-text");
            addToOutput("A procedurally generated dungeon crawler with permadeath.", "procedural-notice");
            addToOutput("Each run is unique. Each death is permanent.", "permadeath-notice");
            addToOutput("Reach deeper floors to unlock new character classes!", "unlock-notice");
        }
        
        // Start the game
        initGame();
    </script>
</body>
</html>
