<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CASTLE.EXE - Castle of the Damned</title>
    <style>
        /* IBM 8-bit font */
        @font-face {
            font-family: 'IBM BIOS';
            src: url('https://int10h.org/oldschool-pc-fonts/fonts/WebIBM/WebIBM.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        
        /* Atari 8-bit font alternative */
        @font-face {
            font-family: 'Atari Classic';
            src: url('https://fonts.cdnfonts.com/s/11094/AtariClassic.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'IBM BIOS', 'Atari Classic', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.1;
            image-rendering: pixelated;
        }
        
        body {
            background-color: #000000;
            color: #FFFFFF;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            padding: 8px;
            cursor: default;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* 80s computer screen glow effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(
                    ellipse at center,
                    rgba(255, 255, 255, 0.03) 0%,
                    rgba(0, 0, 0, 0) 70%
                ),
                repeating-linear-gradient(
                    0deg,
                    rgba(255, 255, 255, 0.02) 0px,
                    rgba(255, 255, 255, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                );
            pointer-events: none;
            z-index: 999;
        }
        
        /* CRT scanlines */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.3;
        }
        
        /* Blinking cursor */
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .header {
            text-align: center;
            padding: 6px 4px;
            border: 1px solid #FFFFFF;
            margin-bottom: 6px;
            flex-shrink: 0;
            background-color: #000000;
            position: relative;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.1);
        }
        
        .header-border {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            border: 1px dashed #FFFFFF;
            pointer-events: none;
        }
        
        h1 {
            color: #FFFFFF;
            font-size: 18px;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: normal;
            text-shadow: 0 0 4px rgba(255, 255, 255, 0.5);
        }
        
        .subtitle {
            color: #AAAAAA;
            font-size: 10px;
            margin-bottom: 3px;
            letter-spacing: 1px;
        }
        
        .game-container {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 6px;
            min-height: 0;
            border: 1px solid #FFFFFF;
            background-color: #000000;
        }
        
        .main-panel {
            flex: 3;
            display: flex;
            flex-direction: column;
            background-color: #000000;
            min-height: 0;
            position: relative;
        }
        
        .info-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #FFFFFF;
            background-color: #000000;
            padding: 4px;
            overflow-y: auto;
            min-height: 0;
            max-width: 240px;
        }
        
        .game-output-container {
            flex: 1;
            overflow-y: auto;
            padding: 6px;
            min-height: 0;
            background-color: #000000;
        }
        
        .game-output {
            line-height: 1.1;
            font-size: 13px;
            min-height: 100%;
            color: #FFFFFF;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.3);
        }
        
        .game-input {
            border-top: 1px solid #FFFFFF;
            padding: 4px;
            display: flex;
            flex-shrink: 0;
            background-color: #000000;
            align-items: center;
        }
        
        .prompt {
            color: #FFFFFF;
            margin-right: 6px;
            font-weight: normal;
            line-height: 20px;
            flex-shrink: 0;
        }
        
        #user-input {
            flex: 1;
            background-color: #000000;
            border: none;
            color: #FFFFFF;
            padding: 2px;
            font-size: 13px;
            height: 20px;
            outline: none;
            caret-color: #FFFFFF;
            text-transform: uppercase;
        }
        
        #user-input:focus {
            outline: none;
            animation: blink 1s infinite;
        }
        
        .info-title {
            color: #FFFFFF;
            font-size: 12px;
            margin-bottom: 4px;
            border-bottom: 1px solid #FFFFFF;
            padding-bottom: 2px;
            text-transform: uppercase;
        }
        
        .info-content {
            flex: 1;
            font-size: 11px;
            line-height: 1.1;
            min-height: 0;
            color: #DDDDDD;
        }
        
        .command-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2px;
            margin-top: 6px;
        }
        
        .command-item {
            color: #AAAAAA;
            font-size: 10px;
            padding: 1px;
        }
        
        .inventory {
            margin-top: 8px;
            padding-top: 4px;
            border-top: 1px dotted #FFFFFF;
        }
        
        .inventory-title {
            color: #FFFFFF;
            font-size: 11px;
            margin-bottom: 2px;
            text-transform: uppercase;
        }
        
        .inventory-items {
            font-size: 10px;
            color: #BBBBBB;
            max-height: 60px;
            overflow-y: auto;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 4px;
            background-color: #000000;
            border: 1px solid #FFFFFF;
            font-size: 10px;
            flex-shrink: 0;
        }
        
        .footer {
            text-align: center;
            padding: 4px;
            margin-top: 6px;
            border-top: 1px solid #FFFFFF;
            font-size: 9px;
            color: #888888;
            flex-shrink: 0;
        }
        
        .keyboard-hint {
            margin-top: 6px;
            font-size: 9px;
            color: #888888;
        }
        
        .welcome-text {
            color: #FFFFFF;
            margin-bottom: 8px;
            text-transform: uppercase;
            font-size: 14px;
        }
        
        .location-title {
            color: #FFFFFF;
            margin-bottom: 6px;
            border-bottom: 1px dotted #FFFFFF;
            padding-bottom: 2px;
            text-transform: uppercase;
        }
        
        .game-text {
            margin-bottom: 6px;
            color: #DDDDDD;
        }
        
        .exit-item {
            color: #FFFFFF;
            margin-left: 12px;
        }
        
        .response {
            color: #FFFFFF;
            margin-top: 6px;
            margin-bottom: 6px;
            font-style: normal;
        }
        
        .combat-text {
            color: #FFFFFF;
            background-color: #550000;
            padding: 2px;
            margin-top: 6px;
            margin-bottom: 6px;
            text-transform: uppercase;
            border: 1px solid #FF0000;
        }
        
        .npc-text {
            color: #FFFFFF;
            background-color: #000055;
            padding: 2px;
            margin-top: 6px;
            margin-bottom: 6px;
            font-style: normal;
            border: 1px solid #4444FF;
        }
        
        .health-bar {
            width: 100%;
            height: 6px;
            background-color: #000000;
            border: 1px solid #FFFFFF;
            margin-top: 2px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background-color: #FFFFFF;
            transition: width 0.3s;
        }
        
        .health-fill::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 1px,
                rgba(0, 0, 0, 0.5) 1px,
                rgba(0, 0, 0, 0.5) 2px
            );
        }
        
        /* Classic computer button */
        .computer-button {
            background-color: #000000;
            color: #FFFFFF;
            border: 1px solid #FFFFFF;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
            margin: 1px;
            text-transform: uppercase;
        }
        
        .computer-button:active {
            background-color: #FFFFFF;
            color: #000000;
        }
        
        /* Scrollbar styling for 80s look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #000000;
            border: 1px solid #FFFFFF;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #000000;
            border: 1px solid #FFFFFF;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #222222;
        }
        
        /* Screen corner decorations - 80s style */
        .corner {
            position: absolute;
            width: 6px;
            height: 6px;
            border: 1px solid #FFFFFF;
            z-index: 1;
        }
        
        .corner-tl {
            top: -1px;
            left: -1px;
            border-right: none;
            border-bottom: none;
        }
        
        .corner-tr {
            top: -1px;
            right: -1px;
            border-left: none;
            border-bottom: none;
        }
        
        .corner-bl {
            bottom: -1px;
            left: -1px;
            border-right: none;
            border-top: none;
        }
        
        .corner-br {
            bottom: -1px;
            right: -1px;
            border-left: none;
            border-top: none;
        }
        
        /* 80s computer boot screen */
        .boot-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            color: #FFFFFF;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 13px;
            line-height: 1.1;
            text-align: center;
            text-transform: uppercase;
        }
        
        .boot-text {
            text-align: center;
            line-height: 1.2;
            margin-bottom: 15px;
        }
        
        .boot-prompt {
            color: #FFFFFF;
            animation: blink 1s infinite;
            margin-top: 10px;
        }
        
        /* 80s error/warning colors */
        .error {
            color: #FFFFFF;
            background-color: #880000;
            padding: 1px 3px;
            border: 1px solid #FF0000;
        }
        
        .warning {
            color: #FFFFFF;
            background-color: #885500;
            padding: 1px 3px;
            border: 1px solid #FFAA00;
        }
        
        .success {
            color: #000000;
            background-color: #FFFFFF;
            padding: 1px 3px;
            border: 1px solid #AAAAAA;
        }
        
        /* 80s ASCII art */
        .ascii-art {
            font-family: 'Courier New', monospace;
            white-space: pre;
            font-size: 10px;
            line-height: 1;
            color: #FFFFFF;
            margin: 6px 0;
        }
        
        /* Disk access indicator (80s flair) */
        .disk-access {
            position: absolute;
            bottom: 4px;
            right: 4px;
            font-size: 8px;
            color: #888888;
            animation: blink 2s infinite;
        }
        
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
            }
            
            .info-panel {
                max-height: 180px;
                max-width: 100%;
            }
            
            * {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- 80s computer boot screen -->
    <div class="boot-screen" id="boot-screen">
        <div class="ascii-art">
     _____   _____   _______   __  __   _____   _        _____   _______   __   __
    / ____| |  __ \ |__   __| |  \/  | |_   _| | |      |  __ \ |  ____|  \ \ / /
   | |      | |__) |   | |    | \  / |   | |   | |      | |  | || |__      \ V / 
   | |      |  _  /    | |    | |\/| |   | |   | |      | |  | ||  __|      > <  
   | |____  | | \ \    | |    | |  | |  _| |_  | |____  | |__| || |____    / . \ 
    \_____| |_|  \_\   |_|    |_|  |_| |_____| |______| |_____/ |______|  /_/ \_\
        </div>
        <div class="boot-text">
            <p>IBM PC/AT COMPATIBLE</p>
            <p>640K RAM OK</p>
            <p>DISK BOOT FAILURE, INSERT SYSTEM DISK</p>
            <p>&nbsp;</p>
            <p>LOADING CASTLE.EXE...</p>
            <p>INITIALIZING ADVENTURE ENGINE...</p>
            <p>LOADING TEXT DATABASE...</p>
            <p>&nbsp;</p>
            <p>COPYRIGHT 1988 MYSTIC SOFTWARE</p>
            <p>LICENSED FROM BRAM STOKER ESTATE</p>
            <p>&nbsp;</p>
            <p class="boot-prompt">PRESS ANY KEY TO CONTINUE</p>
        </div>
    </div>
    
    <div class="header">
        <div class="corner corner-tl"></div>
        <div class="corner corner-tr"></div>
        <h1>CASTLE OF THE DAMNED</h1>
        <div class="subtitle">A TEXT ADVENTURE - BASED ON BRAM STOKER'S DRACULA</div>
        <div class="subtitle">VERSION 2.0 - (C) 1988 MYSTIC SOFTWARE</div>
        <div class="header-border"></div>
        <div class="corner corner-bl"></div>
        <div class="corner corner-br"></div>
    </div>
    
    <div class="game-container">
        <div class="main-panel">
            <div class="corner corner-tl"></div>
            <div class="corner corner-tr"></div>
            <div class="game-output-container" id="game-output-container">
                <div class="game-output" id="game-output">
                    <!-- Game text will appear here -->
                </div>
            </div>
            <div class="game-input">
                <span class="prompt">&gt;</span>
                <input type="text" id="user-input" autocomplete="off" autofocus spellcheck="false" placeholder="TYPE COMMAND...">
            </div>
            <div class="corner corner-bl"></div>
            <div class="corner corner-br"></div>
            <div class="disk-access">DISK ACCESS...</div>
        </div>
        
        <div class="info-panel">
            <div class="corner corner-tl"></div>
            <div class="corner corner-tr"></div>
            <div class="info-title">STATUS</div>
            <div class="info-content">
                <p>CASTLE.EXE RUNNING</p>
                <p>MEMORY: 640K/640K</p>
                <p>DISK: C:\GAMES\</p>
                
                <div class="status-bar">
                    <div>HP: <span id="health">100</span></div>
                    <div>GOLD: <span id="gold">10</span></div>
                </div>
                
                <div class="health-bar">
                    <div class="health-fill" id="health-fill" style="width: 100%"></div>
                </div>
                
                <div class="inventory">
                    <div class="inventory-title">INVENTORY</div>
                    <div class="inventory-items" id="inventory">
                        EMPTY
                    </div>
                </div>
                
                <div class="inventory">
                    <div class="inventory-title">EQUIPPED</div>
                    <div class="inventory-items" id="equipped">
                        NONE
                    </div>
                </div>
                
                <div class="status-bar">
                    <div>SCORE: <span id="score">0</span></div>
                    <div>MOVES: <span id="moves">0</span></div>
                </div>
                
                <div class="status-bar">
                    <div>LOC: <span id="location">OUTSIDE</span></div>
                </div>
                
                <div class="status-bar">
                    <div>COMPANION: <span id="companion">NONE</span></div>
                </div>
                
                <div class="status-bar">
                    <div>LOYALTY: <span id="loyalty">--</span></div>
                </div>
                
                <div class="keyboard-hint">
                    <p>ENTER: SUBMIT</p>
                    <p>UP/DOWN: HISTORY</p>
                    <p>ESC: QUIT</p>
                </div>
            </div>
            
            <div class="info-title" style="margin-top: 10px;">COMMANDS</div>
            <div class="command-list">
                <div class="command-item">GO [DIRECTION]</div>
                <div class="command-item">LOOK / EXAMINE</div>
                <div class="command-item">TAKE / DROP</div>
                <div class="command-item">USE / READ</div>
                <div class="command-item">TALK / ASK</div>
                <div class="command-item">ATTACK / FLEE</div>
                <div class="command-item">INVENTORY</div>
                <div class="command-item">HELP</div>
                <div class="command-item">SCORE</div>
                <div class="command-item">QUIT</div>
            </div>
            <div class="corner corner-bl"></div>
            <div class="corner corner-br"></div>
        </div>
    </div>
    
    <div class="footer">
        <p>CASTLE OF THE DAMNED V2.0 (C) 1988 MYSTIC SOFTWARE | IBM PC/AT COMPATIBLE | USE ARROW KEYS</p>
        <p>COMMANDS: N, S, E, W, U, D, NE, NW, SE, SW | F1: HELP | ESC: QUIT</p>
    </div>

    <script>
        // DOS boot screen
        document.addEventListener('DOMContentLoaded', function() {
            const bootScreen = document.getElementById('boot-screen');
            const userInput = document.getElementById('user-input');
            
            // Simulate 80s computer boot sequence
            setTimeout(function() {
                bootScreen.style.display = 'none';
                initGame();
                userInput.focus();
            }, 3500);
            
            // Allow any key to skip boot screen
            document.addEventListener('keydown', function() {
                if (bootScreen.style.display !== 'none') {
                    bootScreen.style.display = 'none';
                    initGame();
                    userInput.focus();
                }
            });
        });
        
        // Game state
        const gameState = {
            score: 0,
            moves: 0,
            health: 100,
            maxHealth: 100,
            gold: 10,
            inventory: [],
            location: 'outside_castle',
            gameActive: true,
            commandHistory: [],
            historyIndex: -1,
            awaitingInstructions: false,
            equippedWeapon: null,
            inCombat: false,
            currentEnemy: null,
            playerDamage: 5,
            visitedLocations: [],
            companion: null,
            companionLoyalty: 0,
            factionStanding: {
                villagers: 50,
                gypsies: 25,
                church: 75,
                dracula: -100
            },
            morality: "neutral",
            timeOfDay: "day",
            riddlesSolved: 0,
            puzzlesSolved: 0,
            companionMemory: {
                lastHelped: null,
                lastInsulted: null,
                questsCompleted: 0,
                timesAbandoned: 0
            }
        };

        // Game locations
        const locations = {
            outside_castle: {
                name: "OUTSIDE CASTLE DRACULA",
                description: "YOU STAND BEFORE THE MASSIVE GATES OF CASTLE DRACULA. THE STONE WALLS LOOM OMINOUSLY AGAINST THE MOONLIT SKY. A COLD WIND WHISPERS THROUGH THE DEAD TREES. THE GATE IS SLIGHTLY AJAR. TO THE EAST, A SMALL VILLAGE LIES IN THE DISTANCE.",
                exits: {n: "courtyard", e: "village_road", s: "forest_path"},
                items: ["iron_key"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            courtyard: {
                name: "CASTLE COURTYARD",
                description: "YOU'RE IN A DESOLATE COURTYARD. DEAD IVY CLINGS TO THE CASTLE WALLS. A STONE FOUNTAIN IN THE CENTER CONTAINS MURKY WATER. THE MAIN DOORS OF THE CASTLE STAND BEFORE YOU. TO THE NORTHWEST, AN OLD GRAVEYARD SITS NEGLECTED.",
                exits: {s: "outside_castle", n: "main_hall", w: "stables", e: "chapel", nw: "graveyard"},
                items: ["rusty_dagger"],
                npcs: [],
                enemies: ["giant_bat"],
                seen: false,
                canDig: false
            },
            graveyard: {
                name: "FORGOTTEN GRAVEYARD",
                description: "A NEGLECTED GRAVEYARD BEHIND THE CASTLE. TOMBSTONES TILT AT ODD ANGLES, AND FRESH GRAVES SUGGEST RECENT ACTIVITY. AN OLD MAN LEANS ON A SHOVEL, WATCHING YOU.",
                exits: {se: "courtyard", w: "crypt_entrance"},
                items: [],
                npcs: ["grave_digger"],
                enemies: [],
                seen: false,
                canDig: true,
                diggableItems: ["old_bones", "silver_ring", "rusted_medallion"]
            },
            crypt_entrance: {
                name: "CRYPT ENTRANCE",
                description: "A STONE STAIRCASE DESCENDS INTO DARKNESS. CARVINGS OF SKULLS AND BATS ADORN THE ARCHWAY. THE AIR SMELLS OF DAMP EARTH AND DECAY.",
                exits: {e: "graveyard", d: "family_crypt"},
                items: [],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            main_hall: {
                name: "MAIN HALL",
                description: "A VAST HALL WITH A VAULTED CEILING. TATTERED BANNERS HANG FROM THE WALLS. A GRAND STAIRCASE LEADS UPWARD. AN ENORMOUS FIREPLACE DOMINATES THE WEST WALL.",
                exits: {s: "courtyard", u: "upper_gallery", w: "library", e: "dining_hall"},
                items: ["candle"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            library: {
                name: "CASTLE LIBRARY",
                description: "SHELVES OF ANCIENT BOOKS LINE THE WALLS. DUST HANGS THICK IN THE AIR. A LARGE DESK SITS IN THE CENTER WITH A LEATHER-BOUND JOURNAL.",
                exits: {e: "main_hall", s: "study"},
                items: ["old_journal", "silver_cross"],
                npcs: ["librarian_ghost"],
                enemies: [],
                seen: false,
                canDig: false
            },
            study: {
                name: "PRIVATE STUDY",
                description: "A SMALL, CLUTTERED ROOM. MAPS OF TRANSYLVANIA COVER THE WALLS. A SECRET DOOR STANDS SLIGHTLY AJAR TO THE EAST.",
                exits: {n: "library", e: "secret_passage"},
                items: ["stake", "garlic"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            secret_passage: {
                name: "SECRET PASSAGE",
                description: "A NARROW, WINDING PASSAGE HIDDEN BEHIND THE STUDY WALLS. THE AIR IS DAMP AND COLD.",
                exits: {w: "study", d: "crypt"},
                items: [],
                npcs: [],
                enemies: ["rat_swarm"],
                seen: false,
                canDig: false
            },
            crypt: {
                name: "FAMILY CRYPT",
                description: "A CHILLING CHAMBER FILLED WITH STONE COFFINS. ONE COFFIN LIES OPEN, REVEALING RED VELVET LINING.",
                exits: {u: "secret_passage", e: "draculas_lair"},
                items: ["holy_water"],
                npcs: [],
                enemies: ["vampire_spawn"],
                seen: false,
                canDig: false
            },
            family_crypt: {
                name: "ANCIENT FAMILY CRYPT",
                description: "AN OLDER, MORE DECREPIT CRYPT THAN THE MAIN ONE. THE AIR IS THICK WITH DUST AND THE SCENT OF OLD DEATH.",
                exits: {u: "crypt_entrance", e: "hidden_tomb"},
                items: [],
                npcs: [],
                enemies: ["restless_spirit"],
                seen: false,
                canDig: true,
                diggableItems: ["ancient_scroll", "cursed_coin", "bone_key"]
            },
            hidden_tomb: {
                name: "HIDDEN TOMB",
                description: "A SECRET TOMB HIDDEN BEHIND A FALSE WALL. STRANGE SYMBOLS COVER THE WALLS, AND A STONE SARCOPHAGUS DOMINATES THE ROOM.",
                exits: {w: "family_crypt"},
                items: [],
                npcs: ["stone_guardian"],
                enemies: [],
                seen: false,
                canDig: false
            },
            draculas_lair: {
                name: "DRACULA'S LAIR",
                description: "THE INNERMOST CHAMBER OF THE CASTLE. A MASSIVE COFFIN DOMINATES THE ROOM, LID SLIGHTLY AJAR. THE AIR IS ICY COLD.",
                exits: {w: "crypt"},
                items: [],
                npcs: [],
                enemies: ["dracula"],
                seen: false,
                canDig: false
            },
            dining_hall: {
                name: "DINING HALL",
                description: "A LONG TABLE SET FOR A FEAST THAT WILL NEVER COME. COBWEBS DRAPE FROM A CRYSTAL CHANDELIER. SILVERWARE GLINTS IN THE DIM LIGHT.",
                exits: {w: "main_hall", n: "kitchen"},
                items: ["silver_fork"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            kitchen: {
                name: "CASTLE KITCHEN",
                description: "A MASSIVE KITCHEN WITH COLD IRON STOVES. UNIDENTIFIABLE MEAT HANGS FROM HOOKS. A LARGE BUTCHER'S BLOCK STANDS IN THE CENTER.",
                exits: {s: "dining_hall"},
                items: ["butcher_knife"],
                npcs: ["mad_chef"],
                enemies: [],
                seen: false,
                canDig: false
            },
            upper_gallery: {
                name: "UPPER GALLERY",
                description: "A BALCONY OVERLOOKING THE MAIN HALL. PORTRAITS OF PALE NOBLES WATCH YOU WITH DEAD EYES. A DOOR TO THE NORTH LEADS TO PRIVATE QUARTERS.",
                exits: {d: "main_hall", n: "bedchamber"},
                items: ["gold_coins"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            bedchamber: {
                name: "MASTER BEDCHAMBER",
                description: "AN OPULENT BEDROOM WITH A FOUR-POSTER BED. HEAVY CURTAINS BLOCK ALL LIGHT. A DIARY SITS ON THE NIGHTSTAND.",
                exits: {s: "upper_gallery"},
                items: ["vampire_diary"],
                npcs: [],
                enemies: [],
                seen: false,
                canDig: false
            },
            chapel: {
                name: "CASTLE CHAPEL",
                description: "A DESECRATED CHAPEL. THE ALTAR IS OVERTURNED, AND INVERTED CROSSES HANG ON THE WALLS. STAINED GLASS WINDOWS ARE SHATTERED.",
                exits: {w: "courtyard"},
                items: ["bible"],
                npcs: ["priest_ghost"],
                enemies: [],
                seen: false,
                canDig: false
            },
            stables: {
                name: "ABANDONED STABLES",
                description: "EMPTY HORSE STALLS LINE THE WALLS. HAY IS SCATTERED ACROSS THE FLOOR. A CARRIAGE SITS IN THE CORNER.",
                exits: {e: "courtyard"},
                items: ["horse_shoe"],
                npcs: [],
                enemies: ["wild_wolf"],
                seen: false,
                canDig: false
            },
            village_road: {
                name: "VILLAGE ROAD",
                description: "A MUDDY ROAD LEADING TO A SMALL VILLAGE. THE VILLAGERS FEAR THE CASTLE AND RARELY APPROACH.",
                exits: {w: "outside_castle", e: "village"},
                items: [],
                npcs: ["traveler"],
                enemies: [],
                seen: false,
                canDig: false
            },
            village: {
                name: "VILLAGE MARKET",
                description: "A SMALL, FRIGHTENED VILLAGE. THE VILLAGERS EYE YOU WITH SUSPICION. A MERCHANT HAS SET UP A STALL.",
                exits: {w: "village_road", n: "village_inn"},
                items: [],
                npcs: ["merchant", "villager", "seemingly_helpful_villager"],
                enemies: [],
                seen: false,
                canDig: false
            },
            village_inn: {
                name: "VILLAGE INN",
                description: "A COZY INN WITH A ROARING FIREPLACE. LOCALS WHISPER ABOUT THE CASTLE OVER MUGS OF ALE.",
                exits: {s: "village"},
                items: ["healing_potion"],
                npcs: ["innkeeper"],
                enemies: [],
                seen: false,
                canDig: false
            },
            forest_path: {
                name: "FOREST PATH",
                description: "A DARK PATH THROUGH THE TRANSYLVANIAN FOREST. HOWLS ECHO IN THE DISTANCE.",
                exits: {n: "outside_castle", s: "gypsy_camp"},
                items: ["wooden_stake"],
                npcs: [],
                enemies: ["werewolf"],
                seen: false,
                canDig: false
            },
            gypsy_camp: {
                name: "GYPSY CAMP",
                description: "A CAMP OF ROMANI TRAVELERS. THEY SPEAK OF ANCIENT CURSES AND OFFER STRANGE WARES.",
                exits: {n: "forest_path"},
                items: [],
                npcs: ["gypsy_elder", "gypsy_fortune_teller", "alchemist"],
                enemies: [],
                seen: false,
                canDig: false
            }
        };

        // Item definitions
        const items = {
            "iron_key": {
                name: "IRON KEY",
                description: "A HEAVY IRON KEY. IT MIGHT UNLOCK SOMETHING IN THE CASTLE.",
                points: 10,
                portable: true,
                value: 5,
                type: "key"
            },
            "rusty_dagger": {
                name: "RUSTY DAGGER",
                description: "A RUSTY BUT SHARP DAGGER. DAMAGE: 8",
                points: 15,
                portable: true,
                value: 10,
                type: "weapon",
                damage: 8
            },
            "candle": {
                name: "CANDLE",
                description: "A BEESWAX CANDLE. IT PROVIDES LIGHT IN DARK PLACES.",
                points: 5,
                portable: true,
                value: 2,
                type: "light"
            },
            "old_journal": {
                name: "OLD JOURNAL",
                description: "A JOURNAL BELONGING TO A PREVIOUS VAMPIRE HUNTER. IT CONTAINS USEFUL INFORMATION.",
                points: 20,
                portable: true,
                value: 1,
                type: "readable",
                content: "THE JOURNAL DESCRIBES WEAKNESSES OF VAMPIRES: SUNLIGHT, GARLIC, HOLY SYMBOLS, AND WOODEN STAKES THROUGH THE HEART."
            },
            "silver_cross": {
                name: "SILVER CROSS",
                description: "A SILVER CROSS THAT GLOWS FAINTLY. IT MIGHT PROTECT AGAINST EVIL.",
                points: 25,
                portable: true,
                value: 50,
                type: "holy"
            },
            "stake": {
                name: "WOODEN STAKE",
                description: "A SHARPENED WOODEN STAKE. PERFECT FOR VAMPIRE HUNTING. DAMAGE: 15",
                points: 30,
                portable: true,
                value: 20,
                type: "weapon",
                damage: 15
            },
            "garlic": {
                name: "GARLIC CLUSTER",
                description: "A CLUSTER OF PUNGENT GARLIC. VAMPIRES HATE THE SMELL.",
                points: 10,
                portable: true,
                value: 5,
                type: "consumable"
            },
            "holy_water": {
                name: "VIAL OF HOLY WATER",
                description: "WATER BLESSED BY A PRIEST. BURNS THE UNDEAD. DAMAGE: 20",
                points: 40,
                portable: true,
                value: 30,
                type: "weapon",
                damage: 20,
                consumable: true
            },
            "silver_fork": {
                name: "SILVER FORK",
                description: "AN ORNATE SILVER FORK. COULD BE USED AS A WEAPON. DAMAGE: 5",
                points: 10,
                portable: true,
                value: 15,
                type: "weapon",
                damage: 5
            },
            "butcher_knife": {
                name: "BUTCHER KNIFE",
                description: "A SHARP KITCHEN KNIFE. DAMAGE: 10",
                points: 15,
                portable: true,
                value: 8,
                type: "weapon",
                damage: 10
            },
            "vampire_diary": {
                name: "VAMPIRE'S DIARY",
                description: "A DIARY WRITTEN IN AN ANCIENT LANGUAGE. IT MIGHT CONTAIN SECRETS.",
                points: 50,
                portable: true,
                value: 5,
                type: "readable",
                content: "THE DIARY SPEAKS OF DRACULA'S PLANS TO SPREAD HIS CURSE TO LONDON. IT MENTIONS HIS RESTING PLACES AND WEAKNESSES."
            },
            "bible": {
                name: "OLD BIBLE",
                description: "A LEATHER-BOUND BIBLE. THE WORDS GLOW WITH HOLY POWER.",
                points: 30,
                portable: true,
                value: 25,
                type: "holy"
            },
            "horse_shoe": {
                name: "IRON HORSE SHOE",
                description: "A LUCKY HORSE SHOE. MIGHT BRING GOOD FORTUNE.",
                points: 5,
                portable: true,
                value: 3,
                type: "misc"
            },
            "gold_coins": {
                name: "GOLD COINS",
                description: "A SMALL POUCH OF GOLD COINS. WORTH 25 GOLD PIECES.",
                points: 25,
                portable: true,
                value: 25,
                type: "money"
            },
            "healing_potion": {
                name: "HEALING POTION",
                description: "A RED POTION THAT RESTORES HEALTH.",
                points: 20,
                portable: true,
                value: 15,
                type: "consumable",
                heal: 30
            },
            "wooden_stake": {
                name: "CRUDE WOODEN STAKE",
                description: "A ROUGHLY CARVED WOODEN STAKE. DAMAGE: 12",
                points: 20,
                portable: true,
                value: 10,
                type: "weapon",
                damage: 12
            },
            "shovel": {
                name: "RUSTY SHOVEL",
                description: "A DIGGING TOOL. CAN BE USED TO DIG GRAVES.",
                points: 5,
                portable: true,
                value: 8,
                type: "tool",
                digPower: 1
            },
            "old_bones": {
                name: "OLD BONES",
                description: "ANCIENT HUMAN BONES. COULD BE VALUABLE TO NECROMANCERS.",
                points: 5,
                portable: true,
                value: 3,
                type: "misc"
            },
            "silver_ring": {
                name: "TARNISHED SILVER RING",
                description: "A RING WITH STRANGE INSCRIPTIONS.",
                points: 15,
                portable: true,
                value: 20,
                type: "jewelry"
            },
            "rusted_medallion": {
                name: "RUSTED MEDALLION",
                description: "A MEDALLION DEPICTING A WOLF. MIGHT HAVE SIGNIFICANCE.",
                points: 10,
                portable: true,
                value: 5,
                type: "quest"
            },
            "ancient_scroll": {
                name: "ANCIENT SCROLL",
                description: "A SCROLL WRITTEN IN A FORGOTTEN LANGUAGE.",
                points: 30,
                portable: true,
                value: 10,
                type: "readable",
                content: "THE SCROLL DESCRIBES A RITUAL TO BIND RESTLESS SPIRITS TO THEIR GRAVES."
            },
            "cursed_coin": {
                name: "CURSED COIN",
                description: "A COIN THAT FEELS UNNATURALLY COLD. BRINGS MISFORTUNE.",
                points: -10,
                portable: true,
                value: 50,
                type: "cursed"
            },
            "bone_key": {
                name: "BONE KEY",
                description: "A KEY CARVED FROM HUMAN BONE. UNLOCKS SOMETHING TERRIBLE.",
                points: 15,
                portable: true,
                value: 1,
                type: "key"
            },
            "bat_wing": {
                name: "GIANT BAT WING",
                description: "LEATHERY WING OF A GIANT BAT. ALCHEMICAL INGREDIENT.",
                points: 5,
                portable: true,
                value: 8,
                type: "ingredient"
            }
        };

        // NPC definitions
        const npcs = {
            "grave_digger": {
                name: "OLD GREGOR - GRAVE DIGGER",
                description: "A WEATHERED OLD MAN WITH TIRED EYES AND DIRT-STAINED HANDS. HE LEANS ON HIS SHOVEL.",
                dialogue: [
                    "THESE GROUNDS... THEY AIN'T RESTFUL NO MORE.",
                    "I'VE SEEN THINGS COME OUT OF GRAVES THAT SHOULD STAY BURIED.",
                    "THE COUNT PAYS ME WELL TO KEEP QUIET ABOUT WHAT I SEE AT NIGHT.",
                    "I COULD SHOW YOU THE SECRET CATACOMBS... FOR A PRICE.",
                    "THERE'S A TOMB IN THE NORTHWEST CORNER THAT'S NEVER BEEN OPENED."
                ],
                companion: true,
                loyalty: 0,
                skills: ["find_secrets", "dig_graves", "identify_undead"],
                shopItems: ["shovel"],
                buyItems: ["old_bones", "silver_ring"],
                special: "CAN OPEN GRAVES/CRYPTS OTHERS CAN'T",
                joinCost: 20,
                quest: "FIND HIS STOLEN LOCKET IN THE CRYPT",
                memory: {
                    askedToJoin: false,
                    helped: false,
                    insulted: false,
                    questCompleted: false
                }
            },
            "librarian_ghost": {
                name: "GHOST OF THE LIBRARIAN",
                description: "A TRANSLUCENT FIGURE FLOATING AMONG THE BOOKSHELVES.",
                dialogue: [
                    "THE COUNT'S SECRETS ARE HIDDEN IN HIS DIARY...",
                    "BEWARE THE CRYPT BELOW... THE SPAWN ARE RESTLESS...",
                    "SILVER AND WOOD CAN HARM THE UNDEAD..."
                ],
                shopItems: [],
                buyItems: ["old_journal", "silver_cross"],
                special: "CAN REVEAL BOOK-BASED SECRETS"
            },
            "mad_chef": {
                name: "MAD CHEF",
                description: "A DERANGED MAN WIELDING A CLEAVER.",
                dialogue: [
                    "FRESH MEAT! ALWAYS NEED FRESH MEAT!",
                    "THE MASTER PREFERS HIS MEALS... LIVELY...",
                    "STAY OUT OF MY KITCHEN!"
                ],
                shopItems: ["butcher_knife"],
                buyItems: [],
                special: "MAY ATTACK IF YOU LOOK HUNGRY"
            },
            "priest_ghost": {
                name: "GHOST OF THE PRIEST",
                description: "A SORROWFUL SPIRIT IN TATTERED VESTMENTS.",
                dialogue: [
                    "THIS PLACE HAS BEEN CURSED FOR CENTURIES...",
                    "TAKE THIS BIBLE, IT MAY PROTECT YOU...",
                    "ONLY FAITH CAN DEFEAT THE DARKNESS..."
                ],
                shopItems: ["bible"],
                buyItems: [],
                special: "CAN BLESS ITEMS TEMPORARILY"
            },
            "stone_guardian": {
                name: "STONE GUARDIAN",
                description: "A LIVING STATUE BLOCKING A CRYPT ENTRANCE.",
                dialogue: [
                    "I SPEAK WITHOUT A MOUTH AND HEAR WITHOUT EARS. I HAVE NO BODY, BUT I COME ALIVE WITH WIND. WHAT AM I?",
                    "ANSWER MY RIDDLE TO PASS."
                ],
                shopItems: [],
                buyItems: [],
                special: "RIDDLE GUARDIAN",
                riddle: {
                    question: "I SPEAK WITHOUT A MOUTH AND HEAR WITHOUT EARS. I HAVE NO BODY, BUT I COME ALIVE WITH WIND. WHAT AM I?",
                    answer: "echo",
                    attempts: 3,
                    solved: false
                }
            },
            "merchant": {
                name: "VILLAGE MERCHANT",
                description: "A SHREWD-LOOKING MAN WITH A CART OF GOODS.",
                dialogue: [
                    "WHAT DO YOU NEED? I HAVE WARES FOR VAMPIRE HUNTERS.",
                    "THE CASTLE IS NO PLACE FOR THE LIVING...",
                    "SILVER BULLETS? HOLY WATER? I HAVE IT ALL... FOR A PRICE."
                ],
                shopItems: ["healing_potion", "wooden_stake", "silver_cross"],
                buyItems: ["gold_coins", "horse_shoe", "rusty_dagger"]
            },
            "villager": {
                name: "FRIGHTENED VILLAGER",
                description: "A PEASANT WHO LOOKS TERRIFIED.",
                dialogue: [
                    "DON'T GO TO THE CASTLE! IT'S CURSED!",
                    "AT NIGHT, WE HEAR SCREAMS FROM THE BATTLEMENTS...",
                    "THE GYPSIES KNOW MORE ABOUT THE COUNT..."
                ],
                shopItems: [],
                buyItems: []
            },
            "seemingly_helpful_villager": {
                name: "FRIENDLY VILLAGER",
                description: "A HELPFUL-LOOKING PEASANT OFFERING DIRECTIONS.",
                description_true: "A VAMPIRE IN DISGUISE!",
                dialogue: [
                    "THE CASTLE? OH, YOU DON'T WANT TO GO THERE...",
                    "BUT IF YOU MUST, TAKE THE EASTERN PATH."
                ],
                shopItems: [],
                buyItems: [],
                transforms_into: "vampire_spawn",
                trigger: "time_of_day === 'night' OR dialogue_count >= 3",
                warning_signs: [
                    "HE KEEPS LICKING HIS LIPS...",
                    "YOU NOTICE HE CASTS NO REFLECTION IN THE PUDDLE.",
                    "HE KEEPS GLANCING AT YOUR NECK."
                ],
                dialogue_count: 0,
                revealed: false
            },
            "innkeeper": {
                name: "INNKEEPER",
                description: "A BURLY MAN WIPING A MUG.",
                dialogue: [
                    "NEED A ROOM FOR THE NIGHT? 5 GOLD PIECES.",
                    "WE DON'T GET MANY VISITORS SINCE THE COUNT ARRIVED...",
                    "THE FOREST IS DANGEROUS AFTER DARK."
                ],
                shopItems: ["healing_potion"],
                buyItems: []
            },
            "traveler": {
                name: "WANDERING TRAVELER",
                description: "A CLOAKED FIGURE ON THE ROAD.",
                dialogue: [
                    "I WOULDN'T GO TO THAT CASTLE IF I WERE YOU.",
                    "THEY SAY DRACULA CAN TRANSFORM INTO A BAT OR WOLF...",
                    "THE GYPSIES ARE LOYAL TO HIM, BE CAREFUL."
                ],
                shopItems: [],
                buyItems: []
            },
            "gypsy_elder": {
                name: "GYPSY ELDER",
                description: "AN OLD ROMANI MAN WITH WISE EYES.",
                dialogue: [
                    "THE MASTER IS NOT WHAT HE SEEMS...",
                    "WE SERVE THE COUNT, BUT NOT ALL OF US WILLINGLY...",
                    "BREAK THE CURSE BEFORE THE NEXT FULL MOON."
                ],
                shopItems: [],
                buyItems: []
            },
            "gypsy_fortune_teller": {
                name: "GYPSY FORTUNE TELLER",
                description: "A WOMAN GAZING INTO A CRYSTAL BALL.",
                dialogue: [
                    "I SEE DEATH IN YOUR FUTURE... BUT ALSO HOPE.",
                    "THE KEY TO DEFEATING HIM LIES IN HIS OWN LAIR...",
                    "TRUST NOT THE SHADOWS, FOR THEY HIDE HIS CHILDREN."
                ],
                shopItems: ["healing_potion", "wooden_stake"],
                buyItems: []
            },
            "alchemist": {
                name: "GYPSY ALCHEMIST",
                description: "AN OLD WOMAN STIRRING A BUBBLING CAULDRON.",
                dialogue: [
                    "POTIONS FOR SALE! PROTECTION FROM THE NIGHT CREATURES!",
                    "BAT WINGS, WOLF TEETH, VAMPIRE DUST... ALL USEFUL INGREDIENTS.",
                    "I CAN MAKE YOU A TRUTH SERUM... FOR THE RIGHT PRICE."
                ],
                shopItems: ["healing_potion"],
                buyItems: ["bat_wing", "old_bones"],
                special: "CAN CREATE SPECIAL POTIONS"
            }
        };

        // Enemy definitions
        const enemies = {
            "giant_bat": {
                name: "GIANT BAT",
                description: "A BAT WITH A WINGSPAN OF SIX FEET. ITS EYES GLOW RED.",
                health: 30,
                damage: 5,
                points: 25,
                drops: ["bat_wing"],
                weakTo: ["FIRE", "SILVER"]
            },
            "rat_swarm": {
                name: "RAT SWARM",
                description: "HUNDREDS OF DISEASED RATS MOVING AS ONE.",
                health: 20,
                damage: 3,
                points: 15,
                drops: [],
                weakTo: ["FIRE"]
            },
            "vampire_spawn": {
                name: "VAMPIRE SPAWN",
                description: "A PALE HUMANOID WITH FANGS AND CLAWED HANDS.",
                health: 50,
                damage: 10,
                points: 50,
                drops: ["vampire_dust"],
                weakTo: ["HOLY", "WOOD", "GARLIC"]
            },
            "dracula": {
                name: "COUNT DRACULA",
                description: "THE LORD OF VAMPIRES HIMSELF. PALE, ARISTOCRATIC, AND DEADLY.",
                health: 100,
                damage: 20,
                points: 500,
                drops: ["draculas_ring"],
                weakTo: ["HOLY", "WOOD", "GARLIC", "SUNLIGHT"]
            },
            "wild_wolf": {
                name: "WILD WOLF",
                description: "A LARGE, SAVAGE WOLF WITH FROTHING JAWS.",
                health: 25,
                damage: 8,
                points: 20,
                drops: ["wolf_pelt"],
                weakTo: ["SILVER"]
            },
            "werewolf": {
                name: "WEREWOLF",
                description: "A HULKING MAN-WOLF HYBRID UNDER THE FULL MOON.",
                health: 60,
                damage: 15,
                points: 75,
                drops: ["silver_amulet"],
                weakTo: ["SILVER"]
            },
            "restless_spirit": {
                name: "RESTLESS SPIRIT",
                description: "A GHOSTLY APPARITION BOUND TO ITS GRAVE.",
                health: 40,
                damage: 7,
                points: 35,
                drops: [],
                weakTo: ["HOLY", "SALT"]
            }
        };

        // Direction mapping
        const directionMap = {
            "n": "NORTH", "north": "NORTH",
            "s": "SOUTH", "south": "SOUTH",
            "e": "EAST", "east": "EAST",
            "w": "WEST", "west": "WEST",
            "ne": "NORTHEAST", "northeast": "NORTHEAST",
            "nw": "NORTHWEST", "northwest": "NORTHWEST",
            "se": "SOUTHEAST", "southeast": "SOUTHEAST",
            "sw": "SOUTHWEST", "southwest": "SOUTHWEST",
            "u": "UP", "up": "UP",
            "d": "DOWN", "down": "DOWN"
        };

        // DOM elements
        const gameOutput = document.getElementById('game-output');
        const gameOutputContainer = document.getElementById('game-output-container');
        const userInput = document.getElementById('user-input');
        const scoreElement = document.getElementById('score');
        const movesElement = document.getElementById('moves');
        const locationElement = document.getElementById('location');
        const inventoryElement = document.getElementById('inventory');
        const healthElement = document.getElementById('health');
        const goldElement = document.getElementById('gold');
        const healthFillElement = document.getElementById('health-fill');
        const equippedElement = document.getElementById('equipped');
        const companionElement = document.getElementById('companion');
        const loyaltyElement = document.getElementById('loyalty');

        // Initialize game
        function initGame() {
            gameOutput.innerHTML = '';
            addToOutput('<div class="welcome-text">CASTLE OF THE DAMNED - VERSION 2.0</div>');
            addToOutput('<div class="game-text">TEXT ADVENTURE (C) 1988 MYSTIC SOFTWARE</div>');
            addToOutput('<div class="game-text">BASED ON BRAM STOKER\'S DRACULA</div>');
            addToOutput('<div class="game-text">ENHANCED COMPANION SYSTEM</div>');
            addToOutput('<div class="game-text">TYPE "LOOK" TO START OR "HELP" FOR COMMANDS</div>');
            
            // Show starting location immediately
            look();
            
            userInput.focus();
            
            // Set up event listeners
            userInput.addEventListener('keydown', handleKeyDown);
            
            // Listen for F1 key for help
            document.addEventListener('keydown', function(e) {
                if (e.key === 'F1') {
                    e.preventDefault();
                    showHelp();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    quitGame();
                }
            });
            
            // No instructions question - start immediately
            gameState.awaitingInstructions = false;
            updateUI();
            
            // Start day/night cycle
            startDayNightCycle();
        }

        // Start day/night cycle
        function startDayNightCycle() {
            setInterval(function() {
                if (gameState.timeOfDay === "day") {
                    gameState.timeOfDay = "night";
                    if (Math.random() > 0.7) {
                        addToOutput('<div class="game-text">THE SUN SETS. NIGHT FALLS OVER TRANSYLVANIA...</div>');
                        checkNightEvents();
                    }
                } else {
                    gameState.timeOfDay = "day";
                    if (Math.random() > 0.7) {
                        addToOutput('<div class="game-text">DAWN BREAKS. THE CREATURES OF THE NIGHT RETREAT...</div>');
                    }
                }
            }, 30000); // Change every 30 seconds
        }

        // Check for night events
        function checkNightEvents() {
            const loc = locations[gameState.location];
            
            // Check for transforming NPCs
            if (loc.npcs.includes("seemingly_helpful_villager") && !npcs.seemingly_helpful_villager.revealed) {
                if (gameState.timeOfDay === "night" && npcs.seemingly_helpful_villager.dialogue_count >= 2) {
                    addToOutput('<div class="combat-text">THE FRIENDLY VILLAGER\'S SMILE TURNS INTO A SNARL! FANGS EXTEND!</div>');
                    addToOutput('<div class="combat-text">IT WAS A VAMPIRE IN DISGUISE! IT ATTACKS!</div>');
                    
                    // Transform into vampire spawn
                    const index = loc.npcs.indexOf("seemingly_helpful_villager");
                    loc.npcs.splice(index, 1);
                    loc.enemies.push("vampire_spawn");
                    npcs.seemingly_helpful_villager.revealed = true;
                    
                    // Start combat
                    gameState.inCombat = true;
                    gameState.currentEnemy = "vampire_spawn";
                    addToOutput('<div class="combat-text">WHAT WILL YOU DO? (ATTACK OR FLEE)</div>');
                }
            }
        }

        // Handle keyboard input
        function handleKeyDown(event) {
            if (event.key === 'Enter') {
                const command = userInput.value.trim().toUpperCase();
                userInput.value = '';
                processCommand(command);
                gameState.historyIndex = -1;
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (gameState.commandHistory.length > 0) {
                    if (gameState.historyIndex < gameState.commandHistory.length - 1) {
                        gameState.historyIndex++;
                    }
                    userInput.value = gameState.commandHistory[gameState.commandHistory.length - 1 - gameState.historyIndex] || '';
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (gameState.historyIndex > 0) {
                    gameState.historyIndex--;
                    userInput.value = gameState.commandHistory[gameState.commandHistory.length - 1 - gameState.historyIndex] || '';
                } else {
                    gameState.historyIndex = -1;
                    userInput.value = '';
                }
            }
        }

        // Process player command
        function processCommand(command) {
            if (!command) return;
            
            // Add to command history
            gameState.commandHistory.push(command);
            if (gameState.commandHistory.length > 50) {
                gameState.commandHistory.shift();
            }
            
            // Handle special game states
            if (!gameState.gameActive) {
                if (command === 'Y' || command === 'YES') {
                    resetGame();
                } else {
                    addToOutput('<div class="response">THANKS FOR PLAYING CASTLE OF THE DAMNED!</div>');
                }
                return;
            }
            
            // Increment moves
            gameState.moves++;
            
            // Parse command
            const parts = command.toLowerCase().split(' ');
            const verb = parts[0];
            const obj = parts.slice(1).join(' ');
            
            // Handle combat state
            if (gameState.inCombat) {
                handleCombatCommand(verb, obj);
                updateUI();
                return;
            }
            
            // Check for NPC transformations based on dialogue
            checkNPCTranformations(verb, obj);
            
            // Process different commands
            switch(verb) {
                case 'go':
                case 'move':
                case 'walk':
                case 'run':
                    goDirection(obj);
                    break;
                case 'n':
                case 's':
                case 'e':
                case 'w':
                case 'ne':
                case 'nw':
                case 'se':
                case 'sw':
                case 'u':
                case 'd':
                case 'north':
                case 'south':
                case 'east':
                case 'west':
                case 'northeast':
                case 'northwest':
                case 'southeast':
                case 'southwest':
                case 'up':
                case 'down':
                    goDirection(verb);
                    break;
                case 'look':
                case 'l':
                    look();
                    break;
                case 'take':
                case 'get':
                case 'grab':
                    takeItem(obj);
                    break;
                case 'drop':
                case 'discard':
                    dropItem(obj);
                    break;
                case 'inventory':
                case 'i':
                    showInventory();
                    break;
                case 'examine':
                case 'x':
                case 'inspect':
                    examineItem(obj);
                    break;
                case 'read':
                    readItem(obj);
                    break;
                case 'talk':
                    talkToNPC(obj);
                    break;
                case 'ask':
                    handleAskCommand(obj);
                    break;
                case 'command':
                    commandCompanion(obj);
                    break;
                case 'greet':
                    greetCompanion();
                    break;
                case 'insult':
                    insultCompanion();
                    break;
                case 'attack':
                    attackEnemy(obj);
                    break;
                case 'equip':
                    equipWeapon(obj);
                    break;
                case 'buy':
                    buyItem(obj);
                    break;
                case 'sell':
                    sellItem(obj);
                    break;
                case 'list':
                    listShopItems();
                    break;
                case 'use':
                    useItem(obj);
                    break;
                case 'dig':
                    digGrave(obj);
                    break;
                case 'solve':
                    solveRiddle(obj);
                    break;
                case 'score':
                    showScore();
                    break;
                case 'help':
                case 'h':
                    showHelp();
                    break;
                case 'quit':
                case 'q':
                    quitGame();
                    break;
                case 'yes':
                case 'no':
                    addToOutput('<div class="response">TYPE HELP FOR COMMANDS OR LOOK TO SEE YOUR SURROUNDINGS.</div>');
                    break;
                default:
                    addToOutput('<div class="response">I DON\'T UNDERSTAND "' + command + '". TRY HELP FOR COMMANDS.</div>');
            }
            
            updateUI();
        }

        // Check for NPC transformations
        function checkNPCTranformations(verb, obj) {
            const loc = locations[gameState.location];
            
            if (loc.npcs.includes("seemingly_helpful_villager") && verb === "talk" && obj.includes("villager")) {
                npcs.seemingly_helpful_villager.dialogue_count++;
                
                if (npcs.seemingly_helpful_villager.dialogue_count >= 2) {
                    addToOutput('<div class="warning">' + npcs.seemingly_helpful_villager.warning_signs[Math.floor(Math.random() * npcs.seemingly_helpful_villager.warning_signs.length)] + '</div>');
                }
                
                if (npcs.seemingly_helpful_villager.dialogue_count >= 3) {
                    addToOutput('<div class="combat-text">THE FRIENDLY VILLAGER\'S SMILE TURNS INTO A SNARL! FANGS EXTEND!</div>');
                    addToOutput('<div class="combat-text">IT WAS A VAMPIRE IN DISGUISE! IT ATTACKS!</div>');
                    
                    // Transform into vampire spawn
                    const index = loc.npcs.indexOf("seemingly_helpful_villager");
                    loc.npcs.splice(index, 1);
                    loc.enemies.push("vampire_spawn");
                    npcs.seemingly_helpful_villager.revealed = true;
                    
                    // Start combat
                    gameState.inCombat = true;
                    gameState.currentEnemy = "vampire_spawn";
                    addToOutput('<div class="combat-text">WHAT WILL YOU DO? (ATTACK OR FLEE)</div>');
                }
            }
        }

        // Move in a direction
        function goDirection(dir) {
            const direction = directionMap[dir];
            
            if (!direction) {
                addToOutput('<div class="response">I DON\'T KNOW THAT DIRECTION. TRY N, S, E, W, U, D, ETC.</div>');
                return;
            }
            
            const currentLoc = locations[gameState.location];
            const exit = currentLoc.exits[dir];
            
            if (!exit) {
                addToOutput('<div class="response">YOU CAN\'T GO THAT WAY.</div>');
                return;
            }
            
            // Check if location has been visited
            if (!gameState.visitedLocations.includes(exit)) {
                gameState.visitedLocations.push(exit);
                gameState.score += 10;
            }
            
            gameState.location = exit;
            look();
            
            // Companion follows
            if (gameState.companion) {
                addToOutput('<div class="npc-text">' + npcs[gameState.companion].name.split(' - ')[0] + ' FOLLOWS YOU.</div>');
            }
        }

        // Look at current location
        function look() {
            const loc = locations[gameState.location];
            
            let output = `<div class="location-title">${loc.name}</div>`;
            output += `<div class="game-text">${loc.description}</div>`;
            
            // Show time of day
            output += `<div class="game-text">TIME: ${gameState.timeOfDay.toUpperCase()}</div>`;
            
            // Show items in location
            if (loc.items.length > 0) {
                output += '<div class="game-text">YOU SEE: ' + loc.items.map(item => items[item].name).join(', ') + '</div>';
            }
            
            // Show NPCs
            if (loc.npcs.length > 0) {
                output += '<div class="game-text">PEOPLE HERE: ' + loc.npcs.map(npc => {
                    const npcObj = npcs[npc];
                    // Check for revealed vampires
                    if (npc === "seemingly_helpful_villager" && npcObj.revealed) {
                        return "VAMPIRE IN DISGUISE!";
                    }
                    return npcObj.name;
                }).join(', ') + '</div>';
            }
            
            // Show enemies
            if (loc.enemies.length > 0) {
                output += '<div class="combat-text">ENEMIES HERE: ' + loc.enemies.map(enemy => enemies[enemy].name).join(', ') + '</div>';
            }
            
            // Show exits
            const exitList = Object.keys(loc.exits).map(dir => {
                const fullDir = directionMap[dir];
                return `<span class="exit-item">${fullDir}</span>`;
            }).join(' ');
            
            output += `<div class="game-text">EXITS: ${exitList}</div>`;
            
            // Show if location can be dug
            if (loc.canDig) {
                output += '<div class="game-text">THIS AREA LOOKS LIKE IT CAN BE EXCAVATED.</div>';
            }
            
            addToOutput(output);
            
            // Mark location as seen
            loc.seen = true;
            updateUI();
        }

        // Take an item
        function takeItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">TAKE WHAT?</div>');
                return;
            }
            
            const loc = locations[gameState.location];
            const itemKey = findItemInLocation(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">I DON\'T SEE THAT HERE.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            if (!item.portable) {
                addToOutput(`<div class="response">THE ${item.name} CANNOT BE TAKEN.</div>`);
                return;
            }
            
            // Check if player already has this item
            if (gameState.inventory.includes(itemKey)) {
                addToOutput(`<div class="response">YOU ALREADY HAVE THE ${item.name}.</div>`);
                return;
            }
            
            // Remove from location, add to inventory
            const index = loc.items.indexOf(itemKey);
            loc.items.splice(index, 1);
            gameState.inventory.push(itemKey);
            
            // Add points
            gameState.score += item.points;
            addToOutput(`<div class="response">YOU TAKE THE ${item.name}. SCORE: +${item.points} POINTS.</div>`);
            
            // If it's gold coins, add to gold
            if (itemKey === 'gold_coins') {
                gameState.gold += item.value;
                addToOutput(`<div class="response">YOU NOW HAVE ${gameState.gold} GOLD PIECES.</div>`);
            }
            
            // If it's a cursed item
            if (item.type === "cursed") {
                addToOutput('<div class="warning">A CHILL RUNS DOWN YOUR SPINE AS YOU TOUCH THE COIN.</div>');
                gameState.health -= 5;
                updateHealth();
            }
            
            updateUI();
        }

        // Drop an item
        function dropItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">DROP WHAT?</div>');
                return;
            }
            
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU\'RE NOT CARRYING THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            // Remove from inventory, add to location
            const index = gameState.inventory.indexOf(itemKey);
            gameState.inventory.splice(index, 1);
            locations[gameState.location].items.push(itemKey);
            
            // If dropping equipped weapon, unequip it
            if (gameState.equippedWeapon === itemKey) {
                gameState.equippedWeapon = null;
                gameState.playerDamage = 5;
                addToOutput(`<div class="response">YOU UNEQUIP THE ${item.name}.</div>`);
            }
            
            addToOutput(`<div class="response">YOU DROP THE ${item.name}.</div>`);
            
            updateUI();
        }

        // Show inventory
        function showInventory() {
            if (gameState.inventory.length === 0) {
                addToOutput('<div class="response">YOU ARE EMPTY-HANDED.</div>');
            } else {
                const itemList = gameState.inventory.map(key => {
                    const item = items[key];
                    return item.name + (gameState.equippedWeapon === key ? " (EQUIPPED)" : "");
                }).join(', ');
                addToOutput(`<div class="response">YOU ARE CARRYING: ${itemList}</div>`);
                addToOutput(`<div class="response">GOLD: ${gameState.gold} PIECES</div>`);
            }
        }

        // Examine an item
        function examineItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">EXAMINE WHAT?</div>');
                return;
            }
            
            // Check inventory first
            let itemKey = findItemInInventory(itemName);
            let location = "INVENTORY";
            
            // Then check current location
            if (!itemKey) {
                itemKey = findItemInLocation(itemName);
                location = "HERE";
            }
            
            // Then check NPCs
            if (!itemKey) {
                const npcKey = findNPC(itemName);
                if (npcKey) {
                    const npc = npcs[npcKey];
                    // Check for revealed vampires
                    let desc = npc.description;
                    if (npcKey === "seemingly_helpful_villager" && npc.revealed) {
                        desc = npc.description_true;
                    }
                    addToOutput(`<div class="npc-text">${npc.name}: ${desc}</div>`);
                    
                    // Show special info
                    if (npc.special) {
                        addToOutput(`<div class="npc-text">SPECIAL: ${npc.special}</div>`);
                    }
                    return;
                }
            }
            
            // Then check enemies
            if (!itemKey) {
                const enemyKey = findEnemy(itemName);
                if (enemyKey) {
                    const enemy = enemies[enemyKey];
                    addToOutput(`<div class="combat-text">${enemy.name}: ${enemy.description}</div>`);
                    addToOutput(`<div class="combat-text">WEAK TO: ${enemy.weakTo.join(', ')}</div>`);
                    return;
                }
            }
            
            if (!itemKey) {
                addToOutput('<div class="response">I DON\'T SEE THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            addToOutput(`<div class="response">YOU EXAMINE THE ${item.name} (${location}): ${item.description}</div>`);
        }

        // Read an item
        function readItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">READ WHAT?</div>');
                return;
            }
            
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU\'RE NOT CARRYING THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            if (item.type !== "readable" && !item.content) {
                addToOutput(`<div class="response">THERE\'S NOTHING TO READ ON THE ${item.name}.</div>`);
                return;
            }
            
            addToOutput(`<div class="response">YOU READ THE ${item.name}:</div>`);
            addToOutput(`<div class="response">"${item.content}"</div>`);
            
            // Add points for reading important documents
            if (!item.hasBeenRead) {
                gameState.score += 10;
                item.hasBeenRead = true;
            }
        }

        // Talk to an NPC
        function talkToNPC(npcName) {
            if (!npcName) {
                addToOutput('<div class="response">TALK TO WHOM?</div>');
                return;
            }
            
            const loc = locations[gameState.location];
            const npcKey = findNPCInLocation(npcName);
            
            if (!npcKey) {
                addToOutput('<div class="response">I DON\'T SEE THAT PERSON HERE.</div>');
                return;
            }
            
            const npc = npcs[npcKey];
            
            // Special handling for stone guardian
            if (npcKey === "stone_guardian") {
                if (!npc.riddle.solved) {
                    addToOutput(`<div class="npc-text">${npc.name}: "${npc.riddle.question}"</div>`);
                    addToOutput('<div class="npc-text">ANSWER WITH: SOLVE [ANSWER]</div>');
                    return;
                } else {
                    addToOutput('<div class="npc-text">THE STONE GUARDIAN STEPS ASIDE, REVEALING A PASSAGE.</div>');
                    return;
                }
            }
            
            // Random dialogue from NPC
            const dialogue = npc.dialogue[Math.floor(Math.random() * npc.dialogue.length)];
            addToOutput(`<div class="npc-text">${npc.name}: "${dialogue}"</div>`);
            
            // If NPC is a merchant, mention they have items for sale
            if (npc.shopItems.length > 0) {
                addToOutput(`<div class="npc-text">${npc.name}: "I HAVE ITEMS FOR SALE. USE LIST TO SEE WHAT I HAVE."</div>`);
            }
            
            // Special handling for grave digger
            if (npcKey === "grave_digger") {
                if (!npc.memory.askedToJoin) {
                    addToOutput('<div class="npc-text">OLD GREGOR: "NEED HELP WITH THEM GRAVES? COULD JOIN YA... FOR 20 GOLD."</div>');
                    addToOutput('<div class="npc-text">SAY: ASK GREGOR TO JOIN</div>');
                }
            }
        }

        // Handle ASK commands
        function handleAskCommand(fullCommand) {
            if (!fullCommand) {
                addToOutput('<div class="response">ASK WHOM TO DO WHAT?</div>');
                return;
            }
            
            const parts = fullCommand.toLowerCase().split(' to ');
            const npcName = parts[0];
            const action = parts[1];
            
            if (!action) {
                addToOutput('<div class="response">ASK THEM TO DO WHAT?</div>');
                return;
            }
            
            const npcKey = findNPCInLocation(npcName);
            
            if (!npcKey) {
                addToOutput('<div class="response">THAT PERSON ISN\'T HERE.</div>');
                return;
            }
            
            const npc = npcs[npcKey];
            
            if (action.includes("join")) {
                if (npc.companion) {
                    if (gameState.companion) {
                        addToOutput(`<div class="response">YOU ALREADY HAVE A COMPANION: ${npcs[gameState.companion].name.split(' - ')[0]}</div>`);
                        return;
                    }
                    
                    if (gameState.gold >= npc.joinCost) {
                        gameState.gold -= npc.joinCost;
                        gameState.companion = npcKey;
                        gameState.companionLoyalty = 50;
                        npc.memory.askedToJoin = true;
                        addToOutput(`<div class="success">${npc.name.split(' - ')[0]} JOINS YOU! (-${npc.joinCost} GOLD)</div>`);
                        addToOutput(`<div class="npc-text">"I\'LL HELP YA WITH THE DIGGIN\'. JUST DON\'T GET US KILLED."</div>`);
                        updateUI();
                    } else {
                        addToOutput(`<div class="response">YOU NEED ${npc.joinCost} GOLD TO HIRE ${npc.name.split(' - ')[0]}.</div>`);
                    }
                } else {
                    addToOutput(`<div class="response">${npc.name} ISN\'T INTERESTED IN JOINING YOU.</div>`);
                }
            } else {
                addToOutput(`<div class="response">YOU ASK ${npc.name.split(' - ')[0]} TO ${action}, BUT NOTHING HAPPENS.</div>`);
            }
        }

        // Command companion
        function commandCompanion(command) {
            if (!gameState.companion) {
                addToOutput('<div class="response">YOU DON\'T HAVE A COMPANION.</div>');
                return;
            }
            
            const npc = npcs[gameState.companion];
            
            if (command.includes("dig") || command.includes("excavate")) {
                const loc = locations[gameState.location];
                if (loc.canDig) {
                    if (hasItem("shovel") || npc.skills.includes("dig_graves")) {
                        digGraveWithCompanion();
                    } else {
                        addToOutput('<div class="response">YOU NEED A SHOVEL TO DIG HERE.</div>');
                    }
                } else {
                    addToOutput('<div class="response">THERE\'S NOTHING TO DIG HERE.</div>');
                }
            } else if (command.includes("search") || command.includes("look")) {
                addToOutput(`<div class="npc-text">${npc.name.split(' - ')[0]} SNIFFS THE AIR... "I SENSE ${Math.random() > 0.5 ? 'SOMETHING OLD' : 'DEATH'} NEARBY."</div>`);
                gameState.companionLoyalty += 2;
            } else if (command.includes("wait") || command.includes("stay")) {
                addToOutput(`<div class="npc-text">${npc.name.split(' - ')[0]} NODS. "I\'LL WAIT HERE."</div>`);
                // Note: Would need to implement actual waiting mechanic
            } else {
                addToOutput(`<div class="response">${npc.name.split(' - ')[0]} LOOKS CONFUSED BY YOUR COMMAND.</div>`);
                gameState.companionLoyalty -= 1;
            }
            
            updateLoyaltyDisplay();
        }

        // Greet companion
        function greetCompanion() {
            if (!gameState.companion) {
                addToOutput('<div class="response">YOU DON\'T HAVE A COMPANION.</div>');
                return;
            }
            
            const npc = npcs[gameState.companion];
            const greetings = [
                "NODS RESPECTFULLY.",
                "TIPS HIS HAT.",
                "GIVES A TIRED SMILE.",
                "MUMBLES A GREETING.",
                "'MORNIN'."
            ];
            
            const greeting = greetings[Math.floor(Math.random() * greetings.length)];
            addToOutput(`<div class="npc-text">${npc.name.split(' - ')[0]} ${greeting}</div>`);
            gameState.companionLoyalty += 5;
            updateLoyaltyDisplay();
        }

        // Insult companion
        function insultCompanion() {
            if (!gameState.companion) {
                addToOutput('<div class="response">YOU DON\'T HAVE A COMPANION.</div>');
                return;
            }
            
            const npc = npcs[gameState.companion];
            const insults = [
                "SCOWLS AT YOU.",
                "LOOKS HURT.",
                "MUTTERS UNDER HIS BREATH.",
                "GLARES ANGRILY.",
                "'THAT WEREN\'T CALLED FOR.'"
            ];
            
            const insult = insults[Math.floor(Math.random() * insults.length)];
            addToOutput(`<div class="npc-text">${npc.name.split(' - ')[0]} ${insult}</div>`);
            gameState.companionLoyalty -= 15;
            
            // Check if companion leaves
            if (gameState.companionLoyalty <= 0) {
                addToOutput(`<div class="warning">${npc.name.split(' - ')[0]} THROWS DOWN HIS SHOVEL AND WALKS AWAY!</div>`);
                gameState.companion = null;
                gameState.companionLoyalty = 0;
                gameState.companionMemory.timesAbandoned++;
            }
            
            updateLoyaltyDisplay();
        }

        // Dig grave with companion
        function digGraveWithCompanion() {
            const loc = locations[gameState.location];
            const npc = npcs[gameState.companion];
            
            addToOutput(`<div class="npc-text">${npc.name.split(' - ')[0]} STARTS DIGGING WITH PRACTICED EASE...</div>`);
            
            // Chance to find something
            if (Math.random() > 0.3 && loc.diggableItems && loc.diggableItems.length > 0) {
                const itemKey = loc.diggableItems[Math.floor(Math.random() * loc.diggableItems.length)];
                const item = items[itemKey];
                
                // Remove from diggable items
                const index = loc.diggableItems.indexOf(itemKey);
                loc.diggableItems.splice(index, 1);
                
                // Add to location items
                loc.items.push(itemKey);
                
                addToOutput(`<div class="success">${npc.name.split(' - ')[0]} UNCOVERS A ${item.name}!</div>`);
                gameState.companionLoyalty += 10;
                gameState.score += 15;
            } else {
                addToOutput(`<div class="response">${npc.name.split(' - ')[0]} DIGS BUT FINDS NOTHING OF VALUE.</div>`);
                gameState.companionLoyalty += 1;
            }
            
            // Chance to encounter something bad
            if (Math.random() > 0.7) {
                addToOutput('<div class="warning">THE DIGGING DISTURBS SOMETHING IN THE EARTH...</div>');
                if (!loc.enemies.includes("restless_spirit")) {
                    loc.enemies.push("restless_spirit");
                }
            }
            
            updateLoyaltyDisplay();
        }

        // Dig grave (without companion)
        function digGrave(obj) {
            const loc = locations[gameState.location];
            
            if (!loc.canDig) {
                addToOutput('<div class="response">THERE\'S NOTHING TO DIG HERE.</div>');
                return;
            }
            
            if (!hasItem("shovel")) {
                addToOutput('<div class="response">YOU NEED A SHOVEL TO DIG.</div>');
                return;
            }
            
            addToOutput('<div class="response">YOU START DIGGING... IT\'S HARD WORK WITHOUT HELP.</div>');
            
            // Lower chance to find something without companion
            if (Math.random() > 0.5 && loc.diggableItems && loc.diggableItems.length > 0) {
                const itemKey = loc.diggableItems[Math.floor(Math.random() * loc.diggableItems.length)];
                const item = items[itemKey];
                
                // Remove from diggable items
                const index = loc.diggableItems.indexOf(itemKey);
                loc.diggableItems.splice(index, 1);
                
                // Add to location items
                loc.items.push(itemKey);
                
                addToOutput(`<div class="success">YOU UNCOVER A ${item.name}!</div>`);
                gameState.score += 10;
            } else {
                addToOutput('<div class="response">YOU DIG BUT FIND NOTHING OF VALUE.</div>');
            }
            
            // Chance to encounter something bad
            if (Math.random() > 0.6) {
                addToOutput('<div class="warning">THE DIGGING DISTURBS SOMETHING IN THE EARTH...</div>');
                if (!loc.enemies.includes("restless_spirit")) {
                    loc.enemies.push("restless_spirit");
                }
            }
        }

        // Solve riddle
        function solveRiddle(answer) {
            if (!answer) {
                addToOutput('<div class="response">SOLVE WHAT?</div>');
                return;
            }
            
            const loc = locations[gameState.location];
            const npcKey = findNPCInLocation("stone_guardian");
            
            if (!npcKey || npcKey !== "stone_guardian") {
                addToOutput('<div class="response">THERE\'S NO RIDDLE TO SOLVE HERE.</div>');
                return;
            }
            
            const npc = npcs[npcKey];
            
            if (npc.riddle.solved) {
                addToOutput('<div class="response">THE RIDDLE HAS ALREADY BEEN SOLVED.</div>');
                return;
            }
            
            if (answer.toLowerCase() === npc.riddle.answer.toLowerCase()) {
                addToOutput('<div class="success">CORRECT! THE STONE GUARDIAN STEPS ASIDE, REVEALING A HIDDEN PASSAGE!</div>');
                npc.riddle.solved = true;
                gameState.riddlesSolved++;
                gameState.score += 50;
                
                // Add new exit
                loc.exits.e = "hidden_chamber";
            } else {
                npc.riddle.attempts--;
                if (npc.riddle.attempts > 0) {
                    addToOutput(`<div class="warning">INCORRECT. YOU HAVE ${npc.riddle.attempts} ATTEMPTS REMAINING.</div>`);
                } else {
                    addToOutput('<div class="combat-text">THE STONE GUARDIAN ATTACKS! TOO MANY WRONG ANSWERS!</div>');
                    loc.enemies.push("stone_golem");
                    // Note: Would need to add stone_golem enemy definition
                }
            }
        }

        // Attack an enemy
        function attackEnemy(enemyName) {
            if (!enemyName) {
                addToOutput('<div class="response">ATTACK WHAT?</div>');
                return;
            }
            
            const loc = locations[gameState.location];
            const enemyKey = findEnemyInLocation(enemyName);
            
            if (!enemyKey) {
                addToOutput('<div class="response">I DON\'T SEE THAT ENEMY HERE.</div>');
                return;
            }
            
            const enemy = enemies[enemyKey];
            addToOutput(`<div class="combat-text">YOU ATTACK THE ${enemy.name}!</div>`);
            
            // Start combat
            gameState.inCombat = true;
            gameState.currentEnemy = enemyKey;
            
            // First attack
            playerAttack();
        }

        // Handle combat commands
        function handleCombatCommand(verb, obj) {
            if (verb === 'attack' || verb === 'a') {
                playerAttack();
            } else if (verb === 'flee' || verb === 'run') {
                fleeCombat();
            } else if (verb === 'use') {
                useItemInCombat(obj);
            } else {
                addToOutput('<div class="combat-text">IN COMBAT, YOU CAN ONLY ATTACK, FLEE, OR USE ITEMS.</div>');
            }
        }

        // Player attack in combat
        function playerAttack() {
            const enemy = enemies[gameState.currentEnemy];
            let damage = gameState.playerDamage;
            
            // Companion helps in combat
            if (gameState.companion && gameState.companionLoyalty > 30) {
                if (Math.random() > 0.3) {
                    const companionDamage = Math.floor(Math.random() * 5) + 3;
                    damage += companionDamage;
                    addToOutput(`<div class="combat-text">${npcs[gameState.companion].name.split(' - ')[0]} SWINGS HIS SHOVEL! +${companionDamage} DAMAGE</div>`);
                    gameState.companionLoyalty += 2;
                }
            }
            
            addToOutput(`<div class="combat-text">YOU HIT THE ${enemy.name} FOR ${damage} DAMAGE!</div>`);
            enemy.health -= damage;
            
            if (enemy.health <= 0) {
                enemyDefeated();
                return;
            }
            
            // Enemy attacks back
            enemyAttack();
        }

        // Enemy attack in combat
        function enemyAttack() {
            const enemy = enemies[gameState.currentEnemy];
            
            // Companion might take some damage
            if (gameState.companion && gameState.companionLoyalty > 50 && Math.random() > 0.5) {
                addToOutput(`<div class="combat-text">${npcs[gameState.companion].name.split(' - ')[0]} TAKES THE BLOW FOR YOU!</div>`);
                gameState.companionLoyalty += 5;
            } else {
                addToOutput(`<div class="combat-text">THE ${enemy.name} ATTACKS YOU FOR ${enemy.damage} DAMAGE!</div>`);
                gameState.health -= enemy.damage;
            }
            
            updateHealth();
            
            if (gameState.health <= 0) {
                playerDefeated();
                return;
            }
            
            addToOutput(`<div class="combat-text">YOUR HEALTH: ${gameState.health}/${gameState.maxHealth}. ENEMY HEALTH: ${enemy.health}</div>`);
            addToOutput('<div class="combat-text">WHAT WILL YOU DO? (ATTACK OR FLEE)</div>');
            
            updateLoyaltyDisplay();
        }

        // Enemy defeated
        function enemyDefeated() {
            const enemy = enemies[gameState.currentEnemy];
            
            addToOutput(`<div class="combat-text">YOU HAVE DEFEATED THE ${enemy.name}! +${enemy.points} POINTS!</div>`);
            gameState.score += enemy.points;
            
            // Remove enemy from location
            const loc = locations[gameState.location];
            const index = loc.enemies.indexOf(gameState.currentEnemy);
            if (index > -1) {
                loc.enemies.splice(index, 1);
            }
            
            // Drop loot
            if (enemy.drops.length > 0) {
                enemy.drops.forEach(drop => {
                    if (items[drop]) {
                        loc.items.push(drop);
                        addToOutput(`<div class="combat-text">THE ${enemy.name} DROPPED A ${items[drop].name}!</div>`);
                    }
                });
            }
            
            // Companion loyalty boost
            if (gameState.companion) {
                gameState.companionLoyalty += 10;
                addToOutput(`<div class="npc-text">${npcs[gameState.companion].name.split(' - ')[0]} SEEMS PLEASED WITH THE VICTORY.</div>`);
            }
            
            // Check if Dracula was defeated
            if (gameState.currentEnemy === 'dracula') {
                gameWon();
            }
            
            // End combat
            gameState.inCombat = false;
            gameState.currentEnemy = null;
            
            updateLoyaltyDisplay();
        }

        // Player defeated
        function playerDefeated() {
            addToOutput('<div class="combat-text">YOU HAVE BEEN DEFEATED BY THE FORCES OF DARKNESS!</div>');
            
            // Companion reaction
            if (gameState.companion) {
                addToOutput(`<div class="npc-text">${npcs[gameState.companion].name.split(' - ')[0]} FLEES IN TERROR!</div>`);
                gameState.companion = null;
                gameState.companionLoyalty = 0;
            }
            
            addToOutput('<div class="combat-text">GAME OVER</div>');
            addToOutput('<div class="response">PLAY AGAIN? (YES/NO)</div>');
            gameState.gameActive = false;
            gameState.inCombat = false;
        }

        // Flee from combat
        function fleeCombat() {
            addToOutput('<div class="combat-text">YOU FLEE FROM COMBAT!</div>');
            gameState.inCombat = false;
            gameState.currentEnemy = null;
            
            // Take damage while fleeing
            gameState.health -= 5;
            updateHealth();
            
            // Companion loyalty penalty
            if (gameState.companion) {
                gameState.companionLoyalty -= 10;
                addToOutput(`<div class="npc-text">${npcs[gameState.companion].name.split(' - ')[0]} LOOKS DISAPPOINTED IN YOU.</div>`);
            }
            
            if (gameState.health <= 0) {
                playerDefeated();
            }
            
            updateLoyaltyDisplay();
        }

        // Equip a weapon
        function equipWeapon(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">EQUIP WHAT?</div>');
                return;
            }
            
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU DON\'T HAVE THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            if (item.type !== "weapon") {
                addToOutput(`<div class="response">THE ${item.name} IS NOT A WEAPON.</div>`);
                return;
            }
            
            gameState.equippedWeapon = itemKey;
            gameState.playerDamage = item.damage;
            addToOutput(`<div class="response">YOU EQUIP THE ${item.name}. DAMAGE: ${item.damage}</div>`);
            
            updateUI();
        }

        // Buy an item from NPC
        function buyItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">BUY WHAT?</div>');
                return;
            }
            
            // Find NPC with shop items in current location
            const loc = locations[gameState.location];
            let shopNPC = null;
            
            for (const npcKey of loc.npcs) {
                const npc = npcs[npcKey];
                if (npc.shopItems.length > 0) {
                    shopNPC = npc;
                    shopNPC.key = npcKey;
                    break;
                }
            }
            
            if (!shopNPC) {
                addToOutput('<div class="response">THERE\'S NO ONE HERE TO BUY FROM.</div>');
                return;
            }
            
            // Find item in shop
            const itemKey = findItemInList(itemName, shopNPC.shopItems);
            
            if (!itemKey) {
                addToOutput('<div class="response">THAT PERSON DOESN\'T SELL THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            if (gameState.gold < item.value) {
                addToOutput(`<div class="response">YOU DON\'T HAVE ENOUGH GOLD. YOU NEED ${item.value} GOLD.</div>`);
                return;
            }
            
            // Check if player already has this item
            if (gameState.inventory.includes(itemKey)) {
                addToOutput(`<div class="response">YOU ALREADY HAVE A ${item.name}.</div>`);
                return;
            }
            
            // Buy item
            gameState.gold -= item.value;
            gameState.inventory.push(itemKey);
            addToOutput(`<div class="response">YOU BUY THE ${item.name} FOR ${item.value} GOLD.</div>`);
            
            updateUI();
        }

        // Sell an item to NPC
        function sellItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">SELL WHAT?</div>');
                return;
            }
            
            // Find NPC that buys items in current location
            const loc = locations[gameState.location];
            let buyNPC = null;
            
            for (const npcKey of loc.npcs) {
                const npc = npcs[npcKey];
                if (npc.buyItems.length > 0) {
                    buyNPC = npc;
                    buyNPC.key = npcKey;
                    break;
                }
            }
            
            if (!buyNPC) {
                addToOutput('<div class="response">THERE\'S NO ONE HERE INTERESTED IN BUYING.</div>');
                return;
            }
            
            // Check if player has item
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU DON\'T HAVE THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            // Check if NPC buys this type of item
            if (!buyNPC.buyItems.includes(itemKey)) {
                addToOutput(`<div class="response">${buyNPC.name} ISN\'T INTERESTED IN THAT.</div>`);
                return;
            }
            
            // Sell item
            const sellPrice = Math.floor(item.value * 0.7); // 70% of value
            const index = gameState.inventory.indexOf(itemKey);
            gameState.inventory.splice(index, 1);
            gameState.gold += sellPrice;
            
            // If selling equipped weapon, unequip it
            if (gameState.equippedWeapon === itemKey) {
                gameState.equippedWeapon = null;
                gameState.playerDamage = 5;
            }
            
            addToOutput(`<div class="response">YOU SELL THE ${item.name} TO ${buyNPC.name} FOR ${sellPrice} GOLD.</div>`);
            
            updateUI();
        }

        // List shop items
        function listShopItems() {
            const loc = locations[gameState.location];
            let shopNPC = null;
            
            for (const npcKey of loc.npcs) {
                const npc = npcs[npcKey];
                if (npc.shopItems.length > 0) {
                    shopNPC = npc;
                    shopNPC.key = npcKey;
                    break;
                }
            }
            
            if (!shopNPC) {
                addToOutput('<div class="response">THERE\'S NO SHOP HERE.</div>');
                return;
            }
            
            addToOutput(`<div class="npc-text">${shopNPC.name} HAS FOR SALE:</div>`);
            
            shopNPC.shopItems.forEach(itemKey => {
                const item = items[itemKey];
                addToOutput(`<div class="response">- ${item.name}: ${item.value} GOLD (${item.description})</div>`);
            });
            
            if (shopNPC.buyItems.length > 0) {
                addToOutput(`<div class="npc-text">${shopNPC.name} WILL BUY: ${shopNPC.buyItems.map(key => items[key].name).join(', ')}</div>`);
            }
        }

        // Use an item
        function useItem(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">USE WHAT?</div>');
                return;
            }
            
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU DON\'T HAVE THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            
            if (item.type === "consumable" && item.heal) {
                gameState.health = Math.min(gameState.maxHealth, gameState.health + item.heal);
                addToOutput(`<div class="response">YOU USE THE ${item.name} AND HEAL ${item.heal} HEALTH.</div>`);
                
                // Remove from inventory
                const index = gameState.inventory.indexOf(itemKey);
                gameState.inventory.splice(index, 1);
                
                updateHealth();
            } else if (item.type === "weapon") {
                equipWeapon(itemName);
            } else if (item.name === "shovel") {
                digGrave("");
            } else {
                addToOutput(`<div class="response">YOU CAN\'T USE THE ${item.name} THAT WAY.</div>`);
            }
        }

        // Use item in combat
        function useItemInCombat(itemName) {
            if (!itemName) {
                addToOutput('<div class="response">USE WHAT?</div>');
                return;
            }
            
            const itemKey = findItemInInventory(itemName);
            
            if (!itemKey) {
                addToOutput('<div class="response">YOU DON\'T HAVE THAT.</div>');
                return;
            }
            
            const item = items[itemKey];
            const enemy = enemies[gameState.currentEnemy];
            
            // Check if item is effective against enemy
            if (item.type === "holy" && enemy.weakTo.includes("holy")) {
                addToOutput(`<div class="combat-text">THE ${item.name} GLOWS WITH HOLY POWER! THE ${enemy.name} TAKES 15 EXTRA DAMAGE!</div>`);
                enemy.health -= 15;
                
                if (enemy.health <= 0) {
                    enemyDefeated();
                } else {
                    enemyAttack();
                }
            } else if (item.name.includes("garlic") && enemy.weakTo.includes("garlic")) {
                addToOutput(`<div class="combat-text">THE ${enemy.name} RECOILS FROM THE GARLIC! IT TAKES 10 EXTRA DAMAGE!</div>`);
                enemy.health -= 10;
                
                if (enemy.health <= 0) {
                    enemyDefeated();
                } else {
                    enemyAttack();
                }
            } else {
                addToOutput(`<div class="combat-text">THE ${item.name} HAS NO SPECIAL EFFECT ON THE ${enemy.name}.</div>`);
                enemyAttack();
            }
        }

        // Game won
        function gameWon() {
            addToOutput('<div class="welcome-text">CONGRATULATIONS!</div>');
            addToOutput('<div class="game-text">YOU HAVE DEFEATED COUNT DRACULA AND SAVED TRANSYLVANIA!</div>');
            gameState.score += 1000;
            
            // Bonus for companion
            if (gameState.companion) {
                addToOutput(`<div class="npc-text">${npcs[gameState.companion].name.split(' - ')[0]} NODS APPROVINGLY. "WE DONE GOOD."</div>`);
                gameState.score += 200;
            }
            
            // Bonus for riddles and puzzles
            if (gameState.riddlesSolved > 0) {
                addToOutput(`<div class="game-text">RIDDLES SOLVED: ${gameState.riddlesSolved} (+${gameState.riddlesSolved * 25} POINTS)</div>`);
                gameState.score += gameState.riddlesSolved * 25;
            }
            
            addToOutput(`<div class="game-text">FINAL SCORE: ${gameState.score}</div>`);
            addToOutput('<div class="response">PLAY AGAIN? (YES/NO)</div>');
            gameState.gameActive = false;
        }

        // Show score
        function showScore() {
            addToOutput(`<div class="response">SCORE: ${gameState.score} | HEALTH: ${gameState.health}/${gameState.maxHealth} | GOLD: ${gameState.gold} | MOVES: ${gameState.moves}</div>`);
            if (gameState.companion) {
                addToOutput(`<div class="response">COMPANION: ${npcs[gameState.companion].name.split(' - ')[0]} | LOYALTY: ${gameState.companionLoyalty}</div>`);
            }
            addToOutput(`<div class="response">RIDDLES SOLVED: ${gameState.riddlesSolved}</div>`);
        }

        // Show help
        function showHelp() {
            addToOutput('<div class="response">=== CASTLE OF THE DAMNED V2.0 - HELP ===</div>');
            addToOutput('<div class="response">AVAILABLE COMMANDS:</div>');
            addToOutput('<div class="response">GO/LOOK/TAKE/DROP/EXAMINE/INVENTORY</div>');
            addToOutput('<div class="response">READ/TALK/ASK/COMMAND/GREET/INSULT</div>');
            addToOutput('<div class="response">ATTACK/EQUIP/BUY/SELL/LIST/USE/DIG/SOLVE</div>');
            addToOutput('<div class="response">DIRECTIONS: N, S, E, W, NE, NW, SE, SW, U, D</div>');
            addToOutput('<div class="response">SCORE/HELP/QUIT</div>');
            addToOutput('<div class="response">IN COMBAT: ATTACK, FLEE, USE [ITEM]</div>');
            addToOutput('<div class="response">COMPANION COMMANDS: ASK [NPC] TO JOIN, COMMAND DIG, GREET, INSULT</div>');
            addToOutput('<div class="response">EXAMPLE: GO NORTH, TAKE KEY, ASK GREGOR TO JOIN, COMMAND DIG</div>');
            addToOutput('<div class="response">PRESS ESC TO QUIT, F1 FOR THIS HELP SCREEN.</div>');
        }

        // Quit game
        function quitGame() {
            addToOutput(`<div class="response">YOUR FINAL SCORE: ${gameState.score} IN ${gameState.moves} MOVES.</div>`);
            if (gameState.companion) {
                addToOutput(`<div class="response">COMPANION LOYALTY: ${gameState.companionLoyalty}</div>`);
            }
            addToOutput('<div class="response">THANKS FOR PLAYING CASTLE OF THE DAMNED!</div>');
            addToOutput('<div class="response">PLAY AGAIN? (YES/NO)</div>');
            gameState.gameActive = false;
        }

        // Update health display
        function updateHealth() {
            const healthPercent = (gameState.health / gameState.maxHealth) * 100;
            healthFillElement.style.width = `${healthPercent}%`;
            healthElement.textContent = gameState.health;
        }

        // Update loyalty display
        function updateLoyaltyDisplay() {
            if (gameState.companion) {
                loyaltyElement.textContent = gameState.companionLoyalty;
            } else {
                loyaltyElement.textContent = '--';
            }
        }

        // Reset game
        function resetGame() {
            // Reset game state
            gameState.score = 0;
            gameState.moves = 0;
            gameState.health = 100;
            gameState.maxHealth = 100;
            gameState.gold = 10;
            gameState.inventory = [];
            gameState.location = 'outside_castle';
            gameState.gameActive = true;
            gameState.commandHistory = [];
            gameState.historyIndex = -1;
            gameState.equippedWeapon = null;
            gameState.playerDamage = 5;
            gameState.inCombat = false;
            gameState.currentEnemy = null;
            gameState.visitedLocations = ['outside_castle'];
            gameState.awaitingInstructions = false;
            gameState.companion = null;
            gameState.companionLoyalty = 0;
            gameState.riddlesSolved = 0;
            gameState.puzzlesSolved = 0;
            gameState.timeOfDay = "day";
            gameState.companionMemory = {
                lastHelped: null,
                lastInsulted: null,
                questsCompleted: 0,
                timesAbandoned: 0
            };
            
            // Reset locations
            for (const key in locations) {
                locations[key].seen = false;
            }
            
            // Reset items to starting locations
            locations['outside_castle'].items = ['iron_key'];
            locations['courtyard'].items = ['rusty_dagger'];
            locations['courtyard'].enemies = ['giant_bat'];
            locations['graveyard'].items = [];
            locations['graveyard'].npcs = ['grave_digger'];
            locations['graveyard'].enemies = [];
            locations['graveyard'].diggableItems = ['old_bones', 'silver_ring', 'rusted_medallion'];
            locations['crypt_entrance'].items = [];
            locations['crypt_entrance'].enemies = [];
            locations['main_hall'].items = ['candle'];
            locations['library'].items = ['old_journal', 'silver_cross'];
            locations['library'].npcs = ['librarian_ghost'];
            locations['study'].items = ['stake', 'garlic'];
            locations['secret_passage'].enemies = ['rat_swarm'];
            locations['crypt'].items = ['holy_water'];
            locations['crypt'].enemies = ['vampire_spawn'];
            locations['family_crypt'].items = [];
            locations['family_crypt'].enemies = ['restless_spirit'];
            locations['family_crypt'].diggableItems = ['ancient_scroll', 'cursed_coin', 'bone_key'];
            locations['hidden_tomb'].items = [];
            locations['hidden_tomb'].npcs = ['stone_guardian'];
            locations['hidden_tomb'].enemies = [];
            locations['draculas_lair'].enemies = ['dracula'];
            locations['dining_hall'].items = ['silver_fork'];
            locations['kitchen'].items = ['butcher_knife'];
            locations['kitchen'].npcs = ['mad_chef'];
            locations['upper_gallery'].items = ['gold_coins'];
            locations['bedchamber'].items = ['vampire_diary'];
            locations['chapel'].items = ['bible'];
            locations['chapel'].npcs = ['priest_ghost'];
            locations['stables'].items = ['horse_shoe'];
            locations['stables'].enemies = ['wild_wolf'];
            locations['village_road'].npcs = ['traveler'];
            locations['village'].npcs = ['merchant', 'villager', 'seemingly_helpful_villager'];
            locations['village_inn'].items = ['healing_potion'];
            locations['village_inn'].npcs = ['innkeeper'];
            locations['forest_path'].items = ['wooden_stake'];
            locations['forest_path'].enemies = ['werewolf'];
            locations['gypsy_camp'].npcs = ['gypsy_elder', 'gypsy_fortune_teller', 'alchemist'];
            
            // Reset enemies health
            for (const key in enemies) {
                if (key === 'giant_bat') enemies[key].health = 30;
                if (key === 'rat_swarm') enemies[key].health = 20;
                if (key === 'vampire_spawn') enemies[key].health = 50;
                if (key === 'dracula') enemies[key].health = 100;
                if (key === 'wild_wolf') enemies[key].health = 25;
                if (key === 'werewolf') enemies[key].health = 60;
                if (key === 'restless_spirit') enemies[key].health = 40;
            }
            
            // Reset NPCs
            for (const key in npcs) {
                if (npcs[key].memory) {
                    npcs[key].memory.askedToJoin = false;
                    npcs[key].memory.helped = false;
                    npcs[key].memory.insulted = false;
                    npcs[key].memory.questCompleted = false;
                }
                if (npcs[key].riddle) {
                    npcs[key].riddle.solved = false;
                    npcs[key].riddle.attempts = 3;
                }
                if (key === 'seemingly_helpful_villager') {
                    npcs[key].dialogue_count = 0;
                    npcs[key].revealed = false;
                }
            }
            
            gameOutput.innerHTML = '';
            addToOutput('<div class="welcome-text">NEW GAME STARTED!</div>');
            addToOutput('<div class="game-text">TYPE LOOK TO SEE YOUR SURROUNDINGS, OR HELP FOR COMMANDS.</div>');
            
            updateUI();
            updateHealth();
            updateLoyaltyDisplay();
            look();
        }

        // Helper functions
        function findItemInLocation(itemName) {
            const loc = locations[gameState.location];
            for (const itemKey of loc.items) {
                const item = items[itemKey];
                if (item.name.toLowerCase().includes(itemName.toLowerCase()) || 
                    itemKey.toLowerCase().includes(itemName.toLowerCase())) {
                    return itemKey;
                }
            }
            return null;
        }

        function findItemInInventory(itemName) {
            for (const itemKey of gameState.inventory) {
                const item = items[itemKey];
                if (item.name.toLowerCase().includes(itemName.toLowerCase()) || 
                    itemKey.toLowerCase().includes(itemName.toLowerCase())) {
                    return itemKey;
                }
            }
            return null;
        }

        function findItemInList(itemName, itemList) {
            for (const itemKey of itemList) {
                const item = items[itemKey];
                if (item.name.toLowerCase().includes(itemName.toLowerCase()) || 
                    itemKey.toLowerCase().includes(itemName.toLowerCase())) {
                    return itemKey;
                }
            }
            return null;
        }

        function hasItem(itemName) {
            return findItemInInventory(itemName) !== null;
        }

        function findNPC(npcName) {
            for (const npcKey in npcs) {
                const npc = npcs[npcKey];
                if (npc.name.toLowerCase().includes(npcName.toLowerCase()) || 
                    npcKey.toLowerCase().includes(npcName.toLowerCase())) {
                    return npcKey;
                }
            }
            return null;
        }

        function findNPCInLocation(npcName) {
            const loc = locations[gameState.location];
            for (const npcKey of loc.npcs) {
                const npc = npcs[npcKey];
                if (npc.name.toLowerCase().includes(npcName.toLowerCase()) || 
                    npcKey.toLowerCase().includes(npcName.toLowerCase())) {
                    return npcKey;
                }
            }
            return null;
        }

        function findEnemy(enemyName) {
            for (const enemyKey in enemies) {
                const enemy = enemies[enemyKey];
                if (enemy.name.toLowerCase().includes(enemyName.toLowerCase()) || 
                    enemyKey.toLowerCase().includes(enemyName.toLowerCase())) {
                    return enemyKey;
                }
            }
            return null;
        }

        function findEnemyInLocation(enemyName) {
            const loc = locations[gameState.location];
            for (const enemyKey of loc.enemies) {
                const enemy = enemies[enemyKey];
                if (enemy.name.toLowerCase().includes(enemyName.toLowerCase()) || 
                    enemyKey.toLowerCase().includes(enemyName.toLowerCase())) {
                    return enemyKey;
                }
            }
            return null;
        }

        function addToOutput(html) {
            gameOutput.innerHTML += html;
            // Scroll to bottom after adding content
            setTimeout(() => {
                gameOutputContainer.scrollTop = gameOutputContainer.scrollHeight;
            }, 10);
        }

        function updateUI() {
            scoreElement.textContent = gameState.score;
            movesElement.textContent = gameState.moves;
            locationElement.textContent = locations[gameState.location].name;
            goldElement.textContent = gameState.gold;
            
            // Update inventory display
            if (gameState.inventory.length === 0) {
                inventoryElement.textContent = "EMPTY";
            } else {
                inventoryElement.textContent = gameState.inventory.map(key => {
                    const item = items[key];
                    return item.name;
                }).join(", ");
            }
            
            // Update equipped weapon display
            if (gameState.equippedWeapon) {
                equippedElement.textContent = items[gameState.equippedWeapon].name + ` (DMG: ${gameState.playerDamage})`;
            } else {
                equippedElement.textContent = "NONE (DMG: 5)";
            }
            
            // Update companion display
            if (gameState.companion) {
                companionElement.textContent = npcs[gameState.companion].name.split(' - ')[0];
            } else {
                companionElement.textContent = "NONE";
            }
            
            updateLoyaltyDisplay();
            updateHealth();
        }

        // Initialize the game when page loads
        window.onload = initGame;
    </script>
</body>
</html>
