<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DRACULA'S CURSE - ENHANCED</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; touch-action: manipulation; font-family: 'Arial', monospace; }
body { background: #000; color: red; height: 100vh; overflow: hidden; display: flex; flex-direction: column; padding: 10px; }

#game-container { flex: 1; display: flex; flex-direction: column; gap: 10px; width: 100%; }

/* Stats */
.stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
.stat-group { display: flex; flex-direction: column; min-width: 100px; }
.bar { height: 5px; background: #300; width: 100%; position: relative; overflow: hidden; }
.bar-fill { height: 100%; transition: width 0.3s; }
.health { background: #f00; }
.sanity { background: #0f0; }

/* Content */
#content-area { flex: 1; display: flex; flex-direction: column; max-width: 600px; width: 100%; margin: 0 auto; gap: 5px; }
#scene-description { flex: 1; overflow-y: auto; border: 1px solid red; padding: 8px; min-height: 150px; }
#combat-log { min-height: 80px; border: 1px solid red; padding: 8px; display: none; }

/* Buttons */
.button-container { display: grid; gap: 5px; }
#footer-buttons { grid-template-columns: repeat(4, 1fr); margin-bottom: 70px; }
button { background: #000; color: red; border: 1px solid red; padding: 8px; cursor: pointer; transition: all 0.2s; }
button:active { background: red; color: #000; }
button:disabled { opacity: 0.5; }
button:hover:not(:disabled) { background: #300; }

/* Mobile Controls */
#mobile-controls { display: block; position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.9); padding: 10px; border-top: 1px solid red; z-index: 50; }
.mobile-control-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
.mobile-control-btn { flex: 1; margin: 0 2px; padding: 10px; font-size: 14px; }

/* Modals */
.modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); padding: 10px; display: none; z-index: 100; overflow-y: auto; }
.modal-content { border: 1px solid red; padding: 8px; height: 100%; display: flex; flex-direction: column; }
.modal-header { display: flex; justify-content: space-between; margin-bottom: 8px; border-bottom: 1px solid red; padding-bottom: 5px; }
.modal-body { flex: 1; overflow-y: auto; }
.close-modal { background: none; border: none; color: red; cursor: pointer; }

/* Animations */
@keyframes shake { 0%,100% { transform: translateX(0); } 20%,60% { transform: translateX(-5px); } 40%,80% { transform: translateX(5px); } }
.shake { animation: shake 0.4s; }
@keyframes flash-red { 0%,100% { background: #000; } 50% { background: #f00; } }
.flash-red { animation: flash-red 0.3s; }
.critical { animation: critical 0.5s; }
@keyframes critical { 0%,100% { color: red; } 50% { color: yellow; } }
@keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
.poisoned { color: #0f0; animation: pulse 1s infinite; }
.bleeding { color: #f00; animation: pulse 0.5s infinite; }
.cursed { color: #800080; animation: pulse 2s infinite; }
.protected { color: #00ffff; animation: pulse 1.5s infinite; }
@keyframes float-up {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(-50px); opacity: 0; }
}
@keyframes victory-glow {
  0% { box-shadow: 0 0 20px #ff0; }
  100% { box-shadow: none; }
}
.victory { animation: victory-glow 2s ease-out; }

/* Merchant */
.merchant-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px dashed red; }

/* Damage Numbers */
.damage-number {
  position: absolute;
  font-weight: bold;
  animation: float-up 1s forwards;
}

/* Enemy Weakness Display */
.weakness-display {
  margin: 5px 0;
  padding: 3px;
  border: 1px dashed #ff0;
  background: #330;
}
.weakness-item {
  display: inline-block;
  margin: 2px;
  padding: 2px 5px;
  background: #300;
  border: 1px solid #f00;
}

/* Mobile */
@media (max-width: 768px) {
  #scene-description { min-height: 30vh; }
  button { padding: 6px 2px; font-size: 12px; }
  .stat-row { flex-direction: column; gap: 5px; }
  .mobile-control-btn { padding: 8px 4px; font-size: 12px; }
}

/* Character Selection */
.character-select {
  border: 1px solid red;
  padding: 10px;
  margin: 10px 0;
  cursor: pointer;
  transition: all 0.3s;
}
.character-select:hover {
  background: #300;
}
.character-select h2 {
  color: #f00;
  margin-bottom: 5px;
}

/* Save slots */
.save-slot {
  border: 1px solid red;
  padding: 10px;
  margin: 5px 0;
  cursor: pointer;
}
.save-slot:hover {
  background: #300;
}
.save-slot.active {
  background: #300;
  border-color: #f00;
}

/* Visual improvements */
.location-indicator {
  text-align: center;
  font-weight: bold;
  padding: 5px;
  background: #200;
  border: 1px solid red;
  margin-bottom: 5px;
}

.health-low { 
  border: 2px solid #ff4444; 
  animation: pulse 1s infinite;
}
.sanity-low {
  border: 2px solid #ff4444;
  filter: hue-rotate(300deg);
}

/* ========== ENHANCED VISUAL FEEDBACK STYLES ========== */
.floating-text {
  position: absolute;
  font-weight: bold;
  pointer-events: none;
  z-index: 1000;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  font-size: 14px;
}

.xp-gain { color: #00ffff; animation: float-xp 2s ease-out; }
.gold-gain { color: gold; animation: float-gold 2s ease-out; }
.heal-gain { color: #00ff00; animation: float-heal 2s ease-out; }
.sanity-gain { color: #87ceeb; animation: float-sanity 2s ease-out; }
.damage-taken { color: #ff4444; animation: float-damage 2s ease-out; }
.item-found { color: #ffa500; animation: float-item 2s ease-out; }

@keyframes float-xp {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
}

@keyframes float-gold {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-60px) scale(1.3); opacity: 0; }
}

@keyframes float-heal {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  50% { transform: translateY(-30px) scale(1.1); opacity: 1; }
  100% { transform: translateY(-60px) scale(1.2); opacity: 0; }
}

@keyframes float-sanity {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-40px) scale(1.1); opacity: 0; }
}

@keyframes float-damage {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  20% { transform: translateX(-5px) translateY(-10px) scale(1.1); }
  40% { transform: translateX(5px) translateY(-20px) scale(1.2); }
  100% { transform: translateY(-50px) scale(1.1); opacity: 0; }
}

@keyframes float-item {
  0% { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(-45px) scale(1.2) rotate(5deg); opacity: 0; }
}

/* Skill Tree Styles */
.skill-tree-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 15px 0;
}

.skill-category {
  border: 1px solid #444;
  padding: 10px;
  border-radius: 4px;
}

.skill-category h3 {
  text-align: center;
  margin-bottom: 10px;
  color: #f00;
  border-bottom: 1px dashed red;
  padding-bottom: 5px;
}

.skill-node {
  border: 1px solid #444;
  padding: 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
  background: #111;
  position: relative;
  margin-bottom: 8px;
}

.skill-node.available {
  border-color: #666;
  background: #222;
}

.skill-node.available:hover {
  border-color: gold;
  background: #333;
  transform: translateY(-2px);
}

.skill-node.unlocked {
  border-color: #00ff00;
  background: #1a2a1a;
  box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
}

.skill-node.locked {
  border-color: #444;
  background: #1a1a1a;
  opacity: 0.6;
  cursor: not-allowed;
}

.skill-node.requires {
  border-left: 3px solid gold;
}

.skill-cost {
  position: absolute;
  top: 5px;
  right: 5px;
  color: gold;
  font-size: 0.8em;
  background: rgba(0,0,0,0.7);
  padding: 2px 5px;
  border-radius: 3px;
}

.skill-description {
  font-size: 0.8em;
  color: #ccc;
  margin-top: 5px;
}

/* Interactive Map Styles */
#interactive-map {
  width: 100%;
  height: 400px;
  background: #0a0a0a;
  position: relative;
  border: 1px solid red;
  overflow: hidden;
}

.map-location {
  position: absolute;
  width: 80px;
  height: 60px;
  border: 2px solid #333;
  background: #1a1a1a;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.3s;
  padding: 5px;
}

.map-location.visited {
  border-color: #666;
  background: #2a2a2a;
}

.map-location.current {
  border-color: red;
  background: #3a1a1a;
  box-shadow: 0 0 15px red;
  z-index: 10;
  transform: scale(1.1);
}

.map-location.hidden {
  border-color: #444;
  background: #1a1a1a;
  opacity: 0.4;
}

.map-location.discovered {
  border-color: #ffa500;
  background: #2a2a1a;
}

.map-location.accessible {
  border-color: #00ff00;
  background: #1a2a1a;
  cursor: pointer;
}

.map-location.accessible:hover {
  border-color: #ffff00;
  background: #2a3a1a;
  transform: scale(1.15);
  box-shadow: 0 0 10px #ffff00;
}

.map-connection {
  position: absolute;
  background: #444;
  transform-origin: 0 0;
  z-index: -1;
  height: 2px;
}

.map-tooltip {
  position: absolute;
  background: rgba(0,0,0,0.95);
  border: 1px solid red;
  padding: 8px;
  z-index: 100;
  pointer-events: none;
  font-size: 12px;
  max-width: 200px;
  box-shadow: 0 0 10px rgba(255,0,0,0.5);
}

.map-legend {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  margin-top: 10px;
  justify-content: center;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 12px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border: 1px solid #fff;
}

/* Enhanced Button Feedback */
.button-pulse {
  animation: buttonPulse 0.3s ease-out;
}

@keyframes buttonPulse {
  0% { transform: scale(1); }
  50% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

/* Achievement Popups */
.achievement-popup {
  position: fixed;
  top: 20px;
  right: 20px;
  background: linear-gradient(45deg, #1a1a1a, #2a1a1a);
  border: 2px solid gold;
  padding: 15px;
  border-radius: 8px;
  z-index: 1000;
  animation: slideInRight 0.5s ease-out, slideOutRight 0.5s ease-out 2.5s forwards;
  max-width: 300px;
}

@keyframes slideInRight {
  from { transform: translateX(100%); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOutRight {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(100%); opacity: 0; }
}

.achievement-icon {
  font-size: 24px;
  margin-right: 10px;
  color: gold;
}

/* Sound Controls */
.sound-controls {
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1000;
  background: rgba(0,0,0,0.8);
  padding: 5px;
  border-radius: 4px;
  border: 1px solid red;
}

.sound-toggle {
  background: #000;
  border: 1px solid red;
  color: red;
  padding: 5px 10px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 12px;
}

.sound-toggle:hover {
  background: #300;
}

/* Enhanced Combat Animations */
.combat-float {
  animation: combatFloat 0.6s ease-out;
}

@keyframes combatFloat {
  0% { transform: translateY(0) scale(1); }
  50% { transform: translateY(-20px) scale(1.1); }
  100% { transform: translateY(-40px) scale(1); opacity: 0; }
}

/* Skill Points Display */
.skill-points-display {
  background: linear-gradient(45deg, #1a1a2a, #2a1a2a);
  border: 1px solid #00ffff;
  padding: 5px 10px;
  border-radius: 4px;
  margin-left: 10px;
  font-weight: bold;
  color: #00ffff;
}

/* Progress Indicators */
.level-badge {
  background: linear-gradient(45deg, #8B4513, #CD7F32);
  border-radius: 50%;
  width: 25px;
  height: 25px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  border: 2px solid gold;
  font-size: 12px;
  margin-left: 5px;
}

/* Back Button Styles */
.back-button {
  background: #000;
  color: red;
  border: 1px solid red;
  padding: 8px 15px;
  cursor: pointer;
  transition: all 0.2s;
  font-weight: bold;
  margin-top: 10px;
  width: 100%;
}

.back-button:hover {
  background: #300;
}

.back-button:active {
  background: red;
  color: #000;
}
</style>
</head>
<body>
<!-- Sound Controls -->
<div class="sound-controls">
  <button id="sound-toggle" class="sound-toggle">üîä SOUND: ON</button>
</div>

<div id="game-container">
  <!-- Character Selection -->
  <div id="character-selection">
    <h1 style="text-align: center">DRACULA'S CURSE - ENHANCED</h1>
    <p>The year is 1897. The vampire Count Dracula has taken residence in his decaying castle above the village of Bistritz.</p>
    <p style="text-align: center">CHOOSE YOUR HUNTER:</p>
    
    <div class="character-select" id="select-jonathan">
      <h2>JONATHAN HARKER</h2>
      <p><strong>Class:</strong> Diplomat | <strong>HP:</strong> 90 | <strong>SAN:</strong> 110</p>
      <p><strong>Skills:</strong> Silver Strike (2x damage with silver weapons), Parry (25% chance to block attacks)</p>
      <p><strong>Unlocks at Lvl 5:</strong> Vampire Slayer (+25% damage to vampires)</p>
      <p><strong>Unlocks at Lvl 10:</strong> Final Blow (Execute enemies below 20% HP)</p>
    </div>
    
    <div class="character-select" id="select-vanhelsing">
      <h2>VAN HELSING</h2>
      <p><strong>Class:</strong> Professor | <strong>HP:</strong> 100 | <strong>SAN:</strong> 90</p>
      <p><strong>Skills:</strong> Holy Water (double effectiveness), Vampire Knowledge (see enemy weaknesses)</p>
      <p><strong>Unlocks at Lvl 5:</strong> Alchemical Shield (Reduce damage by 30% for 2 turns)</p>
      <p><strong>Unlocks at Lvl 10:</strong> Sun Bomb (Massive damage to all undead)</p>
    </div>
    
    <div class="character-select" id="select-mina">
      <h2>MINA MURRAY</h2>
      <p><strong>Class:</strong> Occultist | <strong>HP:</strong> 80 | <strong>SAN:</strong> 120</p>
      <p><strong>Skills:</strong> Hypnosis (chance to skip enemy turn), Sixth Sense (better item finding)</p>
      <p><strong>Unlocks at Lvl 5:</strong> Clairvoyance (see hidden paths)</p>
      <p><strong>Unlocks at Lvl 10:</strong> Spirit Ward (Prevent sanity loss for 3 turns)</p>
    </div>

    <div class="character-select" id="select-quincey">
      <h2>QUINCEY MORRIS</h2>
      <p><strong>Class:</strong> Gunslinger | <strong>HP:</strong> 85 | <strong>SAN:</strong> 95</p>
      <p><strong>Skills:</strong> Quick Draw (attack first in combat), Marksmanship (+25% crit chance)</p>
      <p><strong>Unlocks at Lvl 5:</strong> Fan Fire (Attack 3 times with reduced damage)</p>
      <p><strong>Unlocks at Lvl 10:</strong> Silver Bullet (Massive single attack that ignores defenses)</p>
    </div>
    
    <div style="margin-top: 10px">
      <label>DIFFICULTY:</label>
      <select id="difficulty" style="background: #000; color: red; border: 1px solid red; padding: 5px;">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
        <option value="nightmare">Nightmare</option>
      </select>
    </div>
    
    <div style="display: flex; gap: 5px; margin-top: 10px;">
      <button id="load-button" style="display: none;">LOAD GAME</button>
      <button id="save-button" style="display: none;">SAVE GAME</button>
      <button id="new-game-plus-button" style="display: none;">NEW GAME+</button>
      <button id="settings-button">SETTINGS</button>
    </div>
  </div>

  <!-- Main Game -->
  <div id="main-game" style="display: none; height: 100%;">
    <div id="content-area">
      <!-- Stats -->
      <div class="stat-row">
        <div class="stat-group">
          <div>HP: <span id="current-hp">100</span>/<span id="max-hp">100</span></div>
          <div class="bar"><div id="player-health-fill" class="bar-fill health" style="width: 100%;"></div></div>
        </div>
        <div class="stat-group">
          <div>SAN: <span id="current-sanity">100</span>/<span id="max-sanity">100</span></div>
          <div class="bar"><div id="player-sanity-fill" class="bar-fill sanity" style="width: 100%;"></div></div>
        </div>
        <div class="stat-group">
          <div>LVL: <span id="player-level">1</span><span id="level-badge" class="level-badge">1</span></div>
          <div>SKILL: <span id="skill-points">0</span></div>
        </div>
      </div>
      
      <div class="stat-row">
        <div class="stat-group"><div>GOLD: <span id="player-gold">50</span></div></div>
        <div class="stat-group"><div>DAY: <span id="game-day">1</span></div></div>
        <div class="stat-group"><div>LOC: <span id="dungeon-level">TAVERN</span></div></div>
      </div>

      <!-- Location -->
      <div class="location-indicator">
        <div id="location-name">TAVERN</div>
        <div class="bar"><div id="level-progress" class="bar-fill health" style="width: 0%;"></div></div>
      </div>

      <!-- Scene -->
      <div id="scene-description">
        <p>You stand in the dimly lit tavern at the foot of the Carpathian Mountains. The villagers whisper of horrors in the castle above.</p>
        <p>The barkeep eyes you warily. "You're not going up there, are you?" A merchant sits in the corner.</p>
      </div>

      <div id="combat-log"></div>

      <!-- Weapon -->
      <div style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px dashed red;">
        <span>WEAPON:</span>
        <span id="equipped-weapon-name">FISTS</span> (<span id="equipped-weapon-dmg">2</span> DMG)
      </div>

      <!-- Status Effects -->
      <div id="status-effects" style="min-height: 20px;"></div>

      <!-- Footer -->
      <div id="footer-buttons" class="button-container" style="display: none;">
        <!-- This is now hidden as we're using mobile controls for all devices -->
      </div>
    </div>
  </div>

  <!-- Mobile Controls (Now used for all devices) -->
  <div id="mobile-controls">
    <div class="mobile-control-row">
      <button class="mobile-control-btn" id="mobile-explore">EXPLORE</button>
      <button class="mobile-control-btn" id="mobile-action">TALK</button>
      <button class="mobile-control-btn" id="mobile-merchant">MERCHANT</button>
      <button class="mobile-control-btn" id="mobile-rest">REST</button>
    </div>
    <div class="mobile-control-row">
      <button class="mobile-control-btn" id="mobile-inventory">INV</button>
      <button class="mobile-control-btn" id="mobile-quests">QUESTS</button>
      <button class="mobile-control-btn" id="mobile-character">STATS</button>
      <button class="mobile-control-btn" id="mobile-skills">SKILLS</button>
      <button class="mobile-control-btn" id="mobile-map">MAP</button>
    </div>
  </div>
</div>

<!-- Modals -->
<div id="inventory-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>INVENTORY</h2>
      <button id="close-inventory" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <h3>WEAPONS</h3>
      <div id="weapons-list"></div>
      <h3 style="margin-top: 10px;">ITEMS</h3>
      <div id="items-list"></div>
      <button class="back-button" id="back-from-inventory">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Merchant Modal -->
<div id="merchant-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>MERCHANT</h2>
      <button id="close-merchant" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <div style="margin-bottom: 10px;">GOLD: <span id="merchant-gold-amount">0</span></div>
      
      <h3>BUY ITEMS</h3>
      <div id="merchant-buy-list"></div>
      
      <h3 style="margin-top: 10px;">SELL ITEMS</h3>
      <div id="merchant-sell-list"></div>
      <button class="back-button" id="back-from-merchant">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Character Stats Modal -->
<div id="character-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="character-name">CHARACTER</h2>
      <button id="close-character" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <div class="stat-row">
        <span>CLASS:</span>
        <span id="character-class">CLASS</span>
      </div>
      <div class="stat-row">
        <span>LEVEL:</span>
        <span id="character-level">1</span>
      </div>
      
      <h3 style="margin-top: 10px;">ATTRIBUTES</h3>
      <div class="stat-row">
        <span>STRENGTH:</span>
        <span id="character-strength">5</span>
      </div>
      <div class="stat-row">
        <span>AGILITY:</span>
        <span id="character-agility">5</span>
      </div>
      <div class="stat-row">
        <span>INTELLIGENCE:</span>
        <span id="character-intelligence">5</span>
      </div>
      
      <h3 style="margin-top: 10px;">SKILLS</h3>
      <div id="character-skills"></div>

      <h3 style="margin-top: 10px;">STATUS EFFECTS</h3>
      <div id="character-status-effects"></div>
      <button class="back-button" id="back-from-character">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Skills Modal -->
<div id="skills-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>SKILL TREE</h2>
      <button id="close-skills" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <div style="display: flex; justify-content: space-between; margin-bottom: 15px; align-items: center;">
        <div>Skill Points: <span id="skill-points-display" class="skill-points-display">0</span></div>
        <div>Level: <span id="skills-level">1</span></div>
      </div>
      
      <div class="skill-tree-container" id="skill-tree-container">
        <!-- Skills will be populated by JavaScript -->
      </div>
      <button class="back-button" id="back-from-skills">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Interactive Map Modal -->
<div id="interactive-map-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>CASTLE MAP</h2>
      <button id="close-map" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <div id="interactive-map">
        <!-- Map will be generated by JavaScript -->
      </div>
      <div class="map-legend">
        <div class="legend-item">
          <div class="legend-color" style="background: red;"></div>
          <span>Current Location</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #00ff00;"></div>
          <span>Accessible</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #666;"></div>
          <span>Visited</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ffa500;"></div>
          <span>Discovered</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #444;"></div>
          <span>Undiscovered</span>
        </div>
      </div>
      <button class="back-button" id="back-from-map">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Quests Modal -->
<div id="quests-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>QUESTS</h2>
      <button id="close-quests" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <h3>ACTIVE QUESTS</h3>
      <div id="active-quests"></div>
      
      <h3 style="margin-top: 10px;">COMPLETED QUESTS</h3>
      <div id="completed-quests"></div>

      <h3 style="margin-top: 10px;">SIDE QUESTS</h3>
      <div id="side-quests"></div>
      <button class="back-button" id="back-from-quests">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Save/Load Modal -->
<div id="save-load-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>SAVE & LOAD GAME</h2>
      <button id="close-save-load" class="close-modal">X</button>
    </div>
    <div class="modal-body">
      <h3>SAVE GAME</h3>
      <div style="margin-bottom: 10px;">
        <input type="text" id="save-name" placeholder="Save name" style="background: #000; color: red; border: 1px solid red; padding: 5px; width: 100%;">
        <button id="save-game-btn" style="width: 100%; margin-top: 5px;">SAVE CURRENT GAME</button>
      </div>
      
      <h3 style="margin-top: 10px;">LOAD GAME</h3>
      <div id="save-slots"></div>
      <button class="back-button" id="back-from-save-load">BACK TO GAME</button>
    </div>
  </div>
</div>

<!-- Combat Modal -->
<div id="combat-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="combat-title">COMBAT</h2>
    </div>
    <div class="modal-body">
      <div id="enemy-display" style="border: 1px solid red; padding: 8px; margin-bottom: 5px; position: relative;">
        <h3 id="enemy-name">ENEMY</h3>
        <div>HP: <span id="enemy-hp">30</span>/<span id="enemy-max-hp">30</span></div>
        <div class="bar"><div id="enemy-hp-bar" class="bar-fill health" style="width: 100%;"></div></div>
        <!-- Enemy Weakness Display -->
        <div id="enemy-weakness-display" style="display: none;" class="weakness-display">
          <strong>Weaknesses:</strong> <span id="enemy-weakness-list"></span>
        </div>
        <div id="enemy-status-effects"></div>
      </div>

      <div id="player-display" style="border: 1px solid red; padding: 8px; margin-bottom: 5px;">
        <h3 id="player-name">PLAYER</h3>
        <div>HP: <span id="player-hp-combat">100</span>/<span id="player-max-hp-combat">100</span></div>
        <div class="bar"><div id="player-hp-bar" class="bar-fill health" style="width: 100%;"></div></div>
        <div>SAN: <span id="player-sanity-combat">100</span>/<span id="player-max-sanity-combat">100</span></div>
        <div class="bar"><div id="player-sanity-bar" class="bar-fill sanity" style="width: 100%;"></div></div>
        <div id="player-combat-status-effects"></div>
      </div>

      <div id="combat-log-modal" style="min-height: 80px; border: 1px solid red; padding: 8px;"></div>

      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px;">
        <button id="attack-button">ATTACK</button>
        <button id="special-button">SPECIAL</button>
        <button id="use-item-button">ITEM</button>
        <button id="flee-button">FLEE</button>
      </div>
    </div>
  </div>
</div>

<!-- Game Over Modal -->
<div id="game-over-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 style="text-align: center">GAME OVER</h2>
    </div>
    <div class="modal-body" style="text-align: center;">
      <p id="game-over-text">You have been defeated!</p>
      <p>Dracula laughs as your life fades away...</p>
      <button id="try-again-button">TRY AGAIN</button>
      <button id="main-menu-button">MAIN MENU</button>
    </div>
  </div>
</div>

<!-- New Game Plus Modal -->
<div id="new-game-plus-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 style="text-align: center">NEW GAME+</h2>
    </div>
    <div class="modal-body" style="text-align: center;">
      <p>Congratulations on defeating Dracula!</p>
      <p>Start a new game with increased difficulty but keep your:</p>
      <ul style="text-align: left; margin: 10px 0;">
        <li>Level and stats</li>
        <li>Inventory (except key items)</li>
        <li>Gold</li>
        <li>Unlocked abilities</li>
      </ul>
      <p>Enemies will be stronger and smarter!</p>
      <button id="start-new-game-plus">BEGIN NEW GAME+</button>
      <button id="regular-new-game">START NORMAL GAME</button>
    </div>
  </div>
</div>

<script>
// Web Audio API Sound Manager
class SoundManager {
  constructor() {
    this.audioContext = null;
    this.sounds = new Map();
    this.enabled = true;
    this.init();
  }

  init() {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.createSounds();
    } catch (e) {
      console.warn('Web Audio API not supported:', e);
      this.enabled = false;
    }
  }

  createSounds() {
    // Button click sound
    this.sounds.set('click', () => this.createBeep(200, 0.1, 'sine'));
    
    // Explore sound
    this.sounds.set('explore', () => this.createBeep(300, 0.3, 'sine'));
    
    // Combat sounds
    this.sounds.set('attack', () => this.createBeep(150, 0.2, 'square'));
    this.sounds.set('hit', () => this.createBeep(100, 0.1, 'sawtooth'));
    this.sounds.set('critical', () => {
      this.createBeep(200, 0.1, 'sine');
      setTimeout(() => this.createBeep(400, 0.2, 'sine'), 100);
    });
    
    // Level up sound
    this.sounds.set('levelup', () => {
      this.createBeep(300, 0.1, 'sine');
      setTimeout(() => this.createBeep(400, 0.1, 'sine'), 100);
      setTimeout(() => this.createBeep(500, 0.2, 'sine'), 200);
    });
    
    // Item sounds
    this.sounds.set('item', () => this.createBeep(600, 0.2, 'triangle'));
    this.sounds.set('heal', () => {
      this.createBeep(400, 0.1, 'sine');
      setTimeout(() => this.createBeep(600, 0.2, 'sine'), 150);
    });
    
    // Notification sounds
    this.sounds.set('notification', () => this.createBeep(800, 0.3, 'sine'));
    this.sounds.set('achievement', () => {
      this.createBeep(500, 0.1, 'sine');
      setTimeout(() => this.createBeep(700, 0.1, 'sine'), 100);
      setTimeout(() => this.createBeep(900, 0.3, 'sine'), 200);
    });
    
    // Map sounds
    this.sounds.set('map', () => this.createBeep(350, 0.2, 'sine'));
    this.sounds.set('travel', () => {
      this.createBeep(200, 0.1, 'sine');
      setTimeout(() => this.createBeep(400, 0.2, 'sine'), 100);
    });
  }

  createBeep(frequency, duration, type) {
    if (!this.enabled || !this.audioContext) return;

    const oscillator = this.audioContext.createOscillator();
    const gainNode = this.audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    
    oscillator.frequency.value = frequency;
    oscillator.type = type;
    
    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
    
    oscillator.start(this.audioContext.currentTime);
    oscillator.stop(this.audioContext.currentTime + duration);
  }

  play(soundName) {
    if (!this.enabled) return;
    
    // Resume audio context if suspended (required by some browsers)
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume();
    }
    
    const sound = this.sounds.get(soundName);
    if (sound) {
      sound();
    }
  }

  toggle() {
    this.enabled = !this.enabled;
    document.getElementById('sound-toggle').textContent = 
      `üîä SOUND: ${this.enabled ? 'ON' : 'OFF'}`;
    if (this.enabled) {
      this.play('click');
    }
  }
}

// Initialize Sound Manager
const soundManager = new SoundManager();

// Enhanced Visual Feedback System
class VisualFeedback {
  static createFloatingText(text, type, parentElement, offsetX = 0, offsetY = 0) {
    const floatingText = document.createElement('div');
    floatingText.className = `floating-text ${type}`;
    floatingText.textContent = text;
    
    const rect = parentElement.getBoundingClientRect();
    floatingText.style.left = `${rect.left + offsetX}px`;
    floatingText.style.top = `${rect.top + offsetY}px`;
    
    document.body.appendChild(floatingText);
    
    // Remove after animation
    setTimeout(() => {
      floatingText.remove();
    }, 2000);
    
    return floatingText;
  }

  static showXP(xpAmount, parentElement) {
    this.createFloatingText(`+${xpAmount} XP`, 'xp-gain', parentElement, 20, -10);
    soundManager.play('notification');
  }

  static showGold(goldAmount, parentElement) {
    this.createFloatingText(`+${goldAmount} GOLD`, 'gold-gain', parentElement, 20, -20);
    soundManager.play('item');
  }

  static showHeal(amount, parentElement) {
    this.createFloatingText(`+${amount} HP`, 'heal-gain', parentElement, 20, -15);
    soundManager.play('heal');
  }

  static showSanity(amount, parentElement) {
    this.createFloatingText(`+${amount} SAN`, 'sanity-gain', parentElement, 20, -25);
    soundManager.play('heal');
  }

  static showDamage(amount, parentElement, isCritical = false) {
    const text = isCritical ? `CRIT! ${amount}` : `${amount}`;
    this.createFloatingText(text, 'damage-taken', parentElement, 10, -10);
    soundManager.play(isCritical ? 'critical' : 'hit');
  }

  static showItem(itemName, parentElement) {
    this.createFloatingText(`Found: ${itemName}`, 'item-found', parentElement, 20, -15);
    soundManager.play('item');
  }

  static showAchievement(title, description) {
    const popup = document.createElement('div');
    popup.className = 'achievement-popup';
    popup.innerHTML = `
      <div style="display: flex; align-items: center;">
        <div class="achievement-icon">üèÜ</div>
        <div>
          <div style="font-weight: bold; color: gold;">ACHIEVEMENT UNLOCKED!</div>
          <div style="font-size: 14px;">${title}</div>
          <div style="font-size: 12px; color: #ccc;">${description}</div>
        </div>
      </div>
    `;
    
    document.body.appendChild(popup);
    soundManager.play('achievement');
    
    setTimeout(() => {
      popup.remove();
    }, 3000);
  }

  static pulseButton(button) {
    button.classList.add('button-pulse');
    soundManager.play('click');
    setTimeout(() => {
      button.classList.remove('button-pulse');
    }, 300);
  }
}

// Interactive Map System
class InteractiveMap {
  constructor() {
    this.mapData = {
      locations: [
        { id: 0, name: "TAVERN", x: 50, y: 350, connections: [1] },
        { id: 1, name: "FOREST", x: 150, y: 300, connections: [0, 2], enemies: ["vampire-spawn", "ghoul"] },
        { id: 2, name: "MOUNTAIN", x: 250, y: 250, connections: [1, 3], enemies: ["werewolf", "ghost"] },
        { id: 3, name: "CASTLE GATES", x: 350, y: 200, connections: [2, 4], enemies: ["brides", "zombie"] },
        { id: 4, name: "CASTLE HALLS", x: 450, y: 150, connections: [3, 5, 7], enemies: ["brides", "vampire-spawn"] },
        { id: 5, name: "DUNGEONS", x: 350, y: 100, connections: [4, 6], enemies: ["ghoul", "zombie"] },
        { id: 6, name: "THRONE ROOM", x: 250, y: 50, connections: [5], enemies: ["dracula"] },
        { id: 7, name: "SECRET CHAPEL", x: 550, y: 100, connections: [4], hidden: true, enemies: ["fallen-paladin"] },
        { id: 8, name: "ALCHEMIST'S LAB", x: 550, y: 200, connections: [4], hidden: true, enemies: ["mad-alchemist"] },
        { id: 9, name: "CRYPT", x: 150, y: 150, connections: [4], hidden: true, enemies: ["lich"] },
        { id: 10, name: "BLOOD FOUNTAIN", x: 450, y: 300, connections: [4], hidden: true, enemies: ["blood-elemental"] }
      ],
      visited: new Set([0]), // Start with tavern visited
      discovered: new Set([0, 1, 2, 3, 4, 5, 6]) // Basic locations discovered
    };
  }

  render() {
    const mapContainer = document.getElementById('interactive-map');
    mapContainer.innerHTML = '';
    
    // Draw connections first (so they appear behind locations)
    this.drawConnections(mapContainer);
    
    // Draw locations
    this.mapData.locations.forEach(location => {
      this.drawLocation(mapContainer, location);
    });
    
    // Add tooltip functionality
    this.addTooltips();
  }

  drawConnections(container) {
    this.mapData.locations.forEach(location => {
      location.connections.forEach(connectedId => {
        const connectedLocation = this.mapData.locations.find(l => l.id === connectedId);
        if (connectedLocation) {
          this.drawConnection(container, location, connectedLocation);
        }
      });
    });
  }

  drawConnection(container, loc1, loc2) {
    const connection = document.createElement('div');
    connection.className = 'map-connection';
    
    const dx = loc2.x - loc1.x;
    const dy = loc2.y - loc1.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    connection.style.width = `${length}px`;
    connection.style.left = `${loc1.x}px`;
    connection.style.top = `${loc1.y}px`;
    connection.style.transform = `rotate(${angle}deg)`;
    
    // Only show connections to visited or discovered locations
    if (this.mapData.visited.has(loc1.id) || this.mapData.visited.has(loc2.id) ||
        this.mapData.discovered.has(loc1.id) || this.mapData.discovered.has(loc2.id)) {
      container.appendChild(connection);
    }
  }

  drawLocation(container, location) {
    const locationElement = document.createElement('div');
    locationElement.className = 'map-location';
    locationElement.textContent = location.name;
    locationElement.style.left = `${location.x - 40}px`;
    locationElement.style.top = `${location.y - 30}px`;
    locationElement.dataset.locationId = location.id;
    
    // Set location state
    if (location.id === game.location) {
      locationElement.classList.add('current');
    } else if (this.mapData.visited.has(location.id)) {
      locationElement.classList.add('visited');
    } else if (this.mapData.discovered.has(location.id)) {
      locationElement.classList.add('discovered');
    } else if (location.hidden) {
      locationElement.classList.add('hidden');
    }
    
    // Check if location is accessible
    const isAccessible = this.isLocationAccessible(location.id);
    if (isAccessible) {
      locationElement.classList.add('accessible');
      locationElement.addEventListener('click', () => this.travelToLocation(location.id));
    }
    
    container.appendChild(locationElement);
  }

  isLocationAccessible(locationId) {
    const currentLocation = this.mapData.locations.find(l => l.id === game.location);
    return currentLocation.connections.includes(locationId) && 
           (this.mapData.visited.has(locationId) || this.mapData.discovered.has(locationId));
  }

  addTooltips() {
    const locations = document.querySelectorAll('.map-location');
    const tooltip = document.createElement('div');
    tooltip.className = 'map-tooltip';
    tooltip.style.display = 'none';
    document.getElementById('interactive-map').appendChild(tooltip);

    locations.forEach(location => {
      location.addEventListener('mouseenter', (e) => {
        const locationId = parseInt(e.target.dataset.locationId);
        const locationData = this.mapData.locations.find(l => l.id === locationId);
        
        let tooltipText = locationData.name;
        if (locationData.hidden) {
          tooltipText += " (Hidden)";
        }
        if (locationData.enemies) {
          tooltipText += `\nEnemies: ${locationData.enemies.map(e => game.enemies[e].name).join(', ')}`;
        }
        
        tooltip.textContent = tooltipText;
        tooltip.style.display = 'block';
        tooltip.style.left = `${e.pageX + 10}px`;
        tooltip.style.top = `${e.pageY + 10}px`;
      });

      location.addEventListener('mousemove', (e) => {
        tooltip.style.left = `${e.pageX + 10}px`;
        tooltip.style.top = `${e.pageY + 10}px`;
      });

      location.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });
    });
  }

  travelToLocation(locationId) {
    if (this.isLocationAccessible(locationId)) {
      game.location = locationId;
      this.mapData.visited.add(locationId);
      updateLocation();
      this.render();
      soundManager.play('travel');
      addToScene(`You travel to ${game.locations[locationId].name}.`);
      hideAllModals();
    }
  }

  discoverLocation(locationId) {
    this.mapData.discovered.add(locationId);
    if (document.getElementById('interactive-map-modal').style.display === 'block') {
      this.render();
    }
  }

  visitLocation(locationId) {
    this.mapData.visited.add(locationId);
    this.mapData.discovered.add(locationId);
  }
}

// Initialize Interactive Map
const interactiveMap = new InteractiveMap();

// Enhanced Character Progression System
const skillTrees = {
  jonathan: {
    combat: [
      { id: 'precise_strikes', name: 'Precise Strikes', cost: 1, 
        description: '+15% critical strike chance', 
        effect: (player) => { player.critChance = (player.critChance || 0) + 0.15; },
        requires: [] },
      { id: 'counter_attack', name: 'Counter Attack', cost: 2,
        description: '25% chance to counterattack when hit',
        effect: (player) => { player.counterChance = 0.25; },
        requires: ['precise_strikes'] },
      { id: 'duelist_stance', name: 'Duelist Stance', cost: 3,
        description: '+20% damage when wielding one-handed weapons',
        effect: (player) => { player.duelistBonus = 0.2; },
        requires: ['counter_attack'] }
    ],
    survival: [
      { id: 'toughness', name: 'Toughness', cost: 1,
        description: '+15 maximum HP',
        effect: (player) => { 
          player.maxHp += 15; 
          player.hp += 15;
        },
        requires: [] },
      { id: 'quick_recovery', name: 'Quick Recovery', cost: 2,
        description: 'Heal 5 HP after each combat',
        effect: (player) => { player.combatHeal = 5; },
        requires: ['toughness'] },
      { id: 'iron_will', name: 'Iron Will', cost: 3,
        description: '+25 maximum sanity and -20% sanity loss',
        effect: (player) => { 
          player.maxSanity += 25;
          player.sanity += 25;
          player.sanityResistance = 0.2;
        },
        requires: ['quick_recovery'] }
    ],
    vampireHunting: [
      { id: 'stake_mastery', name: 'Stake Mastery', cost: 2,
        description: 'Wooden stakes deal 50% more damage to vampires',
        effect: (player) => { player.stakeBonus = 0.5; },
        requires: [] },
      { id: 'holy_resistance', name: 'Holy Resistance', cost: 2,
        description: 'Take 30% less damage from undead enemies',
        effect: (player) => { player.undeadResistance = 0.3; },
        requires: [] },
      { id: 'hunters_instinct', name: "Hunter's Instinct", cost: 3,
        description: 'See vampire weaknesses and +10% damage to all undead',
        effect: (player) => { 
          player.undeadDamage = 0.1;
          player.seeWeaknesses = true;
        },
        requires: ['stake_mastery', 'holy_resistance'] }
    ]
  },
  vanhelsing: {
    combat: [
      { id: 'alchemical_weapons', name: 'Alchemical Weapons', cost: 1,
        description: 'Potions and bombs deal 25% more damage',
        effect: (player) => { player.alchemicalBonus = 0.25; },
        requires: [] },
      { id: 'scholar_combat', name: 'Scholar Combat', cost: 2,
        description: 'INT contributes to damage instead of STR',
        effect: (player) => { player.useIntForDamage = true; },
        requires: ['alchemical_weapons'] },
      { id: 'master_alchemist', name: 'Master Alchemist', cost: 3,
        description: 'Create free potions after combat (30% chance)',
        effect: (player) => { player.freePotions = 0.3; },
        requires: ['scholar_combat'] }
    ],
    survival: [
      { id: 'field_medicine', name: 'Field Medicine', cost: 1,
        description: 'Health potions heal 50% more',
        effect: (player) => { player.healingBonus = 0.5; },
        requires: [] },
      { id: 'preparedness', name: 'Preparedness', cost: 2,
        description: 'Start combat with a random protective item',
        effect: (player) => { player.startWithItem = true; },
        requires: ['field_medicine'] },
      { id: 'endurance_training', name: 'Endurance Training', cost: 2,
        description: '+20 maximum HP and +10% damage resistance',
        effect: (player) => { 
          player.maxHp += 20;
          player.hp += 20;
          player.damageResistance = 0.1;
        },
        requires: ['preparedness'] }
    ],
    vampireHunting: [
      { id: 'vampire_lore', name: 'Vampire Lore', cost: 1,
        description: 'See all enemy weaknesses and resistances',
        effect: (player) => { player.seeAllWeaknesses = true; },
        requires: [] },
      { id: 'holy_empowerment', name: 'Holy Empowerment', cost: 2,
        description: 'Holy items are 50% more effective',
        effect: (player) => { player.holyBonus = 0.5; },
        requires: ['vampire_lore'] },
      { id: 'ancient_rituals', name: 'Ancient Rituals', cost: 3,
        description: 'Unlock powerful ritual abilities in combat',
        effect: (player) => { player.hasRituals = true; },
        requires: ['holy_empowerment'] }
    ]
  },
  mina: {
    combat: [
      { id: 'mental_assault', name: 'Mental Assault', cost: 1,
        description: 'Chance to stun enemies with psychic attacks',
        effect: (player) => { player.stunChance = 0.2; },
        requires: [] },
      { id: 'sixth_sense', name: 'Sixth Sense', cost: 2,
        description: 'Dodge chance based on INT instead of AGI',
        effect: (player) => { player.useIntForDodge = true; },
        requires: ['mental_assault'] },
      { id: 'psychic_barrier', name: 'Psychic Barrier', cost: 3,
        description: 'Create barrier that blocks 50% of damage for 1 turn',
        effect: (player) => { player.hasBarrier = true; },
        requires: ['sixth_sense'] }
    ],
    survival: [
      { id: 'meditation', name: 'Meditation', cost: 1,
        description: 'Rest restores 50% more sanity',
        effect: (player) => { player.meditationBonus = 0.5; },
        requires: [] },
      { id: 'psychic_healing', name: 'Psychic Healing', cost: 2,
        description: 'Heal 10% of max HP when sanity is above 80%',
        effect: (player) => { player.psychicHealing = true; },
        requires: ['meditation'] },
      { id: 'mental_fortitude', name: 'Mental Fortitude', cost: 2,
        description: 'Immune to fear and charm effects',
        effect: (player) => { player.mentalFortitude = true; },
        requires: ['psychic_healing'] }
    ],
    vampireHunting: [
      { id: 'clairvoyance', name: 'Clairvoyance', cost: 1,
        description: 'See hidden paths and secret locations',
        effect: (player) => { player.clairvoyance = true; },
        requires: [] },
      { id: 'spirit_ward', name: 'Spirit Ward', cost: 2,
        description: 'Create protective ward against undead',
        effect: (player) => { player.spiritWard = true; },
        requires: ['clairvoyance'] },
      { id: 'banishment', name: 'Banishment', cost: 3,
        description: 'Chance to instantly banish weaker undead',
        effect: (player) => { player.banishmentChance = 0.3; },
        requires: ['spirit_ward'] }
    ]
  },
  quincey: {
    combat: [
      { id: 'quick_draw', name: 'Quick Draw', cost: 1,
        description: 'Always attack first in combat',
        effect: (player) => { player.quickDraw = true; },
        requires: [] },
      { id: 'fan_fire', name: 'Fan Fire', cost: 2,
        description: 'Attack 3 times with reduced damage',
        effect: (player) => { player.fanFire = true; },
        requires: ['quick_draw'] },
      { id: 'deadly_aim', name: 'Deadly Aim', cost: 3,
        description: '+25% critical damage and ignore 20% armor',
        effect: (player) => { 
          player.critDamage = (player.critDamage || 0) + 0.25;
          player.armorPenetration = 0.2;
        },
        requires: ['fan_fire'] }
    ],
    survival: [
      { id: 'survivor', name: 'Survivor', cost: 1,
        description: 'Heal 10% of damage taken after combat',
        effect: (player) => { player.damageHealing = 0.1; },
        requires: [] },
      { id: 'scavenger', name: 'Scavenger', cost: 2,
        description: 'Find extra ammunition and items',
        effect: (player) => { player.scavenger = true; },
        requires: ['survivor'] },
      { id: 'iron_constitution', name: 'Iron Constitution', cost: 2,
        description: 'Immune to poison and disease',
        effect: (player) => { player.diseaseImmunity = true; },
        requires: ['scavenger'] }
    ],
    vampireHunting: [
      { id: 'silver_expert', name: 'Silver Expert', cost: 1,
        description: 'Silver weapons deal 40% more damage',
        effect: (player) => { player.silverBonus = 0.4; },
        requires: [] },
      { id: 'marksmanship', name: 'Marksmanship', cost: 2,
        description: '+30% critical chance with ranged weapons',
        effect: (player) => { player.rangedCrit = 0.3; },
        requires: ['silver_expert'] },
      { id: 'silver_bullet', name: 'Silver Bullet', cost: 3,
        description: 'Unlock powerful silver bullet ability',
        effect: (player) => { player.silverBullet = true; },
        requires: ['marksmanship'] }
    ]
  }
};

// Enhanced Game State
const game = {
  player: null,
  currentEnemy: null,
  inCombat: false,
  location: 0, // 0=tavern, 1=forest, etc.
  day: 1,
  difficulty: 'normal',
  hasStake: false,
  newGamePlus: false,
  statusEffects: [],
  enemyStatusEffects: [],
  saveSlots: [],
  
  // Game Data
  locations: [
    { name: "TAVERN", desc: "You stand in the dimly lit tavern at the foot of the Carpathian Mountains.", enemies: [] },
    { name: "FOREST", desc: "The dark forest is filled with eerie sounds.", enemies: ["vampire-spawn", "ghoul", "banshee", "wraith", "shadow-stalker"] },
    { name: "MOUNTAIN", desc: "The steep mountain path winds upward.", enemies: ["vampire-spawn", "werewolf", "ghost", "dark-priest", "mountain-troll"] },
    { name: "CASTLE GATES", desc: "The massive iron gates stand ominously open.", enemies: ["brides", "werewolf", "zombie", "shadow-beast", "gatekeeper"] },
    { name: "CASTLE HALLS", desc: "The interior is dark and foreboding.", enemies: ["brides", "vampire-spawn", "ghost", "cursed-knight", "armored-skeleton"] },
    { name: "DUNGEONS", desc: "The stench of death fills the air.", enemies: ["ghoul", "zombie", "banshee", "tortured-soul", "dungeon-crawler"] },
    { name: "THRONE ROOM", desc: "The final confrontation.", enemies: ["dracula"] },
    { name: "SECRET CHAPEL", desc: "A hidden chapel with ancient relics.", enemies: ["fallen-paladin", "demon", "undead-priest"], hidden: true },
    { name: "ALCHEMIST'S LAB", desc: "A mysterious laboratory filled with strange equipment.", enemies: ["homunculus", "mutant", "mad-alchemist"], hidden: true },
    { name: "CRYPT", desc: "Ancient tombs filled with restless dead.", enemies: ["lich", "wraith", "skeletal-mage", "crypt-fiend"], hidden: true },
    { name: "BLOOD FOUNTAIN", desc: "A cursed fountain flowing with blood.", enemies: ["blood-elemental", "vampire-spawn", "shadow-beast"], hidden: true }
  ],
  
  characters: {
    jonathan: { 
      name: "JONATHAN HARKER", 
      class: "Diplomat",
      hp: 90, maxHp: 90, 
      sanity: 110, maxSanity: 110,
      strength: 7, agility: 6, intelligence: 5,
      skills: ["SILVER STRIKE", "PARRY"], 
      perks: ["+10% damage with silver weapons", "25% chance to block attacks"],
      inventory: ["silver-dagger"],
      unlockedAbilities: []
    },
    vanhelsing: { 
      name: "VAN HELSING", 
      class: "Professor",
      hp: 100, maxHp: 100, 
      sanity: 90, maxSanity: 90,
      strength: 5, agility: 4, intelligence: 8,
      skills: ["HOLY WATER", "VAMPIRE KNOWLEDGE"], 
      perks: ["-25% sanity loss from undead", "See enemy weaknesses"],
      inventory: ["holy-water", "garlic"],
      unlockedAbilities: []
    },
    mina: { 
      name: "MINA MURRAY", 
      class: "Occultist",
      hp: 80, maxHp: 80, 
      sanity: 120, maxSanity: 120,
      strength: 4, agility: 7, intelligence: 7,
      skills: ["HYPNOSIS", "SIXTH SENSE"], 
      perks: ["+30% better item finding", "Chance to skip enemy turn"],
      inventory: ["occult-tome"],
      unlockedAbilities: []
    },
    quincey: {
      name: "QUINCEY MORRIS",
      class: "Gunslinger",
      hp: 85, maxHp: 85,
      sanity: 95, maxSanity: 95,
      strength: 6, agility: 8, intelligence: 4,
      skills: ["QUICK DRAW", "MARKSMANSHIP"],
      perks: ["Attack first in combat", "+25% crit chance"],
      inventory: ["revolver"],
      unlockedAbilities: []
    }
  },
  
  enemies: {
    "vampire-spawn": { name: "VAMPIRE SPAWN", hp: 30, maxHp: 30, damage: 6, xp: 25, gold: 15, weakness: ["stake", "holy"], special: "bleed" },
    "brides": { name: "DRACULA'S BRIDES", hp: 50, maxHp: 50, damage: 9, xp: 40, gold: 30, weakness: ["holy"], special: "charm" },
    "werewolf": { name: "WEREWOLF", hp: 70, maxHp: 70, damage: 12, xp: 60, gold: 45, weakness: ["silver"], special: "howl" },
    "ghoul": { name: "GHOUL", hp: 40, maxHp: 40, damage: 8, xp: 35, gold: 20, weakness: ["holy"], special: "disease" },
    "dracula": { name: "COUNT DRACULA", hp: 150, maxHp: 150, damage: 15, xp: 200, gold: 100, weakness: ["stake", "holy"], special: "transform" },
    "banshee": { name: "BANSHEE", hp: 35, maxHp: 35, damage: 7, xp: 30, gold: 25, weakness: ["silver"], special: "screech" },
    "ghost": { name: "GHOST", hp: 25, maxHp: 25, damage: 5, xp: 20, gold: 10, weakness: ["holy"], special: "phase" },
    "zombie": { name: "ZOMBIE", hp: 45, maxHp: 45, damage: 7, xp: 30, gold: 15, weakness: ["fire"], special: "grapple" },
    "wraith": { name: "WRAITH", hp: 40, maxHp: 40, damage: 8, xp: 35, gold: 25, weakness: ["holy"], special: "drain" },
    "dark-priest": { name: "DARK PRIEST", hp: 60, maxHp: 60, damage: 10, xp: 50, gold: 40, weakness: ["holy"], special: "curse" },
    "shadow-beast": { name: "SHADOW BEAST", hp: 80, maxHp: 80, damage: 14, xp: 70, gold: 55, weakness: ["light"], special: "ambush" },
    "cursed-knight": { name: "CURSED KNIGHT", hp: 90, maxHp: 90, damage: 12, xp: 80, gold: 60, weakness: ["silver", "holy"], special: "counter" },
    "tortured-soul": { name: "TORTURED SOUL", hp: 30, maxHp: 30, damage: 6, xp: 25, gold: 20, weakness: ["holy"], special: "wail" },
    "fallen-paladin": { name: "FALLEN PALADIN", hp: 120, maxHp: 120, damage: 18, xp: 150, gold: 80, weakness: ["holy"], special: "smite" },
    "demon": { name: "DEMON", hp: 100, maxHp: 100, damage: 16, xp: 120, gold: 70, weakness: ["holy"], special: "firebreath" },
    "undead-priest": { name: "UNDEAD PRIEST", hp: 70, maxHp: 70, damage: 12, xp: 90, gold: 50, weakness: ["holy"], special: "unholy-blessing" },
    "homunculus": { name: "HOMUNCULUS", hp: 50, maxHp: 50, damage: 10, xp: 60, gold: 40, weakness: ["fire"], special: "regenerate" },
    "mutant": { name: "MUTANT", hp: 90, maxHp: 90, damage: 14, xp: 100, gold: 60, weakness: ["silver"], special: "mutate" },
    "mad-alchemist": { name: "MAD ALCHEMIST", hp: 80, maxHp: 80, damage: 12, xp: 110, gold: 70, weakness: ["fire"], special: "throw-potion" },
    "shadow-stalker": { name: "SHADOW STALKER", hp: 55, maxHp: 55, damage: 11, xp: 45, gold: 35, weakness: ["light"], special: "ambush" },
    "mountain-troll": { name: "MOUNTAIN TROLL", hp: 110, maxHp: 110, damage: 16, xp: 85, gold: 65, weakness: ["fire"], special: "regenerate" },
    "gatekeeper": { name: "GATEKEEPER", hp: 95, maxHp: 95, damage: 14, xp: 75, gold: 55, weakness: ["holy"], special: "counter" },
    "armored-skeleton": { name: "ARMORED SKELETON", hp: 65, maxHp: 65, damage: 10, xp: 55, gold: 40, weakness: ["blunt"], special: "shield" },
    "dungeon-crawler": { name: "DUNGEON CRAWLER", hp: 75, maxHp: 75, damage: 13, xp: 65, gold: 50, weakness: ["fire"], special: "poison" },
    "lich": { name: "LICH", hp: 130, maxHp: 130, damage: 18, xp: 160, gold: 90, weakness: ["holy"], special: "raise-dead" },
    "skeletal-mage": { name: "SKELETAL MAGE", hp: 60, maxHp: 60, damage: 12, xp: 70, gold: 45, weakness: ["holy"], special: "curse" },
    "crypt-fiend": { name: "CRYPT FIEND", hp: 85, maxHp: 85, damage: 15, xp: 95, gold: 60, weakness: ["silver"], special: "disease" },
    "blood-elemental": { name: "BLOOD ELEMENTAL", hp: 100, maxHp: 100, damage: 17, xp: 120, gold: 75, weakness: ["holy"], special: "drain" }
  },
  
  items: {
    "fists": { name: "FISTS", damage: 2 },
    "silver-dagger": { name: "SILVER DAGGER", damage: 8, special: "silver" },
    "wooden-stake": { name: "WOODEN STAKE", damage: 12, special: "stake" },
    "health-potion": { name: "HEALTH POTION", heal: 20 },
    "holy-water": { name: "HOLY WATER", damage: 15, special: "holy" },
    "garlic": { name: "GARLIC", damage: 5, special: "repel" },
    "occult-tome": { name: "OCCULT TOME", special: "knowledge" },
    "antidote": { name: "ANTIDOTE", special: "cure" },
    "blessed-blade": { name: "BLESSED BLADE", damage: 14, special: "holy" },
    "vampire-killer": { name: "VAMPIRE KILLER", damage: 18, special: ["silver", "holy"] },
    "revolver": { name: "REVOLVER", damage: 10, special: "silver" },
    "silver-bullet": { name: "SILVER BULLET", damage: 25, special: ["silver", "holy"], consumable: true },
    "sun-bomb": { name: "SUN BOMB", damage: 40, special: "holy", consumable: true, area: true }
  },
  
  merchantItems: [
    { id: "health-potion", name: "HEALTH POTION", price: 15, heal: 20 },
    { id: "holy-water", name: "HOLY WATER", price: 25, damage: 15, special: "holy" },
    { id: "garlic", name: "GARLIC", price: 10, damage: 5, special: "repel" },
    { id: "silver-dagger", name: "SILVER DAGGER", price: 50, damage: 8, special: "silver" },
    { id: "wooden-stake", name: "WOODEN STAKE", price: 40, damage: 12, special: "stake" },
    { id: "antidote", name: "ANTIDOTE", price: 20, special: "cure" },
    { id: "revolver", name: "REVOLVER", price: 75, damage: 10, special: "silver" },
    { id: "silver-bullet", name: "SILVER BULLET", price: 30, damage: 25, special: ["silver", "holy"], consumable: true },
    { id: "sun-bomb", name: "SUN BOMB", price: 60, damage: 40, special: "holy", consumable: true }
  ],
  
  quests: {
    active: [
      { id: "slay-dracula", title: "SLAY DRACULA", description: "Defeat Count Dracula to lift the curse.", completed: false },
      { id: "find-stake", title: "FIND A STAKE", description: "Obtain a wooden stake to fight vampires.", completed: false }
    ],
    completed: [],
    side: [
      { id: "kill-werewolf", title: "SLAY THE WEREWOLF", description: "Defeat the werewolf haunting the mountains.", completed: false, reward: "blessed-blade" },
      { id: "find-tome", title: "FIND THE LOST TOME", description: "Recover the ancient occult tome from the dungeons.", completed: false, reward: "vampire-killer" },
      { id: "explore-chapel", title: "EXPLORE THE SECRET CHAPEL", description: "Find the hidden chapel in the castle.", completed: false, reward: "holy-water", hidden: true },
      { id: "defeat-alchemist", title: "DEFEAT THE MAD ALCHEMIST", description: "Put an end to the alchemist's experiments.", completed: false, reward: "sun-bomb", hidden: true },
      { id: "clear-crypt", title: "CLEAR THE ANCIENT CRYPT", description: "Purify the ancient crypt of its undead inhabitants.", completed: false, reward: "silver-bullet", hidden: true },
      { id: "destroy-fountain", title: "DESTROY THE BLOOD FOUNTAIN", description: "Destroy the cursed fountain that empowers Dracula.", completed: false, reward: "holy-water", hidden: true }
    ]
  },
  
  statusEffectTypes: {
    "bleed": { name: "BLEEDING", duration: 3, damage: 2, class: "bleeding" },
    "poison": { name: "POISONED", duration: 4, damage: 1, class: "poisoned" },
    "curse": { name: "CURSED", duration: 5, damage: 0, sanityLoss: 5, class: "cursed" },
    "charmed": { name: "CHARMED", duration: 1, skipTurn: true, class: "cursed" },
    "drain": { name: "LIFE DRAIN", duration: 2, damage: 3, healEnemy: true, class: "cursed" },
    "regenerate": { name: "REGENERATING", duration: 3, heal: 5, class: "poisoned" },
    "shield": { name: "SHIELDED", duration: 2, damageReduction: 0.3, class: "poisoned" },
    "spirit-ward": { name: "SPIRIT WARD", duration: 3, preventSanityLoss: true, class: "protected" }
  },
  
  travelEvents: [
    { text: "You find a hidden path that leads to a small clearing.", effect: "findItem" },
    { text: "A strange mist surrounds you, making it hard to see.", effect: "loseSanity", amount: 5 },
    { text: "You stumble upon an abandoned campsite with some useful items.", effect: "findItem" },
    { text: "The howling wind carries whispers that chill you to the bone.", effect: "loseSanity", amount: 10 },
    { text: "You discover a shortcut through the terrain.", effect: "progressFaster" },
    { text: "A wounded traveler warns you of dangers ahead before collapsing.", effect: "findItem" },
    { text: "You find an old journal detailing secret locations in the castle.", effect: "revealHidden" },
    { text: "A mysterious figure offers you a powerful item in exchange for gold.", effect: "mysteriousMerchant" }
  ]
};

// Initialize Game
document.addEventListener('DOMContentLoaded', function() {
  // Character selection
  document.getElementById('select-jonathan').addEventListener('click', () => startGame('jonathan'));
  document.getElementById('select-vanhelsing').addEventListener('click', () => startGame('vanhelsing'));
  document.getElementById('select-mina').addEventListener('click', () => startGame('mina'));
  document.getElementById('select-quincey').addEventListener('click', () => startGame('quincey'));
  
  // Settings
  document.getElementById('settings-button').addEventListener('click', () => {
    openSaveLoadModal();
  });
  
  // Sound toggle
  document.getElementById('sound-toggle').addEventListener('click', () => {
    soundManager.toggle();
    VisualFeedback.pulseButton(document.getElementById('sound-toggle'));
  });
  
  // Mobile controls
  document.getElementById('mobile-explore').addEventListener('click', explore);
  document.getElementById('mobile-action').addEventListener('click', () => {
    if (game.location === 0) {
      talkToBarkeep();
    } else {
      returnToTavern();
    }
  });
  document.getElementById('mobile-merchant').addEventListener('click', openMerchant);
  document.getElementById('mobile-rest').addEventListener('click', rest);
  document.getElementById('mobile-inventory').addEventListener('click', openInventory);
  document.getElementById('mobile-quests').addEventListener('click', openQuests);
  document.getElementById('mobile-character').addEventListener('click', openCharacter);
  document.getElementById('mobile-skills').addEventListener('click', openSkills);
  document.getElementById('mobile-map').addEventListener('click', openInteractiveMap);
  
  // Add sound to all buttons
  document.querySelectorAll('button').forEach(button => {
    button.addEventListener('click', function() {
      VisualFeedback.pulseButton(this);
    });
  });
  
  // Check for saved games
  loadSaveSlots();
  
  // Check for completed game
  if (localStorage.getItem('draculasCurseCompleted')) {
    document.getElementById('new-game-plus-button').style.display = 'block';
    document.getElementById('new-game-plus-button').addEventListener('click', () => {
      document.getElementById('new-game-plus-modal').style.display = 'block';
    });
  }
  
  // Initialize back buttons
  document.getElementById('back-from-inventory').addEventListener('click', hideAllModals);
  document.getElementById('back-from-merchant').addEventListener('click', hideAllModals);
  document.getElementById('back-from-character').addEventListener('click', hideAllModals);
  document.getElementById('back-from-skills').addEventListener('click', closeSkills);
  document.getElementById('back-from-map').addEventListener('click', closeInteractiveMap);
  document.getElementById('back-from-quests').addEventListener('click', hideAllModals);
  document.getElementById('back-from-save-load').addEventListener('click', hideAllModals);
});

// Enhanced Character Progression Functions
function openSkills() {
  document.getElementById('skills-modal').style.display = 'block';
  renderSkillTree();
  soundManager.play('click');
}

function closeSkills() {
  document.getElementById('skills-modal').style.display = 'none';
}

function renderSkillTree() {
  const character = Object.keys(game.characters).find(key => 
    game.characters[key].name === game.player.name
  );
  
  const tree = skillTrees[character];
  const skillPoints = Math.max(0, game.player.level - 1 - (game.player.learnedSkills ? game.player.learnedSkills.length : 0));
  
  document.getElementById('skill-points-display').textContent = skillPoints;
  document.getElementById('skills-level').textContent = game.player.level;
  
  // Initialize learned skills if not exists
  if (!game.player.learnedSkills) {
    game.player.learnedSkills = [];
  }
  
  const container = document.getElementById('skill-tree-container');
  container.innerHTML = '';
  
  // Render each skill category
  renderSkillCategory(container, 'COMBAT SKILLS', tree.combat, skillPoints);
  renderSkillCategory(container, 'SURVIVAL SKILLS', tree.survival, skillPoints);
  renderSkillCategory(container, 'VAMPIRE HUNTING', tree.vampireHunting, skillPoints);
}

function renderSkillCategory(container, categoryName, skills, availablePoints) {
  const categoryDiv = document.createElement('div');
  categoryDiv.className = 'skill-category';
  categoryDiv.innerHTML = `<h3>${categoryName}</h3>`;
  
  skills.forEach(skill => {
    const skillElement = document.createElement('div');
    skillElement.className = 'skill-node';
    skillElement.dataset.skillId = skill.id;
    
    const isUnlocked = game.player.learnedSkills.includes(skill.id);
    const canUnlock = availablePoints >= skill.cost && 
                     skill.requires.every(req => game.player.learnedSkills.includes(req)) &&
                     !isUnlocked;
    
    if (isUnlocked) {
      skillElement.classList.add('unlocked');
    } else if (canUnlock) {
      skillElement.classList.add('available');
    } else {
      skillElement.classList.add('locked');
    }
    
    if (skill.requires.length > 0) {
      skillElement.classList.add('requires');
    }
    
    skillElement.innerHTML = `
      <div style="font-weight: bold;">${skill.name}</div>
      <div class="skill-description">${skill.description}</div>
      <div class="skill-cost">Cost: ${skill.cost}</div>
    `;
    
    if (canUnlock) {
      skillElement.addEventListener('click', () => learnSkill(skill));
    }
    
    categoryDiv.appendChild(skillElement);
  });
  
  container.appendChild(categoryDiv);
}

function learnSkill(skill) {
  const skillPoints = Math.max(0, game.player.level - 1 - (game.player.learnedSkills ? game.player.learnedSkills.length : 0));
  
  if (skillPoints >= skill.cost && 
      skill.requires.every(req => game.player.learnedSkills.includes(req))) {
    
    if (!game.player.learnedSkills) {
      game.player.learnedSkills = [];
    }
    
    game.player.learnedSkills.push(skill.id);
    skill.effect(game.player);
    
    VisualFeedback.showAchievement(
      `Skill Learned: ${skill.name}`,
      skill.description
    );
    
    soundManager.play('levelup');
    renderSkillTree();
    updateUI();
  }
}

// Interactive Map Functions
function openInteractiveMap() {
  document.getElementById('interactive-map-modal').style.display = 'block';
  interactiveMap.render();
  soundManager.play('map');
}

function closeInteractiveMap() {
  document.getElementById('interactive-map-modal').style.display = 'none';
}

function startGame(character, isNewGamePlus = false) {
  if (isNewGamePlus) {
    // Load from completed game
    const completedGame = JSON.parse(localStorage.getItem('draculasCurseCompleted'));
    game.player = completedGame.player;
    game.newGamePlus = true;
    game.difficulty = 'hard'; // Automatically increase difficulty for NG+
  } else {
    // New game
    game.player = JSON.parse(JSON.stringify(game.characters[character]));
    game.player.gold = 50;
    game.player.level = 1;
    game.player.xp = 0;
    game.player.nextLevelXp = 100;
    game.player.equippedWeapon = "fists";
    game.player.inventory = game.player.inventory || [];
    game.player.inventory.push("health-potion", "health-potion");
    game.player.unlockedAbilities = [];
    game.player.learnedSkills = [];
    
    // Character-specific starting items
    if (character === 'quincey') {
      game.player.inventory.push("revolver");
    }
    if (character === 'vanhelsing') {
      game.player.inventory.push("sun-bomb");
    }
  }
  
  game.difficulty = document.getElementById('difficulty').value;
  game.location = 0;
  game.day = 1;
  game.hasStake = false;
  game.statusEffects = [];
  game.enemyStatusEffects = [];
  
  // Apply difficulty
  applyDifficulty();
  
  // Initialize map data
  interactiveMap.visitLocation(0); // Tavern
  interactiveMap.discoverLocation(1); // Forest
  
  // Show game UI
  document.getElementById('character-selection').style.display = 'none';
  document.getElementById('main-game').style.display = 'flex';
  document.getElementById('save-button').style.display = 'block';
  
  // Update UI
  updateUI();
  bindButtons();
  
  // Start game
  updateLocation();
  if (isNewGamePlus) {
    addToScene(`You awaken with a start... the nightmare begins again. But you are stronger now.`);
  } else {
    addToScene(`You awaken in the tavern as ${game.player.name}, ready to face the horrors ahead.`);
  }
  
  // Auto-save after starting
  setTimeout(autoSaveGame, 1000);
}

function applyDifficulty() {
  const modifier = {
    easy: { hp: 0.8, damage: 0.8, reward: 1.2 },
    normal: { hp: 1, damage: 1, reward: 1 },
    hard: { hp: 1.3, damage: 1.3, reward: 0.8 },
    nightmare: { hp: 1.8, damage: 1.5, reward: 0.5 }
  }[game.difficulty];
  
  // Adjust enemies
  Object.keys(game.enemies).forEach(key => {
    game.enemies[key].hp = Math.floor(game.enemies[key].hp * modifier.hp * (game.newGamePlus ? 1.5 : 1));
    game.enemies[key].maxHp = game.enemies[key].hp;
    game.enemies[key].damage = Math.floor(game.enemies[key].damage * modifier.damage * (game.newGamePlus ? 1.2 : 1));
    game.enemies[key].xp = Math.floor(game.enemies[key].xp * modifier.reward);
    game.enemies[key].gold = Math.floor(game.enemies[key].gold * modifier.reward);
  });
}

function updateUI() {
  // Stats
  document.getElementById('current-hp').textContent = game.player.hp;
  document.getElementById('max-hp').textContent = game.player.maxHp;
  document.getElementById('current-sanity').textContent = game.player.sanity;
  document.getElementById('max-sanity').textContent = game.player.maxSanity;
  document.getElementById('player-level').textContent = game.player.level;
  document.getElementById('level-badge').textContent = game.player.level;
  document.getElementById('player-gold').textContent = game.player.gold;
  document.getElementById('game-day').textContent = game.day;
  document.getElementById('skill-points').textContent = Math.max(0, game.player.level - 1 - (game.player.learnedSkills ? game.player.learnedSkills.length : 0));
  
  // Bars
  document.getElementById('player-health-fill').style.width = `${(game.player.hp / game.player.maxHp) * 100}%`;
  document.getElementById('player-sanity-fill').style.width = `${(game.player.sanity / game.player.maxSanity) * 100}%`;
  document.getElementById('level-progress').style.width = `${(game.player.xp / game.player.nextLevelXp) * 100}%`;
  
  // Weapon
  const weapon = game.items[game.player.equippedWeapon] || game.items.fists;
  document.getElementById('equipped-weapon-name').textContent = weapon.name;
  document.getElementById('equipped-weapon-dmg').textContent = weapon.damage;
  
  // Status effects
  updateStatusEffects();
  
  // Visual feedback for low health/sanity
  const sceneDesc = document.getElementById('scene-description');
  if (game.player.hp / game.player.maxHp < 0.3) {
    sceneDesc.classList.add('health-low');
  } else {
    sceneDesc.classList.remove('health-low');
  }
  
  if (game.player.sanity / game.player.maxSanity < 0.3) {
    sceneDesc.classList.add('sanity-low');
  } else {
    sceneDesc.classList.remove('sanity-low');
  }
  
  // Update mobile control button text
  document.getElementById('mobile-explore').textContent = game.location === 0 ? "LEAVE" : "EXPLORE";
  document.getElementById('mobile-action').textContent = game.location === 0 ? "TALK" : "RETURN";
}

function updateStatusEffects() {
  const statusContainer = document.getElementById('status-effects');
  statusContainer.innerHTML = '';
  
  game.statusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    const span = document.createElement('span');
    span.textContent = effectType.name;
    span.className = effectType.class;
    span.style.marginRight = '5px';
    span.style.padding = '2px 5px';
    span.style.fontSize = '0.8em';
    statusContainer.appendChild(span);
  });
}

function bindButtons() {
  // Modals
  document.getElementById('save-button').onclick = openSaveLoadModal;
  
  // Combat
  document.getElementById('attack-button').onclick = playerAttack;
  document.getElementById('special-button').onclick = specialAttack;
  document.getElementById('use-item-button').onclick = useItemInCombat;
  document.getElementById('flee-button').onclick = attemptFlee;
  
  // Close buttons
  document.getElementById('close-inventory').onclick = hideAllModals;
  document.getElementById('close-merchant').onclick = hideAllModals;
  document.getElementById('close-character').onclick = hideAllModals;
  document.getElementById('close-quests').onclick = hideAllModals;
  document.getElementById('close-save-load').onclick = hideAllModals;
  document.getElementById('close-skills').onclick = closeSkills;
  document.getElementById('close-map').onclick = closeInteractiveMap;
  
  // Save/Load
  document.getElementById('save-game-btn').onclick = saveCurrentGame;
  
  // Game over
  document.getElementById('try-again-button').onclick = tryAgain;
  document.getElementById('main-menu-button').onclick = returnToMainMenu;
  
  // New Game+
  document.getElementById('start-new-game-plus').onclick = () => {
    document.getElementById('new-game-plus-modal').style.display = 'none';
    const completedGame = JSON.parse(localStorage.getItem('draculasCurseCompleted'));
    startGame(completedGame.player.character, true);
  };
  document.getElementById('regular-new-game').onclick = () => {
    document.getElementById('new-game-plus-modal').style.display = 'none';
    document.getElementById('character-selection').style.display = 'flex';
  };
}

// Enhanced Save System
function openSaveLoadModal() {
  document.getElementById('save-load-modal').style.display = 'block';
  loadSaveSlots();
}

function loadSaveSlots() {
  game.saveSlots = JSON.parse(localStorage.getItem('draculasCurseSaveSlots') || '[]');
  const saveSlotsContainer = document.getElementById('save-slots');
  saveSlotsContainer.innerHTML = '';
  
  if (game.saveSlots.length === 0) {
    saveSlotsContainer.innerHTML = '<p>No saved games found.</p>';
    return;
  }
  
  game.saveSlots.forEach((slot, index) => {
    const slotElement = document.createElement('div');
    slotElement.className = 'save-slot';
    slotElement.innerHTML = `
      <div><strong>${slot.name}</strong> - Day ${slot.gameState.day}</div>
      <div>${slot.gameState.player.name} - Level ${slot.gameState.player.level}</div>
      <div>Location: ${slot.gameState.locations[slot.gameState.location].name}</div>
      <div>Saved: ${new Date(slot.timestamp).toLocaleString()}</div>
      <button class="load-slot-btn" data-index="${index}">LOAD</button>
      <button class="delete-slot-btn" data-index="${index}">DELETE</button>
    `;
    saveSlotsContainer.appendChild(slotElement);
  });
  
  // Add event listeners
  document.querySelectorAll('.load-slot-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const index = parseInt(this.dataset.index);
      loadGameFromSlot(index);
    });
  });
  
  document.querySelectorAll('.delete-slot-btn').forEach(btn => {
    btn.addEventListener('click', function() {
      const index = parseInt(this.dataset.index);
      deleteSaveSlot(index);
    });
  });
}

function saveCurrentGame() {
  const saveName = document.getElementById('save-name').value || `Save_${new Date().toLocaleDateString()}`;
  
  const saveData = {
    name: saveName,
    timestamp: Date.now(),
    gameState: {
      player: JSON.parse(JSON.stringify(game.player)),
      location: game.location,
      day: game.day,
      difficulty: game.difficulty,
      hasStake: game.hasStake,
      newGamePlus: game.newGamePlus,
      statusEffects: JSON.parse(JSON.stringify(game.statusEffects)),
      locations: JSON.parse(JSON.stringify(game.locations)),
      quests: JSON.parse(JSON.stringify(game.quests))
    }
  };
  
  // Check if we're updating an existing save
  const existingIndex = game.saveSlots.findIndex(slot => slot.name === saveName);
  if (existingIndex !== -1) {
    game.saveSlots[existingIndex] = saveData;
  } else {
    game.saveSlots.push(saveData);
  }
  
  // Limit to 10 save slots
  if (game.saveSlots.length > 10) {
    game.saveSlots = game.saveSlots.slice(-10);
  }
  
  localStorage.setItem('draculasCurseSaveSlots', JSON.stringify(game.saveSlots));
  addToScene(`Game saved as "${saveName}"`);
  loadSaveSlots();
  hideAllModals();
}

function autoSaveGame() {
  if (!game.player || game.player.hp <= 0) return;
  
  const saveData = {
    name: 'AUTOSAVE',
    timestamp: Date.now(),
    gameState: {
      player: JSON.parse(JSON.stringify(game.player)),
      location: game.location,
      day: game.day,
      difficulty: game.difficulty,
      hasStake: game.hasStake,
      newGamePlus: game.newGamePlus,
      statusEffects: JSON.parse(JSON.stringify(game.statusEffects)),
      locations: JSON.parse(JSON.stringify(game.locations)),
      quests: JSON.parse(JSON.stringify(game.quests))
    }
  };
  
  localStorage.setItem('draculasCurseAutoSave', JSON.stringify(saveData));
}

function loadGameFromSlot(index) {
  const saveData = game.saveSlots[index];
  if (!saveData) return;
  
  Object.assign(game, saveData.gameState);
  
  document.getElementById('character-selection').style.display = 'none';
  document.getElementById('main-game').style.display = 'flex';
  document.getElementById('save-button').style.display = 'block';
  
  updateUI();
  bindButtons();
  updateLocation();
  addToScene(`Game loaded: "${saveData.name}". Welcome back, ${game.player.name}!`);
  hideAllModals();
}

function deleteSaveSlot(index) {
  game.saveSlots.splice(index, 1);
  localStorage.setItem('draculasCurseSaveSlots', JSON.stringify(game.saveSlots));
  loadSaveSlots();
}

// Game Actions with Enhanced Visual Feedback
function explore() {
  clearScene();
  if (game.location === 0) {
    game.location = 1;
    updateLocation();
    interactiveMap.visitLocation(1);
    addToScene(game.locations[1].desc);
    
    // Random travel event
    if (Math.random() < 0.5) {
      const event = game.travelEvents[Math.floor(Math.random() * game.travelEvents.length)];
      addToScene(event.text);
      
      switch(event.effect) {
        case "findItem":
          findItem();
          break;
        case "loseSanity":
          // Check for Spirit Ward protection
          const spiritWard = game.statusEffects.find(e => e.type === "spirit-ward");
          if (!spiritWard) {
            game.player.sanity = Math.max(0, game.player.sanity - event.amount);
            updateUI();
            VisualFeedback.showDamage(event.amount, document.getElementById('scene-description'));
          } else {
            addToScene("Spirit Ward protects your sanity from the eerie whispers.");
          }
          break;
        case "progressFaster":
          game.location = Math.min(game.location + 1, game.locations.length - 1);
          updateLocation();
          interactiveMap.visitLocation(game.location);
          break;
        case "revealHidden":
          // Mina's ability reveals hidden locations
          if (game.player.skills.includes("CLAIRVOYANCE")) {
            game.locations.forEach(loc => {
              if (loc.hidden) loc.hidden = false;
            });
            addToScene("The journal reveals hidden locations in the castle!");
          }
          break;
        case "mysteriousMerchant":
          const rareItems = ["vampire-killer", "blessed-blade", "sun-bomb"];
          const offeredItem = rareItems[Math.floor(Math.random() * rareItems.length)];
          const price = Math.floor(game.items[offeredItem].damage * 3);
          
          if (confirm(`A mysterious figure offers you ${game.items[offeredItem].name} for ${price} gold. Accept?`)) {
            if (game.player.gold >= price) {
              game.player.gold -= price;
              game.player.inventory.push(offeredItem);
              addToScene(`You obtained ${game.items[offeredItem].name}!`);
              updateUI();
            } else {
              addToScene("You don't have enough gold for the mysterious offer.");
            }
          }
          break;
      }
    }
    
    // Discover adjacent locations
    const currentLocation = interactiveMap.mapData.locations.find(l => l.id === game.location);
    currentLocation.connections.forEach(adjacentId => {
      interactiveMap.discoverLocation(adjacentId);
    });
    
    setTimeout(() => startRandomEncounter(), 1000);
  } else {
    addToScene(`You explore the ${game.locations[game.location].name.toLowerCase()}...`);
    
    // Check for hidden areas (Mina's ability)
    if (game.player.skills.includes("CLAIRVOYANCE") && Math.random() < 0.3) {
      // Check if there are hidden locations to find
      const hiddenLocations = game.locations.filter(l => l.hidden);
      if (hiddenLocations.length > 0) {
        const foundLocation = hiddenLocations[Math.floor(Math.random() * hiddenLocations.length)];
        foundLocation.hidden = false;
        interactiveMap.discoverLocation(game.locations.indexOf(foundLocation));
        addToScene("Your sixth sense tingles... you find a hidden path to " + foundLocation.name + "!");
        return;
      }
    }
    
    if (Math.random() < 0.7) {
      setTimeout(() => startRandomEncounter(), 1000);
    } else if (Math.random() < 0.5) {
      findItem();
    } else {
      setTimeout(() => addToScene("You find nothing of interest."), 1000);
    }
  }
  
  // Sound feedback
  soundManager.play('explore');
  
  // Auto-save after exploring
  setTimeout(autoSaveGame, 500);
}

function findItem() {
  let possibleItems = ["health-potion", "holy-water", "garlic"];
  
  // Mina's Sixth Sense ability gives better items
  if (game.player.skills.includes("SIXTH SENSE")) {
    possibleItems = possibleItems.concat(["antidote", "silver-dagger", "sun-bomb"]);
  }
  
  // Higher level characters find better items
  if (game.player.level > 3) {
    possibleItems.push("wooden-stake");
  }
  if (game.player.level > 5) {
    possibleItems.push("blessed-blade");
  }
  if (game.player.level > 7) {
    possibleItems.push("vampire-killer");
  }
  
  const foundItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
  game.player.inventory.push(foundItem);
  addToScene(`You found a ${game.items[foundItem].name}!`);
  VisualFeedback.showItem(game.items[foundItem].name, document.getElementById('scene-description'));
}

function startRandomEncounter() {
  const enemies = game.locations[game.location].enemies;
  const enemyType = enemies[Math.floor(Math.random() * enemies.length)];
  startCombat(enemyType);
}

function startCombat(enemyType) {
  game.inCombat = true;
  game.currentEnemy = JSON.parse(JSON.stringify(game.enemies[enemyType]));
  game.enemyStatusEffects = [];
  
  // Update UI
  document.getElementById('combat-title').textContent = `COMBAT: ${game.currentEnemy.name}`;
  document.getElementById('enemy-name').textContent = game.currentEnemy.name;
  document.getElementById('enemy-hp').textContent = game.currentEnemy.hp;
  document.getElementById('enemy-max-hp').textContent = game.currentEnemy.maxHp;
  document.getElementById('enemy-hp-bar').style.width = '100%';
  
  document.getElementById('player-name').textContent = game.player.name;
  document.getElementById('player-hp-combat').textContent = game.player.hp;
  document.getElementById('player-max-hp-combat').textContent = game.player.maxHp;
  document.getElementById('player-hp-bar').style.width = `${(game.player.hp / game.player.maxHp) * 100}%`;
  document.getElementById('player-sanity-combat').textContent = game.player.sanity;
  document.getElementById('player-max-sanity-combat').textContent = game.player.maxSanity;
  document.getElementById('player-sanity-bar').style.width = `${(game.player.sanity / game.player.maxSanity) * 100}%`;
  
  // Show enemy weaknesses if Van Helsing has Vampire Knowledge
  const weaknessDisplay = document.getElementById('enemy-weakness-display');
  const weaknessList = document.getElementById('enemy-weakness-list');
  if (game.player.skills.includes("VAMPIRE KNOWLEDGE") || (game.player.seeWeaknesses && game.currentEnemy.name.includes("VAMPIRE"))) {
    weaknessDisplay.style.display = 'block';
    weaknessList.innerHTML = '';
    game.currentEnemy.weakness.forEach(weakness => {
      const weaknessElement = document.createElement('span');
      weaknessElement.className = 'weakness-item';
      weaknessElement.textContent = weakness.toUpperCase();
      weaknessList.appendChild(weaknessElement);
    });
  } else {
    weaknessDisplay.style.display = 'none';
  }
  
  // Set combat log
  const combatLog = document.getElementById('combat-log-modal');
  combatLog.innerHTML = `<p>A ${game.currentEnemy.name} ATTACKS!</p>`;
  
  // Special enemy intro
  if (enemyType === "dracula") {
    combatLog.innerHTML += `<p>"I AM DRACULA! YOU DARE CHALLENGE ME?"</p>`;
  } else if (enemyType === "werewolf") {
    combatLog.innerHTML += `<p>The beast howls as it charges at you!</p>`;
  } else if (enemyType === "fallen-paladin") {
    combatLog.innerHTML += `<p>"You shall not pass, mortal!" the corrupted paladin declares.</p>`;
  } else if (enemyType === "lich") {
    combatLog.innerHTML += `<p>"Your soul will make a fine addition to my collection!" the lich cackles.</p>`;
  }
  
  // Show modal
  document.getElementById('combat-modal').style.display = 'block';
  updateCombatStatusEffects();
  
  // Quincey's Quick Draw ability
  if ((game.player.skills.includes("QUICK DRAW") || game.player.quickDraw) && Math.random() < 0.75) {
    setTimeout(() => {
      addCombatLog("QUICK DRAW: You attack first!");
      playerAttack();
    }, 500);
  }
}

// Improved combat balance with visual feedback
function playerAttack() {
  if (!game.inCombat) return;
  
  // Check if charmed
  const charmed = game.statusEffects.find(e => e.type === "charmed");
  if (charmed) {
    addCombatLog(`You are charmed and can't attack!`);
    game.statusEffects = game.statusEffects.filter(e => e.type !== "charmed");
    updateStatusEffects();
    setTimeout(() => enemyAttack(), 1000);
    return;
  }
  
  const weapon = game.items[game.player.equippedWeapon] || game.items.fists;
  let damage = weapon.damage + Math.floor(Math.random() * 4);
  
  // Strength bonus (balanced)
  damage += Math.floor(game.player.strength / 3);
  
  // Check for critical (Quincey's Marksmanship - balanced)
  const critChance = 0.05 + (game.player.agility / 200) + 
    (game.player.skills.includes("MARKSMANSHIP") ? 0.2 : 0) +
    (game.player.critChance || 0);
  const isCritical = Math.random() < critChance;
  if (isCritical) damage = Math.floor(damage * (1.5 + (game.player.critDamage || 0)));
  
  // Check for weapon special effects
  if (weapon.special && Array.isArray(weapon.special) 
      ? weapon.special.some(s => game.currentEnemy.weakness.includes(s))
      : game.currentEnemy.weakness.includes(weapon.special)) {
    damage = Math.floor(damage * 1.5);
    addCombatLog(`${weapon.name} IS EFFECTIVE!`);
  }
  
  // Jonathan's Silver Strike ability (balanced)
  if (game.player.skills.includes("SILVER STRIKE") && weapon.special === "silver") {
    damage = Math.floor(damage * 1.8);
    addCombatLog(`SILVER STRIKE ACTIVATED!`);
  }
  
  // Jonathan's Vampire Slayer ability
  if (game.player.unlockedAbilities.includes("VAMPIRE SLAYER") && 
      (game.currentEnemy.name.includes("VAMPIRE") || game.currentEnemy.name === "COUNT DRACULA")) {
    damage = Math.floor(damage * 1.25);
    addCombatLog(`VAMPIRE SLAYER: +25% DAMAGE!`);
  }
  
  // Check for Final Blow (execute below 20%)
  if (game.player.unlockedAbilities.includes("FINAL BLOW") && 
      game.currentEnemy.hp <= game.currentEnemy.maxHp * 0.2) {
    damage = game.currentEnemy.hp;
    addCombatLog(`FINAL BLOW: Execute!`);
  }
  
  // Apply damage
  game.currentEnemy.hp -= damage;
  
  // Update UI
  const hpPercent = (game.currentEnemy.hp / game.currentEnemy.maxHp) * 100;
  document.getElementById('enemy-hp').textContent = Math.max(0, game.currentEnemy.hp);
  document.getElementById('enemy-hp-bar').style.width = `${Math.max(0, hpPercent)}%`;
  
  // Show damage number
  VisualFeedback.showDamage(damage, document.getElementById('enemy-display'), isCritical);
  
  // Animation
  document.getElementById('enemy-display').classList.add('shake');
  setTimeout(() => document.getElementById('enemy-display').classList.remove('shake'), 400);
  
  addCombatLog(`YOU HIT FOR ${damage} DAMAGE!${isCritical ? ' <span class="critical">CRITICAL!</span>' : ''}`);
  
  // Apply status effects from weapon
  if (weapon.special === "silver" && Math.random() < 0.2) {
    applyEnemyStatusEffect("bleed");
  }
  
  // Check if enemy defeated
  if (game.currentEnemy.hp <= 0) {
    enemyDefeated();
    return;
  }
  
  // Enemy counterattack
  setTimeout(() => enemyAttack(), 1000);
}

function enemyAttack() {
  if (!game.inCombat) return;
  
  let damage = game.currentEnemy.damage + Math.floor(Math.random() * 4);
  
  // Check for parry (Jonathan's ability - balanced)
  if (game.player.skills.includes("PARRY") && Math.random() < 0.25) {
    addCombatLog(`PARRY: You block the attack!`);
    setTimeout(() => playerAttack(), 1000);
    return;
  }
  
  // Check for shield effect
  const shield = game.statusEffects.find(e => e.type === "shield");
  if (shield) {
    damage = Math.floor(damage * (1 - game.statusEffectTypes.shield.damageReduction));
    addCombatLog(`SHIELD: Damage reduced by 30%!`);
  }
  
  // Apply damage resistance from skills
  if (game.player.damageResistance) {
    damage = Math.floor(damage * (1 - game.player.damageResistance));
  }
  
  // Apply status effects from enemy special
  switch(game.currentEnemy.special) {
    case "bleed":
      if (Math.random() < 0.3) {
        applyStatusEffect("bleed");
        addCombatLog(`The ${game.currentEnemy.name}'s attack makes you bleed!`);
      }
      break;
    case "charm":
      if (Math.random() < 0.25 && !game.player.mentalFortitude) {
        applyStatusEffect("charmed");
        addCombatLog(`${game.currentEnemy.name} CHARMS YOU! YOU CAN'T ATTACK NEXT TURN!`);
      }
      break;
    case "howl":
      if (Math.random() < 0.4) {
        damage = Math.floor(damage * 1.5);
        addCombatLog(`${game.currentEnemy.name} HOWLS, increasing its attack power!`);
      }
      break;
    case "disease":
      if (Math.random() < 0.25 && !game.player.diseaseImmunity) {
        applyStatusEffect("poison");
        addCombatLog(`The ${game.currentEnemy.name} infects you with disease!`);
      }
      break;
    case "screech":
      // Check for Spirit Ward protection
      const spiritWard = game.statusEffects.find(e => e.type === "spirit-ward");
      if (!spiritWard) {
        game.player.sanity = Math.max(0, game.player.sanity - 10);
        updateUI();
        addCombatLog(`The ${game.currentEnemy.name} SCREECHES, damaging your sanity!`);
      } else {
        addCombatLog(`Spirit Ward protects you from the sanity-damaging screech!`);
      }
      break;
    case "transform":
      if (!game.currentEnemy.transformed && game.currentEnemy.hp < game.currentEnemy.maxHp / 2) {
        game.currentEnemy.transformed = true;
        game.currentEnemy.damage += 5;
        addCombatLog(`${game.currentEnemy.name} TRANSFORMS! ATTACK INCREASED!`);
      }
      break;
    case "drain":
      if (Math.random() < 0.4) {
        applyStatusEffect("drain");
        addCombatLog(`${game.currentEnemy.name} DRAINS YOUR LIFE FORCE!`);
      }
      break;
    case "regenerate":
      if (Math.random() < 0.5) {
        applyEnemyStatusEffect("regenerate");
        addCombatLog(`${game.currentEnemy.name} begins to regenerate!`);
      }
      break;
    case "raise-dead":
      if (Math.random() < 0.3) {
        addCombatLog(`${game.currentEnemy.name} raises fallen allies!`);
        // Could add minions here in a more complex implementation
      }
      break;
  }
  
  // Apply damage
  game.player.hp -= damage;
  updateUI();
  
  // Update combat UI
  document.getElementById('player-hp-combat').textContent = game.player.hp;
  document.getElementById('player-hp-bar').style.width = `${(game.player.hp / game.player.maxHp) * 100}%`;
  
  // Show damage number
  VisualFeedback.showDamage(damage, document.getElementById('player-display'), false);
  
  // Animation
  document.getElementById('player-display').classList.add('flash-red');
  setTimeout(() => document.getElementById('player-display').classList.remove('flash-red'), 300);
  
  addCombatLog(`${game.currentEnemy.name} HITS YOU FOR ${damage} DAMAGE!`);
  
  // Apply status effects
  applyStatusEffectsDamage();
  updateCombatStatusEffects();
  
  // Check if player defeated
  if (game.player.hp <= 0) {
    playerDefeated();
  }
}

function applyStatusEffect(type) {
  const existing = game.statusEffects.find(e => e.type === type);
  if (existing) {
    existing.duration = game.statusEffectTypes[type].duration; // Refresh duration
  } else {
    game.statusEffects.push({
      type: type,
      duration: game.statusEffectTypes[type].duration
    });
  }
  updateStatusEffects();
}

function applyEnemyStatusEffect(type) {
  const existing = game.enemyStatusEffects.find(e => e.type === type);
  if (existing) {
    existing.duration = game.statusEffectTypes[type].duration; // Refresh duration
  } else {
    game.enemyStatusEffects.push({
      type: type,
      duration: game.statusEffectTypes[type].duration
    });
  }
  updateCombatStatusEffects();
}

function applyStatusEffectsDamage() {
  // Player status effects
  game.statusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    if (effectType.damage) {
      game.player.hp = Math.max(0, game.player.hp - effectType.damage);
      addCombatLog(`${effectType.name}: -${effectType.damage} HP`);
    }
    if (effectType.sanityLoss) {
      // Check for Spirit Ward protection
      const spiritWard = game.statusEffects.find(e => e.type === "spirit-ward");
      if (!spiritWard) {
        game.player.sanity = Math.max(0, game.player.sanity - effectType.sanityLoss);
        addCombatLog(`${effectType.name}: -${effectType.sanityLoss} SAN`);
      } else {
        addCombatLog(`Spirit Ward protects you from sanity loss!`);
      }
    }
    if (effectType.healEnemy) {
      game.currentEnemy.hp = Math.min(game.currentEnemy.maxHp, game.currentEnemy.hp + effectType.damage);
      addCombatLog(`${effectType.name}: Enemy heals ${effectType.damage} HP`);
    }
  });
  
  // Enemy status effects
  game.enemyStatusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    if (effectType.damage) {
      game.currentEnemy.hp = Math.max(0, game.currentEnemy.hp - effectType.damage);
      addCombatLog(`${effectType.name}: -${effectType.damage} HP to enemy`);
    }
    if (effectType.heal) {
      game.currentEnemy.hp = Math.min(game.currentEnemy.maxHp, game.currentEnemy.hp + effectType.heal);
      addCombatLog(`${effectType.name}: Enemy heals ${effectType.heal} HP`);
    }
  });
  
  // Update durations
  game.statusEffects.forEach(effect => effect.duration--);
  game.enemyStatusEffects.forEach(effect => effect.duration--);
  
  // Remove expired effects
  game.statusEffects = game.statusEffects.filter(e => e.duration > 0);
  game.enemyStatusEffects = game.enemyStatusEffects.filter(e => e.duration > 0);
  
  updateUI();
}

function updateCombatStatusEffects() {
  const playerEffects = document.getElementById('player-combat-status-effects');
  const enemyEffects = document.getElementById('enemy-status-effects');
  
  playerEffects.innerHTML = '';
  enemyEffects.innerHTML = '';
  
  game.statusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    const span = document.createElement('div');
    span.textContent = `${effectType.name} (${effect.duration})`;
    span.className = effectType.class;
    playerEffects.appendChild(span);
  });
  
  game.enemyStatusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    const span = document.createElement('div');
    span.textContent = `${effectType.name} (${effect.duration})`;
    span.className = effectType.class;
    enemyEffects.appendChild(span);
  });
}

function enemyDefeated() {
  // Award XP and gold
  game.player.xp += game.currentEnemy.xp;
  game.player.gold += game.currentEnemy.gold;
  
  // Visual feedback
  VisualFeedback.showXP(game.currentEnemy.xp, document.getElementById('enemy-display'));
  VisualFeedback.showGold(game.currentEnemy.gold, document.getElementById('enemy-display'));
  
  // Combat heal from skills
  if (game.player.combatHeal) {
    const healAmount = Math.min(game.player.combatHeal, game.player.maxHp - game.player.hp);
    if (healAmount > 0) {
      game.player.hp += healAmount;
      VisualFeedback.showHeal(healAmount, document.getElementById('player-display'));
      addCombatLog(`QUICK RECOVERY: +${healAmount} HP`);
    }
  }
  
  addCombatLog(`${game.currentEnemy.name} DEFEATED! +${game.currentEnemy.xp} XP | +${game.currentEnemy.gold} GOLD`);
  
  // Victory animation
  document.getElementById('player-display').classList.add('victory');
  setTimeout(() => {
    document.getElementById('player-display').classList.remove('victory');
  }, 2000);
  
  // Check for quest completion
  if (game.currentEnemy.name === "COUNT DRACULA") {
    completeQuest("slay-dracula");
    // Mark game as completed for New Game+
    localStorage.setItem('draculasCurseCompleted', JSON.stringify({
      player: {
        ...game.player,
        character: Object.keys(game.characters).find(key => game.characters[key].name === game.player.name)
      }
    }));
    document.getElementById('new-game-plus-button').style.display = 'block';
  } else if (game.currentEnemy.name === "WEREWOLF") {
    completeQuest("kill-werewolf");
  } else if (game.currentEnemy.name === "MAD ALCHEMIST") {
    completeQuest("defeat-alchemist");
  } else if (game.currentEnemy.name === "FALLEN PALADIN") {
    completeQuest("explore-chapel");
  } else if (game.currentEnemy.name === "LICH") {
    completeQuest("clear-crypt");
  } else if (game.currentEnemy.name === "BLOOD ELEMENTAL") {
    completeQuest("destroy-fountain");
  }
  
  // Check for level up
  if (game.player.xp >= game.player.nextLevelXp) {
    levelUp();
  }
  
  updateUI();
  
  // End combat
  setTimeout(() => {
    game.inCombat = false;
    game.statusEffects = [];
    document.getElementById('combat-modal').style.display = 'none';
    addToScene(`You defeated the ${game.currentEnemy.name}!`);
    
    // Mark location as visited on map
    interactiveMap.visitLocation(game.location);
    
    // Auto-save after combat
    autoSaveGame();
    
    // Progress through locations
    if (game.currentEnemy.name === "COUNT DRACULA") {
      // Game completed
      addToScene("CONGRATULATIONS! You have defeated Dracula and lifted the curse!");
      addToScene("The villagers will sing songs of your bravery for generations to come.");
    } else if (game.location < game.locations.length - 1 && Math.random() < 0.3) {
      game.location++;
      updateLocation();
      interactiveMap.visitLocation(game.location);
      addToScene(`You progress deeper into the castle...`);
      addToScene(game.locations[game.location].desc);
    }
  }, 1500);
}

function levelUp() {
  game.player.level++;
  game.player.xp -= game.player.nextLevelXp;
  game.player.nextLevelXp = Math.floor(game.player.nextLevelXp * 1.5);
  
  // Stat increases
  game.player.maxHp += 10;
  game.player.hp = game.player.maxHp;
  game.player.maxSanity += 5;
  game.player.sanity = game.player.maxSanity;
  
  // Random stat boost
  const stat = ["strength", "agility", "intelligence"][Math.floor(Math.random() * 3)];
  game.player[stat]++;
  
  // Check for ability unlocks
  if (game.player.level === 5) {
    if (game.player.name === "JONATHAN HARKER") {
      game.player.unlockedAbilities.push("VAMPIRE SLAYER");
      game.player.skills.push("VAMPIRE SLAYER");
    } else if (game.player.name === "VAN HELSING") {
      game.player.unlockedAbilities.push("ALCHEMICAL SHIELD");
      game.player.skills.push("ALCHEMICAL SHIELD");
    } else if (game.player.name === "MINA MURRAY") {
      game.player.unlockedAbilities.push("CLAIRVOYANCE");
      game.player.skills.push("CLAIRVOYANCE");
    } else if (game.player.name === "QUINCEY MORRIS") {
      game.player.unlockedAbilities.push("FAN FIRE");
      game.player.skills.push("FAN FIRE");
    }
  }
  
  if (game.player.level === 10) {
    if (game.player.name === "JONATHAN HARKER") {
      game.player.unlockedAbilities.push("FINAL BLOW");
      game.player.skills.push("FINAL BLOW");
    } else if (game.player.name === "VAN HELSING") {
      game.player.unlockedAbilities.push("SUN BOMB");
      game.player.skills.push("SUN BOMB");
    } else if (game.player.name === "MINA MURRAY") {
      game.player.unlockedAbilities.push("SPIRIT WARD");
      game.player.skills.push("SPIRIT WARD");
    } else if (game.player.name === "QUINCEY MORRIS") {
      game.player.unlockedAbilities.push("SILVER BULLET");
      game.player.skills.push("SILVER BULLET");
    }
  }
  
  addCombatLog(`LEVEL UP! NOW LEVEL ${game.player.level}`);
  addCombatLog(`+10 MAX HP | +5 MAX SANITY | +1 ${stat.toUpperCase()}`);
  
  if (game.player.level === 5 || game.player.level === 10) {
    addCombatLog(`NEW ABILITY UNLOCKED: ${game.player.unlockedAbilities[game.player.unlockedAbilities.length - 1]}!`);
  }
  
  // Visual feedback
  VisualFeedback.showAchievement(
    `Level ${game.player.level} Reached!`,
    `New skill point available!`
  );
  soundManager.play('levelup');
  
  updateUI();
}

function specialAttack() {
  if (!game.inCombat) return;
  
  if (game.player.skills.includes("SILVER STRIKE")) {
    const weapon = game.items[game.player.equippedWeapon];
    if (weapon && weapon.special === "silver") {
      playerAttack(); // Regular attack will be doubled
    } else {
      addCombatLog("YOU NEED A SILVER WEAPON!");
    }
  } else if (game.player.skills.includes("HOLY WATER")) {
    const holyWaterIndex = game.player.inventory.indexOf("holy-water");
    if (holyWaterIndex !== -1) {
      game.player.inventory.splice(holyWaterIndex, 1);
      let damage = 30; // Double effectiveness
      if (game.currentEnemy.weakness.includes("holy")) damage = Math.floor(damage * 1.5);
      
      game.currentEnemy.hp -= damage;
      document.getElementById('enemy-hp').textContent = Math.max(0, game.currentEnemy.hp);
      document.getElementById('enemy-hp-bar').style.width = `${(game.currentEnemy.hp / game.currentEnemy.maxHp) * 100}%`;
      
      addCombatLog(`YOU THROW HOLY WATER FOR ${damage} DAMAGE!`);
      
      if (game.currentEnemy.hp <= 0) {
        enemyDefeated();
      } else {
        setTimeout(() => enemyAttack(), 1000);
      }
    } else {
      addCombatLog("YOU HAVE NO HOLY WATER!");
    }
  } else if (game.player.skills.includes("HYPNOSIS")) {
    if (Math.random() < 0.6) {
      addCombatLog(`YOU HYPNOTIZE THE ${game.currentEnemy.name}! IT SKIPS ITS TURN!`);
      setTimeout(() => playerAttack(), 1000);
    } else {
      addCombatLog("YOUR HYPNOSIS FAILS!");
      setTimeout(() => enemyAttack(), 1000);
    }
  } else if (game.player.skills.includes("VAMPIRE SLAYER")) {
    if (game.currentEnemy.name.includes("VAMPIRE") || game.currentEnemy.name === "COUNT DRACULA") {
      playerAttack(); // Regular attack will get the bonus
    } else {
      addCombatLog("THIS ABILITY ONLY WORKS ON VAMPIRES!");
    }
  } else if (game.player.skills.includes("ALCHEMICAL SHIELD")) {
    applyStatusEffect("shield");
    addCombatLog("ALCHEMICAL SHIELD: Damage reduced by 30% for 2 turns!");
    setTimeout(() => enemyAttack(), 1000);
  } else if (game.player.skills.includes("FAN FIRE") || game.player.fanFire) {
    // Quincey's Fan Fire - attack 3 times at reduced damage
    const weapon = game.items[game.player.equippedWeapon] || game.items.fists;
    let totalDamage = 0;
    
    for (let i = 0; i < 3; i++) {
      let damage = Math.floor(weapon.damage * 0.6) + Math.floor(Math.random() * 3);
      damage += Math.floor(game.player.strength / 3);
      
      // Check for critical
      const isCritical = Math.random() < 0.05 + (game.player.agility / 100) + 
        (game.player.skills.includes("MARKSMANSHIP") ? 0.25 : 0) +
        (game.player.critChance || 0);
      if (isCritical) damage = Math.floor(damage * (1.5 + (game.player.critDamage || 0)));
      
      totalDamage += damage;
      addCombatLog(`Fan Fire hit for ${damage} damage${isCritical ? ' (CRIT!)' : ''}`);
    }
    
    game.currentEnemy.hp -= totalDamage;
    document.getElementById('enemy-hp').textContent = Math.max(0, game.currentEnemy.hp);
    document.getElementById('enemy-hp-bar').style.width = `${(game.currentEnemy.hp / game.currentEnemy.maxHp) * 100}%`;
    
    VisualFeedback.showDamage(totalDamage, document.getElementById('enemy-display'), false);
    
    if (game.currentEnemy.hp <= 0) {
      enemyDefeated();
    } else {
      setTimeout(() => enemyAttack(), 1000);
    }
  } else if (game.player.skills.includes("SILVER BULLET") || game.player.silverBullet) {
    // Quincey's ultimate ability
    const silverBulletIndex = game.player.inventory.indexOf("silver-bullet");
    if (silverBulletIndex !== -1) {
      game.player.inventory.splice(silverBulletIndex, 1);
      let damage = 50;
      
      if (game.currentEnemy.weakness && 
          (game.currentEnemy.weakness.includes("silver") || game.currentEnemy.weakness.includes("holy"))) {
        damage = Math.floor(damage * 1.5);
      }
      
      game.currentEnemy.hp -= damage;
      document.getElementById('enemy-hp').textContent = Math.max(0, game.currentEnemy.hp);
      document.getElementById('enemy-hp-bar').style.width = `${(game.currentEnemy.hp / game.currentEnemy.maxHp) * 100}%`;
      
      addCombatLog(`SILVER BULLET: You deal ${damage} massive damage!`);
      
      if (game.currentEnemy.hp <= 0) {
        enemyDefeated();
      } else {
        setTimeout(() => enemyAttack(), 1000);
      }
    } else {
      addCombatLog("YOU HAVE NO SILVER BULLETS!");
    }
  } else if (game.player.skills.includes("CLAIRVOYANCE") && !game.inCombat) {
    // Handled in explore function
  } else if (game.player.skills.includes("SPIRIT WARD")) {
    applyStatusEffect("spirit-ward");
    addCombatLog("SPIRIT WARD: You're protected from sanity loss for 3 turns!");
    setTimeout(() => enemyAttack(), 1000);
  } else if (game.player.skills.includes("SUN BOMB")) {
    // Van Helsing's ultimate ability
    const sunBombIndex = game.player.inventory.indexOf("sun-bomb");
    if (sunBombIndex !== -1) {
      game.player.inventory.splice(sunBombIndex, 1);
      let damage = 40;
      
      // Sun Bomb is extra effective against undead
      const undeadEnemies = ["VAMPIRE", "GHOST", "ZOMBIE", "WRAITH", "SKELETON", "LICH", "DRACULA"];
      if (undeadEnemies.some(undead => game.currentEnemy.name.includes(undead))) {
        damage = Math.floor(damage * 1.5);
        addCombatLog("SUN BOMB: Extra effective against undead!");
      }
      
      if (game.currentEnemy.weakness.includes("holy")) {
        damage = Math.floor(damage * 1.3);
      }
      
      game.currentEnemy.hp -= damage;
      document.getElementById('enemy-hp').textContent = Math.max(0, game.currentEnemy.hp);
      document.getElementById('enemy-hp-bar').style.width = `${(game.currentEnemy.hp / game.currentEnemy.maxHp) * 100}%`;
      
      addCombatLog(`SUN BOMB: You unleash holy light for ${damage} damage!`);
      
      if (game.currentEnemy.hp <= 0) {
        enemyDefeated();
      } else {
        setTimeout(() => enemyAttack(), 1000);
      }
    } else {
      addCombatLog("YOU HAVE NO SUN BOMBS!");
    }
  }
}

function playerDefeated() {
  addCombatLog("YOU HAVE BEEN DEFEATED!");
  setTimeout(() => {
    game.inCombat = false;
    document.getElementById('combat-modal').style.display = 'none';
    document.getElementById('game-over-modal').style.display = 'block';
  }, 1500);
}

function useItemInCombat() {
  openInventory();
}

function attemptFlee() {
  // Agility affects flee chance
  const fleeChance = 0.5 + (game.player.agility / 100);
  
  if (Math.random() < fleeChance) {
    addCombatLog("YOU SUCCESSFULLY FLEE!");
    setTimeout(() => {
      game.inCombat = false;
      document.getElementById('combat-modal').style.display = 'none';
      addToScene(`You barely escape from the ${game.currentEnemy.name}!`);
      
      // Return to previous location when fleeing
      if (game.location > 1) {
        game.location--;
        updateLocation();
        interactiveMap.visitLocation(game.location);
      }
    }, 1000);
  } else {
    addCombatLog("FAILED TO FLEE!");
    setTimeout(() => enemyAttack(), 1000);
  }
}

// Location Functions
function updateLocation() {
  document.getElementById('location-name').textContent = game.locations[game.location].name;
  document.getElementById('dungeon-level').textContent = game.locations[game.location].name;
  updateUI(); // This will update the mobile control button text
}

function talkToBarkeep() {
  if (!game.hasStake) {
    addToScene(`"Take this," the barkeep says, sliding a WOODEN STAKE across the counter.`);
    game.player.inventory.push("wooden-stake");
    game.hasStake = true;
    completeQuest("find-stake");
    VisualFeedback.showItem("WOODEN STAKE", document.getElementById('scene-description'));
  } else {
    const dialogues = [
      `"You still here? Don't say I didn't warn you," the barkeep mutters.`,
      `"The nights grow longer. Dracula's power increases," he whispers.`,
      `"The merchant has good wares, but don't trust him too much," he advises.`,
      `"They say there's a werewolf in the mountains... be careful out there."`,
      `"I heard there's a powerful weapon hidden in the castle dungeons."`,
      `"Some say there's a secret chapel in the castle with powerful relics."`,
      `"A mad alchemist was last seen in the castle's lower levels."`,
      `"They say an ancient crypt lies beneath the castle, filled with terrible things."`,
      `"I've heard whispers of a cursed blood fountain that empowers Dracula."`
    ];
    addToScene(dialogues[Math.floor(Math.random() * dialogues.length)]);
  }
}

function returnToTavern() {
  game.location = 0;
  updateLocation();
  interactiveMap.visitLocation(0);
  clearScene();
  addToScene(game.locations[0].desc);
}

function rest() {
  const healAmount = Math.floor(game.player.maxHp * 0.3);
  const sanityAmount = Math.floor(game.player.maxSanity * 0.2);
  
  // Apply meditation bonus
  if (game.player.meditationBonus) {
    sanityAmount = Math.floor(sanityAmount * (1 + game.player.meditationBonus));
  }
  
  game.player.hp = Math.min(game.player.maxHp, game.player.hp + healAmount);
  game.player.sanity = Math.min(game.player.maxSanity, game.player.sanity + sanityAmount);
  
  // Rest cures some status effects
  game.statusEffects = game.statusEffects.filter(e => !["bleed", "poison"].includes(e.type));
  updateStatusEffects();
  
  addToScene(`You rest and recover ${healAmount} HP and ${sanityAmount} sanity.`);
  VisualFeedback.showHeal(healAmount, document.getElementById('scene-description'));
  VisualFeedback.showSanity(sanityAmount, document.getElementById('scene-description'));
  updateUI();
  
  // Auto-save after resting
  autoSaveGame();
  
  if (game.location > 0 && Math.random() < 0.2) {
    setTimeout(() => {
      addToScene(`You are ambushed while resting!`);
      startRandomEncounter();
    }, 1000);
  }
}

// Merchant Functions
function openMerchant() {
  // Update gold display
  document.getElementById('merchant-gold-amount').textContent = game.player.gold;
  
  // Create buy list
  const buyList = document.getElementById('merchant-buy-list');
  buyList.innerHTML = '';
  
  game.merchantItems.forEach(item => {
    const itemElement = document.createElement('div');
    itemElement.className = 'merchant-item';
    itemElement.innerHTML = `
      <span>${item.name} (${item.price} GOLD)</span>
      <button class="buy-button" data-id="${item.id}" data-price="${item.price}">BUY</button>
    `;
    buyList.appendChild(itemElement);
  });
  
  // Create sell list
  const sellList = document.getElementById('merchant-sell-list');
  sellList.innerHTML = '';
  
  // Count items
  const itemCounts = {};
  game.player.inventory.forEach(item => {
    if (game.items[item] && item !== "fists") {
      itemCounts[item] = (itemCounts[item] || 0) + 1;
    }
  });
  
  // Add sellable items
  Object.keys(itemCounts).forEach(itemId => {
    const item = game.items[itemId];
    const sellPrice = Math.floor((item.damage || item.heal || 5) * 2);
    
    const itemElement = document.createElement('div');
    itemElement.className = 'merchant-item';
    itemElement.innerHTML = `
      <span>${item.name} x${itemCounts[itemId]} (${sellPrice} GOLD)</span>
      <button class="sell-button" data-id="${itemId}" data-price="${sellPrice}">SELL</button>
    `;
    sellList.appendChild(itemElement);
  });
  
  // Add event listeners
  document.querySelectorAll('.buy-button').forEach(button => {
    button.addEventListener('click', function() {
      const itemId = this.dataset.id;
      const price = parseInt(this.dataset.price);
      
      if (game.player.gold >= price) {
        game.player.gold -= price;
        game.player.inventory.push(itemId);
        updateUI();
        document.getElementById('merchant-gold-amount').textContent = game.player.gold;
        addToScene(`You bought a ${game.items[itemId].name} for ${price} gold.`);
        openMerchant(); // Refresh
      } else {
        addToScene("Not enough gold!");
      }
    });
  });
  
  document.querySelectorAll('.sell-button').forEach(button => {
    button.addEventListener('click', function() {
      const itemId = this.dataset.id;
      const price = parseInt(this.dataset.price);
      
      // Remove from inventory
      const index = game.player.inventory.indexOf(itemId);
      if (index !== -1) {
        game.player.inventory.splice(index, 1);
        game.player.gold += price;
        updateUI();
        document.getElementById('merchant-gold-amount').textContent = game.player.gold;
        addToScene(`You sold a ${game.items[itemId].name} for ${price} gold.`);
        openMerchant(); // Refresh
      }
    });
  });
  
  document.getElementById('merchant-modal').style.display = 'block';
}

// Inventory Functions
function openInventory() {
  // Weapons
  const weaponsList = document.getElementById('weapons-list');
  weaponsList.innerHTML = '';
  
  // Count weapons
  const weaponCounts = {};
  game.player.inventory.forEach(item => {
    if (game.items[item]?.damage) {
      weaponCounts[item] = (weaponCounts[item] || 0) + 1;
    }
  });
  
  // Add fists (always available)
  weaponCounts["fists"] = 1;
  
  // Display weapons
  Object.keys(weaponCounts).forEach(weaponId => {
    const weapon = game.items[weaponId];
    const isEquipped = weaponId === game.player.equippedWeapon;
    
    const weaponElement = document.createElement('div');
    weaponElement.className = 'item-row';
    weaponElement.innerHTML = `
      <span>${weapon.name} (${weapon.damage} DMG)${isEquipped ? ' [EQUIPPED]' : ''}</span>
      <button class="equip-button" data-id="${weaponId}">${isEquipped ? 'UNEQUIP' : 'EQUIP'}</button>
    `;
    weaponsList.appendChild(weaponElement);
  });
  
  // Items
  const itemsList = document.getElementById('items-list');
  itemsList.innerHTML = '';
  
  // Count items
  const itemCounts = {};
  game.player.inventory.forEach(item => {
    if (game.items[item]?.heal || game.items[item]?.special === "cure" || item === "sun-bomb") {
      itemCounts[item] = (itemCounts[item] || 0) + 1;
    }
  });
  
  // Display items
  Object.keys(itemCounts).forEach(itemId => {
    const item = game.items[itemId];
    
    const itemElement = document.createElement('div');
    itemElement.className = 'item-row';
    itemElement.innerHTML = `
      <span>${item.name} x${itemCounts[itemId]}</span>
      <button class="use-button" data-id="${itemId}">USE</button>
    `;
    itemsList.appendChild(itemElement);
  });
  
  // Add event listeners
  document.querySelectorAll('.equip-button').forEach(button => {
    button.addEventListener('click', function() {
      const weaponId = this.dataset.id;
      
      if (game.player.equippedWeapon === weaponId) {
        game.player.equippedWeapon = "fists";
        addToScene(`You unequip your weapon.`);
      } else {
        game.player.equippedWeapon = weaponId;
        addToScene(`You equip the ${game.items[weaponId].name}.`);
      }
      
      updateUI();
      openInventory(); // Refresh
    });
  });
  
  document.querySelectorAll('.use-button').forEach(button => {
    button.addEventListener('click', function() {
      const itemId = this.dataset.id;
      const item = game.items[itemId];
      
      if (item.heal) {
        let healAmount = Math.min(item.heal, game.player.maxHp - game.player.hp);
        
        // Apply healing bonus
        if (game.player.healingBonus) {
          healAmount = Math.floor(healAmount * (1 + game.player.healingBonus));
        }
        
        game.player.hp += healAmount;
        
        // Remove from inventory
        const index = game.player.inventory.indexOf(itemId);
        if (index !== -1) game.player.inventory.splice(index, 1);
        
        if (game.inCombat) {
          addCombatLog(`YOU USE A ${item.name} AND HEAL ${healAmount} HP!`);
          VisualFeedback.showHeal(healAmount, document.getElementById('player-display'));
          setTimeout(() => enemyAttack(), 1000);
        } else {
          addToScene(`You use a ${item.name} and heal ${healAmount} HP.`);
          VisualFeedback.showHeal(healAmount, document.getElementById('scene-description'));
        }
        
        updateUI();
        openInventory(); // Refresh
      } else if (item.special === "cure") {
        // Remove all negative status effects
        game.statusEffects = [];
        updateStatusEffects();
        
        // Remove from inventory
        const index = game.player.inventory.indexOf(itemId);
        if (index !== -1) game.player.inventory.splice(index, 1);
        
        if (game.inCombat) {
          addCombatLog(`YOU USE AN ${item.name} AND CURE ALL AILMENTS!`);
          setTimeout(() => enemyAttack(), 1000);
        } else {
          addToScene(`You use an ${item.name} and cure all ailments.`);
        }
        
        updateUI();
        openInventory(); // Refresh
      } else if (itemId === "sun-bomb") {
        // Can't use Sun Bomb from inventory, only from special attack
        addToScene("Sun Bomb can only be used in combat with the SPECIAL button.");
      }
    });
  });
  
  document.getElementById('inventory-modal').style.display = 'block';
}

// Character Stats
function openCharacter() {
  document.getElementById('character-name').textContent = game.player.name;
  document.getElementById('character-class').textContent = game.player.class;
  document.getElementById('character-level').textContent = game.player.level;
  
  document.getElementById('character-strength').textContent = game.player.strength;
  document.getElementById('character-agility').textContent = game.player.agility;
  document.getElementById('character-intelligence').textContent = game.player.intelligence;
  
  const skillsList = document.getElementById('character-skills');
  skillsList.innerHTML = '';
  
  game.player.skills.forEach(skill => {
    const skillElement = document.createElement('div');
    skillElement.textContent = `‚Ä¢ ${skill}`;
    skillsList.appendChild(skillElement);
  });
  
  const statusEffectsList = document.getElementById('character-status-effects');
  statusEffectsList.innerHTML = '';
  
  game.statusEffects.forEach(effect => {
    const effectType = game.statusEffectTypes[effect.type];
    const effectElement = document.createElement('div');
    effectElement.textContent = `‚Ä¢ ${effectType.name} (${effect.duration} turns)`;
    effectElement.className = effectType.class;
    statusEffectsList.appendChild(effectElement);
  });
  
  document.getElementById('character-modal').style.display = 'block';
}

// Quests
function openQuests() {
  const activeQuests = document.getElementById('active-quests');
  activeQuests.innerHTML = '';
  
  game.quests.active.forEach(quest => {
    const questElement = document.createElement('div');
    questElement.style.padding = '5px 0';
    questElement.style.borderBottom = '1px dashed red';
    questElement.innerHTML = `
      <div style="font-weight: bold;">${quest.title}</div>
      <div>${quest.description}</div>
      <div>${quest.completed ? '(Completed)' : '(Active)'}</div>
    `;
    activeQuests.appendChild(questElement);
  });
  
  const completedQuests = document.getElementById('completed-quests');
  completedQuests.innerHTML = '';
  
  game.quests.completed.forEach(quest => {
    const questElement = document.createElement('div');
    questElement.style.padding = '5px 0';
    questElement.style.borderBottom = '1px dashed red';
    questElement.innerHTML = `
      <div style="font-weight: bold; color: #0f0;">${quest.title}</div>
      <div>${quest.description}</div>
    `;
    completedQuests.appendChild(questElement);
  });
  
  const sideQuests = document.getElementById('side-quests');
  sideQuests.innerHTML = '';
  
  game.quests.side.forEach(quest => {
    if (quest.hidden && !game.player.skills.includes("CLAIRVOYANCE")) return;
    
    const questElement = document.createElement('div');
    questElement.style.padding = '5px 0';
    questElement.style.borderBottom = '1px dashed red';
    questElement.innerHTML = `
      <div style="font-weight: bold;">${quest.title}</div>
      <div>${quest.description}</div>
      <div>${quest.completed ? '(Completed)' : '(Active)'}</div>
    `;
    sideQuests.appendChild(questElement);
  });
  
  document.getElementById('quests-modal').style.display = 'block';
}

function completeQuest(questId) {
  // Main quests
  const mainQuestIndex = game.quests.active.findIndex(q => q.id === questId);
  if (mainQuestIndex !== -1) {
    const quest = game.quests.active[mainQuestIndex];
    quest.completed = true;
    
    // Move to completed
    game.quests.completed.push(quest);
    game.quests.active.splice(mainQuestIndex, 1);
    
    addToScene(`QUEST COMPLETED: ${quest.title}`);
  }
  
  // Side quests
  const sideQuestIndex = game.quests.side.findIndex(q => q.id === questId);
  if (sideQuestIndex !== -1) {
    const quest = game.quests.side[sideQuestIndex];
    quest.completed = true;
    
    // Give reward
    if (quest.reward) {
      game.player.inventory.push(quest.reward);
      addToScene(`You received ${game.items[quest.reward].name} as a reward!`);
      VisualFeedback.showItem(game.items[quest.reward].name, document.getElementById('scene-description'));
    }
    
    addToScene(`SIDE QUEST COMPLETED: ${quest.title}`);
  }
  
  // Refresh if open
  if (document.getElementById('quests-modal').style.display === 'block') {
    openQuests();
  }
}

// Utility Functions
function addToScene(text) {
  const scene = document.getElementById('scene-description');
  scene.innerHTML += `<p>${text}</p>`;
  scene.scrollTop = scene.scrollHeight;
}

function addCombatLog(text) {
  const log = document.getElementById('combat-log-modal');
  log.innerHTML += `<p>${text}</p>`;
  log.scrollTop = log.scrollHeight;
}

function clearScene() {
  document.getElementById('scene-description').innerHTML = '';
}

function hideAllModals() {
  document.querySelectorAll('.modal').forEach(modal => {
    modal.style.display = 'none';
  });
  
  // If in combat, return to combat modal
  if (game.inCombat) {
    document.getElementById('combat-modal').style.display = 'block';
  }
}

function tryAgain() {
  document.getElementById('game-over-modal').style.display = 'none';
  game.player.hp = game.player.maxHp;
  game.player.sanity = game.player.maxSanity;
  game.statusEffects = [];
  updateUI();
}

function returnToMainMenu() {
  document.getElementById('game-over-modal').style.display = 'none';
  document.getElementById('main-game').style.display = 'none';
  document.getElementById('character-selection').style.display = 'flex';
  document.getElementById('save-button').style.display = 'none';
}
</script>
</body>
</html>
