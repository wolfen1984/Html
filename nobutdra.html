<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Castle of the Damned (1985) - Button Edition</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #c00;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #c00;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #c00;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
            min-height: 150px;
        }
        #status {
            border-top: 1px solid #c00;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        
        /* Button and Control Styles */
        .control-section {
            border: 1px solid #c00;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #111;
        }
        .section-title {
            color: #ff6b6b;
            margin-bottom: 8px;
            text-align: center;
            font-size: 11px;
        }
        .button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 5px;
            margin-bottom: 8px;
        }
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 8px;
        }
        .game-button {
            background: #222;
            border: 1px solid #c00;
            color: #c00;
            padding: 8px 5px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            text-align: center;
            flex: 1;
            min-width: 60px;
            transition: all 0.1s;
        }
        .game-button:hover {
            background: #333;
            border-color: #ff0000;
        }
        .game-button:active {
            background: #444;
            transform: scale(0.98);
        }
        .game-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Dropdown Styles */
        select {
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 6px;
            font-family: inherit;
            font-size: 10px;
            width: 100%;
            margin-bottom: 8px;
        }
        .dropdown-container {
            margin-bottom: 8px;
        }
        .dropdown-label {
            color: #ff6b6b;
            margin-bottom: 4px;
            font-size: 10px;
        }
        
        /* Special Button Colors */
        .btn-move { color: #00cccc; }
        .btn-action { color: #ff9933; }
        .btn-combat { color: #ff0000; }
        .btn-magic { color: #00ffff; }
        .btn-inventory { color: #ffff66; }
        .btn-npc { color: #ffcc66; }
        .btn-system { color: #888; }
        
        /* UI Controls */
        #ui-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #000;
            border: 1px solid #c00;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        
        /* Class Selection */
        #class-selection {
            text-align: center;
            padding: 10px;
            border: 2px solid #c00;
            margin: 10px;
            background-color: #111;
        }
        .class-button {
            background: #222;
            border: 1px solid #c00;
            color: #c00;
            padding: 10px;
            margin: 5px;
            font-size: 12px;
            cursor: pointer;
            width: 150px;
        }
        .class-button:hover {
            background: #333;
            border-color: #ff0000;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .button-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            .game-button {
                font-size: 9px;
                padding: 6px 3px;
            }
        }
        @media (max-width: 480px) {
            .button-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Message Colors */
        .command { color: #ff6b6b; }
        .error { color: #ff0000; }
        .item { color: #00cccc; }
        .enemy { color: #cc00cc; }
        .npc { color: #ff9933; }
        .success { color: #00cc00; }
        .quest { color: #ffff66; }
        .loot { color: #ff66b2; }
        .system { color: #888; }
        .damage { color: #ff4500; }
        .heal { color: #32cd32; }
        .skill { color: #00ffff; }
        .puzzle { color: #ff66ff; }
        .hint { color: #aaa; }
        .dialogue { color: #ffcc66; }
    </style>
</head>
<body>
    <div id="ui-controls">
        <div class="button-row">
            <button class="game-button btn-system" onclick="saveGame()">SAVE</button>
            <button class="game-button btn-system" onclick="loadGame()">LOAD</button>
            <button class="game-button btn-system" onclick="quickSave()">QSAVE</button>
            <button class="game-button btn-system" onclick="quickLoad()">QLOAD</button>
        </div>
    </div>
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    
    <div id="header">
        <h1>CASTLE OF THE DAMNED</h1>
        <div>1985 â€¢ NIGHTFALLS GAMES â€¢ BUTTON EDITION</div>
    </div>
    
    <div id="game-container">
        <div id="output">Welcome to Castle of the Damned - Button Edition! Choose your class to begin.</div>
        
        <!-- Class Selection (shown at start) -->
        <div id="class-selection" style="display: block;">
            <div class="section-title">CHOOSE YOUR CLASS</div>
            <div class="button-row">
                <button class="class-button" onclick="startGame('hunter')">HUNTER</button>
                <button class="class-button" onclick="startGame('sorcerer')">SORCERER</button>
                <button class="class-button" onclick="startGame('dhampir')">DHAMPIR</button>
            </div>
        </div>
        
        <!-- Main Game Controls (hidden until class selected) -->
        <div id="game-controls" style="display: none;">
            <!-- Movement Section -->
            <div class="control-section">
                <div class="section-title">MOVEMENT</div>
                <div class="button-grid">
                    <button class="game-button btn-move" onclick="executeCommand('n')">NORTH</button>
                    <button class="game-button btn-move" onclick="executeCommand('s')">SOUTH</button>
                    <button class="game-button btn-move" onclick="executeCommand('e')">EAST</button>
                    <button class="game-button btn-move" onclick="executeCommand('w')">WEST</button>
                    <button class="game-button btn-move" onclick="executeCommand('look')">LOOK</button>
                    <button class="game-button btn-move" onclick="executeCommand('secret')" id="secret-btn" style="display:none">SECRET</button>
                </div>
            </div>
            
            <!-- Object Interaction Section -->
            <div class="control-section">
                <div class="section-title">OBJECT INTERACTION</div>
                <div class="dropdown-container">
                    <div class="dropdown-label">SELECT OBJECT:</div>
                    <select id="object-select" onchange="updateObjectActions()">
                        <option value="">-- Choose Object --</option>
                    </select>
                </div>
                <div id="object-actions" class="button-row" style="display: none;">
                    <!-- Object action buttons will appear here -->
                </div>
            </div>
            
            <!-- Combat Section -->
            <div class="control-section" id="combat-section" style="display: none;">
                <div class="section-title">COMBAT</div>
                <div class="button-row">
                    <button class="game-button btn-combat" onclick="executeCommand('attack')">ATTACK</button>
                    <button class="game-button btn-combat" onclick="showSkillsMenu()">SKILLS</button>
                    <button class="game-button btn-combat" onclick="showCombatItems()">USE ITEM</button>
                    <button class="game-button btn-combat" onclick="executeCommand('flee')">FLEE</button>
                </div>
                <div id="skills-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Skill buttons will appear here -->
                </div>
                <div id="combat-items" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Combat item buttons will appear here -->
                </div>
            </div>
            
            <!-- NPC Interaction Section -->
            <div class="control-section" id="npc-section" style="display: none;">
                <div class="section-title">NPC INTERACTION</div>
                <div id="npc-actions" class="button-row">
                    <!-- NPC action buttons will appear here -->
                </div>
                <div id="npc-topics" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- NPC topic buttons will appear here -->
                </div>
            </div>
            
            <!-- Inventory Section -->
            <div class="control-section">
                <div class="section-title">INVENTORY</div>
                <div class="button-row">
                    <button class="game-button btn-inventory" onclick="executeCommand('inventory')">INVENTORY</button>
                    <button class="game-button btn-inventory" onclick="showEquipMenu()">EQUIP</button>
                    <button class="game-button btn-inventory" onclick="showUseMenu()">USE ITEM</button>
                    <button class="game-button btn-inventory" onclick="executeCommand('skills')">SKILLS</button>
                </div>
                <div id="equip-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Equip buttons will appear here -->
                </div>
                <div id="use-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Use item buttons will appear here -->
                </div>
            </div>
            
            <!-- Shop Section (when at alchemist) -->
            <div class="control-section" id="shop-section" style="display: none;">
                <div class="section-title">SHOP</div>
                <div class="button-row">
                    <button class="game-button btn-inventory" onclick="executeCommand('list')">SHOW SHOP</button>
                    <button class="game-button btn-inventory" onclick="showBuyMenu()">BUY</button>
                    <button class="game-button btn-inventory" onclick="showSellMenu()">SELL</button>
                </div>
                <div id="buy-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Buy buttons will appear here -->
                </div>
                <div id="sell-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Sell buttons will appear here -->
                </div>
            </div>
            
            <!-- Special Actions Section -->
            <div class="control-section">
                <div class="section-title">SPECIAL ACTIONS</div>
                <div class="button-row">
                    <button class="game-button btn-action" onclick="executeCommand('take all')">TAKE ALL</button>
                    <button class="game-button btn-action" onclick="showExamineMenu()">EXAMINE</button>
                    <button class="game-button btn-action" onclick="executeCommand('charge crystal')" id="charge-btn" style="display:none">CHARGE CRYSTAL</button>
                    <button class="game-button btn-action" onclick="executeCommand('forge')" id="forge-btn" style="display:none">FORGE WEAPON</button>
                </div>
                <div id="examine-menu" class="button-row" style="display: none; margin-top: 5px;">
                    <!-- Examine buttons will appear here -->
                </div>
            </div>
            
            <!-- System Section -->
            <div class="control-section">
                <div class="section-title">SYSTEM</div>
                <div class="button-row">
                    <button class="game-button btn-system" onclick="executeCommand('help')">HELP</button>
                    <button class="game-button btn-system" onclick="executeCommand('status')">STATUS</button>
                    <button class="game-button btn-system" onclick="executeCommand('quit')">QUIT</button>
                </div>
            </div>
        </div>
        
        <div id="status"></div>
    </div>

    <!-- Keep the original JavaScript exactly as provided -->
    <script>
        // ==================== SOUND SYSTEM ====================
        // [Keep the entire original SoundSystem class exactly as provided]
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.3; // Lower volume for background music
                    this.sfxGain.gain.value = 0.5; // Higher volume for SFX
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            // ==================== MUSIC GENERATION ====================
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                // Don't restart same music
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                // Stop current background
                this.stopBackground();
                
                this.currentBgName = musicName;
                
                // Generate music based on name
                switch(musicName) {
                    case 'theme':
                        this.playThemeTune(loop);
                        break;
                    case 'castle':
                        this.playCastleMusic(loop);
                        break;
                    case 'gothic':
                        this.playGothicMusic(loop);
                        break;
                    case 'boss':
                        this.playBossMusic(loop);
                        break;
                    case 'victory':
                        this.playVictoryMusic(loop);
                        break;
                    case 'catacombs':
                        this.playCatacombsMusic(loop);
                        break;
                    default:
                        this.playThemeTune(loop);
                }
            }
            
            playThemeTune(loop) {
                // Gothic Dracula theme with longer notes
                const melody = [
                    {note: 220, duration: 0.6},    // A (lower, eerie)
                    {note: 196, duration: 0.3},    // G
                    {note: 174.61, duration: 0.9}, // F (long, haunting)
                    {note: 164.81, duration: 0.6}, // E
                    {note: 146.83, duration: 0.3}, // D
                    {note: 130.81, duration: 1.2}, // C (very long, deep)
                    {note: 164.81, duration: 0.6}, // E
                    {note: 196, duration: 0.9},    // G (long)
                    {note: 220, duration: 1.5},    // A (very long, dramatic)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.2);
            }
            
            playCastleMusic(loop) {
                // Dark, gothic castle music
                const melody = [
                    {note: 130.81, duration: 0.8}, // C low (long)
                    {note: 164.81, duration: 0.8}, // E (long)
                    {note: 196.00, duration: 0.8}, // G (long)
                    {note: 146.83, duration: 0.8}, // D (long)
                    {note: 174.61, duration: 1.6}, // F (very long)
                ];
                
                this.playMelody(melody, 'square', loop, 0.15);
            }
            
            playGothicMusic(loop) {
                // Gothic, atmospheric music
                const melody = [
                    {note: 220, duration: 1.2},   // A (long)
                    {note: 207.65, duration: 0.6}, // G# (medium)
                    {note: 196.00, duration: 1.2}, // G (long)
                    {note: 184.99, duration: 0.6}, // F# (medium)
                    {note: 174.61, duration: 1.8}, // F (very long)
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.1);
            }
            
            playCatacombsMusic(loop) {
                // Creepy catacombs music
                const melody = [
                    {note: 98.00, duration: 1.0},   // G low (long)
                    {note: 116.54, duration: 0.5},  // A# (medium)
                    {note: 130.81, duration: 1.0},  // C (long)
                    {note: 103.83, duration: 0.5},  // G# (medium)
                    {note: 123.47, duration: 1.5},  // B (very long)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.12);
            }
            
            playBossMusic(loop) {
                // Intense vampire battle music with longer notes
                const melody = [
                    {note: 261.63, duration: 0.4}, // C (medium)
                    {note: 329.63, duration: 0.4}, // E (medium)
                    {note: 392.00, duration: 0.4}, // G (medium)
                    {note: 523.25, duration: 0.8}, // C high (long)
                    {note: 392.00, duration: 0.4}, // G (medium)
                    {note: 329.63, duration: 0.4}, // E (medium)
                    {note: 261.63, duration: 1.0}, // C (very long)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.25);
            }
            
            playVictoryMusic(loop) {
                // Gothic victory fanfare with longer notes
                const melody = [
                    {note: 523.25, duration: 0.4}, // C (medium)
                    {note: 659.25, duration: 0.4}, // E (medium)
                    {note: 783.99, duration: 0.4}, // G (medium)
                    {note: 1046.50, duration: 1.0}, // C high (very long)
                    {note: 783.99, duration: 0.4}, // G (medium)
                    {note: 1046.50, duration: 1.0}, // C high (very long)
                    {note: 1318.51, duration: 1.8}, // E high (very very long)
                ];
                
                this.playMelody(melody, 'sine', loop, 0.3);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                // Schedule notes
                let currentTime = now;
                melody.forEach((note, index) => {
                    // Set frequency
                    source.frequency.setValueAtTime(note.note, currentTime);
                    
                    // Create envelope for each note (longer fade for longer notes)
                    const fadeIn = Math.min(0.1, note.duration * 0.15);
                    const fadeOut = Math.min(0.15, note.duration * 0.2);
                    
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + fadeIn);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - fadeOut);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    
                    currentTime += note.duration;
                });
                
                if (loop) {
                    // Loop the melody
                    source.start(now);
                    source.stop(now + currentTime - now);
                    
                    // Schedule next loop
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try {
                        this.currentBgSource.stop();
                    } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            // ==================== SOUND EFFECTS ====================
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                switch(soundName) {
                    case 'click':
                        this.playClick(volume);
                        break;
                    case 'notification':
                        this.playNotification(volume);
                        break;
                    case 'levelup':
                        this.playLevelUp(volume);
                        break;
                    case 'attack':
                        this.playAttack(volume);
                        break;
                    case 'enemyHit':
                        this.playEnemyHit(volume);
                        break;
                    case 'playerHit':
                        this.playPlayerHit(volume);
                        break;
                    case 'victory':
                        this.playVictory(volume);
                        break;
                    case 'defeat':
                        this.playDefeat(volume);
                        break;
                    case 'pickup':
                        this.playPickup(volume);
                        break;
                    case 'equip':
                        this.playEquip(volume);
                        break;
                    case 'door':
                        this.playDoor(volume);
                        break;
                    case 'step':
                        this.playStep(volume);
                        break;
                    case 'spell':
                        this.playSpell(volume);
                        break;
                    case 'heal':
                        this.playHeal(volume);
                        break;
                    case 'buff':
                        this.playBuff(volume);
                        break;
                    case 'puzzle':
                        this.playPuzzle(volume);
                        break;
                    case 'secret':
                        this.playSecret(volume);
                        break;
                    case 'bat':
                        this.playBat(volume);
                        break;
                    case 'howl':
                        this.playHowl(volume);
                        break;
                    case 'thunder':
                        this.playThunder(volume);
                        break;
                }
            }
            
            playClick(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playNotification(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playLevelUp(volume) {
                const now = this.audioContext.currentTime;
                
                // Play a dramatic ascending arpeggio
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C high
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.2);
                });
            }
            
            playAttack(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playEnemyHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playPlayerHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playVictory(volume) {
                const now = this.audioContext.currentTime;
                
                // Gothic victory fanfare
                const notes = [
                    {freq: 523.25, time: 0.0, duration: 0.4},
                    {freq: 659.25, time: 0.4, duration: 0.4},
                    {freq: 783.99, time: 0.8, duration: 0.4},
                    {freq: 1046.50, time: 1.2, duration: 1.0},
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    gainNode.gain.setValueAtTime(0, now + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + note.time + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + note.time);
                    oscillator.stop(now + note.time + note.duration);
                });
            }
            
            playDefeat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, now);
                oscillator.frequency.exponentialRampToValueAtTime(110, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playPickup(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, now);
                oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playEquip(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playDoor(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStep(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playSpell(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playHeal(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playBuff(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(500, now);
                oscillator.frequency.exponentialRampToValueAtTime(700, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playPuzzle(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playSecret(volume) {
                const now = this.audioContext.currentTime;
                
                // Mysterious secret sound
                const notes = [400, 600, 800, 1000];
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.15);
                });
            }
            
            playBat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1600, now + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.4);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.1, now + 0.2);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playHowl(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 1.0);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 1.0);
            }
            
            playThunder(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 1.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 1.5);
            }
            
            // ==================== UTILITY METHODS ====================
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            hunter: { 
                hp: 35, mp: 8, str: 8, def: 6, stealth: 4, 
                desc: "A vampire hunter skilled with silver and holy weapons.",
                skills: ['silver_strike', 'ward']
            },
            sorcerer: { 
                hp: 24, mp: 28, str: 4, def: 3, stealth: 5,
                desc: "A master of arcane arts, able to wield light against darkness.",
                skills: ['sunbeam', 'barrier']
            },
            dhampir: { 
                hp: 30, mp: 15, str: 6, def: 4, stealth: 7,
                desc: "Half-vampire, half-human. You walk between both worlds.",
                skills: ['blood_drain', 'shadow_step']
            }
        };

        // ==================== SKILL SYSTEM ====================
        const skills = {
            silver_strike: {
                name: "Silver Strike",
                mpCost: 6,
                description: "A silver-enhanced strike that wounds vampires deeply",
                class: "hunter",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.8) + Math.floor(Math.random() * 10);
                    enemyData.hp -= damage;
                    print(`You strike with SILVER for ${damage} damage!`, 'damage');
                    soundSystem.playSound('attack', 0.7);
                    
                    // Extra damage against vampires
                    if (enemyData.originalType && enemyData.originalType.includes('vampire')) {
                        const bonus = Math.floor(damage * 0.5);
                        enemyData.hp -= bonus;
                        print(`Silver burns the vampire for ${bonus} bonus damage!`, 'damage');
                    }
                    return true;
                }
            },
            ward: {
                name: "Holy Ward",
                mpCost: 4,
                description: "Create a protective ward against dark creatures",
                class: "hunter",
                effect: function(player, enemyData) {
                    player.ward = 4;
                    print("You create a holy ward. Next damage reduced significantly!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            sunbeam: {
                name: "Sunbeam",
                mpCost: 10,
                description: "Channel sunlight to burn undead and vampires",
                class: "sorcerer",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.8) + Math.floor(Math.random() * 20) + 15;
                    enemyData.hp -= damage;
                    print(`You channel SUNLIGHT for ${damage} damage!`, 'damage');
                    soundSystem.playSound('spell', 0.7);
                    
                    // Extra effect against undead
                    if (enemyData.originalType && (enemyData.originalType.includes('vampire') || 
                        enemyData.originalType.includes('skeleton') || 
                        enemyData.originalType.includes('ghost'))) {
                        enemyData.sunburned = 4;
                        print("The undead creature is burning in sunlight!", 'success');
                    }
                    return true;
                }
            },
            barrier: {
                name: "Arcane Barrier",
                mpCost: 8,
                description: "Create a magical barrier that absorbs damage",
                class: "sorcerer",
                effect: function(player, enemyData) {
                    player.barrier = Math.floor(player.maxHp * 0.4);
                    print(`You create an arcane barrier that absorbs ${player.barrier} damage!`, 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            blood_drain: {
                name: "Blood Drain",
                mpCost: 8,
                description: "Drain life from your enemy to heal yourself",
                class: "dhampir",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.2) + Math.floor(Math.random() * 12);
                    enemyData.hp -= damage;
                    const heal = Math.floor(damage * 0.6);
                    player.hp = Math.min(player.maxHp, player.hp + heal);
                    print(`You drain ${damage} life and heal ${heal} HP!`, 'skill');
                    soundSystem.playSound('heal', 0.6);
                    return true;
                }
            },
            shadow_step: {
                name: "Shadow Step",
                mpCost: 12,
                description: "Move through shadows to avoid attacks",
                class: "dhampir",
                effect: function(player, enemyData) {
                    player.shadowed = 3;
                    print("You blend with the shadows. Enemies will likely miss!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 3, type: 'weapon', value: 0, desc: "Your bare hands." },
            stake: { name: "Wooden Stake", dmg: 12, type: 'weapon', value: 25, desc: "A sharp wooden stake. Effective against vampires.", vs_vampire: 10 },
            silver_sword: { name: "Silver Sword", dmg: 18, type: 'weapon', value: 120, desc: "A sword forged from pure silver. Burns the undead.", vs_undead: 15 },
            crossbow: { name: "Crossbow", dmg: 16, type: 'weapon', value: 80, desc: "A heavy crossbow with silver-tipped bolts.", range: true },
            morning_star: { name: "Morning Star", dmg: 22, type: 'weapon', value: 150, desc: "A spiked flail blessed by a priest.", holy: true },
            arcane_staff: { name: "Arcane Staff", dmg: 14, type: 'weapon', value: 100, desc: "A staff imbued with light magic.", magic: 12, light: true },
            wolfsbane_dagger: { name: "Wolfsbane Dagger", dmg: 10, type: 'weapon', value: 65, desc: "A dagger coated in wolfsbane. Effective against werewolves.", vs_werewolf: 20 },
            holy_water_sprinkler: { name: "Holy Water Sprinkler", dmg: 8, type: 'weapon', value: 45, desc: "A device that sprays holy water.", holy: true, vs_undead: 25 }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather: { name: "Leather Armor", def: 6, type: 'armor', value: 30, desc: "Soft leather armor. Good mobility.", stealth: 3 },
            chainmail: { name: "Chainmail", def: 10, type: 'armor', value: 80, desc: "Heavy chainmail. Good protection.", stealth: -1 },
            hunter_coat: { name: "Hunter's Coat", def: 8, type: 'armor', value: 60, desc: "A long coat with silver threads woven in.", stealth: 4, vs_vampire: 5 },
            plate: { name: "Plate Armor", def: 15, type: 'armor', value: 150, desc: "Full plate armor. Maximum protection.", stealth: -5 },
            robe: { name: "Sorcerer's Robe", def: 5, type: 'armor', value: 40, desc: "A dark robe that enhances magic.", stealth: 4, magic: 8 },
            vampire_cloak: { name: "Vampire Cloak", def: 4, type: 'armor', value: 90, desc: "A dark cloak that blends with shadows.", stealth: 8, darkness: true }
        };

        const items = {
            potion: { type: 'consumable', effect: { hp: 30 }, value: 25, desc: "Heals 30 HP." },
            manapot: { type: 'consumable', effect: { mp: 25 }, value: 30, desc: "Restores 25 MP." },
            elixir: { type: 'consumable', effect: { hp: 60, mp: 40 }, value: 75, desc: "Restores 60 HP and 40 MP." },
            garlic: { type: 'consumable', effect: { ward_vampire: 5 }, value: 15, desc: "Repels vampires for 5 turns." },
            holy_water: { type: 'consumable', effect: { damage_undead: 75 }, value: 50, desc: "Water blessed by a priest. Devastating to undead." },
            wolfsbane: { type: 'consumable', effect: { damage_werewolf: 50 }, value: 35, desc: "A poisonous plant deadly to werewolves." },
            silver_bullet: { type: 'consumable', effect: { damage_vampire: 100 }, value: 80, desc: "A single silver bullet for a firearm." },
            key: { type: 'key', value: 1, desc: "An iron key. It might open something." },
            torch: { type: 'tool', value: 5, desc: "A lit torch. Illuminates dark areas and repels creatures of darkness." },
            gem: { type: 'treasure', value: 125, desc: "A valuable blood-red gemstone." },
            ancient_tome: { type: 'quest', value: 1, desc: "An ancient tome containing vampire lore." },
            vampire_dust: { type: 'quest', value: 1, desc: "Dust from a defeated vampire." },
            werewolf_fang: { type: 'quest', value: 1, desc: "A sharp fang from a werewolf." },
            ghost_essence: { type: 'quest', value: 1, desc: "Ectoplasmic essence from a ghost." },
            crucifix: { type: 'tool', value: 40, desc: "A silver crucifix that wards off evil." },
            mirror: { type: 'tool', value: 25, desc: "A silver-backed hand mirror. Vampires cast no reflection." },
            sun_crystal: { type: 'quest', value: 1, desc: "A crystal that stores sunlight." },
            blood_vial: { type: 'consumable', effect: { hp: 50, mp: -10 }, value: 30, desc: "Vampire blood. Heals but corrupts." }
        };

        const enemies = {
            bat_swarm: { 
                name: "Bat Swarm", 
                hp: 25, dmg: 8, gold: 12, xp: 20, 
                desc: "A swirling mass of sharp-fanged bats.",
                loot: ['garlic'], 
                sounds: { attack: 'bat', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            skeleton: { 
                name: "Skeletal Guard", 
                hp: 40, dmg: 11, gold: 25, xp: 35,
                desc: "An animated skeleton in rusty armor.",
                loot: ['stake', 'potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'castle'
            },
            ghost: { 
                name: "Wailing Ghost", 
                hp: 35, dmg: 9, gold: 20, xp: 30,
                desc: "A translucent spirit that chills the air with its moans.",
                loot: ['ghost_essence', 'manapot'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            werewolf: { 
                name: "Werewolf", 
                hp: 60, dmg: 18, gold: 45, xp: 50,
                desc: "A monstrous hybrid of man and wolf with razor-sharp claws.",
                loot: ['werewolf_fang', 'potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'howl' },
                bgSound: 'castle'
            },
            vampire_spawn: { 
                name: "Vampire Spawn", 
                hp: 55, dmg: 15, gold: 40, xp: 45,
                desc: "A fledgling vampire with pale skin and blood-red eyes.",
                loot: ['vampire_dust', 'blood_vial'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            vampire_knight: { 
                name: "Vampire Knight", 
                hp: 85, dmg: 22, gold: 70, xp: 75,
                desc: "An ancient vampire in black plate armor, wielding a massive sword.",
                loot: ['silver_sword', 'elixir'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'castle'
            },
            vampire_lord: { 
                name: "Vampire Lord", 
                hp: 200, dmg: 35, gold: 300, xp: 200,
                desc: "The master of the castle - an ancient vampire of immense power.",
                loot: ['morning_star', 'hunter_coat', 'elixir', 'gem', 'gem'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss'
            }
        };

        // Create enemy instance function to fix shared HP bug
        function createEnemy(type) {
            const enemyTemplate = enemies[type];
            if (!enemyTemplate) return null;
            
            return {
                ...enemyTemplate,
                hp: enemyTemplate.hp,
                stunned: 0,
                sunburned: 0,
                originalType: type
            };
        }

        const npcs = {
            alchemist: { 
                name: "Alchemist Viktor", 
                desc: "A scholarly man surrounded by bubbling potions and strange instruments.", 
                dialog: "Welcome! I study the creatures of the night. Bring me specimens and I'll reward you.",
                quest: { items: ['vampire_dust', 'werewolf_fang', 'ghost_essence'], reward: { gold: 250, item: 'arcane_staff', xp: 100 }, completed: false },
                hostile: false,
                shopItems: ['stake', 'crossbow', 'garlic', 'holy_water', 'wolfsbane', 'potion', 'manapot', 'crucifix', 'mirror'],
                dialogueTopics: ['vampires', 'werewolves', 'ghosts', 'cures'],
                dialogue: {
                    'default': "The night holds many secrets... and dangers.",
                    'vampires': "A stake through the heart or sunlight will destroy them. Garlic repels them.",
                    'werewolves': "Silver and wolfsbane are their bane. They transform under the full moon.",
                    'ghosts': "They cannot cross salt lines. Holy water damages them severely.",
                    'cures': "I'm researching cures for vampirism and lycanthropy. No success yet..."
                }
            },
            priest: {
                name: "Father Mikhail",
                desc: "An old priest praying in the chapel. He clutches a large silver cross.",
                dialog: "This castle is an abomination! Help me cleanse it of the undead.",
                quest: { item: 'ancient_tome', reward: { gold: 150, item: 'holy_water_sprinkler', xp: 80 }, completed: false },
                hostile: false,
                dialogueTopics: ['vampires', 'holy_water', 'blessings', 'crucifix'],
                dialogue: {
                    'default': "May God protect you in this cursed place.",
                    'vampires': "They cannot enter holy ground without invitation. Use that to your advantage.",
                    'holy_water': "I can bless water to harm undead. Very effective against vampires.",
                    'blessings': "Bring me your weapons, and I shall bless them against the dark.",
                    'crucifix': "A true crucifix will repel vampires. They fear the symbol of our Lord."
                }
            },
            hunter: {
                name: "Vanessa the Hunter",
                desc: "A grim woman covered in scars, polishing a silver sword.",
                dialog: "I've hunted vampires for twenty years. This castle is their nest. We must burn it.",
                quest: { item: 'vampire_dust', count: 5, reward: { gold: 200, item: 'silver_sword', xp: 90 }, completed: false },
                hostile: false,
                dialogueTopics: ['silver', 'stakes', 'vampire_lord', 'hunter_coat'],
                dialogue: {
                    'default': "Stay alert. They can be anywhere.",
                    'silver': "Silver is the vampire's bane. A silver sword is worth its weight in gold here.",
                    'stakes': "A wooden stake through the heart will kill any vampire, young or old.",
                    'vampire_lord': "The master of this castle is ancient and powerful. He must be destroyed at dawn.",
                    'hunter_coat': "My coat has silver threads woven in. It offers some protection against their claws."
                }
            },
            captive_vampire: {
                name: "Lysandra",
                desc: "A pale, beautiful vampire chained with silver. She looks tired and resigned.",
                dialog: "Free me... and I will help you defeat my master. I want this curse ended.",
                quest: { item: 'silver_key', reward: { gold: 0, item: 'vampire_cloak', xp: 60 }, completed: false },
                hostile: false,
                dialogueTopics: ['master', 'curse', 'silver', 'dawn'],
                dialogue: {
                    'default': "These silver chains burn... please...",
                    'master': "He sleeps in the highest tower. Attack at dawn when he is weakest.",
                    'curse': "I was turned against my will centuries ago. I long for peace.",
                    'silver': "Silver weakens us. The key to my chains is in the master's study.",
                    'dawn': "At dawn, vampires are weakest. The master will be in his coffin."
                }
            },
            ghost_maiden: {
                name: "Elenora's Ghost",
                desc: "A translucent young woman in a white dress, floating above the ground.",
                dialog: "The master took my life... my soul cannot rest while he exists...",
                quest: { item: 'sun_crystal', reward: { gold: 0, item: 'mirror', xp: 40 }, completed: false },
                hostile: false,
                dialogueTopics: ['master', 'mirror', 'crystal', 'tragedy'],
                dialogue: {
                    'default': "So cold... so alone...",
                    'master': "He fears the sun above all else. Find the sun crystal in the observatory.",
                    'mirror': "Vampires cast no reflection. A mirror can reveal them in disguise.",
                    'crystal': "The sun crystal stores sunlight. It could destroy the master.",
                    'tragedy': "He turned me on my wedding night... my fiancÃ© died trying to save me..."
                }
            },
            mad_scientist: {
                name: "Dr. Moreau",
                desc: "A wild-eyed man in a stained lab coat, surrounded by bizarre experiments.",
                dialog: "The fusion of man and beast! Perfection! But the master disapproves...",
                quest: null,
                hostile: true,
                dialogueTopics: ['experiments', 'werewolves', 'master', 'perfection'],
                dialogue: {
                    'default': "Stay away from my specimens!",
                    'experiments': "I create life from death! The master's subjects are perfect test subjects.",
                    'werewolves': "My finest creation! Man and wolf united!",
                    'master': "He thinks my work blasphemous. He doesn't understand true science!",
                    'perfection': "The ultimate being would combine vampire, werewolf, and human traits!"
                }
            },
            cursed_blacksmith: {
                name: "Boris the Cursed",
                desc: "A massive man with wolf-like features, hammering at an anvil.",
                dialog: "The moon's curse is upon me... but I still know my craft. Silver work calms the beast.",
                quest: null,
                hostile: false,
                dialogueTopics: ['silver', 'werewolf_curse', 'weapons', 'moon'],
                dialogue: {
                    'default': "The beast stirs within...",
                    'silver': "Silver soothes the curse. I work it to keep the wolf at bay.",
                    'werewolf_curse': "The master infected me. Each full moon, I transform...",
                    'weapons': "I can forge silver weapons. Bring me gems and silver.",
                    'moon': "When the moon is full, lock me in the cellar. For your safety."
                }
            },
            // NEW: Librarian Ghost (appears after puzzle)
            librarian_ghost: {
                name: "Ghost of the Librarian",
                desc: "A spectral figure in scholarly robes, tending to phantom books.",
                dialog: "Knowledge must be preserved... even in death...",
                quest: { item: 'ancient_tome', reward: { gold: 50, item: 'crucifix', xp: 35 }, completed: false },
                hostile: false,
                dialogueTopics: ['tome', 'vampire_weaknesses', 'library', 'knowledge'],
                dialogue: {
                    'default': "So many books... so much to protect...",
                    'tome': "The ancient tome contains the master's true name. With it, he can be bound.",
                    'vampire_weaknesses': "Sunlight, silver, holy symbols, garlic, running water...",
                    'library': "The master's private collection is in the west wing. Password protected.",
                    'knowledge': "I died protecting these books. The master wanted them burned..."
                }
            }
        };

        // Enhanced room descriptions with interactive objects - CASTLE THEME
        const roomDescriptions = [
            { 
                desc: "The Castle Gates. Massive iron doors stand before you. Torches flicker in iron sconces.", 
                sound: 'theme',
                objects: {
                    'gates': {
                        desc: "Enormous wrought-iron gates depicting bat-winged demons. They're barred from within.",
                        state: 'locked',
                        states: {
                            'locked': "The gates are firmly locked. You'll need a key or another way in.",
                            'unlocked': "The gates creak open ominously."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: null
                    },
                    'torches': "Iron sconces holding torches that burn with an unnatural blue flame.",
                    'gargoyles': "Stone gargoyles leer down at you. Their eyes seem to follow your movements."
                }
            },
            { 
                desc: "Grand Hall. Tattered banners hang from the ceiling. A massive staircase leads upward.", 
                sound: 'castle',
                objects: {
                    'banners': "Faded banners depicting a bat-winged crest. They flutter in a non-existent breeze.",
                    'staircase': "A grand marble staircase carpeted in red velvet worn thin by centuries.",
                    'chandelier': "A massive crystal chandelier coated in dust and cobwebs."
                }
            },
            { 
                desc: "Portrait Gallery. Paintings of pale aristocrats line the walls. Their eyes follow you.", 
                sound: 'gothic',
                objects: {
                    'portraits': {
                        desc: "Oil paintings of the castle's former inhabitants. All have unnaturally pale skin.",
                        state: 'normal',
                        states: {
                            'normal': "The portraits watch you with hungry eyes.",
                            'examined': "You notice none have reflections in painted mirrors behind them."
                        },
                        requiredItem: 'mirror',
                        action: 'examine',
                        hiddenItem: 'clue'
                    },
                    'frames': "Ornate gold frames tarnished with age. Some hang crookedly."
                }
            },
            { 
                desc: "Dining Hall. A long table set for a feast. The food has turned to dust.", 
                sound: 'castle',
                objects: {
                    'table': "A massive oak table set with tarnished silver and crystal goblets.",
                    'goblets': "Some goblets contain a dark red residue that might be ancient wine... or blood.",
                    'chairs': "High-backed chairs with velvet cushions rotted to threads."
                }
            },
            { 
                desc: "Kitchen. Giant cauldrons hang over cold hearths. Rusty cleavers line the walls.", 
                sound: 'castle',
                objects: {
                    'cauldrons': "Iron pots large enough to cook a man. One still bubbles with a thick red liquid.",
                    'cleavers': "Butcher's tools stained dark brown. The smell of old blood lingers.",
                    'pantry': {
                        desc: "A locked pantry door. Strange scratching comes from within.",
                        state: 'locked',
                        states: {
                            'locked': "The pantry is securely locked.",
                            'unlocked': "The door creaks open, revealing... nothing but dust and rat droppings."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: 'garlic'
                    }
                }
            },
            { 
                desc: "Chapel. Faded frescoes of saints line the walls. The altar is stained dark.", 
                sound: 'theme',
                objects: {
                    'frescoes': "Peeling paintings of saints with their eyes gouged out.",
                    'altar': {
                        desc: "A stone altar defiled with dark symbols. It feels... corrupted.",
                        state: 'defiled',
                        states: {
                            'defiled': "The altar pulses with dark energy.",
                            'cleansed': "Holy water has cleansed the altar. It now glows faintly."
                        },
                        requiredItem: 'holy_water',
                        action: 'cleanse',
                        hiddenItem: 'crucifix'
                    },
                    'pews': "Wooden pews shattered as if by tremendous force."
                }
            },
            { 
                desc: "Library. Books bound in strange leather line the shelves. Some whisper as you pass.", 
                sound: 'gothic',
                objects: {
                    'books': "Volumes bound in what might be human skin. They pulse with dark energy.",
                    'shelves': "Floor-to-ceiling bookshelves filled with forbidden knowledge.",
                    'study': {
                        desc: "A private study area with a massive oak desk.",
                        state: 'locked',
                        states: {
                            'locked': "The desk drawers are locked.",
                            'unlocked': "The drawer contains a silver key and strange notes."
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'ancient_tome'
                    }
                }
            },
            { 
                desc: "Alchemy Lab. Bubbling potions glow with unnatural colors. The air smells of sulfur.", 
                sound: 'gothic',
                objects: {
                    'potions': "Colored liquids bubbling in glass vessels. Some contain floating... things.",
                    'lab': "An alchemical workstation with a scorched grimoire and strange instruments.",
                    'cage': {
                        desc: "A large iron cage containing skeletal remains.",
                        state: 'locked',
                        states: {
                            'locked': "The cage is securely locked.",
                            'unlocked': "Inside, you find notes on vampire anatomy."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: 'vampire_dust'
                    }
                }
            },
            { 
                desc: "Torture Chamber. Rusty implements of pain line the walls. Chains rattle in the draft.", 
                sound: 'gothic',
                objects: {
                    'implements': "Rusted knives, pincers, and other cruel tools. Some are still warm.",
                    'chains': "Heavy iron chains that clink together despite no visible breeze.",
                    'rack': "A stretching rack with leather straps chewed through by something strong."
                }
            },
            { 
                desc: "Barracks. Rotted bunks line the walls. Rat-gnawed bones litter the floor.", 
                sound: 'castle',
                objects: {
                    'bunks': "Moldy bed frames with rotten straw mattresses. Something moves in the shadows.",
                    'bones': "Human bones picked clean. Large teeth marks are visible.",
                    'locker': {
                        desc: "A rusted footlocker at the end of a bunk.",
                        state: 'locked',
                        states: {
                            'locked': "The locker is rusted shut.",
                            'unlocked': "Inside is a rusted but serviceable crossbow."
                        },
                        requiredItem: 'oil',
                        action: 'oil',
                        hiddenItem: 'crossbow'
                    }
                }
            },
            { 
                desc: "Courtyard. Dead vines cling to stone walls. The moon shines blood-red.", 
                sound: 'theme',
                objects: {
                    'vines': "Withered ivy that crumbles at your touch.",
                    'moon': "A blood-red full moon that casts eerie shadows.",
                    'fountain': {
                        desc: "A dry marble fountain with a statue of a bat-winged demon.",
                        state: 'dry',
                        states: {
                            'dry': "The fountain is filled with dead leaves.",
                            'flowing': "Water now flows from the demon's mouth. Something glints within."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'gem'
                    }
                }
            },
            { 
                desc: "Wine Cellar. Racks of dusty bottles. Some contain dark, viscous liquid.", 
                sound: 'gothic',
                objects: {
                    'bottles': "Dusty wine bottles, some centuries old. The labels are faded.",
                    'racks': "Wooden racks sagging under the weight of time.",
                    'cask': {
                        desc: "A massive oak cask bound with iron.",
                        state: 'sealed',
                        states: {
                            'sealed': "The cask is sealed tight.",
                            'opened': "Inside is not wine, but a hibernating bat swarm!"
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: null,
                        spawnEnemy: 'bat_swarm'
                    }
                }
            },
            { 
                desc: "Guard Room. Empty suits of armor stand at attention. One moves.", 
                sound: 'castle',
                objects: {
                    'armor': {
                        desc: "The suits of armor are empty yet move. One raises its sword.",
                        state: 'animated',
                        states: {
                            'animated': "The armor attacks!",
                            'defeated': "The armor collapses into a pile of rusted metal."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'silver_key',
                        spawnEnemy: 'skeleton'
                    },
                    'weapons': "Rusted swords and spears mounted on the walls."
                }
            },
            { 
                desc: "Servant Quarters. Simple cots and worn uniforms. A diary tells of disappearances.", 
                sound: 'castle',
                objects: {
                    'cots': "Rough beds with thin, moth-eaten blankets.",
                    'uniforms': "Black and white servant uniforms hanging on pegs.",
                    'diary': "A maid's diary describing nightly disappearances among the staff."
                }
            },
            { 
                desc: "Throne Room. A black obsidian throne sits empty. Shadows dance on the walls.", 
                sound: 'castle',
                objects: {
                    'throne': {
                        desc: "A massive obsidian throne carved with bat motifs.",
                        state: 'normal',
                        states: {
                            'normal': "The throne emanates cold darkness.",
                            'examined': "Behind the throne, you find a hidden lever."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: null,
                        triggersSecret: true,
                        secretRoom: 50
                    },
                    'tapestries': "Black velvet tapestries depicting scenes of vampiric conquest.",
                    'dais': "A raised platform where the throne sits. The stone is stained dark."
                }
            },
            { 
                desc: "Observatory. A telescope points at the blood-red moon. Star charts cover the walls.", 
                sound: 'theme',
                objects: {
                    'telescope': "A brass telescope pointed at the crimson moon.",
                    'charts': "Astronomical charts showing constellations of bats and wolves.",
                    'crystal': {
                        desc: "A large crystal prism catching moonlight.",
                        state: 'dark',
                        states: {
                            'dark': "The crystal is dark and lifeless.",
                            'charged': "The crystal glows with stored moonlight!",
                            'sunlight': "The crystal now glows with brilliant sunlight!"
                        },
                        requiredItem: null,
                        action: 'charge',
                        hiddenItem: 'sun_crystal',
                        puzzle: true
                    }
                }
            },
            { 
                desc: "Treasure Vault. Piles of gold and jewels glitter in the torchlight.", 
                sound: 'castle',
                objects: {
                    'gold': "Mountains of gold coins from forgotten kingdoms.",
                    'jewels': "Gemstones of every color sparkling in the dim light.",
                    'chest': {
                        desc: "An iron-bound chest with a complex lock.",
                        state: 'locked',
                        states: {
                            'locked': "The chest is securely locked.",
                            'unlocked': "The chest contains legendary weapons!"
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'morning_star'
                    }
                }
            },
            { 
                desc: "Crypt. Stone sarcophagi line the walls. The air smells of decay and old blood.", 
                sound: 'catacombs',
                objects: {
                    'sarcophagi': "Ancient stone coffins. Some lids have been pushed aside from within.",
                    'crypt': "A burial chamber for the castle's unliving inhabitants.",
                    'coffin': {
                        desc: "A newer, polished black coffin in the center of the room.",
                        state: 'closed',
                        states: {
                            'closed': "The coffin lid is firmly shut.",
                            'open': "The coffin is empty except for rich black soil."
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: 'vampire_dust'
                    }
                }
            },
            { 
                desc: "Armory. Weapons of silver and steel line the walls. Most are dusty.", 
                sound: 'castle',
                objects: {
                    'weapons': "Swords, axes, and maces of various sizes and materials.",
                    'racks': "Weapon racks once holding proud arms, now mostly empty.",
                    'display': {
                        desc: "A display case holding a beautiful silver sword.",
                        state: 'locked',
                        states: {
                            'locked': "The case is locked with a silver padlock.",
                            'unlocked': "The silver sword is yours for the taking!"
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'silver_sword'
                    }
                }
            },
            { 
                desc: "Prison Cells. Iron bars enclose small, filthy spaces. Moans echo.", 
                sound: 'catacombs',
                objects: {
                    'bars': "Thick iron bars rusted with age and... other substances.",
                    'cells': "Tiny, dark rooms where prisoners were left to rot or worse.",
                    'chains': {
                        desc: "Silver chains hanging from the wall of one cell.",
                        state: 'empty',
                        states: {
                            'empty': "The chains hang empty. They're stained with blood.",
                            'used': "A vampire was held here recently. The chains are still warm."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Master Bedchamber. A canopy bed with black silk curtains. The room is freezing.", 
                sound: 'gothic',
                objects: {
                    'bed': "A four-poster bed with black silk curtains. The mattress looks unused.",
                    'curtains': "Heavy black velvet curtains blocking all light from the windows.",
                    'wardrobe': {
                        desc: "An ornate wardrobe of dark wood.",
                        state: 'locked',
                        states: {
                            'locked': "The wardrobe is locked.",
                            'unlocked': "Inside are fine clothes... and a hidden compartment."
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'gem'
                    }
                }
            },
            { 
                desc: "Study. A desk covered in maps and letters. A single candle burns endlessly.", 
                sound: 'gothic',
                objects: {
                    'desk': {
                        desc: "A mahogany desk covered in correspondence and maps.",
                        state: 'normal',
                        states: {
                            'normal': "The desk has several drawers.",
                            'searched': "A hidden compartment contains the master's journal."
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'ancient_tome'
                    },
                    'maps': "Parchment maps showing the castle and surrounding lands.",
                    'candle': "A black candle that burns without melting, casting an eerie light."
                }
            },
            { 
                desc: "Art Gallery. More portraits, these of beautiful women all with the same pale features.", 
                sound: 'gothic',
                objects: {
                    'portraits': "Paintings of beautiful women, all with jet black hair and blood-red lips.",
                    'frames': "Ornate silver frames tarnished with age.",
                    'mirror': {
                        desc: "A large standing mirror covered by a black cloth.",
                        state: 'covered',
                        states: {
                            'covered': "The mirror is covered.",
                            'uncovered': "The mirror shows no reflections of the portraits!"
                        },
                        requiredItem: null,
                        action: 'uncover',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Music Room. A grand piano plays a haunting nocturne by itself.", 
                sound: 'gothic',
                objects: {
                    'piano': "A dusty grand piano with yellowed keys that depress on their own.",
                    'music': "Sheet music for a melancholic piece called 'Requiem for the Damned'.",
                    'bench': {
                        desc: "The piano bench.",
                        state: 'closed',
                        states: {
                            'closed': "The bench is closed.",
                            'open': "Inside are love letters from centuries past."
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Bathhouse. Tiled pools filled with black water. Steam rises without heat.", 
                sound: 'gothic',
                objects: {
                    'pools': "Marble baths filled with still, black water. Something moves beneath.",
                    'tiles': "Mosaic tile work depicting nymphs and satyrs in compromising positions.",
                    'steam': "Cold mist that rises from the water's surface despite no heat source."
                }
            },
            { 
                desc: "Training Room. Wooden dummies stand ready. One moves when not watched.", 
                sound: 'castle',
                objects: {
                    'dummies': {
                        desc: "Straw-stuffed practice targets. One twitches when you look away.",
                        state: 'normal',
                        states: {
                            'normal': "The dummies show signs of heavy use.",
                            'searched': "Inside one dummy's stuffing, you find a silver key!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'silver_key'
                    },
                    'weapons': "Practice weapons made of wood. Some are stained dark."
                }
            },
            { 
                desc: "Clock Tower. A massive clock frozen at midnight. Bats nest in the gears.", 
                sound: 'theme',
                objects: {
                    'clock': {
                        desc: "A giant clock face with hands forever at midnight.",
                        state: 'frozen',
                        states: {
                            'frozen': "The clock mechanism is jammed with bat guano.",
                            'cleaned': "The clock is clean but still doesn't work.",
                            'working': "The clock chimes! A secret is revealed!"
                        },
                        requiredItem: null,
                        action: 'clean',
                        hiddenItem: 'silver_key',
                        puzzle: true
                    },
                    'gears': "Enormous brass mechanisms clogged with bat nests.",
                    'bats': "Sleeping bats hanging from every available surface."
                }
            },
            { 
                desc: "Aviary. Empty birdcages hang from the ceiling. Feathers float in the air.", 
                sound: 'gothic',
                objects: {
                    'cages': "Gilded birdcages, all empty. Some doors hang open, others are bent outward.",
                    'feathers': "Black feathers that drift on non-existent breezes.",
                    'perches': "Wooden perches scarred by large, sharp talons."
                }
            },
            { 
                desc: "Laboratory. Strange machines hum with dark energy. Glass tanks hold horrors.", 
                sound: 'gothic',
                objects: {
                    'machines': "Brass and copper devices that hum with stored necromantic energy.",
                    'tanks': "Glass cylinders containing horrific hybrids of various creatures.",
                    'notes': "The doctor's notes on 'improving' natural creatures with vampiric traits."
                }
            },
            { 
                desc: "Conservatory. Dead plants in ceramic pots. A single black rose blooms.", 
                sound: 'theme',
                objects: {
                    'plants': "Withered exotic plants from around the world.",
                    'pots': "Ornate ceramic containers filled with dry, cracked earth.",
                    'rose': "A single perfect black rose that seems to absorb light around it."
                }
            },
            { 
                desc: "Archive. Scrolls crumble at your touch. Ancient knowledge lost forever.", 
                sound: 'gothic',
                objects: {
                    'scrolls': "Parchment documents that disintegrate when touched.",
                    'shelves': "Rows of shelves holding the castle's dark history.",
                    'knowledge': "What remains suggests dark rituals and vampiric lore."
                }
            },
            { 
                desc: "Forge. Cold anvils and extinguished fires. A silver sword half-forged on the bench.", 
                sound: 'castle',
                objects: {
                    'anvils': "Massive iron blocks once used for shaping weapons, now cold.",
                    'fires': "Stone hearths filled with gray ash and unburned coal.",
                    'sword': {
                        desc: "A half-completed silver blade still in the tongs.",
                        state: 'incomplete',
                        states: {
                            'incomplete': "The sword needs finishing.",
                            'complete': "The blacksmith has finished the silver sword!"
                        },
                        requiredItem: 'gem',
                        action: 'forge',
                        hiddenItem: 'silver_sword'
                    }
                }
            },
            { 
                desc: "Well Room. A deep well in the center. Something whispers from below.", 
                sound: 'catacombs',
                objects: {
                    'well': "A stone-lined shaft descending into darkness. A rope hangs down.",
                    'whispers': "Faint voices from the depths begging for release.",
                    'bucket': "A wooden bucket on a chain, stained dark red."
                }
            },
            { 
                desc: "Pantry. Rotted food in sacks. Something still moves within.", 
                sound: 'gothic',
                objects: {
                    'food': "Moldy grains and spoiled meat in burlap sacks.",
                    'sacks': "Burst bags spilling their foul contents across the floor.",
                    'something': "There's definitely movement in the darkest corner."
                }
            },
            { 
                desc: "Stable. Empty stalls with rotting hay. A large, wolflike skeleton lies in one.", 
                sound: 'castle',
                objects: {
                    'stalls': "Wooden stalls where horses once stood. The hay is rotten.",
                    'tack': "Leather harnesses and saddles chewed by rats.",
                    'skeleton': "The bones of something much larger than a horse, with wolflike features."
                }
            },
            { 
                desc: "Private Library. Books bound in human skin. They seem to watch you.", 
                sound: 'gothic',
                objects: {
                    'books': "Volumes bound in what looks like human skin. They pulse faintly.",
                    'shelves': "Ebony bookshelves reaching to a shadowed ceiling.",
                    'door': {
                        desc: "A massive oak door carved with protective runes.",
                        state: 'warded',
                        states: {
                            'warded': "The door glows with protective magic.",
                            'unlocked': "The ward dissipates."
                        },
                        requiredItem: 'crucifix',
                        action: 'unward',
                        hiddenItem: null
                    }
                }
            },
            { 
                desc: "Astrology Room. Star charts on the walls. Constellations move on their own.", 
                sound: 'theme',
                objects: {
                    'charts': "Maps of the heavens showing constellations of bats and wolves.",
                    'constellations': "The painted stars shift position when you're not looking.",
                    'orrey': "A mechanical model of the solar system, frozen in time."
                }
            },
            { 
                desc: "Meditation Chamber. Incense burners cold. A mat lies in the center.", 
                sound: 'gothic',
                objects: {
                    'incense': "Brass burners filled with gray ash that smells of funeral flowers.",
                    'mat': "A woven reed mat worn thin by years of use. It feels oddly cold.",
                    'chamber': "A perfectly round room designed for dark contemplation."
                }
            },
            { 
                desc: "Armory Vault. Magical weapons behind glass. All cases are broken open.", 
                sound: 'castle',
                objects: {
                    'weapons': "Glimmering swords and staves behind shattered display cases.",
                    'glass': "Broken protective coverings litter the floor.",
                    'vault': "A secure room that clearly failed to protect its contents."
                }
            },
            { 
                desc: "Guard Tower. Arrow slits look over the misty land. A skeleton holds a rusted crossbow.", 
                sound: 'castle',
                objects: {
                    'slits': "Narrow windows designed for archers.",
                    'skeleton': "A fallen guard still clutching a rusted crossbow.",
                    'crossbow': "A heavy crossbow with a broken string."
                }
            },
            { 
                desc: "Dungeon. Deeper than the prison. The walls sweat blood.", 
                sound: 'catacombs',
                objects: {
                    'walls': "Damp stone that weeps a red liquid. It smells of copper.",
                    'dungeon': "The lowest level where the worst prisoners were kept.",
                    'cells': "Tiny, dark cells with heavy iron doors."
                }
            },
            { 
                desc: "Catacombs. Bones arranged in patterns. They rearrange when you look away.", 
                sound: 'catacombs',
                objects: {
                    'bones': {
                        desc: "Human remains laid out in intricate patterns.",
                        state: 'normal',
                        states: {
                            'normal': "The bones form occult patterns on the floor.",
                            'disturbed': "You've moved some bones. One wall looks different...",
                            'searched': "Behind the moved stones, you find a hidden crucifix!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'crucifix'
                    },
                    'patterns': "Geometric designs that shift into new configurations constantly.",
                    'catacombs': "Tunnels lined with skulls that watch your passage."
                }
            },
            { 
                desc: "Shrine. A statue of a bat-winged demon. Offerings of gold and gems at its feet.", 
                sound: 'theme',
                objects: {
                    'statue': "A marble figure of a demon with bat wings and fangs.",
                    'offerings': "Piles of treasure left by desperate worshippers.",
                    'altar': "A black stone altar stained with centuries of blood sacrifice."
                }
            },
            { 
                desc: "Clockwork Room. Mechanical bats frozen in mid-flight. One eye follows you.", 
                sound: 'gothic',
                objects: {
                    'bats': "Brass automaton bats frozen in various poses. One twitches.",
                    'clockwork': "Intricate gears and springs that should move but don't.",
                    'eye': "A glass lens in one bat's head that tracks your movements."
                }
            },
            { 
                desc: "Mirror Hall. Reflections show different versions of yourself. Some are vampires.", 
                sound: 'gothic',
                objects: {
                    'mirrors': {
                        desc: "Tall looking glasses that show alternate versions of you.",
                        state: 'hostile',
                        states: {
                            'hostile': "The reflections show you as a vampire!",
                            'calm': "The reflections show your true self."
                        },
                        requiredItem: 'crucifix',
                        action: 'use',
                        hiddenItem: 'mirror',
                        puzzle: true
                    },
                    'reflections': "Some mirror-you's bare fangs, others recoil in horror.",
                    'hall': "A corridor lined with mirrors that seem to go on forever."
                }
            },
            { 
                desc: "Laboratory Depth. Flesh and machine fused in tanks. Things move within.", 
                sound: 'gothic',
                objects: {
                    'tanks': "Glass cylinders containing horrific hybrids.",
                    'flesh': "Pulsating tissue connected to wires and pipes.",
                    'things': "Shapes that press against the glass from inside the tanks."
                }
            },
            { 
                desc: "Necromancer's Sanctum. Black candles burn with green flame. Skulls line shelves.", 
                sound: 'gothic',
                objects: {
                    'candles': "Tapered black wax burning with unnatural green fire.",
                    'skulls': "Polished craniums arranged by size and species.",
                    'shelves': "Bookshelves holding forbidden texts and preserved organs."
                }
            },
            { 
                desc: "Sorcerer's Tower. Floating books and glowing orbs. Magic crackles in the air.", 
                sound: 'theme',
                objects: {
                    'books': "Tomes that drift through the air, pages turning on their own.",
                    'orbs': "Crystal spheres containing captured starlight.",
                    'magic': "Raw arcane energy that makes the hair on your arms stand up."
                }
            },
            { 
                desc: "Royal Treasury. Mountains of gold and jewels. A dragon skeleton guards it.", 
                sound: 'castle',
                objects: {
                    'gold': "Piles of coins, ingots, and jewelry worth a kingdom's ransom.",
                    'jewels': "Gemstones of every color glittering in the dim light.",
                    'dragon': {
                        desc: "The massive bones of a wyrm arranged as if still alive.",
                        state: 'alert',
                        states: {
                            'alert': "The dragon bones rattle threateningly.",
                            'calm': "Wearing the vampire cloak, the dragon ignores you."
                        },
                        requiredItem: 'vampire_cloak',
                        action: 'sneak',
                        hiddenItem: 'gem'
                    },
                    'skeleton': "A complete dragon skeleton that seems to watch you."
                }
            },
            { 
                desc: "Summit Chamber. The very top of the castle. Wind howls through broken windows. The master awaits.", 
                sound: 'boss',
                objects: {
                    'windows': "Shattered stained glass letting in cold wind and moonlight.",
                    'wind': "A howling gale that carries whispers of the dead.",
                    'coffin': "A massive black coffin on a raised dais. This is it.",
                    'chamber': "The highest point of Castle of the Damned. There's no going back now."
                }
            },
            // Secret Room 50: Hidden Vault (accessed from Throne Room)
            { 
                desc: "Hidden Vault. A secret chamber behind the throne. Ancient artifacts glow on pedestals.", 
                sound: 'theme',
                objects: {
                    'artifacts': "Magical items of great power rest here.",
                    'pedestals': "Stone columns holding treasures beyond imagination.",
                    'vault': "This room was meant to be found only by the worthy."
                }
            }
        ];

        // Generate 51 rooms (50 + secret room)
        function generateRooms() {
            const rooms = [];
            for (let i = 0; i < 51; i++) {
                const roomDesc = roomDescriptions[i] || { desc: "A mysterious room.", sound: 'gothic', objects: {} };
                rooms.push({
                    id: i,
                    desc: roomDesc.desc,
                    sound: roomDesc.sound,
                    objects: roomDesc.objects || {},
                    exits: i < 50 ? { 
                        n: i < 40 ? i + 10 : null, 
                        s: i >= 10 ? i - 10 : null, 
                        e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                        w: i % 10 !== 0 ? i - 1 : null 
                    } : { n: null, s: 15, e: null, w: null }, // Secret room connected to Throne Room
                    items: [],
                    enemy: null,
                    npc: null,
                    explored: false,
                    dark: i > 25 && i < 40,
                    locked: i === 36, // Private Library locked
                    secret: i === 50
                });
            }

            // Place items, enemies, and NPCs with enemy instances
            rooms[1].items = ['stake'];
            rooms[3].enemy = createEnemy('bat_swarm');
            rooms[5].items = ['potion'];
            rooms[7].enemy = createEnemy('skeleton');
            rooms[10].npc = 'alchemist';
            rooms[12].enemy = createEnemy('ghost');
            rooms[15].npc = 'priest';
            rooms[17].items = ['garlic'];
            rooms[20].enemy = createEnemy('vampire_spawn');
            rooms[22].npc = 'hunter';
            rooms[25].items = ['holy_water'];
            rooms[28].enemy = createEnemy('werewolf');
            rooms[30].npc = 'captive_vampire';
            rooms[32].items = ['leather'];
            rooms[35].enemy = createEnemy('vampire_knight');
            rooms[37].npc = 'ghost_maiden';
            rooms[39].items = ['crossbow'];
            rooms[40].npc = 'mad_scientist';
            rooms[42].enemy = createEnemy('skeleton');
            rooms[43].npc = 'cursed_blacksmith';
            rooms[45].enemy = createEnemy('vampire_knight');
            rooms[46].npc = 'librarian_ghost';
            rooms[47].items = ['gem', 'werewolf_fang'];
            rooms[49].enemy = createEnemy('vampire_lord');
            rooms[50].items = ['gem', 'gem', 'elixir', 'morning_star']; // Secret room treasure
            
            return rooms;
        }

        // Initialize rooms
        let rooms = generateRooms();

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            stealth: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: false,
            moves: 0,
            poisoned: false,
            ward: 0,
            barrier: 0,
            shadowed: 0,
            knownPasswords: [],
            discoveredSecrets: [],
            time: 'midnight' // Track time for vampire weaknesses
        };

        // ==================== SAVE SYSTEM ====================
        const SAVE_SLOTS = {
            QUICK: 'castle_damned_quick',
            SLOT1: 'castle_damned_slot1',
            SLOT2: 'castle_damned_slot2',
            SLOT3: 'castle_damned_slot3'
        };

        function saveGame(slot = SAVE_SLOTS.SLOT1) {
            if (!gameStarted || !player.class) {
                print("No game in progress to save.", 'error');
                return;
            }
            
            const saveData = {
                player: JSON.parse(JSON.stringify(player)),
                rooms: JSON.parse(JSON.stringify(rooms)),
                gameStarted: gameStarted,
                currentBackground: currentBackground,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem(slot, JSON.stringify(saveData));
                print(`Game saved to slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                soundSystem.playSound('notification', 0.5);
            } catch (e) {
                print("Failed to save game: " + e.message, 'error');
            }
        }

        function quickSave() {
            saveGame(SAVE_SLOTS.QUICK);
        }

        function loadGame(slot = SAVE_SLOTS.SLOT1) {
            try {
                const saveData = localStorage.getItem(slot);
                if (!saveData) {
                    print(`No save found in slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}`, 'error');
                    return false;
                }
                
                const data = JSON.parse(saveData);
                
                // Restore player state
                player = data.player;
                
                // Restore rooms (need to recreate enemy instances)
                rooms = data.rooms;
                rooms.forEach(room => {
                    if (room.enemy && room.enemy.originalType) {
                        // Recreate enemy instance from template
                        const enemyInstance = createEnemy(room.enemy.originalType);
                        if (enemyInstance) {
                            // Keep current HP if enemy wasn't defeated
                            enemyInstance.hp = room.enemy.hp;
                            enemyInstance.stunned = room.enemy.stunned || 0;
                            enemyInstance.sunburned = room.enemy.sunburned || 0;
                            room.enemy = enemyInstance;
                        }
                    }
                });
                
                gameStarted = data.gameStarted;
                currentBackground = data.currentBackground;
                
                print(`Game loaded from slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                print(`Loaded save from ${new Date(data.timestamp).toLocaleString()}`, 'system');
                soundSystem.playSound('notification', 0.5);
                
                look();
                updateUI();
                return true;
            } catch (e) {
                print("Failed to load game: " + e.message, 'error');
                return false;
            }
        }

        function quickLoad() {
            loadGame(SAVE_SLOTS.QUICK);
        }

        // ==================== GAME SYSTEMS ====================
        const lootTable = ['potion', 'manapot', 'stake', 'torch', 'gem', 'garlic', 'wolfsbane', 'blood_vial'];
        let gameStarted = false;
        let currentBackground = 'theme';
        const soundSystem = new SoundSystem();

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            // Play notification sound for important messages
            if (className === 'success' || className === 'loot' || className === 'quest') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            } else if (className === 'puzzle') {
                soundSystem.playSound('puzzle', 0.5);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            let statusText = `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} STE:${player.stealth} ` +
                `LVL:${player.level} GOLD:${player.gold} TIME:${player.time}${combat}`;
                
            // Add status effects
            const effects = [];
            if (player.poisoned) effects.push('POISON');
            if (player.ward > 0) effects.push(`WARD(${player.ward})`);
            if (player.barrier > 0) effects.push(`BARRIER(${player.barrier})`);
            if (player.shadowed > 0) effects.push(`SHADOW(${player.shadowed})`);
            
            if (effects.length > 0) {
                statusText += `\nEFFECTS: ${effects.join(' ')}`;
            }
            
            status.textContent = statusText;
        }

        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            let baseStealth = classes[player.class].stealth;
            if (weapon.stealth) baseStealth += weapon.stealth;
            if (armor.stealth) baseStealth += armor.stealth;
            player.stealth = Math.max(0, baseStealth);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 120;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 18;
                player.hp = player.maxHp;
                player.maxMp += 10;
                player.mp = player.maxMp;
                player.str += 2;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        // ==================== BUTTON-BASED COMMAND EXECUTION ====================
        function executeCommand(cmd) {
            if (!player.class) return;
            
            const parts = cmd.split(' ');
            const verb = parts[0];
            const arg = parts[1];
            const arg2 = parts[2];
            const arg3 = parts[3];
            
            print(`> ${cmd}`, 'command');
            soundSystem.playSound('click', 0.3);
            
            switch (verb) {
                case 'n': case 'north': move('n'); break;
                case 's': case 'south': move('s'); break;
                case 'e': case 'east': move('e'); break;
                case 'w': case 'west': move('w'); break;
                case 'secret': move('secret'); break;
                case 'look': look(); break;
                case 'attack': if (arg) attack(arg); else attack(); break;
                case 'inventory': case 'inv': case 'i': showInventory(); break;
                case 'skills': showSkills(); break;
                case 'status': updateStatus(); break;
                case 'help': help(); break;
                case 'quit': resetGame(); break;
                case 'take': 
                    if (arg === 'all') {
                        takeAll();
                    } else if (arg) {
                        take(arg);
                    }
                    break;
                case 'list': listShop(); break;
                case 'forge': forgeWeapon(); break;
                case 'charge': if (arg === 'crystal') chargeCrystal(); break;
                case 'flee': fleeCombat(); break;
                case 'examine':
                    if (arg) {
                        examine(arg);
                    }
                    break;
                case 'use':
                    if (arg) {
                        use(arg);
                    }
                    break;
                case 'equip':
                    if (arg) {
                        equip(arg);
                    }
                    break;
                case 'talk':
                    if (arg && arg2) {
                        talkTo(arg, arg2);
                    } else if (arg) {
                        talkTo(arg);
                    }
                    break;
                case 'give':
                    if (arg) {
                        give(arg);
                    }
                    break;
                case 'buy':
                    if (arg) {
                        buy(arg);
                    }
                    break;
                case 'sell':
                    if (arg) {
                        sell(arg);
                    }
                    break;
                case 'skill':
                    if (arg) {
                        useSkill(arg);
                    }
                    break;
                default:
                    print("Command executed.", 'system');
            }
            
            updateUI();
        }

        // ==================== UI UPDATE FUNCTIONS ====================
        function updateUI() {
            updateStatus();
            
            // Update object dropdown
            updateObjectDropdown();
            
            // Show/hide sections based on game state
            const room = rooms[player.location];
            
            // Show combat section if enemy present
            if (room.enemy) {
                document.getElementById('combat-section').style.display = 'block';
            } else {
                document.getElementById('combat-section').style.display = 'none';
                document.getElementById('skills-menu').style.display = 'none';
                document.getElementById('combat-items').style.display = 'none';
            }
            
            // Show NPC section if NPC present
            if (room.npc) {
                document.getElementById('npc-section').style.display = 'block';
                updateNPCActions();
            } else {
                document.getElementById('npc-section').style.display = 'none';
                document.getElementById('npc-topics').style.display = 'none';
            }
            
            // Show shop section if at alchemist
            if (room.npc === 'alchemist') {
                document.getElementById('shop-section').style.display = 'block';
            } else {
                document.getElementById('shop-section').style.display = 'none';
                document.getElementById('buy-menu').style.display = 'none';
                document.getElementById('sell-menu').style.display = 'none';
            }
            
            // Show special buttons based on location
            document.getElementById('secret-btn').style.display = 
                (rooms[player.location].exits && rooms[player.location].exits.secret) ? 'inline-block' : 'none';
            
            document.getElementById('charge-btn').style.display = 
                (player.location === 16) ? 'inline-block' : 'none'; // Observatory
            
            document.getElementById('forge-btn').style.display = 
                (room.npc === 'cursed_blacksmith') ? 'inline-block' : 'none';
            
            // Hide menus
            hideAllMenus();
        }

        function updateObjectDropdown() {
            const select = document.getElementById('object-select');
            select.innerHTML = '<option value="">-- Choose Object --</option>';
            
            const room = rooms[player.location];
            if (room.dark && !player.torch) return;
            
            // Add room objects
            for (const key in room.objects) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                select.appendChild(option);
            }
            
            // Add items in room
            room.items.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = `${item} (item)`;
                select.appendChild(option);
            });
        }

        function updateObjectActions() {
            const select = document.getElementById('object-select');
            const objectName = select.value;
            const actionsDiv = document.getElementById('object-actions');
            
            if (!objectName) {
                actionsDiv.style.display = 'none';
                return;
            }
            
            actionsDiv.innerHTML = '';
            actionsDiv.style.display = 'flex';
            
            const room = rooms[player.location];
            
            // Check if it's a room object or an item
            if (room.objects[objectName]) {
                const obj = room.objects[objectName];
                
                if (typeof obj === 'string') {
                    // Simple object - just examine
                    const btn = document.createElement('button');
                    btn.className = 'game-button btn-action';
                    btn.textContent = 'EXAMINE';
                    btn.onclick = () => {
                        print(`You examine the ${objectName}:`, 'system');
                        print(obj, 'system');
                        hideAllMenus();
                    };
                    actionsDiv.appendChild(btn);
                } else {
                    // Complex object with states
                    const btn = document.createElement('button');
                    btn.className = 'game-button btn-action';
                    
                    if (obj.action === 'examine') {
                        btn.textContent = 'EXAMINE';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'examine');
                            hideAllMenus();
                        };
                    } else if (obj.action === 'search') {
                        btn.textContent = 'SEARCH';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'search');
                            hideAllMenus();
                        };
                    } else if (obj.action === 'unlock') {
                        btn.textContent = 'UNLOCK';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'unlock');
                            hideAllMenus();
                        };
                    } else if (obj.action === 'open') {
                        btn.textContent = 'OPEN';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'open');
                            hideAllMenus();
                        };
                    } else if (obj.action === 'cleanse') {
                        btn.textContent = 'CLEANSE';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'cleanse');
                            hideAllMenus();
                        };
                    } else if (obj.action === 'use') {
                        btn.textContent = 'USE';
                        btn.onclick = () => {
                            interactWithObject(objectName, 'use');
                            hideAllMenus();
                        };
                    } else {
                        btn.textContent = 'INTERACT';
                        btn.onclick = () => {
                            interactWithObject(objectName);
                            hideAllMenus();
                        };
                    }
                    
                    actionsDiv.appendChild(btn);
                }
            } else {
                // It's an item on the ground
                const takeBtn = document.createElement('button');
                takeBtn.className = 'game-button btn-action';
                takeBtn.textContent = 'TAKE';
                takeBtn.onclick = () => {
                    take(objectName);
                    hideAllMenus();
                    updateObjectDropdown();
                };
                actionsDiv.appendChild(takeBtn);
                
                const examineBtn = document.createElement('button');
                examineBtn.className = 'game-button btn-action';
                examineBtn.textContent = 'EXAMINE';
                examineBtn.onclick = () => {
                    examine(objectName);
                    hideAllMenus();
                };
                actionsDiv.appendChild(examineBtn);
            }
        }

        function updateNPCActions() {
            const room = rooms[player.location];
            const npcName = room.npc;
            const npc = npcs[npcName];
            const actionsDiv = document.getElementById('npc-actions');
            const topicsDiv = document.getElementById('npc-topics');
            
            actionsDiv.innerHTML = '';
            topicsDiv.innerHTML = '';
            
            if (!npc) return;
            
            // Talk button
            const talkBtn = document.createElement('button');
            talkBtn.className = 'game-button btn-npc';
            talkBtn.textContent = 'TALK';
            talkBtn.onclick = () => {
                talkTo(npcName);
                // Show topic buttons
                if (npc.dialogueTopics) {
                    topicsDiv.innerHTML = '';
                    npc.dialogueTopics.forEach(topic => {
                        const topicBtn = document.createElement('button');
                        topicBtn.className = 'game-button btn-npc';
                        topicBtn.textContent = topic.toUpperCase();
                        topicBtn.style.fontSize = '9px';
                        topicBtn.onclick = () => talkTo(npcName, topic);
                        topicsDiv.appendChild(topicBtn);
                    });
                    topicsDiv.style.display = 'flex';
                }
            };
            actionsDiv.appendChild(talkBtn);
            
            // Give button (if has quest)
            if (npc.quest && !npc.quest.completed) {
                const giveBtn = document.createElement('button');
                giveBtn.className = 'game-button btn-npc';
                giveBtn.textContent = 'GIVE';
                giveBtn.onclick = () => {
                    give(npcName);
                    updateUI();
                };
                actionsDiv.appendChild(giveBtn);
            }
            
            // Attack button (if hostile)
            if (npc.hostile) {
                const attackBtn = document.createElement('button');
                attackBtn.className = 'game-button btn-combat';
                attackBtn.textContent = 'ATTACK';
                attackBtn.onclick = () => {
                    attack(npcName);
                    updateUI();
                };
                actionsDiv.appendChild(attackBtn);
            }
        }

        function showSkillsMenu() {
            const menu = document.getElementById('skills-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            if (!player.class) return;
            
            const classSkills = classes[player.class].skills;
            classSkills.forEach(skillName => {
                const skill = skills[skillName];
                if (skill && player.mp >= skill.mpCost) {
                    const btn = document.createElement('button');
                    btn.className = 'game-button btn-magic';
                    btn.textContent = skill.name;
                    btn.style.fontSize = '9px';
                    btn.onclick = () => {
                        useSkill(skillName);
                        hideAllMenus();
                    };
                    menu.appendChild(btn);
                }
            });
            
            if (menu.children.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "No MP for skills!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
            }
        }

        function showCombatItems() {
            const menu = document.getElementById('combat-items');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            // Show combat-useful items
            const combatItems = player.inventory.filter(item => 
                items[item] && (item === 'holy_water' || item === 'wolfsbane' || 
                               item === 'garlic' || item === 'silver_bullet')
            );
            
            if (combatItems.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "No combat items!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
                return;
            }
            
            combatItems.forEach(itemName => {
                const btn = document.createElement('button');
                btn.className = 'game-button btn-action';
                btn.textContent = `USE ${itemName.toUpperCase()}`;
                btn.style.fontSize = '9px';
                btn.onclick = () => {
                    use(itemName);
                    hideAllMenus();
                };
                menu.appendChild(btn);
            });
        }

        function showEquipMenu() {
            const menu = document.getElementById('equip-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            // Find equippable items
            const equippable = player.inventory.filter(item => 
                weapons[item] || armors[item]
            );
            
            if (equippable.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "Nothing to equip!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
                return;
            }
            
            equippable.forEach(itemName => {
                const btn = document.createElement('button');
                btn.className = 'game-button btn-inventory';
                btn.textContent = `EQUIP ${itemName.toUpperCase()}`;
                btn.style.fontSize = '9px';
                btn.onclick = () => {
                    equip(itemName);
                    hideAllMenus();
                };
                menu.appendChild(btn);
            });
        }

        function showUseMenu() {
            const menu = document.getElementById('use-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            // Find usable items (consumables)
            const usable = player.inventory.filter(item => 
                items[item] && items[item].type === 'consumable'
            );
            
            if (usable.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "No usable items!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
                return;
            }
            
            usable.forEach(itemName => {
                const btn = document.createElement('button');
                btn.className = 'game-button btn-inventory';
                btn.textContent = `USE ${itemName.toUpperCase()}`;
                btn.style.fontSize = '9px';
                btn.onclick = () => {
                    use(itemName);
                    hideAllMenus();
                };
                menu.appendChild(btn);
            });
        }

        function showBuyMenu() {
            const menu = document.getElementById('buy-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            const npc = npcs['alchemist'];
            if (!npc || !npc.shopItems) return;
            
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (!item) return;
                
                const btn = document.createElement('button');
                btn.className = 'game-button btn-inventory';
                btn.textContent = `BUY ${itemName} (${item.value}g)`;
                btn.style.fontSize = '8px';
                btn.onclick = () => {
                    buy(itemName);
                    hideAllMenus();
                };
                btn.disabled = player.gold < item.value;
                menu.appendChild(btn);
            });
        }

        function showSellMenu() {
            const menu = document.getElementById('sell-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            // Items that can be sold (not quest items)
            const sellable = player.inventory.filter(item => {
                const itemObj = weapons[item] || armors[item] || items[item];
                return itemObj && itemObj.type !== 'quest' && item !== 'torch';
            });
            
            if (sellable.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "Nothing to sell!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
                return;
            }
            
            sellable.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                const sellPrice = Math.floor(item.value * 0.7);
                
                const btn = document.createElement('button');
                btn.className = 'game-button btn-inventory';
                btn.textContent = `SELL ${itemName} (${sellPrice}g)`;
                btn.style.fontSize = '8px';
                btn.onclick = () => {
                    sell(itemName);
                    hideAllMenus();
                };
                menu.appendChild(btn);
            });
        }

        function showExamineMenu() {
            const menu = document.getElementById('examine-menu');
            menu.innerHTML = '';
            menu.style.display = 'flex';
            
            // Show inventory items to examine
            player.inventory.forEach(itemName => {
                const btn = document.createElement('button');
                btn.className = 'game-button btn-action';
                btn.textContent = `EXAMINE ${itemName}`;
                btn.style.fontSize = '9px';
                btn.onclick = () => {
                    examine(itemName);
                    hideAllMenus();
                };
                menu.appendChild(btn);
            });
            
            if (player.inventory.length === 0) {
                const msg = document.createElement('div');
                msg.textContent = "Inventory empty!";
                msg.style.color = '#c00';
                msg.style.fontSize = '10px';
                msg.style.padding = '5px';
                menu.appendChild(msg);
            }
        }

        function hideAllMenus() {
            document.getElementById('skills-menu').style.display = 'none';
            document.getElementById('combat-items').style.display = 'none';
            document.getElementById('equip-menu').style.display = 'none';
            document.getElementById('use-menu').style.display = 'none';
            document.getElementById('buy-menu').style.display = 'none';
            document.getElementById('sell-menu').style.display = 'none';
            document.getElementById('examine-menu').style.display = 'none';
            document.getElementById('npc-topics').style.display = 'none';
            document.getElementById('object-actions').style.display = 'none';
            document.getElementById('object-select').value = '';
        }

        // ==================== ENHANCED OBJECT INTERACTION ====================
        function interactWithObject(objectName, action = null, param = null) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see anything!", 'error');
                return;
            }
            
            // Find the object
            let matchedObject = null;
            let objectKey = null;
            
            for (const key in room.objects) {
                if (key.toLowerCase().includes(objectName.toLowerCase()) || 
                    objectName.toLowerCase().includes(key.toLowerCase())) {
                    matchedObject = room.objects[key];
                    objectKey = key;
                    break;
                }
            }
            
            if (!matchedObject) {
                print(`You don't see a ${objectName} here.`, 'error');
                return;
            }
            
            // Simple object (string description)
            if (typeof matchedObject === 'string') {
                print(`You examine the ${objectKey}:`, 'system');
                print(matchedObject, 'system');
                soundSystem.playSound('notification', 0.3);
                return;
            }
            
            // Complex object (object with states)
            const obj = matchedObject;
            
            if (!action) {
                // Just examine
                print(`You examine the ${objectKey}:`, 'system');
                print(obj.desc, 'system');
                print(`Current state: ${obj.states[obj.state]}`, 'hint');
                
                if (obj.state === 'normal' && obj.action === 'examine') {
                    // Auto-examine if that's the action
                    performObjectAction(obj, objectKey, 'examine', param);
                }
                return;
            }
            
            // Perform specific action
            performObjectAction(obj, objectKey, action, param);
        }
        
        function performObjectAction(obj, objectKey, action, param) {
            const room = rooms[player.location];
            
            // Check if this action is valid for this object
            if (obj.action && obj.action !== action) {
                print(`You can't ${action} the ${objectKey}.`, 'error');
                return;
            }
            
            // Check if required item is needed
            if (obj.requiredItem && !player.inventory.includes(obj.requiredItem)) {
                print(`${obj.states[obj.state]}`, 'hint');
                if (obj.requiredItem === 'oil') {
                    print("Perhaps you need something to lubricate it...", 'hint');
                } else if (obj.requiredItem === 'torch') {
                    print("Maybe fire could help...", 'hint');
                } else if (obj.requiredItem === 'key') {
                    print("You need a key to unlock this.", 'hint');
                } else if (obj.requiredItem === 'silver_key') {
                    print("You need a silver key.", 'hint');
                } else if (obj.requiredItem === 'crucifix') {
                    print("This needs a holy symbol...", 'hint');
                } else if (obj.requiredItem === 'vampire_cloak') {
                    print("This requires a vampire's stealth...", 'hint');
                } else if (obj.requiredItem === 'holy_water') {
                    print("This place needs purification.", 'hint');
                } else if (obj.requiredItem === 'gem') {
                    print("This needs a valuable gem...", 'hint');
                }
                return;
            }
            
            // Handle puzzle objects
            if (obj.puzzle) {
                handlePuzzle(obj, objectKey, action, param);
                return;
            }
            
            // Handle enemy-spawning objects
            if (obj.spawnEnemy && obj.state === 'sealed') {
                obj.state = 'opened';
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'puzzle');
                soundSystem.playSound('bat');
                
                // Spawn enemy
                rooms[player.location].enemy = createEnemy(obj.spawnEnemy);
                player.inCombat = obj.spawnEnemy;
                print(`A ${obj.spawnEnemy.replace('_', ' ')} emerges!`, 'enemy');
                return;
            }
            
            // Handle secret-triggering objects
            if (obj.triggersSecret && obj.state === 'normal') {
                obj.state = 'examined';
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'puzzle');
                soundSystem.playSound('puzzle');
                
                // Open secret passage
                if (obj.secretRoom !== undefined) {
                    rooms[player.location].exits.secret = obj.secretRoom;
                    print("A hidden passage opens!", 'success');
                    soundSystem.playSound('secret');
                    player.discoveredSecrets.push(`Secret passage in room ${player.location}`);
                }
                return;
            }
            
            // Standard state transition
            if (obj.requiredItem && player.inventory.includes(obj.requiredItem)) {
                // Use the item
                const index = player.inventory.indexOf(obj.requiredItem);
                if (index !== -1 && items[obj.requiredItem] && 
                    (items[obj.requiredItem].type === 'tool' || items[obj.requiredItem].type === 'consumable')) {
                    player.inventory.splice(index, 1);
                    print(`(You use the ${obj.requiredItem})`, 'system');
                }
                
                // Change state
                const oldState = obj.state;
                
                if (obj.state === 'sealed') obj.state = 'opened';
                else if (obj.state === 'rusted') obj.state = 'oiled';
                else if (obj.state === 'locked') obj.state = 'unlocked';
                else if (obj.state === 'warded') obj.state = 'unlocked';
                else if (obj.state === 'defiled') obj.state = 'cleansed';
                else if (obj.state === 'closed') obj.state = 'open';
                else if (obj.state === 'normal' && obj.action === 'search') obj.state = 'searched';
                else if (obj.state === 'normal' && obj.action === 'examine') obj.state = 'examined';
                else if (obj.state === 'alert') obj.state = 'calm';
                else if (obj.state === 'hostile') obj.state = 'calm';
                else if (obj.state === 'frozen') obj.state = 'cleaned';
                else if (obj.state === 'cleaned') obj.state = 'working';
                else if (obj.state === 'incomplete') obj.state = 'complete';
                else if (obj.state === 'covered') obj.state = 'uncovered';
                else if (obj.state === 'dry') obj.state = 'flowing';
                else if (obj.state === 'empty') obj.state = 'used';
                else if (obj.state === 'dark') obj.state = 'charged';
                else if (obj.state === 'charged') obj.state = 'sunlight';
                
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'success');
                soundSystem.playSound('notification', 0.5);
                
                // Check for hidden item
                if (obj.hiddenItem && (obj.state === 'open' || obj.state === 'unlocked' || 
                    obj.state === 'searched' || obj.state === 'examined' || obj.state === 'cleansed' ||
                    obj.state === 'calm' || obj.state === 'flowing' || obj.state === 'working' ||
                    obj.state === 'complete' || obj.state === 'sunlight')) {
                    
                    if (!room.items.includes(obj.hiddenItem)) {
                        room.items.push(obj.hiddenItem);
                        print(`You find: ${obj.hiddenItem}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                // Special cases
                if (objectKey === 'sword' && obj.state === 'complete') {
                    // Sword forged by blacksmith
                    print("The blacksmith presents you with a finished silver sword!", 'success');
                }
                
                if (objectKey === 'crystal' && obj.state === 'sunlight') {
                    // Sun crystal charged
                    print("The crystal now glows with the light of dawn! It could destroy the master!", 'puzzle');
                    player.time = 'dawn';
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 0) {
                    // Castle gates unlock
                    print("The castle gates creak open!", 'success');
                    soundSystem.playSound('door');
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 36) {
                    // Private library door unwarded
                    print("The magical ward dissipates! The door is now accessible.", 'success');
                    soundSystem.playSound('secret');
                    rooms[36].locked = false;
                }
                
                // Update player XP for solving puzzles
                player.xp += 15;
            } else {
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'system');
            }
        }
        
        function handlePuzzle(obj, objectKey, action, param) {
            if (objectKey === 'clock') {
                if (obj.state === 'frozen') {
                    print("The clock is frozen at midnight, jammed with bat guano.", 'puzzle');
                    print("You need to clean it first.", 'hint');
                } else if (obj.state === 'cleaned') {
                    print("The clock is clean but still doesn't work. It needs to be wound.", 'puzzle');
                } else if (obj.state === 'working') {
                    print("The clock chimes! A hidden compartment opens in the mechanism!", 'success');
                    soundSystem.playSound('secret');
                    
                    // Add silver key to room items
                    if (!rooms[player.location].items.includes('silver_key')) {
                        rooms[player.location].items.push('silver_key');
                        print("You find: silver_key!", 'loot');
                        soundSystem.playSound('pickup');
                    }
                    
                    player.xp += 30;
                    player.discoveredSecrets.push("Solved the Clock Tower puzzle");
                }
            } else if (objectKey === 'mirrors') {
                if (obj.state === 'hostile') {
                    print("The reflections show you as a vampire! They reach out from the mirrors!", 'enemy');
                    if (!player.inCombat) {
                        rooms[player.location].enemy = createEnemy('vampire_spawn');
                        player.inCombat = 'vampire_spawn';
                        print("A vampire emerges from the mirror!", 'enemy');
                    }
                } else if (obj.state === 'calm') {
                    print("Holding the crucifix, the reflections show your true self.", 'success');
                    print("One mirror shatters, revealing a hidden compartment!", 'puzzle');
                    
                    if (!rooms[player.location].items.includes('mirror')) {
                        rooms[player.location].items.push('mirror');
                        print("You find: mirror!", 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
            } else if (objectKey === 'crystal') {
                if (obj.state === 'dark') {
                    print("The crystal is dark. It needs to be charged with moonlight.", 'puzzle');
                    if (player.time === 'midnight') {
                        print("It's midnight - perfect time to charge it!", 'hint');
                    }
                } else if (obj.state === 'charged') {
                    print("The crystal glows with moonlight. Now it needs sunlight...", 'puzzle');
                    print("Maybe at dawn...", 'hint');
                }
            }
        }
        
        function chargeCrystal() {
            const room = rooms[player.location];
            if (room.id !== 16) {
                print("There's no crystal here to charge.", 'error');
                return;
            }
            
            const obj = room.objects['crystal'];
            if (!obj || !obj.puzzle) {
                print("You can't charge this.", 'error');
                return;
            }
            
            interactWithObject('crystal', 'charge');
        }

        // ==================== DEEPENED NPC INTERACTION ====================
        function talkTo(npcName, topic = null) {
            const room = rooms[player.location];
            
            if (!room.npc) {
                print("There's no one here to talk to.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            
            if (npc.hostile) {
                print(`${npc.name}: "Stay away from my work!"`, 'npc');
                return;
            }
            
            soundSystem.playSound('notification', 0.5);
            
            if (topic && npc.dialogueTopics && npc.dialogueTopics.includes(topic)) {
                // Specific topic
                print(`${npc.name}: "${npc.dialogue[topic]}"`, 'dialogue');
                
                // Special topic responses
                if (room.npc === 'cursed_blacksmith' && topic === 'silver') {
                    if (player.inventory.includes('gem')) {
                        print(`${npc.name}: "I see you have a gem. I can forge you something special for it and 50 gold."`, 'npc');
                    }
                }
                
                if (room.npc === 'alchemist' && topic === 'cures') {
                    print(`${npc.name}: "If you find vampire blood, bring it to me. I might be able to synthesize a cure."`, 'npc');
                }
                
                // Add topic to known topics
                if (!player.knownPasswords.includes(topic)) {
                    player.knownPasswords.push(topic);
                }
            } else if (topic) {
                // Unknown topic
                print(`${npc.name}: "I don't know anything about that."`, 'npc');
            } else {
                // General talk
                print(`${npc.name}: "${npc.dialog}"`, 'npc');
                
                // Show available topics
                if (npc.dialogueTopics) {
                    print(`You can ask about: ${npc.dialogueTopics.join(', ')}`, 'hint');
                    print("Use 'talk [npc] [topic]' to discuss specific topics.", 'system');
                }
            }
            
            // Quest information
            if (npc.quest) {
                if (npc.quest.completed) {
                    print(`${npc.name}: "Thank you again for your help."`, 'npc');
                } else if (npc.quest.items) {
                    // Multiple items quest (alchemist)
                    const counts = {};
                    npc.quest.items.forEach(item => {
                        counts[item] = player.inventory.filter(i => i === item).length;
                    });
                    
                    print(`${npc.name}: "I need: ${npc.quest.items.map(item => `${item} (${counts[item]})`).join(', ')}."`, 'quest');
                    
                    const hasAll = npc.quest.items.every(item => counts[item] > 0);
                    if (hasAll) {
                        print(`You have all the items! Type 'give ${room.npc}' to complete the quest.`, 'quest');
                    }
                } else if (npc.quest.item) {
                    if (npc.quest.count) {
                        const count = player.inventory.filter(item => item === npc.quest.item).length;
                        print(`${npc.name}: "I need ${npc.quest.count} ${npc.quest.item}s. You have ${count}."`, 'quest');
                    } else {
                        const hasItem = player.inventory.includes(npc.quest.item);
                        print(`${npc.name}: "Bring me the ${npc.quest.item}."`, 'quest');
                        if (hasItem) {
                            print(`You have the ${npc.quest.item}. Type 'give ${room.npc}' to complete the quest.`, 'quest');
                        }
                    }
                }
            }
            
            // Special NPC offers
            if (room.npc === 'cursed_blacksmith') {
                print(`${npc.name}: "I can forge silver weapons. Bring me a gem and gold."`, 'npc');
            } else if (room.npc === 'priest') {
                print(`${npc.name}: "I can bless your weapons against the undead. Bring them to me."`, 'npc');
            } else if (room.npc === 'alchemist') {
                print(`${npc.name}: "I sell potions and tools for hunting the creatures of the night."`, 'npc');
            }
        }

        // ==================== SKILL FUNCTIONS ====================
        function showSkills() {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            print(`=== ${player.class.toUpperCase()} SKILLS ===`, 'skill');
            
            classSkills.forEach(skillName => {
                const skill = skills[skillName];
                if (skill) {
                    print(`${skill.name} (${skill.mpCost} MP): ${skill.description}`, 'skill');
                }
            });
            
            print("Use SKILLS button in combat to use a skill.", 'system');
        }

        function useSkill(skillName) {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const room = rooms[player.location];
            if (!room.enemy || !player.inCombat) {
                print("You can only use skills in combat!", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            if (!classSkills.includes(skillName)) {
                print(`You don't have the ${skillName} skill!`, 'error');
                return;
            }
            
            const skill = skills[skillName];
            if (!skill) {
                print("Unknown skill.", 'error');
                return;
            }
            
            if (player.mp < skill.mpCost) {
                print(`Not enough MP! Need ${skill.mpCost}, have ${player.mp}.`, 'error');
                return;
            }
            
            player.mp -= skill.mpCost;
            print(`You use ${skill.name}! (-${skill.mpCost} MP)`, 'skill');
            
            const endsTurn = skill.effect(player, room.enemy);
            
            // Apply sunburn damage if enemy is sunburned
            if (room.enemy.sunburned && room.enemy.sunburned > 0) {
                const sunDamage = Math.floor(room.enemy.dmg * 0.4);
                room.enemy.hp -= sunDamage;
                room.enemy.sunburned--;
                print(`Sunlight burns the enemy for ${sunDamage} damage!`, 'damage');
                soundSystem.playSound('attack', 0.3);
            }
            
            // Check if enemy is defeated
            if (room.enemy.hp <= 0) {
                const enemyType = room.enemy.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 25) + 10;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 15) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'vampire_lord') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Vampire Lord!", 'success');
                    print("Castle of the Damned is cleansed!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
                updateStatus();
                updateUI();
                return;
            }
            
            // If skill doesn't end turn, enemy doesn't attack
            if (endsTurn) {
                // Enemy turn if not stunned
                if (room.enemy.stunned && room.enemy.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    room.enemy.stunned--;
                } else {
                    enemyTurn(room.enemy);
                }
            }
            
            updateStatus();
        }

        function enemyTurn(enemyData) {
            // Apply damage reduction if warded
            let damageMultiplier = 1;
            if (player.ward > 0) {
                damageMultiplier = 0.3; // Strong reduction for holy ward
                player.ward--;
                if (player.ward <= 0) {
                    print("Your holy ward fades.", 'system');
                }
            }
            
            // Apply miss chance if shadowed
            let hitChance = 1.0;
            if (player.shadowed > 0) {
                hitChance = 0.5; // 50% miss chance
                player.shadowed--;
                if (player.shadowed <= 0) {
                    print("You step out of the shadows.", 'system');
                }
            }
            
            // Check if attack misses
            if (Math.random() > hitChance) {
                print("The enemy's attack misses!", 'success');
                return;
            }
            
            // Apply barrier if exists
            let enemyDmg = Math.max(enemyData.dmg - player.def + Math.floor(Math.random() * 6), 1);
            enemyDmg = Math.floor(enemyDmg * damageMultiplier);
            
            if (player.barrier > 0) {
                const absorbed = Math.min(player.barrier, enemyDmg);
                enemyDmg -= absorbed;
                player.barrier -= absorbed;
                print(`Your barrier absorbs ${absorbed} damage.`, 'heal');
                
                if (player.barrier <= 0) {
                    print("Your arcane barrier shatters!", 'system');
                }
            }
            
            if (enemyDmg > 0) {
                player.hp -= enemyDmg;
                print(`The enemy hits you for ${enemyDmg} damage.`, 'damage');
                soundSystem.playSound('playerHit', 0.5);
                
                // Apply werewolf curse if werewolf
                if (enemyData.originalType === 'werewolf' && Math.random() > 0.8) {
                    print("The werewolf's bite infects you! You feel the curse spreading!", 'error');
                    // Could implement curse mechanics here
                }
                
                if (player.hp <= 0) {
                    print("You have been slain... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                }
            }
        }

        // ==================== GAME LOGIC ====================
        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.stealth = c.stealth;
            player.gold = 60;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['potion', 'torch', 'garlic'];
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.ward = 0;
            player.barrier = 0;
            player.shadowed = 0;
            player.knownPasswords = [];
            player.discoveredSecrets = [];
            player.time = 'midnight';
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 60 gold, a potion, a torch, and garlic.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            
            // Hide class selection, show game controls
            document.getElementById('class-selection').style.display = 'none';
            document.getElementById('game-controls').style.display = 'block';
            
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateUI();
        }

        function look() {
            const room = rooms[player.location];
            
            // Update background music based on room
            if (room.enemy && room.enemy.bgSound) {
                currentBackground = room.enemy.bgSound;
            } else {
                currentBackground = room.sound;
            }
            soundSystem.playBackground(currentBackground);
            
            // Check if room is dark
            if (room.dark && !player.torch) {
                print("The room is pitch black. You can't see anything!", 'error');
                print("You need a light source.", 'error');
                return;
            }
            
            if (!room.explored) {
                room.explored = true;
                player.xp += 8;
                print(`+8 XP for exploring!`, 'system');
                soundSystem.playSound('notification', 0.5);
            }
            
            print(room.desc);
            
            // List interactive objects
            const objectKeys = Object.keys(room.objects);
            if (objectKeys.length > 0) {
                print(`You see: ${objectKeys.join(', ')}`, 'item');
                print("Use the OBJECT dropdown to interact with things.", 'hint');
            }
            
            if (room.items.length > 0) {
                print(`Items here: ${room.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
            
            if (room.enemy) {
                const enemy = room.enemy;
                print(`${enemy.desc}`, 'enemy');
                const healthPercent = (enemy.hp / enemies[enemy.originalType].hp) * 100;
                if (healthPercent <= 25) {
                    print(`It looks critically wounded.`, 'enemy');
                } else if (healthPercent <= 50) {
                    print(`It looks badly wounded.`, 'enemy');
                } else if (healthPercent <= 75) {
                    print(`It looks wounded.`, 'enemy');
                } else {
                    print(`It looks healthy.`, 'enemy');
                }
            }
            
            if (room.npc) {
                const npc = npcs[room.npc];
                print(`${npc.name} is here. ${npc.desc}`, 'npc');
                print(`Use the NPC INTERACTION buttons to speak with them.`, 'hint');
            }
            
            if (room.locked) {
                print("The door to this room is locked!", 'error');
            }
            
            let exits = [];
            for (let dir in room.exits) if (room.exits[dir] !== null) exits.push(dir);
            if (room.exits.secret) exits.push('secret');
            print(`Exits: ${exits.join(' ')}`);
            
            updateStatus();
        }

        function move(direction) {
            const room = rooms[player.location];
            const target = room.exits[direction];
            
            if (target === null) {
                print("You can't go that way.", 'error');
                soundSystem.playSound('click');
                return;
            }
            
            // Check for locked door
            const targetRoom = rooms[target];
            if (targetRoom.locked) {
                if (player.inventory.includes('silver_key')) {
                    targetRoom.locked = false;
                    print("You use the silver key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else if (player.inventory.includes('key')) {
                    targetRoom.locked = false;
                    print("You use the key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else {
                    print("The door is locked! You need a key.", 'error');
                    return;
                }
            }
            
            soundSystem.playSound('step', 0.3);
            
            // Check for random encounter
            player.moves++;
            if (player.moves % 3 === 0) {
                const encounterChance = Math.max(35 - player.stealth, 8);
                if (Math.random() * 100 < encounterChance) {
                    const randomEnemies = ['bat_swarm', 'skeleton', 'ghost', 'vampire_spawn'];
                    const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
                    rooms[player.location].enemy = createEnemy(enemyType);
                    print(`A ${enemyType.replace('_', ' ')} ambushes you!`, 'enemy');
                    player.inCombat = enemyType;
                    soundSystem.playSound('attack', 0.5);
                    updateUI();
                    return;
                }
            }
            
            player.location = target;
            print(`You go ${direction}.`, 'command');
            
            // Auto-save on movement
            quickSave();
            
            // Advance time
            if (player.moves % 10 === 0) {
                if (player.time === 'midnight') player.time = 'early morning';
                else if (player.time === 'early morning') player.time = 'dawn';
                else if (player.time === 'dawn') player.time = 'morning';
                else if (player.time === 'morning') player.time = 'midday';
                else if (player.time === 'midday') player.time = 'afternoon';
                else if (player.time === 'afternoon') player.time = 'dusk';
                else if (player.time === 'dusk') player.time = 'evening';
                else if (player.time === 'evening') player.time = 'night';
                else if (player.time === 'night') player.time = 'midnight';
                
                print(`Time passes... It is now ${player.time}.`, 'system');
                
                // Play thunder at night
                if (player.time === 'night' || player.time === 'midnight') {
                    soundSystem.playSound('thunder', 0.3);
                }
            }
            
            // Check for dark room
            const newRoom = rooms[player.location];
            if (newRoom.dark && !player.torch) {
                print("You enter complete darkness. You can't see!", 'error');
            } else {
                look();
            }
            
            updateUI();
        }

        function take(itemName) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            const index = room.items.indexOf(itemName);
            if (index === -1) {
                // Check if it's a special item from an object
                for (const key in room.objects) {
                    const obj = room.objects[key];
                    if (typeof obj === 'object' && obj.hiddenItem === itemName && 
                        (obj.state === 'open' || obj.state === 'unlocked' || obj.state === 'searched' || 
                         obj.state === 'examined' || obj.state === 'cleansed' || obj.state === 'calm' ||
                         obj.state === 'flowing' || obj.state === 'working' || obj.state === 'complete' ||
                         obj.state === 'sunlight')) {
                        room.items.push(itemName);
                        print(`You take the ${itemName} from the ${key}.`, 'success');
                        soundSystem.playSound('pickup');
                        updateStatus();
                        return;
                    }
                }
                print("That item isn't here.", 'error');
                return;
            }
            
            room.items.splice(index, 1);
            player.inventory.push(itemName);
            print(`You take the ${itemName}.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function takeAll() {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            if (room.items.length === 0) {
                print("There's nothing to take.", 'error');
                return;
            }
            
            room.items.forEach(item => {
                player.inventory.push(item);
                print(`You take the ${item}.`, 'success');
                soundSystem.playSound('pickup');
            });
            
            room.items = [];
            updateStatus();
        }

        function give(npcName) {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== npcName) {
                print("That NPC isn't here.", 'error');
                return;
            }
            
            const npc = npcs[npcName];
            
            if (!npc.quest || npc.quest.completed) {
                print(`${npc.name} doesn't want anything from you.`, 'npc');
                return;
            }
            
            if (npc.quest.items) {
                // Multiple items quest (alchemist)
                const hasAll = npc.quest.items.every(item => 
                    player.inventory.includes(item)
                );
                
                if (!hasAll) {
                    print(`You don't have all the required items.`, 'error');
                    return;
                }
                
                // Remove items
                npc.quest.items.forEach(item => {
                    const index = player.inventory.indexOf(item);
                    if (index !== -1) {
                        player.inventory.splice(index, 1);
                    }
                });
                
                npc.quest.completed = true;
                player.gold += npc.quest.reward.gold;
                player.xp += npc.quest.reward.xp;
                if (npc.quest.reward.item) {
                    player.inventory.push(npc.quest.reward.item);
                }
                
                print(`${npc.name}: "Excellent! Here is your reward."`, 'success');
                print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                if (npc.quest.reward.item) {
                    print(`You receive: ${npc.quest.reward.item}`, 'loot');
                }
                
                soundSystem.playSound('victory');
                checkLevelUp();
            } else if (npc.quest.count) {
                const items = player.inventory.filter(item => item === npc.quest.item);
                if (items.length >= npc.quest.count) {
                    for (let i = 0; i < npc.quest.count; i++) {
                        const index = player.inventory.indexOf(npc.quest.item);
                        player.inventory.splice(index, 1);
                    }
                    
                    npc.quest.completed = true;
                    player.gold += npc.quest.reward.gold;
                    player.xp += npc.quest.reward.xp;
                    if (npc.quest.reward.item) {
                        player.inventory.push(npc.quest.reward.item);
                    }
                    
                    print(`${npc.name}: "Excellent! Here is your reward."`, 'success');
                    print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                    if (npc.quest.reward.item) {
                        print(`You receive: ${npc.quest.reward.item}`, 'loot');
                    }
                    
                    soundSystem.playSound('victory');
                    checkLevelUp();
                } else {
                    print(`You need ${npc.quest.count} ${npc.quest.item}s. You only have ${items.length}.`, 'error');
                }
            } else {
                const index = player.inventory.indexOf(npc.quest.item);
                if (index === -1) {
                    print(`You don't have the ${npc.quest.item}.`, 'error');
                    return;
                }
                
                player.inventory.splice(index, 1);
                npc.quest.completed = true;
                player.gold += npc.quest.reward.gold;
                player.xp += npc.quest.reward.xp;
                if (npc.quest.reward.item) {
                    player.inventory.push(npc.quest.reward.item);
                }
                
                print(`${npc.name}: "Thank you! Here is your reward."`, 'success');
                print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                if (npc.quest.reward.item) {
                    print(`You receive: ${npc.quest.reward.item}`, 'loot');
                }
                
                soundSystem.playSound('victory');
                checkLevelUp();
            }
            
            updateStatus();
        }

        function forgeWeapon() {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== 'cursed_blacksmith') {
                print("The blacksmith isn't here.", 'error');
                return;
            }
            
            // Check for gem and gold
            if (player.inventory.includes('gem') && player.gold >= 50) {
                const gemIndex = player.inventory.indexOf('gem');
                player.inventory.splice(gemIndex, 1);
                player.gold -= 50;
                
                const forgedWeapons = ['silver_sword', 'crossbow', 'wolfsbane_dagger'];
                const weapon = forgedWeapons[Math.floor(Math.random() * forgedWeapons.length)];
                player.inventory.push(weapon);
                
                print("Boris hammers away at his anvil, silver glowing in the forge...", 'system');
                setTimeout(() => {
                    print(`Boris hands you a freshly forged ${weapon}!`, 'success');
                    print("The blacksmith growls approvingly.", 'npc');
                    soundSystem.playSound('equip');
                }, 1000);
            } else {
                print("You need a gem and 50 gold for forging.", 'error');
                return;
            }
            
            updateStatus();
        }

        function listShop() {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            print(`${npc.name}'s Shop:`, 'npc');
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (item) {
                    const price = item.value;
                    print(`${item.name || itemName} - ${price} gold: ${item.desc}`, 'item');
                }
            });
            print("Sell items for 70% of value.", 'npc');
        }

        function buy(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            if (!npc.shopItems.includes(itemName)) {
                print("The alchemist doesn't sell that.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                print("That item doesn't exist.", 'error');
                return;
            }
            
            if (player.gold < item.value) {
                print(`You need ${item.value} gold, but only have ${player.gold}.`, 'error');
                return;
            }
            
            player.gold -= item.value;
            player.inventory.push(itemName);
            print(`You buy ${item.name || itemName} for ${item.value} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function sell(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const index = player.inventory.indexOf(itemName);
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item || item.type === 'quest') {
                print("You can't sell that.", 'error');
                return;
            }
            
            const sellPrice = Math.floor(item.value * 0.7);
            player.gold += sellPrice;
            player.inventory.splice(index, 1);
            print(`You sell ${item.name || itemName} for ${sellPrice} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

        function attack(target) {
            const room = rooms[player.location];
            
            if (target) {
                if (room.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        room.enemy = createEnemy('werewolf');
                        room.npc = null;
                        player.inCombat = 'werewolf';
                        player.stealth = Math.max(0, player.stealth - 5);
                        print("Your reputation suffers! Stealth -5.", 'error');
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        room.npc = null;
                        player.stealth = Math.max(0, player.stealth - 10);
                        print("Your dark deed stains your soul! Stealth -10.", 'error');
                        player.xp += 25;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    updateUI();
                    return;
                }
            }
            
            if (!room.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyData = room.enemy;
            player.inCombat = enemyData.originalType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemyData.originalType}!`, 'command');
            
            // Player attack
            const playerDmg = player.dmg + Math.floor(Math.random() * 6);
            
            // Apply weapon bonuses
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            let bonusDamage = 0;
            
            if (enemyData.originalType.includes('vampire') && weapon.vs_vampire) {
                bonusDamage += weapon.vs_vampire;
            }
            if (enemyData.originalType.includes('werewolf') && weapon.vs_werewolf) {
                bonusDamage += weapon.vs_werewolf;
            }
            if ((enemyData.originalType.includes('vampire') || enemyData.originalType.includes('skeleton') || 
                 enemyData.originalType.includes('ghost')) && weapon.vs_undead) {
                bonusDamage += weapon.vs_undead;
            }
            if (weapon.holy && (enemyData.originalType.includes('vampire') || enemyData.originalType.includes('skeleton') || 
                enemyData.originalType.includes('ghost'))) {
                bonusDamage += 10;
            }
            
            const totalDamage = playerDmg + bonusDamage;
            enemyData.hp -= totalDamage;
            print(`You hit for ${totalDamage} damage${bonusDamage > 0 ? ` (+${bonusDamage} bonus)` : ''}.`, 'damage');
            soundSystem.playSound(enemyData.sounds.hit, 0.5);
            
            // Apply sunburn damage if enemy is sunburned
            if (enemyData.sunburned && enemyData.sunburned > 0) {
                const sunDamage = Math.floor(enemyData.dmg * 0.4);
                enemyData.hp -= sunDamage;
                enemyData.sunburned--;
                print(`Sunlight burns the enemy for ${sunDamage} damage!`, 'damage');
                soundSystem.playSound('attack', 0.3);
            }
            
            // Use special items
            if (enemyData.originalType.includes('vampire') && player.inventory.includes('holy_water')) {
                const holyDamage = 75;
                enemyData.hp -= holyDamage;
                print(`The holy water burns the vampire for ${holyDamage} damage!`, 'damage');
                const waterIndex = player.inventory.indexOf('holy_water');
                player.inventory.splice(waterIndex, 1);
            }
            
            if (enemyData.originalType.includes('werewolf') && player.inventory.includes('wolfsbane')) {
                const wolfsbaneDamage = 50;
                enemyData.hp -= wolfsbaneDamage;
                print(`Wolfsbane poisons the werewolf for ${wolfsbaneDamage} damage!`, 'damage');
                const wolfsbaneIndex = player.inventory.indexOf('wolfsbane');
                player.inventory.splice(wolfsbaneIndex, 1);
            }
            
            if (enemyData.originalType.includes('vampire') && player.inventory.includes('garlic')) {
                print("The garlic repels the vampire! It seems weakened.", 'success');
                enemyData.dmg = Math.floor(enemyData.dmg * 0.7);
            }
            
            if (enemyData.hp <= 0) {
                const enemyType = enemyData.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 30) + 15;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 10;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'vampire_lord') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Vampire Lord!", 'success');
                    print("Castle of the Damned is cleansed!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
            } else {
                print(`The ${enemyData.name} has ${enemyData.hp} HP left.`);
                
                // Check if enemy is stunned
                if (enemyData.stunned && enemyData.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    enemyData.stunned--;
                } else {
                    enemyTurn(enemyData);
                }
            }
            
            updateStatus();
            updateUI();
        }

        function fleeCombat() {
            const room = rooms[player.location];
            
            if (!room.enemy) {
                print("You're not in combat!", 'error');
                return;
            }
            
            // Chance to flee based on stealth
            const fleeChance = 30 + player.stealth * 5;
            if (Math.random() * 100 < fleeChance) {
                print("You successfully flee from combat!", 'success');
                room.enemy = null;
                player.inCombat = null;
                soundSystem.playSound('step');
            } else {
                print("You fail to escape!", 'error');
                enemyTurn(room.enemy);
            }
            
            updateUI();
        }

        function use(itemName) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(`You heal ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(`You restore ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.ward_vampire) {
                    player.ward = item.effect.ward_vampire;
                    print(`Garlic repels vampires for ${player.ward} turns.`, 'success');
                    soundSystem.playSound('buff', 0.5);
                }
                if (item.effect.damage_undead) {
                    print("Holy water must be used in combat against undead!", 'error');
                    return;
                }
                if (item.effect.damage_werewolf) {
                    print("Wolfsbane must be used in combat against werewolves!", 'error');
                    return;
                }
                if (item.effect.damage_vampire) {
                    print("Silver bullets must be used in combat against vampires!", 'error');
                    return;
                }
                if (item.effect.hp && item.effect.mp === -10) {
                    // Blood vial (heals but corrupts)
                    print("You drink the vampire blood. You feel stronger but corrupted...", 'system');
                }
                player.inventory.splice(index, 1);
                updateStatus();
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(player.torch ? "You light the torch." : "You extinguish the torch.", 'system');
                soundSystem.playSound('click');
            } else if (itemName === 'crucifix') {
                print("You hold up the crucifix. It glows with holy light.", 'system');
                soundSystem.playSound('buff', 0.5);
                // Could implement area effect against undead
            } else if (itemName === 'mirror') {
                print("You look in the mirror. Your reflection looks back.", 'system');
                // Could implement vampire detection
            } else {
                print("You can't use that now.");
            }
        }

        function showInventory() {
            if (player.inventory.length === 0) {
                print("Your inventory is empty.");
            } else {
                print("Inventory:");
                const counts = {};
                player.inventory.forEach(item => {
                    counts[item] = (counts[item] || 0) + 1;
                });
                
                Object.keys(counts).forEach(itemName => {
                    const item = weapons[itemName] || armors[itemName] || items[itemName];
                    const count = counts[itemName];
                    const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
                    print(`${itemName} x${count}: ${itemDesc}`, 'item');
                });
            }
            const weapon = weapons[player.equipped.weapon];
            const armor = armors[player.equipped.armor];
            print(`Equipped: ${weapon.name} (${weapon.dmg + player.str} DMG), ${armor.name} (${armor.def} DEF)`);
            print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.stealth} STEALTH`);
            
            // Show discovered secrets
            if (player.discoveredSecrets.length > 0) {
                print(`\nDiscovered Secrets:`, 'puzzle');
                player.discoveredSecrets.forEach(secret => {
                    print(`  ${secret}`, 'hint');
                });
            }
        }

        function examine(itemName) {
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                // Try to interact with object
                interactWithObject(itemName);
                return;
            }
            
            print(`${item.name || itemName}:`, 'item');
            print(`  ${item.desc}`);
            
            if (weapons[itemName]) {
                print(`  Damage: ${item.dmg}`);
                if (item.vs_vampire) print(`  vs Vampires: +${item.vs_vampire}`);
                if (item.vs_werewolf) print(`  vs Werewolves: +${item.vs_werewolf}`);
                if (item.vs_undead) print(`  vs Undead: +${item.vs_undead}`);
                if (item.holy) print(`  Holy: Effective against undead`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
                if (item.light) print(`  Light: Glows with magical light`);
            } else if (armors[itemName]) {
                print(`  Defense: ${item.def}`);
                if (item.stealth) print(`  Stealth: ${item.stealth > 0 ? '+' : ''}${item.stealth}`);
                if (item.vs_vampire) print(`  vs Vampires: +${item.vs_vampire}`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
                if (item.darkness) print(`  Darkness: Blends with shadows`);
            } else if (items[itemName]) {
                print(`  Value: ${item.value} gold`);
            }
        }

        function help() {
            print("=== CASTLE OF THE DAMNED - BUTTON EDITION ===", 'command');
            print("ALL COMMANDS ARE AVAILABLE AS BUTTONS!", 'success');
            print("", 'system');
            print("MOVEMENT: Use NORTH, SOUTH, EAST, WEST buttons", 'system');
            print("LOOK: Use LOOK button to see room description", 'system');
            print("OBJECTS: Select from dropdown, then click action button", 'system');
            print("COMBAT: ATTACK, SKILLS, USE ITEM, or FLEE buttons", 'system');
            print("NPCS: TALK, GIVE, or ask specific topics", 'system');
            print("INVENTORY: See items, EQUIP gear, USE consumables", 'system');
            print("SHOP: At the Alchemist, BUY/SELL items", 'system');
            print("SPECIAL: TAKE ALL, EXAMINE, FORGE, CHARGE CRYSTAL", 'system');
            print("SYSTEM: SAVE/LOAD, HELP, STATUS, QUIT", 'system');
            print("", 'system');
            print("=== VAMPIRE HUNTING TIPS ===", 'command');
            print("- Vampires weak to: silver, sunlight, holy symbols, garlic, stakes", 'system');
            print("- Werewolves weak to: silver, wolfsbane", 'system');
            print("- Ghosts weak to: holy water, salt", 'system');
            print("- Use garlic to repel vampires, holy water in combat", 'system');
            print("- Time affects vampire strength (weakest at dawn)", 'system');
            print("- Find the sun crystal and charge it at dawn", 'system');
            print("- Silver keys open many doors", 'system');
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            rooms = generateRooms();
            
            // Show class selection, hide game controls
            document.getElementById('class-selection').style.display = 'block';
            document.getElementById('game-controls').style.display = 'none';
            
            soundSystem.playBackground('theme');
            print("GAME OVER", 'error');
            print("Choose a class: hunter, sorcerer, dhampir.", 'system');
            updateStatus();
        }

        // ==================== INIT ====================
        print("CASTLE OF THE DAMNED (1985) - BUTTON EDITION", 'success');
        print("NIGHTFALLS GAMES PRESENTS", 'system');
        print("", 'system');
        print("A GOTHIC HORROR ADVENTURE - NOW WITH FULL BUTTON CONTROLS!", 'system');
        print("No typing needed! All commands available as buttons.", 'success');
        print("", 'system');
        print("KEY FEATURES:", 'puzzle');
        print("- Complete button-based interface", 'system');
        print("- Dropdown menus for object interaction", 'system');
        print("- Dynamic combat and NPC interaction buttons", 'system');
        print("- All original game features preserved", 'system');
        print("", 'system');
        print("Touch sound button to toggle audio", 'system');
        print("SAVE/LOAD buttons in top-left corner", 'system');
        print("", 'system');
        print("Choose your class below:", 'system');
        updateStatus();
        
        // Sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundSystem.toggle();
        });

        // Initialize audio on first user interaction
        document.addEventListener('click', function initAudio() {
            soundSystem.resumeAudioContext();
            if (!gameStarted) {
                soundSystem.playBackground('theme');
            }
            document.removeEventListener('click', initAudio);
        }, { once: true });
    </script>
</body>
</html>
