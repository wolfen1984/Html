<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
    <title>Might & Magic: Dungeon Delver (Mobile)</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        /* === GLOBAL STYLES (mobile first) === */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            background-color: #000;
            color: #fff;
            line-height: 1.3;
            padding: 8px;
            max-width: 500px;
            margin: 0 auto;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            background-image: radial-gradient(circle at 10% 20%, rgba(40, 0, 0, 0.9) 0%, transparent 20%),
                              radial-gradient(circle at 90% 80%, rgba(0, 20, 40, 0.9) 0%, transparent 20%);
            image-rendering: pixelated;
        }
        .game-container {
            border: 4px double #fff;
            padding: 12px;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.85);
            box-shadow: 0 0 0 1px #333, 0 0 20px rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        .game-container::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%);
            background-size: 100% 4px;
            z-index: 2;
            pointer-events: none;
        }
        h1 {
            color: #ff3355;
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 3px 3px 0 #000;
            font-size: 1.5rem;
            border-bottom: 2px dotted #666;
            padding-bottom: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        h2 {
            color: #ff3355;
            margin: 12px 0 8px;
            padding-bottom: 6px;
            border-bottom: 1px dashed #666;
            font-size: 1rem;
        }
        .screen { display: none; min-height: 400px; }
        .active-screen { display: block; }

        /* Status bar */
        .status-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            background-color: #222;
            padding: 8px 6px;
            border: 2px solid #fff;
            margin-bottom: 12px;
            font-size: 9px;
        }
        .status-item {
            margin: 2px 5px;
            color: #ff3355;
            min-width: 70px;
        }
        .status-value {
            color: #fff;
            display: block;
            margin-top: 2px;
            font-size: 11px;
        }

        /* Direction bar (replaces first‚Äëperson text) */
        .direction-bar {
            background-color: #1a1a1a;
            border: 2px solid #ffaa00;
            padding: 8px 10px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            text-transform: uppercase;
        }
        .direction { color: #ffaa00; background: #000; padding: 4px 8px; border: 1px solid #666; }
        .dungeon-quickinfo { color: #aaa; display: flex; gap: 10px; }

        /* AUTO‚ÄëMAP ‚Äì now the main visual element */
        .automap-container {
            background-color: #111;
            border: 3px solid #fff;
            padding: 15px 5px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .automap-grid {
            display: inline-grid;
            grid-template-columns: repeat(9, minmax(28px, 8vw));
            gap: 3px;
            justify-content: center;
            margin: 5px 0;
            border: 2px solid #444;
            padding: 8px;
            background-color: #000;
        }
        .map-cell {
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 1px solid #333;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
        }
        .map-wall { background-color: #444; }
        .map-floor { background-color: #222; }
        .map-player { background-color: #44aaff; color: #000; }
        .map-monster { background-color: #ff3355; color: #000; }
        .map-treasure { background-color: #ffaa00; color: #000; }
        .map-exit { background-color: #44ff88; color: #000; }
        .map-door { background-color: #664400; color: #ffaa00; }
        .map-legend {
            font-size: 9px;
            color: #aaa;
            margin-top: 6px;
            text-align: center;
        }

        /* Party display ‚Äì horizontal scroll */
        .party-container {
            display: flex;
            overflow-x: auto;
            gap: 10px;
            margin: 15px 0;
            padding-bottom: 8px;
        }
        .party-container::-webkit-scrollbar { height: 6px; }
        .party-container::-webkit-scrollbar-thumb { background: #ff3355; border-radius: 10px; }
        .party-member {
            flex: 0 0 150px;
            background-color: #222;
            border: 2px solid #fff;
            padding: 10px;
            font-size: 9px;
        }
        .party-member.active { border-color: #ffaa00; }
        .member-name { color: #ff3355; font-size: 10px; margin-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .member-class { color: #44aaff; font-size: 8px; margin-bottom: 6px; }
        .member-health { height: 6px; background-color: #333; margin: 4px 0; }
        .member-health-fill { height: 100%; background-color: #ff3355; }
        .member-mana { height: 6px; background-color: #333; margin: 4px 0; }
        .member-mana-fill { height: 100%; background-color: #44aaff; }
        .member-status { font-size: 8px; color: #aaa; }

        /* Dungeon controls ‚Äì 2x4 grid */
        .dungeon-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        .dungeon-btn {
            background-color: #333;
            color: #ffaa00;
            border: 2px solid #fff;
            padding: 16px 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            text-align: center;
            touch-action: manipulation;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dungeon-btn:active { background-color: #444; border-color: #ffaa00; transform: translateY(1px); }

        /* Combat log */
        .combat-log {
            background-color: #111;
            border: 2px solid #fff;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        /* Bottom action buttons */
        .action-buttons {
            display: flex;
            justify-content: space-around;
            gap: 10px;
            margin: 15px 0;
        }
        .action-btn {
            background-color: #333;
            color: #ffaa00;
            border: 2px solid #fff;
            padding: 12px 5px;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            flex: 1;
            text-align: center;
        }
        .action-btn:active { background-color: #444; border-color: #ffaa00; }

        /* Town, shops etc. (unchanged) */
        .menu, .town-locations, .shop-items { display: grid; grid-template-columns: 1fr; gap: 8px; }
        .menu-option, .town-location, .shop-item {
            background-color: #333;
            border: 2px solid #fff;
            padding: 15px;
            text-align: center;
            font-size: 12px;
        }
        .town-location { border-color: #666; }
        .divider {
            height: 2px; background-color: #fff; margin: 15px 0; position: relative;
        }
        .divider::before, .divider::after {
            content: "‚óÜ"; position: absolute; top: -10px; color: #ffaa00;
            font-size: 16px; background-color: #000; padding: 0 8px;
        }
        .divider::before { left: 10px; }
        .divider::after { right: 10px; }
        .footer { text-align: center; margin-top: 15px; color: #666; font-size: 8px; }
        .crt-curve {
            position: fixed; top:0; left:0; right:0; bottom:0;
            pointer-events: none;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0) 60%, rgba(0,0,0,0.3) 100%);
            z-index: 100;
        }
    </style>
</head>
<body>
<div class="crt-curve"></div>
<div class="game-container">
    <h1>MIGHT & MAGIC: DUNGEON DELVER</h1>
    <div class="divider"></div>

    <!-- Status bar (always visible) -->
    <div class="status-bar">
        <div class="status-item">DUNGEON: <span class="status-value" id="currentDungeon">-</span></div>
        <div class="status-item">FLOOR: <span class="status-value" id="currentFloor">1</span></div>
        <div class="status-item">HP: <span class="status-value" id="partyHealth">100</span>/<span class="status-value" id="partyMaxHealth">100</span></div>
        <div class="status-item">GOLD: <span class="status-value" id="gold">500</span></div>
        <div class="status-item">TORCHES: <span class="status-value" id="torches">10</span></div>
        <div class="status-item">MAP: <span class="status-value" id="mapProgress">0</span>%</div>
    </div>

    <!-- Character Creation Screen -->
    <div id="creationScreen" class="screen active-screen">
        <h2>PARTY CREATION</h2>
        <p>FORM YOUR PARTY OF FOUR.</p>
        <div id="partyCreation" style="margin:20px 0;"></div>
        <div style="text-align:center;"><button onclick="completePartyCreation()">BEGIN ADVENTURE</button></div>
    </div>

    <!-- Town Screen -->
    <div id="townScreen" class="screen">
        <h2>TOWN OF RIVERWOOD</h2>
        <div class="town-interface">
            <div class="town-locations">
                <div class="town-location" onclick="goToInn()"><div class="location-name">INN</div><div class="location-desc">REST & HEAL</div></div>
                <div class="town-location" onclick="goToShop()"><div class="location-name">BLACKSMITH</div><div class="location-desc">BUY ITEMS</div></div>
                <div class="town-location" onclick="goToMagicShop()"><div class="location-name">MAGIC SHOP</div><div class="location-desc">BUY SPELLS</div></div>
                <div class="town-location" onclick="goToGuild()"><div class="location-name">GUILD</div><div class="location-desc">QUESTS</div></div>
                <div class="town-location" onclick="goToTemple()"><div class="location-name">TEMPLE</div><div class="location-desc">CURES</div></div>
                <div class="town-location" onclick="goToDungeonSelect()"><div class="location-name">DUNGEON GATE</div><div class="location-desc">ENTER</div></div>
            </div>
        </div>
        <div id="townMessage" style="margin-top:15px; padding:10px; background:#222;"></div>
    </div>

    <!-- Dungeon Selection Screen -->
    <div id="dungeonSelectScreen" class="screen">
        <h2>SELECT DUNGEON</h2>
        <div class="menu">
            <div class="menu-option" onclick="enterDungeon('catacombs')">CATACOMBS (L1-3)</div>
            <div class="menu-option" onclick="enterDungeon('crystal')">CRYSTAL CAVERNS (L2-4)</div>
            <div class="menu-option" onclick="enterDungeon('fortress')">FORGOTTEN FORTRESS (L3-5)</div>
            <div class="menu-option" onclick="enterDungeon('labyrinth')">MINOTAUR (L4-6)</div>
            <div class="menu-option" onclick="enterDungeon('void')">VOID TEMPLE (L5+)</div>
        </div>
        <button onclick="goToTown()">BACK</button>
    </div>

    <!-- DUNGEON SCREEN (Redesigned for portrait) -->
    <div id="dungeonScreen" class="screen">
        <h2 id="dungeonTitle">DUNGEON - FLOOR 1</h2>

        <!-- Direction bar (replaces old first‚Äëperson text) -->
        <div class="direction-bar">
            <span class="direction" id="infoDirection">NORTH</span>
            <div class="dungeon-quickinfo">
                <span id="infoPos">(5,5)</span>
                <span>üëæ <span id="infoMonsters">0</span></span>
                <span>‚ö†Ô∏è <span id="infoTraps">0</span></span>
            </div>
        </div>

        <!-- AUTO-MAP (now the main view) -->
        <div class="automap-container">
            <div id="automapGrid" class="automap-grid"></div>
            <div class="map-legend">‚ñà=WALL ‚ñë=FLOOR P=YOU M=MONSTER T=TREASURE E=EXIT D=DOOR</div>
        </div>

        <!-- Party Status (horizontal scroll) -->
        <div class="party-container" id="partyContainer"></div>

        <!-- Dungeon Action Controls (grid) -->
        <div class="dungeon-controls">
            <div class="dungeon-btn" onclick="moveForward()">‚Üë MOVE</div>
            <div class="dungeon-btn" onclick="turnLeft()">‚Ü∞ LEFT</div>
            <div class="dungeon-btn" onclick="turnRight()">‚Ü± RIGHT</div>
            <div class="dungeon-btn" onclick="moveBackward()">‚Üì BACK</div>
            <div class="dungeon-btn" onclick="searchArea()">üîç SEARCH</div>
            <div class="dungeon-btn" onclick="restInDungeon()">üí§ REST</div>
            <div class="dungeon-btn" onclick="useSkill('detect_traps')">‚ö†Ô∏è DETECT</div>
            <div class="dungeon-btn" onclick="useSkill('detect_secret')">üîì SECRET</div>
        </div>

        <!-- Combat Log -->
        <div id="combatLog" class="combat-log"></div>

        <!-- Bottom action buttons -->
        <div class="action-buttons">
            <div class="action-btn" onclick="fleeToTown()">FLEE</div>
            <div class="action-btn" onclick="useTorch()" id="torchButton">TORCH (<span id="torchCount">10</span>)</div>
            <div class="action-btn" onclick="viewInventory()">INV</div>
        </div>
    </div>

    <!-- Combat Screen -->
    <div id="combatScreen" class="screen">
        <h2>ENCOUNTER!</h2>
        <div id="combatView" style="text-align:center; margin:10px 0;"></div>
        <div class="combat-log" id="battleLog" style="height:150px;"></div>
        <div style="display:grid; grid-template-columns:repeat(2,1fr); gap:8px; margin:15px 0;">
            <button onclick="attackEnemy()">ATTACK</button>
            <button onclick="castSpell()">SPELL</button>
            <button onclick="useItem()">ITEM</button>
            <button onclick="fleeCombat()">FLEE</button>
            <button onclick="defend()">DEFEND</button>
        </div>
        <div class="party-container" id="combatParty"></div>
    </div>

    <!-- Shop Screen -->
    <div id="shopScreen" class="screen">
        <h2>BLACKSMITH</h2>
        <div class="shop-items">
            <div class="shop-item" onclick="buyItem('torch',5)">TORCH - 5G</div>
            <div class="shop-item" onclick="buyItem('healing_potion',25)">HEAL POTION - 25G</div>
            <div class="shop-item" onclick="buyItem('antidote',20)">ANTIDOTE - 20G</div>
            <div class="shop-item" onclick="buyItem('iron_key',50)">IRON KEY - 50G</div>
            <div class="shop-item" onclick="buyItem('trap_kit',75)">TRAP KIT - 75G</div>
            <div class="shop-item" onclick="buyItem('map_scroll',100)">MAP SCROLL - 100G</div>
        </div>
        <button onclick="goToTown()">LEAVE</button>
        <div id="shopMessage" style="margin-top:15px;"></div>
    </div>

    <!-- Magic Shop -->
    <div id="magicShopScreen" class="screen">
        <h2>MAGIC EMPORIUM</h2>
        <div class="shop-items">
            <div class="shop-item" onclick="buySpell('light')">LIGHT - 100G</div>
            <div class="shop-item" onclick="buySpell('detect_traps')">DETECT TRAPS - 150G</div>
            <div class="shop-item" onclick="buySpell('detect_secret')">DETECT SECRET - 200G</div>
            <div class="shop-item" onclick="buySpell('heal')">HEAL - 250G</div>
            <div class="shop-item" onclick="buySpell('fireball')">FIREBALL - 300G</div>
        </div>
        <button onclick="goToTown()">LEAVE</button>
        <div id="magicShopMessage" style="margin-top:15px;"></div>
    </div>

    <!-- Puzzle Screen -->
    <div id="puzzleScreen" class="screen">
        <h2>PUZZLE</h2>
        <div class="puzzle-container" style="background:#1a1a2a; border:2px solid #44aaff; padding:20px;">
            <div id="puzzleElements" style="display:flex; justify-content:center; gap:10px;"></div>
            <button onclick="checkPuzzle()">ACTIVATE</button>
            <button onclick="skipPuzzle()">FORCE</button>
            <div id="puzzleResult" style="margin-top:20px;"></div>
        </div>
    </div>

    <!-- Game Over & Victory -->
    <div id="gameOverScreen" class="screen">
        <h2 style="color:#ff3355; text-align:center;">PARTY DEFEATED</h2>
        <p>FLOORS EXPLORED: <span id="finalFloors">0</span></p>
        <p>MONSTERS SLAIN: <span id="finalMonsters">0</span></p>
        <p>TREASURE FOUND: <span id="finalTreasure">0</span> GOLD</p>
        <button onclick="restartGame()">NEW GAME</button>
    </div>
    <div id="victoryScreen" class="screen">
        <h2 style="color:#ffaa00; text-align:center;">DUNGEON CONQUERED!</h2>
        <p>FLOORS CLEARED: <span id="victoryFloors">0</span></p>
        <p>MONSTERS SLAIN: <span id="victoryMonsters">0</span></p>
        <p>TREASURE ACQUIRED: <span id="victoryTreasure">0</span> GOLD</p>
        <button onclick="goToTown()">TOWN</button>
        <button onclick="restartGame()">NEW ADVENTURE</button>
    </div>
</div>
<div class="footer">MIGHT & MAGIC: DUNGEON DELVER ‚Ä¢ MOBILE PORTRAIT</div>

<script>
    // ==================== FULL ORIGINAL GAME CODE (adapted for new UI) ====================
    // Game state
    const gameState = {
        party: [], gold: 500, torches: 10, currentDungeon: null, currentFloor: 1,
        dungeonGrid: [], playerX: 5, playerY: 5, playerDirection: 0,
        exploredTiles: new Set(), discoveredSecrets: new Set(), discoveredTraps: new Set(),
        monstersSlain: 0, treasureFound: 0, totalTurns: 0,
        inCombat: false, currentEnemy: null, combatTurn: 0,
        inPuzzle: false, currentPuzzle: null,
        inventory: {
            keys: { iron: 0, silver: 0, gold: 0 },
            potions: { healing: 3, mana: 1, antidote: 1 },
            scrolls: { identify: 1, mapping: 0 },
            special: []
        },
        spells: ['light'],
        dungeonsCompleted: []
    };

    const directions = [
        { x: 0, y: -1, name: "NORTH" },
        { x: 1, y: 0, name: "EAST" },
        { x: 0, y: 1, name: "SOUTH" },
        { x: -1, y: 0, name: "WEST" }
    ];

    const TILE = {
        WALL: '#', FLOOR: '.', DOOR: 'D', SECRET_DOOR: 'S',
        STAIRS_UP: 'U', STAIRS_DOWN: 'V', TREASURE: 'T',
        MONSTER: 'M', TRAP: 'X', PUZZLE: 'P', EXIT: 'E'
    };

    const classes = {
        warrior: { name: "WARRIOR", hpPerLevel: 12, mpPerLevel: 2, skills: ["SWORD","SHIELD","HEAVY_ARMOR"], startingEquipment: ["LONG_SWORD","CHAIN_MAIL"] },
        rogue: { name: "ROGUE", hpPerLevel: 8, mpPerLevel: 4, skills: ["DAGGER","LOCKPICK","TRAP_DISARM","STEALTH"], startingEquipment: ["DAGGER","LEATHER_ARMOR"] },
        mage: { name: "MAGE", hpPerLevel: 6, mpPerLevel: 10, skills: ["STAFF","SPELLCAST","IDENTIFY","ENCHANT"], startingEquipment: ["STAFF","ROBE"] },
        cleric: { name: "CLERIC", hpPerLevel: 10, mpPerLevel: 6, skills: ["MACE","HEAL","TURN_UNDEAD","PROTECTION"], startingEquipment: ["MACE","CHAIN_MAIL"] }
    };

    const dungeons = {
        catacombs: { name: "CATACOMBS OF RIVERWOOD", floors: 3, monsters: ["SKELETON","ZOMBIE","GOBLIN"], treasures: [50,200] },
        crystal: { name: "CRYSTAL CAVERNS", floors: 4, monsters: ["CRYSTAL_GOLEM","EARTH_ELEMENTAL","BAT_SWARM"], treasures: [100,300] },
        fortress: { name: "FORGOTTEN FORTRESS", floors: 5, monsters: ["ORC","ORC_WARLORD","WAR_GOLEM"], treasures: [150,400] },
        labyrinth: { name: "MINOTAUR'S LABYRINTH", floors: 6, monsters: ["MINOTAUR","HARPIE","CYCLOPS"], treasures: [200,500] },
        void: { name: "VOID TEMPLE", floors: 7, monsters: ["DEMON","VOID_WALKER","SHADOW"], treasures: [300,750] }
    };

    const monsters = {
        SKELETON: { name: "SKELETON", health: 30, damage: [3,8], xp: 25, gold: [5,15], level: 1 },
        ZOMBIE: { name: "ZOMBIE", health: 40, damage: [4,10], xp: 30, gold: [8,20], level: 1 },
        GOBLIN: { name: "GOBLIN", health: 25, damage: [2,6], xp: 20, gold: [3,12], level: 1 },
        CRYSTAL_GOLEM: { name: "CRYSTAL GOLEM", health: 60, damage: [6,14], xp: 50, gold: [20,40], level: 2 },
        EARTH_ELEMENTAL: { name: "EARTH ELEMENTAL", health: 80, damage: [8,16], xp: 70, gold: [25,50], level: 3 },
        ORC: { name: "ORC", health: 45, damage: [5,12], xp: 35, gold: [10,25], level: 2 },
        ORC_WARLORD: { name: "ORC WARLORD", health: 100, damage: [10,20], xp: 100, gold: [50,100], level: 4 },
        MINOTAUR: { name: "MINOTAUR", health: 120, damage: [12,24], xp: 150, gold: [75,150], level: 5 },
        DEMON: { name: "DEMON", health: 150, damage: [15,30], xp: 200, gold: [100,200], level: 6 },
        VOID_WALKER: { name: "VOID WALKER", health: 100, damage: [10,25], xp: 180, gold: [80,180], level: 6 }
    };

    // Initialize
    window.onload = function() { initGame(); };
    function initGame() {
        initPartyCreation();
        showScreen('creationScreen');
        const saved = localStorage.getItem('dungeonDelverSave');
        if (saved && confirm("Load saved game?")) {
            Object.assign(gameState, JSON.parse(saved));
            updateStatusBar();
            showScreen('townScreen');
            updatePartyDisplay();
        }
    }

    function initPartyCreation() {
        const pc = document.getElementById('partyCreation');
        pc.innerHTML = '';
        for (let i=0;i<4;i++) {
            pc.innerHTML += `
                <div class="party-member">
                    <h3>MEMBER ${i+1}</h3>
                    <input type="text" id="memberName${i}" value="ADVENTURER ${i+1}" style="width:100%; margin:5px 0;">
                    <select id="memberClass${i}" style="width:100%;">
                        <option value="warrior">WARRIOR</option>
                        <option value="rogue">ROGUE</option>
                        <option value="mage">MAGE</option>
                        <option value="cleric">CLERIC</option>
                    </select>
                    <div>STR <span id="str${i}">10</span> <button onclick="adjStat(${i},'str',1)">+</button><button onclick="adjStat(${i},'str',-1)">-</button></div>
                    <div>DEX <span id="dex${i}">10</span> <button onclick="adjStat(${i},'dex',1)">+</button><button onclick="adjStat(${i},'dex',-1)">-</button></div>
                    <div>INT <span id="int${i}">10</span> <button onclick="adjStat(${i},'int',1)">+</button><button onclick="adjStat(${i},'int',-1)">-</button></div>
                    <div>VIT <span id="vit${i}">10</span> <button onclick="adjStat(${i},'vit',1)">+</button><button onclick="adjStat(${i},'vit',-1)">-</button></div>
                </div>
            `;
        }
    }
    window.adjStat = function(i,s,a) {
        let e=document.getElementById(s+i);
        let v=parseInt(e.textContent)+a;
        if(v>=5&&v<=18) e.textContent=v;
    };
    function completePartyCreation() {
        gameState.party = [];
        for(let i=0;i<4;i++) {
            let c = document.getElementById(`memberClass${i}`).value;
            gameState.party.push({
                id:i, name:document.getElementById(`memberName${i}`).value.toUpperCase()||`ADVENTURER ${i+1}`,
                class:c, className:classes[c].name, level:1, xp:0, nextLevelXP:100,
                health:20+parseInt(document.getElementById(`vit${i}`).textContent)*2,
                maxHealth:20+parseInt(document.getElementById(`vit${i}`).textContent)*2,
                mana:c==='mage'?30:c==='cleric'?20:10,
                maxMana:c==='mage'?30:c==='cleric'?20:10,
                strength:parseInt(document.getElementById(`str${i}`).textContent),
                dexterity:parseInt(document.getElementById(`dex${i}`).textContent),
                intelligence:parseInt(document.getElementById(`int${i}`).textContent),
                vitality:parseInt(document.getElementById(`vit${i}`).textContent),
                skills:[...classes[c].skills], equipment:[...classes[c].startingEquipment],
                status:[], active:true
            });
        }
        updateStatusBar(); updatePartyDisplay(); showScreen('townScreen');
        document.getElementById('townMessage').innerHTML = 'WELCOME TO RIVERWOOD!';
    }

    function showScreen(id) {
        document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active-screen'));
        document.getElementById(id).classList.add('active-screen');
        if(id==='dungeonScreen') { updateDungeonView(); updatePartyDisplay(); updateAutoMap(); }
    }

    function updateStatusBar() {
        let th=0, tm=0;
        gameState.party.forEach(m=>{ if(m.active){ th+=m.health; tm+=m.maxHealth; } });
        document.getElementById('partyHealth').textContent=th;
        document.getElementById('partyMaxHealth').textContent=tm;
        document.getElementById('gold').textContent=gameState.gold;
        document.getElementById('torches').textContent=gameState.torches;
        document.getElementById('torchCount').textContent=gameState.torches;
        if(gameState.currentDungeon) {
            document.getElementById('currentDungeon').textContent=dungeons[gameState.currentDungeon].name;
            document.getElementById('currentFloor').textContent=gameState.currentFloor;
            let total=gameState.dungeonGrid.length*gameState.dungeonGrid[0].length;
            let pct=total?Math.round(gameState.exploredTiles.size/total*100):0;
            document.getElementById('mapProgress').textContent=pct;
        }
    }

    function updatePartyDisplay() {
        let pc=document.getElementById('partyContainer');
        if(!pc) return;
        pc.innerHTML='';
        gameState.party.forEach(m=>{
            pc.innerHTML+=`
                <div class="party-member ${m.active?'active':''}">
                    <div class="member-name">${m.name}</div>
                    <div class="member-class">${m.className} L${m.level}</div>
                    <div>HP ${m.health}/${m.maxHealth}</div><div class="member-health"><div class="member-health-fill" style="width:${m.health/m.maxHealth*100}%"></div></div>
                    <div>MP ${m.mana}/${m.maxMana}</div><div class="member-mana"><div class="member-mana-fill" style="width:${m.mana/m.maxMana*100}%"></div></div>
                    <div class="member-status">${m.status.length?m.status.join(','):'HEALTHY'}</div>
                </div>
            `;
        });
    }

    function updateAutoMap() {
        let grid=document.getElementById('automapGrid');
        if(!grid) return;
        grid.innerHTML='';
        let size=gameState.dungeonGrid.length;
        for(let y=-4;y<=4;y++) {
            for(let x=-4;x<=4;x++) {
                let mx=gameState.playerX+x, my=gameState.playerY+y;
                let cell=document.createElement('div');
                cell.className='map-cell';
                if(mx>=0&&my>=0&&my<size&&mx<size) {
                    let explored=gameState.exploredTiles.has(mx+','+my);
                    let tile=gameState.dungeonGrid[my][mx];
                    if(mx===gameState.playerX&&my===gameState.playerY) { cell.classList.add('map-player'); cell.textContent='P'; }
                    else if(!explored) cell.classList.add('map-wall');
                    else {
                        if(tile===TILE.WALL) { cell.classList.add('map-wall'); cell.textContent='‚ñà'; }
                        else if(tile===TILE.DOOR) { cell.classList.add('map-door'); cell.textContent='D'; }
                        else if(tile===TILE.MONSTER) { cell.classList.add('map-monster'); cell.textContent='M'; }
                        else if(tile===TILE.TREASURE) { cell.classList.add('map-treasure'); cell.textContent='T'; }
                        else if(tile===TILE.EXIT||tile===TILE.STAIRS_DOWN) { cell.classList.add('map-exit'); cell.textContent='E'; }
                        else if(tile===TILE.TRAP) {
                            if(gameState.discoveredTraps.has(mx+','+my)) { cell.classList.add('map-treasure'); cell.textContent='X'; }
                            else { cell.classList.add('map-floor'); cell.textContent='.'; }
                        }
                        else { cell.classList.add('map-floor'); cell.textContent='.'; }
                    }
                } else cell.classList.add('map-wall');
                grid.appendChild(cell);
            }
        }
        grid.style.gridTemplateColumns='repeat(9, minmax(28px, 8vw))';
    }

    function updateDungeonView() {
        let d=directions[gameState.playerDirection];
        document.getElementById('infoDirection').textContent=d.name;
        document.getElementById('infoPos').textContent=`(${gameState.playerX},${gameState.playerY})`;
        document.getElementById('infoMonsters').textContent=countNearbyMonsters();
        document.getElementById('infoTraps').textContent=gameState.discoveredTraps.size;
        document.getElementById('dungeonTitle').textContent=gameState.currentDungeon?`${dungeons[gameState.currentDungeon].name} - FLOOR ${gameState.currentFloor}`:`DUNGEON - FLOOR ${gameState.currentFloor}`;
        updateStatusBar();
    }

    function countNearbyMonsters() {
        let c=0;
        for(let dy=-3;dy<=3;dy++) for(let dx=-3;dx<=3;dx++) {
            let x=gameState.playerX+dx, y=gameState.playerY+dy;
            if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length&&gameState.dungeonGrid[y][x]===TILE.MONSTER) c++;
        }
        return c;
    }

    function generateDungeonFloor() {
        let s=11;
        gameState.dungeonGrid=[];
        for(let y=0;y<s;y++) {
            gameState.dungeonGrid[y]=[];
            for(let x=0;x<s;x++) {
                if(x===0||y===0||x===s-1||y===s-1) gameState.dungeonGrid[y][x]=TILE.WALL;
                else gameState.dungeonGrid[y][x]=Math.random()>0.3?TILE.FLOOR:TILE.WALL;
            }
        }
        gameState.dungeonGrid[gameState.playerY][gameState.playerX]=TILE.FLOOR;
        for(let i=0;i<3;i++) {
            let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
            if(gameState.dungeonGrid[y][x]===TILE.FLOOR) gameState.dungeonGrid[y][x]=TILE.DOOR;
        }
        if(gameState.currentFloor<dungeons[gameState.currentDungeon].floors) {
            let placed=false;
            while(!placed) {
                let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
                if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>3||Math.abs(y-5)>3)) {
                    gameState.dungeonGrid[y][x]=TILE.STAIRS_DOWN; placed=true;
                }
            }
        } else {
            let placed=false;
            while(!placed) {
                let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
                if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>3||Math.abs(y-5)>3)) {
                    gameState.dungeonGrid[y][x]=TILE.EXIT; placed=true;
                }
            }
        }
        for(let i=0;i<5+gameState.currentFloor;i++) {
            let placed=false;
            while(!placed) {
                let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
                if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>2||Math.abs(y-5)>2)) {
                    gameState.dungeonGrid[y][x]=TILE.MONSTER; placed=true;
                }
            }
        }
        for(let i=0;i<3+Math.floor(gameState.currentFloor/2);i++) {
            let placed=false;
            while(!placed) {
                let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
                if(gameState.dungeonGrid[y][x]===TILE.FLOOR) { gameState.dungeonGrid[y][x]=TILE.TREASURE; placed=true; }
            }
        }
        for(let i=0;i<2+gameState.currentFloor;i++) {
            let placed=false;
            while(!placed) {
                let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
                if(gameState.dungeonGrid[y][x]===TILE.FLOOR) { gameState.dungeonGrid[y][x]=TILE.TRAP; placed=true; }
            }
        }
        let placed=false;
        while(!placed) {
            let x=Math.floor(Math.random()*(s-2))+1, y=Math.floor(Math.random()*(s-2))+1;
            if(gameState.dungeonGrid[y][x]===TILE.FLOOR && (Math.abs(x-5)>2||Math.abs(y-5)>2)) {
                gameState.dungeonGrid[y][x]=TILE.PUZZLE; placed=true;
            }
        }
        gameState.exploredTiles.add(`${gameState.playerX},${gameState.playerY}`);
    }

    // Movement & actions (full original implementations)
    function moveForward() {
        let d=directions[gameState.playerDirection];
        let nx=gameState.playerX+d.x, ny=gameState.playerY+d.y;
        if(nx<0||ny<0||ny>=gameState.dungeonGrid.length||nx>=gameState.dungeonGrid[0].length) { logMessage("WALL"); return; }
        let tile=gameState.dungeonGrid[ny][nx];
        if(tile===TILE.WALL) logMessage("WALL");
        else if(tile===TILE.DOOR) {
            if(gameState.inventory.keys.iron>0) { gameState.inventory.keys.iron--; gameState.dungeonGrid[ny][nx]=TILE.FLOOR; moveTo(nx,ny); logMessage("UNLOCKED DOOR"); }
            else logMessage("LOCKED");
        } else if(tile===TILE.MONSTER) startCombat(nx,ny);
        else if(tile===TILE.TREASURE) { collectTreasure(nx,ny); moveTo(nx,ny); }
        else if(tile===TILE.TRAP) triggerTrap(nx,ny);
        else if(tile===TILE.STAIRS_DOWN) descendFloor();
        else if(tile===TILE.EXIT) completeDungeon();
        else if(tile===TILE.PUZZLE) startPuzzle(nx,ny);
        else moveTo(nx,ny);
        gameState.totalTurns++;
        updateDungeonView(); updateAutoMap();
    }
    function moveTo(x,y) { gameState.playerX=x; gameState.playerY=y; gameState.exploredTiles.add(x+','+y); if(gameState.dungeonGrid[y][x]===TILE.TRAP&&!gameState.discoveredTraps.has(x+','+y)) triggerTrap(x,y); }
    function turnLeft() { gameState.playerDirection=(gameState.playerDirection+3)%4; gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function turnRight() { gameState.playerDirection=(gameState.playerDirection+1)%4; gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function moveBackward() { gameState.playerDirection=(gameState.playerDirection+2)%4; gameState.totalTurns++; updateDungeonView(); updateAutoMap(); }
    function searchArea() {
        logMessage("SEARCHING...");
        if(Math.random()<0.3) {
            let r=Math.random();
            if(r<0.4) { let g=Math.floor(Math.random()*50)+10; gameState.gold+=g; logMessage(`FOUND ${g} GOLD`); }
            else if(r<0.7) logMessage("HIDDEN DOOR?");
            else discoverTraps();
        } else logMessage("NOTHING.");
        gameState.totalTurns++; updateStatusBar();
    }
    function discoverTraps() {
        let f=0;
        for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++) {
            let x=gameState.playerX+dx, y=gameState.playerY+dy;
            if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length&&gameState.dungeonGrid[y][x]===TILE.TRAP) {
                let k=x+','+y;
                if(!gameState.discoveredTraps.has(k)) { gameState.discoveredTraps.add(k); f++; }
            }
        }
        if(f) logMessage(`DISCOVERED ${f} TRAPS`); else logMessage("NO TRAPS");
    }
    function restInDungeon() {
        logMessage("REST...");
        gameState.party.forEach(m=>{ if(m.active) { m.health=Math.min(m.maxHealth, m.health+Math.floor(m.maxHealth*0.1)); m.mana=Math.min(m.maxMana, m.mana+Math.floor(m.maxMana*0.2)); } });
        if(Math.random()<0.3) { logMessage("AMBUSH!"); startRandomCombat(); }
        gameState.totalTurns+=3; updatePartyDisplay(); updateStatusBar();
    }
    function useSkill(s) {
        if(!gameState.spells.includes(s)) { logMessage("DON'T KNOW THAT SPELL"); return; }
        let caster=gameState.party.find(m=>m.active&&(m.class==='mage'||m.class==='cleric')&&m.mana>=10);
        if(!caster) { logMessage("NO CASTER WITH MANA"); return; }
        caster.mana-=10;
        if(s==='detect_traps') discoverTraps();
        else if(s==='light') { revealArea(); logMessage("LIGHT"); }
        else if(s==='heal') { gameState.party.forEach(m=>{ if(m.active) m.health=Math.min(m.maxHealth, m.health+20); }); logMessage("HEAL"); updatePartyDisplay(); }
        else logMessage("SPELL USED");
        gameState.totalTurns++; updateStatusBar();
    }
    function revealArea() {
        for(let dy=-2;dy<=2;dy++) for(let dx=-2;dx<=2;dx++) {
            let x=gameState.playerX+dx, y=gameState.playerY+dy;
            if(x>=0&&y>=0&&y<gameState.dungeonGrid.length&&x<gameState.dungeonGrid[0].length) gameState.exploredTiles.add(x+','+y);
        }
        updateAutoMap();
    }
    function useTorch() { if(gameState.torches>0) { gameState.torches--; revealArea(); logMessage("LIT TORCH"); } else logMessage("NO TORCHES"); updateStatusBar(); document.getElementById('torchCount').textContent=gameState.torches; }
    function fleeToTown() { if(confirm("FLEE?")) { gameState.gold-=Math.floor(gameState.gold*0.1); goToTown(); } }

    function enterDungeon(id) {
        gameState.currentDungeon=id; gameState.currentFloor=1; gameState.playerX=5; gameState.playerY=5; gameState.playerDirection=0;
        gameState.exploredTiles.clear(); gameState.discoveredSecrets.clear(); gameState.discoveredTraps.clear(); gameState.totalTurns=0;
        generateDungeonFloor(); showScreen('dungeonScreen'); updateDungeonView(); updateAutoMap();
        logMessage(`ENTERED ${dungeons[id].name}`);
    }

    function startCombat(x,y) {
        let d=dungeons[gameState.currentDungeon];
        let mt=d.monsters[Math.floor(Math.random()*d.monsters.length)];
        gameState.currentEnemy={...monsters[mt], x, y};
        gameState.inCombat=true;
        gameState.dungeonGrid[y][x]=TILE.FLOOR;
        document.getElementById('combatView').innerHTML=`<div style="color:#f35">${gameState.currentEnemy.name} APPEARS!</div><div>HP:${gameState.currentEnemy.health}</div>`;
        updateCombatParty(); showScreen('combatScreen');
        document.getElementById('battleLog').innerHTML=`<p>COMBAT STARTED!</p>`;
    }
    function startRandomCombat() {
        let d=dungeons[gameState.currentDungeon];
        let mt=d.monsters[Math.floor(Math.random()*d.monsters.length)];
        gameState.currentEnemy={...monsters[mt], x:gameState.playerX, y:gameState.playerY};
        gameState.inCombat=true;
        showScreen('combatScreen');
        document.getElementById('combatView').innerHTML=`<div style="color:#f35">${gameState.currentEnemy.name} AMBUSHES!</div><div>HP:${gameState.currentEnemy.health}</div>`;
        updateCombatParty(); document.getElementById('battleLog').innerHTML='<p>AMBUSH!</p>';
    }
    function updateCombatParty() {
        let cp=document.getElementById('combatParty');
        if(!cp) return;
        cp.innerHTML='';
        gameState.party.forEach((m,i)=>{
            cp.innerHTML+=`
                <div class="party-member ${m.active?'active':''}">
                    <div>${m.name}</div><div>HP ${m.health}</div>
                    <button onclick="partyMemberAction(${i},'attack')">ATTACK</button>
                    <button onclick="partyMemberAction(${i},'defend')">DEFEND</button>
                </div>
            `;
        });
    }
    window.partyMemberAction = function(i,act) {
        if(!gameState.inCombat||!gameState.currentEnemy) return;
        let m=gameState.party[i];
        if(!m.active||m.health<=0) return;
        let log=document.getElementById('battleLog');
        if(act==='attack') {
            let dmg=Math.floor(Math.random()*8)+4;
            gameState.currentEnemy.health-=dmg;
            log.innerHTML+=`<p>${m.name} hits for ${dmg}</p>`;
        } else if(act==='defend') {
            m.status.push('DEFENDING');
            log.innerHTML+=`<p>${m.name} defends</p>`;
        }
        if(gameState.currentEnemy.health<=0) { enemyDefeated(); return; }
        setTimeout(enemyAttack,100);
        log.scrollTop=log.scrollHeight;
        updateCombatParty();
    };
    function enemyAttack() {
        if(!gameState.currentEnemy) return;
        let log=document.getElementById('battleLog');
        let dmg=Math.floor(Math.random()*(gameState.currentEnemy.damage[1]-gameState.currentEnemy.damage[0]+1))+gameState.currentEnemy.damage[0];
        let alive=gameState.party.filter(m=>m.active&&m.health>0);
        if(!alive.length) return;
        let target=alive[Math.floor(Math.random()*alive.length)];
        let defending=target.status.includes('DEFENDING');
        let actual=defending?Math.floor(dmg/2):dmg;
        target.health-=actual;
        log.innerHTML+=`<p>${gameState.currentEnemy.name} hits ${target.name} for ${actual}</p>`;
        target.status=target.status.filter(s=>s!=='DEFENDING');
        if(target.health<=0) {
            target.health=0;
            log.innerHTML+=`<p>${target.name} KO!</p>`;
            if(gameState.party.filter(m=>m.active&&m.health>0).length===0) { gameOver(); return; }
        }
        updateCombatParty();
        log.scrollTop=log.scrollHeight;
    }
    function enemyDefeated() {
        let log=document.getElementById('battleLog');
        gameState.gold+=Math.floor(Math.random()*50)+20;
        gameState.monstersSlain++;
        log.innerHTML+=`<p>VICTORY! GOLD +${gameState.gold}</p>`;
        setTimeout(()=>{
            gameState.inCombat=false; gameState.currentEnemy=null;
            showScreen('dungeonScreen'); updateStatusBar(); updatePartyDisplay();
        },1500);
    }
    function fleeCombat() {
        if(Math.random()<0.5) { document.getElementById('battleLog').innerHTML+='<p>FLED!</p>'; setTimeout(()=>{ gameState.inCombat=false; gameState.currentEnemy=null; showScreen('dungeonScreen'); },1000); }
        else { document.getElementById('battleLog').innerHTML+='<p>CANNOT FLEE!</p>'; enemyAttack(); }
    }
    function attackEnemy() { /* use party buttons */ }
    function castSpell() { logMessage("Spell not implemented"); }
    function useItem() { logMessage("Item not implemented"); }
    function defend() { logMessage("Use party defend button"); }

    function collectTreasure(x,y) {
        let g=Math.floor(Math.random()*200)+50;
        gameState.gold+=g; gameState.dungeonGrid[y][x]=TILE.FLOOR; logMessage(`FOUND ${g} GOLD`); updateStatusBar();
    }
    function triggerTrap(x,y) {
        let k=x+','+y;
        if(gameState.discoveredTraps.has(k)) { logMessage("DISARMED"); gameState.dungeonGrid[y][x]=TILE.FLOOR; return; }
        gameState.discoveredTraps.add(k);
        let dmg=Math.floor(Math.random()*20)+5;
        gameState.party.forEach(m=>{ if(m.active) m.health=Math.max(1,m.health-dmg); });
        gameState.dungeonGrid[y][x]=TILE.FLOOR;
        logMessage(`TRAP! ${dmg} DAMAGE`);
        updatePartyDisplay();
        if(gameState.party.filter(m=>m.active&&m.health>0).length===0) gameOver();
    }
    function startPuzzle(x,y) {
        gameState.inPuzzle=true; gameState.currentPuzzle={x,y};
        document.getElementById('puzzleElements').innerHTML='FIRE WATER EARTH AIR'.split(' ').map(e=>`<div class="puzzle-element" onclick="cycleElement(this)" data-element="${e}">${e[0]}</div>`).join('');
        showScreen('puzzleScreen');
    }
    window.cycleElement=function(el){ let els=['FIRE','WATER','EARTH','AIR']; let cur=el.dataset.element; let nxt=els[(els.indexOf(cur)+1)%4]; el.dataset.element=nxt; el.textContent=nxt[0]; };
    function checkPuzzle() {
        let order=[...document.querySelectorAll('#puzzleElements .puzzle-element')].map(e=>e.dataset.element);
        if(order.join()==='FIRE,WATER,EARTH,AIR') {
            document.getElementById('puzzleResult').innerHTML='<p class="heal">SOLVED! +100G</p>';
            gameState.gold+=100; gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x]=TILE.FLOOR;
            setTimeout(()=>{ gameState.inPuzzle=false; showScreen('dungeonScreen'); },2000);
        } else {
            document.getElementById('puzzleResult').innerHTML='<p>WRONG -5HP</p>';
            gameState.party.forEach(m=>m.health=Math.max(1,m.health-5));
            updatePartyDisplay();
        }
    }
    function skipPuzzle() { if(confirm("FORCE?")) { if(Math.random()<0.5) { document.getElementById('puzzleResult').innerHTML='SUCCESS'; gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x]=TILE.FLOOR; } else { document.getElementById('puzzleResult').innerHTML='FAIL -15HP'; gameState.party.forEach(m=>m.health=Math.max(1,m.health-15)); } setTimeout(()=>{ gameState.inPuzzle=false; showScreen('dungeonScreen'); },2000); } }
    function descendFloor() {
        if(gameState.currentFloor<dungeons[gameState.currentDungeon].floors) {
            gameState.currentFloor++; gameState.playerX=5; gameState.playerY=5; gameState.playerDirection=0;
            gameState.exploredTiles.clear(); gameState.discoveredSecrets.clear(); gameState.discoveredTraps.clear();
            generateDungeonFloor(); logMessage(`FLOOR ${gameState.currentFloor}`); updateDungeonView(); updateAutoMap();
        }
    }
    function completeDungeon() {
        gameState.gold+=1000*gameState.currentFloor; gameState.dungeonsCompleted.push(gameState.currentDungeon);
        document.getElementById('victoryFloors').textContent=gameState.currentFloor;
        document.getElementById('victoryMonsters').textContent=gameState.monstersSlain;
        document.getElementById('victoryTreasure').textContent=gameState.gold;
        showScreen('victoryScreen'); localStorage.setItem('dungeonDelverSave',JSON.stringify(gameState));
    }
    function gameOver() {
        document.getElementById('finalFloors').textContent=gameState.currentFloor;
        document.getElementById('finalMonsters').textContent=gameState.monstersSlain;
        document.getElementById('finalTreasure').textContent=gameState.gold;
        showScreen('gameOverScreen'); localStorage.removeItem('dungeonDelverSave');
    }
    function restartGame() { location.reload(); }
    function goToTown() { gameState.currentDungeon=null; gameState.inCombat=false; gameState.inPuzzle=false; showScreen('townScreen'); }
    function goToDungeonSelect() { showScreen('dungeonSelectScreen'); }
    function goToShop() { showScreen('shopScreen'); }
    function goToMagicShop() { showScreen('magicShopScreen'); }
    function goToInn() { gameState.party.forEach(m=>{ m.health=m.maxHealth; m.mana=m.maxMana; }); gameState.gold-=40; if(gameState.gold<0) gameState.gold=0; updateStatusBar(); document.getElementById('townMessage').innerHTML='RESTED'; }
    function goToGuild() { document.getElementById('townMessage').innerHTML='GUILD: NO QUESTS NOW'; }
    function goToTemple() { document.getElementById('townMessage').innerHTML='TEMPLE BLESSES YOU'; }
    function buyItem(item,c) { if(gameState.gold>=c) { gameState.gold-=c; if(item==='torch') gameState.torches++; else if(item==='healing_potion') gameState.inventory.potions.healing++; else if(item==='iron_key') gameState.inventory.keys.iron++; document.getElementById('shopMessage').innerHTML='PURCHASED'; } else document.getElementById('shopMessage').innerHTML='NOT ENOUGH'; updateStatusBar(); }
    function buySpell(s) { let cost={light:100,detect_traps:150,detect_secret:200,heal:250,fireball:300}[s]; if(gameState.gold>=cost&&!gameState.spells.includes(s)) { gameState.gold-=cost; gameState.spells.push(s); document.getElementById('magicShopMessage').innerHTML='LEARNED'; } else document.getElementById('magicShopMessage').innerHTML='CANNOT BUY'; updateStatusBar(); }
    function logMessage(m) { let l=document.getElementById('combatLog'); if(l) { l.innerHTML+=`<p>${m}</p>`; l.scrollTop=l.scrollHeight; } }
    function viewInventory() { alert('Keys: iron '+gameState.inventory.keys.iron+' | Potions: healing '+gameState.inventory.potions.healing); }
</script>
</body>
</html>
