<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower of Terror (1984) - Nightfalls Games</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #0f0;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #0f0;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            align-items: center;
        }
        #prompt {
            margin-right: 8px;
            white-space: nowrap;
        }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid #0f0;
            color: #0f0;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 4px 0;
        }
        #status {
            border-top: 1px solid #0f0;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        .command {
            color: #ff0;
        }
        .error {
            color: #f00;
        }
        .item {
            color: #0ff;
        }
        .enemy {
            color: #f0f;
        }
        .npc {
            color: #ffa500;
        }
        .success {
            color: #0f0;
        }
        .quest {
            color: #ffff00;
        }
        .loot {
            color: #ff69b4;
        }
        .system {
            color: #888;
        }
        .damage {
            color: #ff4500;
        }
        .heal {
            color: #32cd32;
        }
        .skill {
            color: #00ffff;
        }
        .puzzle {
            color: #ff00ff;
        }
        .hint {
            color: #aaa;
        }
        .dialogue {
            color: #ffcc00;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        .quick-command {
            display: inline-block;
            background: #222;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 6px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        #quick-commands {
            margin-top: 8px;
            text-align: center;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        #save-load-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #000;
            border: 1px solid #0f0;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        .save-load-btn {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 4px;
            margin: 2px;
            cursor: pointer;
            font-size: 8px;
        }
    </style>
</head>
<body>
    <div id="save-load-controls">
        <button class="save-load-btn" onclick="saveGame()">SAVE</button>
        <button class="save-load-btn" onclick="loadGame()">LOAD</button>
        <button class="save-load-btn" onclick="quickSave()">QSAVE</button>
        <button class="save-load-btn" onclick="quickLoad()">QLOAD</button>
    </div>
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    <div id="header">
        <h1>TOWER OF TERROR</h1>
        <div>1984 â€¢ NIGHTFALLS GAMES</div>
    </div>
    <div id="game-container">
        <div id="output">Welcome to the Tower of Terror! Type 'help' for commands.</div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="quick-commands">
            <span class="quick-command" onclick="quickCommand('n')">N</span>
            <span class="quick-command" onclick="quickCommand('s')">S</span>
            <span class="quick-command" onclick="quickCommand('e')">E</span>
            <span class="quick-command" onclick="quickCommand('w')">W</span>
            <span class="quick-command" onclick="quickCommand('look')">LOOK</span>
            <span class="quick-command" onclick="quickCommand('attack')">ATTACK</span>
            <span class="quick-command" onclick="quickCommand('inventory')">INV</span>
            <span class="quick-command" onclick="quickCommand('skills')">SKILLS</span>
        </div>
        <div id="status"></div>
    </div>

    <script>
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.3; // Lower volume for background music
                    this.sfxGain.gain.value = 0.5; // Higher volume for SFX
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            // ==================== MUSIC GENERATION ====================
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                // Don't restart same music
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                // Stop current background
                this.stopBackground();
                
                this.currentBgName = musicName;
                
                // Generate music based on name
                switch(musicName) {
                    case 'theme':
                        this.playThemeTune(loop);
                        break;
                    case 'dungeon':
                        this.playDungeonMusic(loop);
                        break;
                    case 'eerie':
                        this.playEerieMusic(loop);
                        break;
                    case 'boss':
                        this.playBossMusic(loop);
                        break;
                    case 'victory':
                        this.playVictoryMusic(loop);
                        break;
                    default:
                        this.playThemeTune(loop);
                }
            }
            
            playThemeTune(loop) {
                // Create main melody
                const melody = [
                    {note: 440, duration: 0.3},  // A
                    {note: 493.88, duration: 0.3}, // B
                    {note: 523.25, duration: 0.3}, // C
                    {note: 587.33, duration: 0.3}, // D
                    {note: 659.25, duration: 0.6}, // E
                    {note: 587.33, duration: 0.3}, // D
                    {note: 523.25, duration: 0.3}, // C
                    {note: 493.88, duration: 0.3}, // B
                    {note: 440, duration: 0.6},    // A
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.2);
            }
            
            playDungeonMusic(loop) {
                // Dark, suspenseful dungeon music
                const melody = [
                    {note: 130.81, duration: 0.5}, // C low
                    {note: 164.81, duration: 0.5}, // E
                    {note: 196.00, duration: 0.5}, // G
                    {note: 146.83, duration: 0.5}, // D
                    {note: 174.61, duration: 1.0}, // F
                ];
                
                this.playMelody(melody, 'square', loop, 0.15);
            }
            
            playEerieMusic(loop) {
                // Creepy, atmospheric music
                const melody = [
                    {note: 220, duration: 1.0},   // A
                    {note: 207.65, duration: 0.5}, // G#
                    {note: 196.00, duration: 1.0}, // G
                    {note: 184.99, duration: 0.5}, // F#
                    {note: 174.61, duration: 1.0}, // F
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.1);
            }
            
            playBossMusic(loop) {
                // Intense boss battle music
                const melody = [
                    {note: 261.63, duration: 0.2}, // C
                    {note: 329.63, duration: 0.2}, // E
                    {note: 392.00, duration: 0.2}, // G
                    {note: 523.25, duration: 0.4}, // C high
                    {note: 392.00, duration: 0.2}, // G
                    {note: 329.63, duration: 0.2}, // E
                    {note: 261.63, duration: 0.4}, // C
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.25);
            }
            
            playVictoryMusic(loop) {
                // Victory fanfare
                const melody = [
                    {note: 523.25, duration: 0.2}, // C
                    {note: 659.25, duration: 0.2}, // E
                    {note: 783.99, duration: 0.2}, // G
                    {note: 1046.50, duration: 0.5}, // C high
                    {note: 783.99, duration: 0.2}, // G
                    {note: 1046.50, duration: 0.5}, // C high
                    {note: 1318.51, duration: 1.0}, // E high
                ];
                
                this.playMelody(melody, 'sine', loop, 0.3);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                // Schedule notes
                let currentTime = now;
                melody.forEach((note, index) => {
                    // Set frequency
                    source.frequency.setValueAtTime(note.note, currentTime);
                    
                    // Create envelope for each note
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    
                    currentTime += note.duration;
                });
                
                if (loop) {
                    // Loop the melody
                    source.start(now);
                    source.stop(now + currentTime - now);
                    
                    // Schedule next loop
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try {
                        this.currentBgSource.stop();
                    } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            // ==================== SOUND EFFECTS ====================
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                switch(soundName) {
                    case 'click':
                        this.playClick(volume);
                        break;
                    case 'notification':
                        this.playNotification(volume);
                        break;
                    case 'levelup':
                        this.playLevelUp(volume);
                        break;
                    case 'attack':
                        this.playAttack(volume);
                        break;
                    case 'enemyHit':
                        this.playEnemyHit(volume);
                        break;
                    case 'playerHit':
                        this.playPlayerHit(volume);
                        break;
                    case 'victory':
                        this.playVictory(volume);
                        break;
                    case 'defeat':
                        this.playDefeat(volume);
                        break;
                    case 'pickup':
                        this.playPickup(volume);
                        break;
                    case 'equip':
                        this.playEquip(volume);
                        break;
                    case 'door':
                        this.playDoor(volume);
                        break;
                    case 'step':
                        this.playStep(volume);
                        break;
                    case 'spell':
                        this.playSpell(volume);
                        break;
                    case 'heal':
                        this.playHeal(volume);
                        break;
                    case 'buff':
                        this.playBuff(volume);
                        break;
                    case 'puzzle':
                        this.playPuzzle(volume);
                        break;
                    case 'secret':
                        this.playSecret(volume);
                        break;
                }
            }
            
            playClick(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playNotification(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playLevelUp(volume) {
                const now = this.audioContext.currentTime;
                
                // Play a cheerful ascending arpeggio
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C high
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.2);
                });
            }
            
            playAttack(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playEnemyHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playPlayerHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playVictory(volume) {
                const now = this.audioContext.currentTime;
                
                // Victory fanfare
                const notes = [
                    {freq: 523.25, time: 0.0, duration: 0.2},
                    {freq: 659.25, time: 0.2, duration: 0.2},
                    {freq: 783.99, time: 0.4, duration: 0.2},
                    {freq: 1046.50, time: 0.6, duration: 0.5},
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    gainNode.gain.setValueAtTime(0, now + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + note.time + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + note.time);
                    oscillator.stop(now + note.time + note.duration);
                });
            }
            
            playDefeat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, now);
                oscillator.frequency.exponentialRampToValueAtTime(110, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playPickup(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, now);
                oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playEquip(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playDoor(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStep(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playSpell(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playHeal(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playBuff(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(500, now);
                oscillator.frequency.exponentialRampToValueAtTime(700, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playPuzzle(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playSecret(volume) {
                const now = this.audioContext.currentTime;
                
                // Magical secret sound
                const notes = [400, 600, 800, 1000];
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.15);
                });
            }
            
            // ==================== UTILITY METHODS ====================
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            warrior: { 
                hp: 35, mp: 5, str: 8, def: 6, stealth: 3, 
                desc: "A hardy fighter with heavy armor training.",
                skills: ['bash', 'block']
            },
            wizard: { 
                hp: 22, mp: 25, str: 3, def: 2, stealth: 6,
                desc: "A master of arcane arts, quick and silent.",
                skills: ['fireball', 'shield']
            },
            necromancer: { 
                hp: 28, mp: 18, str: 4, def: 3, stealth: 5,
                desc: "A dark summoner who moves in shadows.",
                skills: ['life_drain', 'summon']
            }
        };

        // ==================== SKILL SYSTEM ====================
        const skills = {
            bash: {
                name: "Bash",
                mpCost: 5,
                description: "A powerful strike that stuns the enemy",
                class: "warrior",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.5) + Math.floor(Math.random() * 8);
                    enemyData.hp -= damage;
                    print(`You BASH the enemy for ${damage} damage!`, 'damage');
                    soundSystem.playSound('attack', 0.7);
                    
                    // 50% chance to stun
                    if (Math.random() > 0.5) {
                        enemyData.stunned = 2;
                        print("The enemy is stunned!", 'success');
                    }
                    return true;
                }
            },
            block: {
                name: "Block",
                mpCost: 3,
                description: "Raise your guard, reducing next damage",
                class: "warrior",
                effect: function(player, enemyData) {
                    player.blocking = 3;
                    print("You assume a defensive stance. Next damage reduced!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            fireball: {
                name: "Fireball",
                mpCost: 8,
                description: "Launch a magical fireball at your enemy",
                class: "wizard",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.5) + Math.floor(Math.random() * 15) + 10;
                    enemyData.hp -= damage;
                    print(`You cast FIREBALL for ${damage} damage!`, 'damage');
                    soundSystem.playSound('spell', 0.7);
                    
                    // 30% chance to burn
                    if (Math.random() > 0.7) {
                        enemyData.burning = 3;
                        print("The enemy is burning!", 'success');
                    }
                    return true;
                }
            },
            shield: {
                name: "Magic Shield",
                mpCost: 6,
                description: "Create a magical barrier that absorbs damage",
                class: "wizard",
                effect: function(player, enemyData) {
                    player.shield = Math.floor(player.maxHp * 0.3);
                    print(`You create a magical shield that absorbs ${player.shield} damage!`, 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            life_drain: {
                name: "Life Drain",
                mpCost: 7,
                description: "Steal life from your enemy to heal yourself",
                class: "necromancer",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.8) + Math.floor(Math.random() * 10);
                    enemyData.hp -= damage;
                    const heal = Math.floor(damage * 0.5);
                    player.hp = Math.min(player.maxHp, player.hp + heal);
                    print(`You drain ${damage} life from the enemy and heal ${heal} HP!`, 'skill');
                    soundSystem.playSound('heal', 0.6);
                    return true;
                }
            },
            summon: {
                name: "Summon Skeleton",
                mpCost: 10,
                description: "Summon a skeletal minion to fight for you",
                class: "necromancer",
                effect: function(player, enemyData) {
                    if (player.skeleton) {
                        print("You already have a skeleton minion!", 'error');
                        return false;
                    }
                    player.skeleton = {
                        hp: 20,
                        dmg: 8
                    };
                    print("You summon a skeletal minion to fight by your side!", 'success');
                    soundSystem.playSound('spell', 0.6);
                    return false; // Doesn't end turn
                }
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 3, type: 'weapon', value: 0, desc: "Your bare hands." },
            dagger: { name: "Dagger", dmg: 8, type: 'weapon', value: 15, desc: "A small, sharp dagger. Good for stealth attacks.", stealth: 2 },
            sword: { name: "Iron Sword", dmg: 14, type: 'weapon', value: 50, desc: "A sturdy iron longsword." },
            staff: { name: "Oak Staff", dmg: 10, type: 'weapon', value: 40, desc: "An oak staff with magical carvings.", magic: 5 },
            greatsword: { name: "Greatsword", dmg: 20, type: 'weapon', value: 120, desc: "A massive two-handed sword.", stealth: -3 },
            bow: { name: "Short Bow", dmg: 12, type: 'weapon', value: 35, desc: "A basic wooden bow with arrows.", range: true },
            mace: { name: "Iron Mace", dmg: 16, type: 'weapon', value: 65, desc: "A heavy mace for crushing armor." },
            fire_staff: { name: "Fire Staff", dmg: 18, type: 'weapon', value: 150, desc: "A staff imbued with fire magic.", magic: 10, element: 'fire' },
            skeleton_key: { name: "Skeleton Key", dmg: 1, type: 'weapon', value: 200, desc: "A magical key that can unlock any door.", magic: 5 },
            amulet_warding: { name: "Warding Amulet", dmg: 0, type: 'weapon', value: 100, desc: "An amulet that protects against dark magic.", magic: 10 }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather: { name: "Leather Armor", def: 6, type: 'armor', value: 30, desc: "Soft leather armor. Good mobility.", stealth: 2 },
            chainmail: { name: "Chainmail", def: 10, type: 'armor', value: 80, desc: "Heavy chainmail. Good protection.", stealth: -2 },
            robe: { name: "Mage Robe", def: 4, type: 'armor', value: 25, desc: "A dark mage's robe. Enhances magic.", stealth: 3, magic: 5 },
            plate: { name: "Plate Armor", def: 15, type: 'armor', value: 150, desc: "Full plate armor. Maximum protection.", stealth: -5 },
            scale: { name: "Scale Armor", def: 8, type: 'armor', value: 60, desc: "Scale armor. Balanced protection.", stealth: 0 },
            cloak: { name: "Shadow Cloak", def: 2, type: 'armor', value: 45, desc: "A cloak that blends with shadows.", stealth: 5 }
        };

        const items = {
            potion: { type: 'consumable', effect: { hp: 25 }, value: 20, desc: "Heals 25 HP." },
            manapot: { type: 'consumable', effect: { mp: 20 }, value: 25, desc: "Restores 20 MP." },
            elixir: { type: 'consumable', effect: { hp: 50, mp: 30 }, value: 60, desc: "Restores 50 HP and 30 MP." },
            antidote: { type: 'consumable', effect: { cure: 'poison' }, value: 15, desc: "Cures poison." },
            skull: { type: 'quest', value: 1, desc: "A polished human skull. The necromancer wants this." },
            tome: { type: 'quest', value: 1, desc: "An ancient spell tome. The wizard seeks this." },
            amulet: { type: 'quest', value: 1, desc: "A glowing amulet. The priest wants this destroyed." },
            key: { type: 'key', value: 1, desc: "An iron key. It might open something." },
            torch: { type: 'tool', value: 5, desc: "A lit torch. Illuminates dark areas." },
            gem: { type: 'treasure', value: 100, desc: "A valuable gemstone." },
            scroll_fireball: { type: 'scroll', effect: 'fireball', value: 50, desc: "Scroll of Fireball. Casts a fireball spell." },
            oil: { type: 'tool', value: 10, desc: "A flask of lubricating oil. Useful for stuck mechanisms." },
            password_scroll: { type: 'quest', value: 1, desc: "A scroll with strange symbols. Might be a password." },
            clock_gear: { type: 'quest', value: 1, desc: "A small brass gear from a clock mechanism." },
            librarian_amulet: { type: 'key', value: 50, desc: "A librarian's amulet. It glows with protective magic." },
            holy_water: { type: 'consumable', effect: { damage_undead: 50 }, value: 40, desc: "Water blessed by a priest. Hurts undead creatures." },
            mirror_shard: { type: 'quest', value: 1, desc: "A shard of broken mirror. It reflects strange images." }
        };

        const enemies = {
            rat: { 
                name: "Giant Rat", 
                hp: 20, dmg: 5, gold: 8, xp: 15, 
                desc: "A giant sewer rat with sharp teeth and matted fur.",
                loot: ['potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie'
            },
            skeleton: { 
                name: "Skeleton Warrior", 
                hp: 35, dmg: 9, gold: 20, xp: 30,
                desc: "An animated skeleton wielding a rusty sword.",
                loot: ['dagger', 'potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'dungeon'
            },
            ghost: { 
                name: "Phantom", 
                hp: 28, dmg: 7, gold: 15, xp: 25,
                desc: "A translucent phantom that moans eerily and chills the air.",
                loot: ['torch', 'manapot'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie'
            },
            spider: { 
                name: "Giant Spider", 
                hp: 25, dmg: 8, gold: 12, xp: 22,
                desc: "A giant spider with venomous fangs and sticky webs.",
                loot: ['potion', 'antidote'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie'
            },
            guard: { 
                name: "Tower Guard", 
                hp: 45, dmg: 12, gold: 35, xp: 40,
                desc: "A well-trained tower guard in chainmail armor.",
                loot: ['chainmail', 'sword'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'dungeon'
            },
            wraith: { 
                name: "Wraith", 
                hp: 60, dmg: 15, gold: 50, xp: 60,
                desc: "A powerful spectral being that drains life energy.",
                loot: ['elixir', 'gem'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie'
            },
            boss: { 
                name: "Lich King", 
                hp: 150, dmg: 25, gold: 200, xp: 150,
                desc: "The Tower's master - an undead lich of immense power.",
                loot: ['greatsword', 'plate', 'elixir', 'gem', 'gem'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss'
            }
        };

        // Create enemy instance function to fix shared HP bug
        function createEnemy(type) {
            const enemyTemplate = enemies[type];
            if (!enemyTemplate) return null;
            
            return {
                ...enemyTemplate,
                hp: enemyTemplate.hp,
                stunned: 0,
                burning: 0,
                originalType: type
            };
        }

        const npcs = {
            merchant: { 
                name: "Merchant Garvin", 
                desc: "A shady trader with a heavy cloak and many pouches.", 
                dialog: "Welcome! I buy and sell goods. I'm also looking for rare artifacts...",
                quest: null,
                hostile: false,
                shopItems: ['dagger', 'sword', 'staff', 'bow', 'mace', 'leather', 'chainmail', 'robe', 'potion', 'manapot', 'oil', 'antidote'],
                dialogueTopics: ['artifacts', 'supplies', 'rumors'],
                dialogue: {
                    'default': "What can I do for you?",
                    'artifacts': "I hear there's a Skeleton Key in the Clock Tower. Opens any door! The clock needs fixing though...",
                    'supplies': "I sell everything an adventurer needs. Torches, oil, potions... just ask!",
                    'rumors': "They say the librarian's ghost haunts the catacombs. She had an amulet that wards off dark magic."
                }
            },
            wizard: {
                name: "Archmage Valerius",
                desc: "An old wizard with a long white beard and glowing eyes. He smells of ozone and old books.",
                dialog: "I seek the Ancient Tome. Bring it to me and I shall reward you with powerful magic.",
                quest: { item: 'tome', reward: { gold: 100, item: 'fire_staff', xp: 50 }, completed: false },
                hostile: false,
                dialogueTopics: ['tome', 'library', 'clock', 'mirrors'],
                dialogue: {
                    'default': "The arcane arts require patience and study.",
                    'tome': "The Tome of Eld is in the Royal Library. The door is warded with powerful magic.",
                    'library': "Only the librarian's amulet can bypass the library's wards. Find Elara in the catacombs.",
                    'clock': "The Clock Tower mechanism is broken. You'll need a replacement gear from the Guard Post.",
                    'mirrors': "The Mirror Hall shows reflections of other realities. Be careful what you show them."
                }
            },
            necromancer: {
                name: "Mortis the Necromancer",
                desc: "A pale man surrounded by dark energy. Bones rattle in his satchel.",
                dialog: "I require human skulls for my rituals. Bring me 3 skulls and I'll grant you power over death.",
                quest: { item: 'skull', count: 3, reward: { gold: 150, item: 'elixir', xp: 75 }, completed: false },
                hostile: false,
                dialogueTopics: ['skulls', 'skeletons', 'lich', 'catacombs'],
                dialogue: {
                    'default': "Death is not an end, but a transformation.",
                    'skulls': "I need skulls for my bone golem. The catacombs are full of them, but beware the guardian.",
                    'skeletons': "My minions patrol the tower. They ignore those who bear the mark of death...",
                    'lich': "The Lich King was once a student of mine. He grew too powerful, too ambitious.",
                    'catacombs': "The catacombs hold many secrets. The librarian's ghost knows where the amulet is hidden."
                }
            },
            priest: {
                name: "Brother Anselm",
                desc: "A holy man praying in the chapel. A silver holy symbol hangs from his neck.",
                dialog: "That cursed amulet must be destroyed! Bring it to me and I shall bless your journey.",
                quest: { item: 'amulet', reward: { gold: 80, item: 'holy_water', xp: 40 }, completed: false },
                hostile: false,
                dialogueTopics: ['amulet', 'holy_water', 'ghosts', 'blessing'],
                dialogue: {
                    'default': "May the light protect you in this dark place.",
                    'amulet': "That amulet is evil! It must be destroyed in the chapel's sacred flame.",
                    'holy_water': "I can bless water to harm undead. Useful against skeletons and ghosts.",
                    'ghosts': "The restless dead wander these halls. Only faith can put them to rest.",
                    'blessing': "Bring me the amulet, and I shall bless your equipment against the dark."
                }
            },
            thief: {
                name: "Silent Sam",
                desc: "A shady figure lurking in the shadows. You can barely see him.",
                dialog: "Psst... I can teach you to move quietly. For a price... 50 gold.",
                quest: null,
                hostile: false,
                dialogueTopics: ['training', 'lockpicking', 'shadows', 'secret'],
                dialogue: {
                    'default': "Keep your voice down... the walls have ears.",
                    'training': "50 gold for stealth training. Worth every coin in this place.",
                    'lockpicking': "I could pick that locked door for you... for a gem.",
                    'shadows': "The Shadow Cloak in the treasury makes you nearly invisible. The dragon bones guard it.",
                    'secret': "The mirror in the hall... show it your true self, and it might show you something useful."
                }
            },
            guard_captain: {
                name: "Captain Roland",
                desc: "A stern-looking guard captain with a scar across his face.",
                dialog: "Stay out of trouble, adventurer. The tower is dangerous for trespassers.",
                quest: null,
                hostile: true,
                dialogueTopics: ['key', 'prisoner', 'duty'],
                dialogue: {
                    'default': "I don't have time for chit-chat. Move along.",
                    'key': "Lost my key in the training room. Not that it's any of your business.",
                    'prisoner': "That prisoner stays where he is. His crimes are his own business.",
                    'duty': "My duty is to protect this tower. From everyone."
                }
            },
            prisoner: {
                name: "Chained Prisoner",
                desc: "A poor soul chained to the wall. His wrists are raw from the shackles.",
                dialog: "Please... free me... the key is with the guard captain... I know where treasure is hidden...",
                quest: { item: 'key', reward: { gold: 200, item: 'cloak', xp: 60 }, completed: false },
                hostile: false,
                dialogueTopics: ['key', 'treasure', 'secret_passage', 'captain'],
                dialogue: {
                    'default': "Please... help me...",
                    'key': "The captain has the key. He trains in the guard room... drops things sometimes.",
                    'treasure': "The treasury has a dragon skeleton guard. It ignores those wearing the Shadow Cloak.",
                    'secret_passage': "There's a secret passage behind the throne. Press the third skull on the left...",
                    'captain': "He's cruel but careless. Check the training dummies for the key he lost."
                }
            },
            blacksmith: {
                name: "Grom the Blacksmith",
                desc: "A burly dwarf covered in soot, hammering at an anvil.",
                dialog: "Aye, I can forge weapons! Bring me gems and gold, and I'll make you something special.",
                quest: null,
                hostile: false,
                dialogueTopics: ['forge', 'repair', 'materials', 'dragon_bone'],
                dialogue: {
                    'default': "Good steel needs good heat and a strong arm!",
                    'forge': "Bring me a gem and 50 gold, I'll forge you a proper weapon!",
                    'repair': "That broken sword in the forge? Needs oil on the joints first, then I can fix it.",
                    'materials': "Dragon bone makes the strongest weapons. But getting it from the treasury... that's risky.",
                    'dragon_bone': "The dragon skeleton in the treasury... its bones are magical. Could make a legendary weapon."
                }
            },
            // NEW: Librarian Ghost (appears after puzzle)
            librarian_ghost: {
                name: "Ghost of Elara",
                desc: "A translucent figure of a woman in scholarly robes. She floats above the ground.",
                dialog: "The library... my library... protect the knowledge...",
                quest: { item: 'password_scroll', reward: { gold: 0, item: 'librarian_amulet', xp: 30 }, completed: false },
                hostile: false,
                dialogueTopics: ['library', 'amulet', 'password', 'books'],
                dialogue: {
                    'default': "The words must be protected...",
                    'library': "My library is warded. Only my amulet grants passage. I hid it... before...",
                    'amulet': "Find my amulet in the catacombs. Look for the shelf that doesn't belong...",
                    'password': "The library password... it's in the study. The desk holds many secrets.",
                    'books': "The books live... protect them... from the lich..."
                }
            }
        };

        // Enhanced room descriptions with interactive objects
        const roomDescriptions = [
            { 
                desc: "The Entrance Hall. A massive iron door lies behind you. Torches flicker on stone walls.", 
                sound: 'theme',
                objects: {
                    'door': {
                        desc: "A massive iron door, heavily rusted and covered in scratches. It appears to be locked from this side.",
                        state: 'locked',
                        states: {
                            'locked': "The door is firmly locked. You'll need a key to open it.",
                            'unlocked': "The door is now unlocked."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: null
                    },
                    'torches': "Wall-mounted torches that cast flickering shadows. The flames never seem to die down.",
                    'walls': "Ancient stone walls carved with worn symbols you can't decipher."
                }
            },
            { 
                desc: "Guard Room. Two empty suits of armor stand watch. One seems to be moving...", 
                sound: 'dungeon',
                objects: {
                    'armor': {
                        desc: "The suits of armor are rusted and empty. Yet one creaks as if something invisible wears it.",
                        state: 'sealed',
                        states: {
                            'sealed': "The armor's joints are frozen with rust. It's completely sealed shut.",
                            'oiled': "You've oiled the joints. The breastplate has a slight gap.",
                            'open': "The breastplate is open. Inside is a small compartment."
                        },
                        requiredItem: 'oil',
                        action: 'oil',
                        hiddenItem: 'small_key'
                    },
                    'armors': "The suits of armor are rusted and empty. Yet one creaks as if something invisible wears it."
                }
            },
            { 
                desc: "Stone Corridor. Cobwebs hang from the ceiling. The air is cold and damp.", 
                sound: 'dungeon',
                objects: {
                    'cobwebs': {
                        desc: "Thick, dusty cobwebs filled with dead insects. Something large made these.",
                        state: 'intact',
                        states: {
                            'intact': "The cobwebs block your path. They're thick and sticky.",
                            'burned': "The cobwebs have been burned away, revealing a hidden niche in the wall."
                        },
                        requiredItem: 'torch',
                        action: 'burn',
                        hiddenItem: 'scroll_fireball'
                    },
                    'ceiling': "A vaulted stone ceiling covered in mold and cobwebs."
                }
            },
            { 
                desc: "Storage Room. Broken crates and barrels litter the floor. Something scurries in the dark.", 
                sound: 'eerie',
                objects: {
                    'crates': "Splintered wooden crates, all empty except for dust and rat droppings.",
                    'barrels': "Rotted barrels leaking a foul-smelling liquid. Better not investigate further."
                }
            },
            { 
                desc: "Armory. Rusty weapons line the walls. Most are beyond use.", 
                sound: 'dungeon',
                objects: {
                    'weapons': "Rusted swords, broken spears, and shattered shields. Nothing salvageable.",
                    'walls': "Weapon racks once held proud arms, now reduced to decaying iron."
                }
            },
            { 
                desc: "Chapel. Faded frescoes depict forgotten gods. Candles burn on a stone altar.", 
                sound: 'theme',
                objects: {
                    'frescoes': {
                        desc: "Peeling paintings of gods with missing eyes. Their gazes seem to follow you.",
                        state: 'normal',
                        states: {
                            'normal': "The fresco shows a many-armed god holding a key and an amulet.",
                            'examined': "You notice one god holds a key identical to yours, and another wears the amulet you carry."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: null
                    },
                    'candles': "Black candles burning with an unnatural blue flame. They never melt.",
                    'altar': {
                        desc: "A stone altar stained dark. Old blood, perhaps. It feels... unholy.",
                        state: 'cold',
                        states: {
                            'cold': "The altar is cold to the touch.",
                            'burning': "Sacred flames now burn on the altar, purifying it."
                        },
                        requiredItem: 'holy_water',
                        action: 'bless',
                        hiddenItem: 'gem'
                    }
                }
            },
            { 
                desc: "Library. Books lie scattered, pages torn. The smell of mildew fills the air.", 
                sound: 'eerie',
                objects: {
                    'books': "Tattered tomes with indecipherable text. Some pages move on their own.",
                    'pages': "Loose pages covered in strange symbols that shift when you look away."
                }
            },
            { 
                desc: "Alchemy Lab. Broken vials ooze colorful liquids. A strange scent lingers.", 
                sound: 'eerie',
                objects: {
                    'vials': "Shattered glass vials leaking glowing liquids. Some still bubble ominously.",
                    'lab': "An alchemical workstation with a burnt grimoire and strange instruments."
                }
            },
            { 
                desc: "Torture Chamber. Rusty implements hang from walls. Chains rattle in the draft.", 
                sound: 'eerie',
                objects: {
                    'implements': "Rusted knives, pincers, and other cruel tools. Some are still stained.",
                    'chains': "Heavy iron chains that clink together despite no visible breeze.",
                    'walls': "Stone walls with shackle points and dark stains."
                }
            },
            { 
                desc: "Barracks. Rotted bunks line the walls. Rats nest in the straw.", 
                sound: 'dungeon',
                objects: {
                    'bunks': "Moldy bed frames with rotten straw mattresses. Something scurries within.",
                    'straw': "Foul-smelling nesting material for the tower's vermin.",
                    'rats': "You hear them scratching but see only shadows."
                }
            },
            { 
                desc: "Courtyard. Dead vines cling to stone walls. The moon shines through broken clouds.", 
                sound: 'theme',
                objects: {
                    'vines': "Withered ivy that crumbles at your touch. It once covered these walls.",
                    'moon': "A pale, full moon that casts eerie shadows through the broken tower roof.",
                    'walls': "Crumbling outer walls showing the tower's great age."
                }
            },
            { 
                desc: "Wine Cellar. Broken casks leak foul liquid. Shadows move between barrels.", 
                sound: 'eerie',
                objects: {
                    'casks': "Shattered wine barrels leaking vinegar-smelling liquid.",
                    'barrels': "Dusty barrels, some still intact but contents long spoiled.",
                    'shadows': "They seem to move independently of any light source..."
                }
            },
            { 
                desc: "Kitchen. A giant cauldron hangs over cold ashes. Knives gleam on a block.", 
                sound: 'dungeon',
                objects: {
                    'cauldron': "A massive iron pot containing a congealed, unidentifiable stew.",
                    'ashes': "Cold fireplace ashes that still smell of old smoke and something... meaty.",
                    'knives': "Surprisingly sharp cleavers and knives on a blood-stained block."
                }
            },
            { 
                desc: "Dining Hall. A long table set for a feast that never came. Plates are covered in dust.", 
                sound: 'eerie',
                objects: {
                    'table': "A massive oak table set with tarnished silver and cracked plates.",
                    'plates': "Fine china covered in thick dust and cobwebs.",
                    'feast': "Petrified food that looks like it turned to stone ages ago."
                }
            },
            { 
                desc: "Throne Room. A skeletal figure sits on a stone throne, crown askew.", 
                sound: 'dungeon',
                objects: {
                    'throne': {
                        desc: "A carved stone throne worn smooth by time and use.",
                        state: 'normal',
                        states: {
                            'normal': "The throne has skulls carved into its arms.",
                            'pressed': "You hear a click as the third skull on the left sinks into the arm."
                        },
                        requiredItem: null,
                        action: 'press',
                        hiddenItem: null,
                        triggersSecret: true,
                        secretRoom: 50
                    },
                    'skeleton': "A royal skeleton slumped in the throne, crown tilted on its skull.",
                    'crown': "A tarnished gold crown set with dull gems. It might be valuable."
                }
            },
            { 
                desc: "Observatory. A cracked telescope points at the sky through a broken dome.", 
                sound: 'theme',
                objects: {
                    'telescope': "A brass telescope with cracked lenses. It's pointed at a strange constellation.",
                    'dome': "A shattered glass dome showing the night sky above.",
                    'sky': "Stars arranged in patterns you don't recognize."
                }
            },
            { 
                desc: "Treasure Vault. Empty chests lie open. Something valuable might remain...", 
                sound: 'dungeon',
                objects: {
                    'chests': "Forced-open treasure chests, all empty. Scratches suggest something was dragged out.",
                    'vault': "A reinforced room meant to hold riches, now barren."
                }
            },
            { 
                desc: "Crypt. Stone sarcophagi line the walls. The air smells of decay.", 
                sound: 'eerie',
                objects: {
                    'sarcophagi': "Ancient stone coffins carved with warnings. Some lids are cracked open.",
                    'crypt': "A burial chamber for the tower's former rulers. None rest peacefully."
                }
            },
            { 
                desc: "Guard Post. A journal lies open on a desk. The last entry is smeared with blood.", 
                sound: 'dungeon',
                objects: {
                    'journal': {
                        desc: "A leather-bound logbook. The final entry reads: 'They're in the walls...'",
                        state: 'closed',
                        states: {
                            'closed': "The journal lies open to the last page.",
                            'read': "Flipping through, you find an entry: 'The clock stopped on the master's birthday: 7th month, 23rd day...'"
                        },
                        requiredItem: null,
                        action: 'read',
                        hiddenItem: 'password_scroll'
                    },
                    'desk': {
                        desc: "A simple wooden desk covered in dust and old paperwork.",
                        state: 'locked',
                        states: {
                            'locked': "The desk drawer is locked.",
                            'unlocked': "The drawer contains a small brass gear."
                        },
                        requiredItem: 'small_key',
                        action: 'unlock',
                        hiddenItem: 'clock_gear'
                    },
                    'blood': "Dried brown stains that tell a story of sudden violence."
                }
            },
            { 
                desc: "Prison Cells. Iron bars enclose small spaces. Moaning echoes from within.", 
                sound: 'eerie',
                objects: {
                    'bars': "Thick iron bars rusted but still strong. Some are bent outward.",
                    'cells': "Tiny, filthy rooms where prisoners were left to rot.",
                    'moaning': "An eerie sound that seems to come from the stones themselves."
                }
            },
            { 
                desc: "Royal Bedchamber. A canopy bed with moth-eaten curtains. Jewels glitter in a box.", 
                sound: 'dungeon',
                objects: {
                    'bed': "A four-poster bed with rotting silk curtains and a moldy mattress.",
                    'curtains': "Once-fine fabric now full of holes and insect nests.",
                    'jewels': "A small chest containing glittering gems that catch the dim light.",
                    'box': "An ornate jewelry box with tarnished silver fittings."
                }
            },
            { 
                desc: "Study. A desk covered in yellowed maps. A single candle burns endlessly.", 
                sound: 'eerie',
                objects: {
                    'desk': {
                        desc: "A mahogany desk covered in faded maps of the tower and surrounding lands.",
                        state: 'normal',
                        states: {
                            'normal': "The desk has several drawers.",
                            'searched': "In a hidden compartment, you find a scroll with strange symbols."
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'password_scroll'
                    },
                    'maps': "Parchment charts showing secret passages and marked rooms.",
                    'candle': "A black candle that burns without melting, casting an unnatural light."
                }
            },
            { 
                desc: "Art Gallery. Portraits with eyes that follow you. One frame is empty.", 
                sound: 'eerie',
                objects: {
                    'portraits': "Paintings of stern nobles whose eyes track your movement.",
                    'frame': "An empty gilt frame. The canvas shows only a pale face-shaped stain.",
                    'eyes': "No matter where you move, the painted eyes seem to watch you."
                }
            },
            { 
                desc: "Music Room. A grand piano plays a haunting tune by itself.", 
                sound: 'eerie',
                objects: {
                    'piano': "A dusty grand piano with yellowed keys that depress on their own.",
                    'tune': "A melancholic melody that seems to whisper forgotten names."
                }
            },
            { 
                desc: "Bathhouse. Tiled pools filled with black water. Steam rises without heat.", 
                sound: 'eerie',
                objects: {
                    'pools': "Mosaic-tiled baths filled with still, black water. Something moves beneath.",
                    'tiles': "Intricate tile work depicting sea monsters and drowning sailors.",
                    'steam': "Cold mist that rises from the water's surface despite no heat source."
                }
            },
            { 
                desc: "Training Room. Wooden dummies stand ready. One moves when not watched.", 
                sound: 'dungeon',
                objects: {
                    'dummies': {
                        desc: "Straw-stuffed practice targets. One twitches when you look away.",
                        state: 'normal',
                        states: {
                            'normal': "The dummies show signs of heavy use.",
                            'searched': "Inside one dummy's stuffing, you find a rusty key!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'key'
                    },
                    'training': "Weapon marks on the walls show this was once a busy practice area."
                }
            },
            { 
                desc: "Clock Tower. Gears turn silently. The hands are stuck at midnight.", 
                sound: 'theme',
                objects: {
                    'clock': {
                        desc: "A massive clock face with motionless hands forever at midnight.",
                        state: 'broken',
                        states: {
                            'broken': "The clock mechanism is missing a gear. The hands won't move.",
                            'repaired': "With the gear replaced, you can now set the clock.",
                            'set': "The clock chimes! A secret compartment opens in the wall."
                        },
                        requiredItem: 'clock_gear',
                        action: 'repair',
                        hiddenItem: 'skeleton_key',
                        puzzle: true,
                        puzzleSolution: { hour: 7, minute: 23 }
                    },
                    'gears': "Enormous brass mechanisms that turn without making a sound.",
                    'hands': "Frozen clock hands that seem to resist any attempt to move them."
                }
            },
            { 
                desc: "Aviary. Empty birdcages hang from the ceiling. Feathers float in the air.", 
                sound: 'eerie',
                objects: {
                    'cages': "Gilded birdcages, all empty. Some doors hang open, others are bent outward.",
                    'feathers': "Black feathers that drift on non-existent breezes.",
                    'ceiling': "A glass roof shattered long ago, letting in the elements."
                }
            },
            { 
                desc: "Laboratory. Strange machines hum with residual energy. Glass tubes glow faintly.", 
                sound: 'eerie',
                objects: {
                    'machines': "Brass and copper devices that hum with stored magical energy.",
                    'tubes': "Glass cylinders filled with glowing liquids of unnatural colors.",
                    'energy': "A static charge in the air that makes your hair stand on end."
                }
            },
            { 
                desc: "Garden. Dead plants in stone planters. A single black rose blooms.", 
                sound: 'theme',
                objects: {
                    'plants': "Withered shrubs and trees that crumble to dust at a touch.",
                    'planters': "Stone containers filled with dry, cracked earth.",
                    'rose': "A single perfect black rose that seems to absorb light around it."
                }
            },
            { 
                desc: "Archives. Scrolls crumble at your touch. Ancient knowledge lost forever.", 
                sound: 'eerie',
                objects: {
                    'scrolls': "Parchment documents that disintegrate when touched. The ink has faded.",
                    'archives': "Rows of shelves holding the tower's lost history.",
                    'knowledge': "What remains suggests dark rituals and forbidden magic."
                }
            },
            { 
                desc: "Forge. Cold anvils and extinguished fires. A sword half-forged on the bench.", 
                sound: 'dungeon',
                objects: {
                    'anvils': "Massive iron blocks once used for shaping weapons, now cold.",
                    'fires': "Stone hearths filled with gray ash and unburned coal.",
                    'sword': {
                        desc: "A half-completed blade still in the tongs, as if work stopped suddenly.",
                        state: 'rusted',
                        states: {
                            'rusted': "The sword is rusted into the tongs.",
                            'oiled': "The oil loosens the rust. The sword comes free!",
                            'repaired': "Grom has repaired the sword into a fine weapon."
                        },
                        requiredItem: 'oil',
                        action: 'oil',
                        hiddenItem: 'broken_sword'
                    }
                }
            },
            { 
                desc: "Well Room. A deep well in the center. Something whispers from below.", 
                sound: 'eerie',
                objects: {
                    'well': "A stone-lined shaft descending into darkness. A rope hangs down.",
                    'whispers': "Faint voices from the depths speaking in a language you don't know.",
                    'center': "The well occupies the room's exact center, suggesting ritual importance."
                }
            },
            { 
                desc: "Pantry. Rotted food in sacks. Something still moves within.", 
                sound: 'eerie',
                objects: {
                    'food': "Moldy grains and spoiled meat in burlap sacks.",
                    'sacks': "Burst bags spilling their foul contents across the floor.",
                    'something': "There's definitely movement in the darkest corner. Best not to investigate."
                }
            },
            { 
                desc: "Servant Quarters. Simple cots and worn clothing. A diary tells of escape.", 
                sound: 'dungeon',
                objects: {
                    'cots': "Rough beds with straw mattresses and thin blankets.",
                    'clothing': "Patched uniforms hanging on pegs, covered in dust.",
                    'diary': "A servant's journal describing a failed escape attempt."
                }
            },
            { 
                desc: "Royal Library. Books bound in strange leather. They seem to watch you.", 
                sound: 'eerie',
                objects: {
                    'books': "Volumes bound in what looks like human skin. They pulse faintly.",
                    'leather': "The binding feels warm and slightly moist, like living tissue.",
                    'library': "A circular room with shelves reaching to a shadowed ceiling.",
                    'door': {
                        desc: "A massive oak door carved with protective runes.",
                        state: 'warded',
                        states: {
                            'warded': "The door glows with protective magic. You cannot touch it.",
                            'unlocked': "The ward dissipates. The door is now accessible."
                        },
                        requiredItem: 'librarian_amulet',
                        action: 'unward',
                        hiddenItem: null
                    }
                }
            },
            { 
                desc: "Astronomy Room. Star charts on the walls. Constellations move on their own.", 
                sound: 'theme',
                objects: {
                    'charts': "Maps of the heavens showing constellations that don't exist.",
                    'constellations': "The painted stars shift position when you're not looking.",
                    'astronomy': "Instruments for tracking celestial bodies, all pointing wrong."
                }
            },
            { 
                desc: "Meditation Chamber. Incense burners cold. A mat lies in the center.", 
                sound: 'eerie',
                objects: {
                    'incense': "Brass burners filled with gray ash that smells of funeral flowers.",
                    'mat': "A woven reed mat worn thin by years of use. It feels oddly warm.",
                    'chamber': "A perfectly round room designed for contemplation... or summoning."
                }
            },
            { 
                desc: "Armory Vault. Magical weapons behind glass. All cases are broken open.", 
                sound: 'dungeon',
                objects: {
                    'weapons': "Glimmering swords and staves behind shattered display cases.",
                    'glass': "Broken protective coverings litter the floor.",
                    'vault': "A secure room that clearly failed to protect its contents."
                }
            },
            { 
                desc: "Guard Tower. Arrow slits look over the land. A skeleton holds a bow.", 
                sound: 'dungeon',
                objects: {
                    'slits': "Narrow windows designed for archers to fire while protected.",
                    'skeleton': "A fallen guard still clutching a rusted bow.",
                    'bow': "A war bow with a broken string, useless now."
                }
            },
            { 
                desc: "Dungeon. Deeper than the prison. The walls sweat and moan.", 
                sound: 'eerie',
                objects: {
                    'walls': "Damp stone that weeps a foul-smelling liquid. They seem to pulse.",
                    'dungeon': "The lowest level where the worst prisoners were kept... and worse things.",
                    'moan': "The very stones emit a low, pained sound."
                }
            },
            { 
                desc: "Catacombs. Bones arranged in patterns. They rearrange when you look away.", 
                sound: 'eerie',
                objects: {
                    'bones': {
                        desc: "Human remains laid out in intricate patterns with magical significance.",
                        state: 'normal',
                        states: {
                            'normal': "The bones form a circular pattern on the floor.",
                            'disturbed': "You've moved some bones. One shelf looks out of place...",
                            'searched': "Behind the moved shelf, you find a hidden amulet!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'librarian_amulet'
                    },
                    'patterns': "Geometric designs that shift into new configurations constantly.",
                    'catacombs': "Tunnels lined with skulls that watch your passage."
                }
            },
            { 
                desc: "Shrine. A statue of a forgotten deity. Offerings of gold and gems at its feet.", 
                sound: 'theme',
                objects: {
                    'statue': "A marble figure of a many-armed god with a cruel smile.",
                    'offerings': "Piles of treasure left by desperate worshippers long ago.",
                    'deity': "A forgotten god of pain and secrets. Its eyes seem alive."
                }
            },
            { 
                desc: "Clockwork Room. Mechanical creatures frozen in mid-action. One eye follows you.", 
                sound: 'eerie',
                objects: {
                    'creatures': "Brass automatons frozen in various poses. One twitches.",
                    'clockwork': "Intricate gears and springs that should move but don't... mostly.",
                    'eye': "A glass lens in one machine's face that tracks your movements."
                }
            },
            { 
                desc: "Mirror Hall. Reflections show different versions of yourself. Some attack.", 
                sound: 'eerie',
                objects: {
                    'mirrors': {
                        desc: "Tall looking glasses that show alternate versions of you.",
                        state: 'hostile',
                        states: {
                            'hostile': "The reflections mimic your movements, then attack!",
                            'calm': "The reflections show your true self. One mirror shatters, revealing a passage."
                        },
                        requiredItem: 'cloak',
                        action: 'use',
                        hiddenItem: 'mirror_shard',
                        puzzle: true
                    },
                    'reflections': "Some mirror-you's reach out, others turn away in fear.",
                    'hall': "A corridor lined with mirrors that seem to go on forever."
                }
            },
            { 
                desc: "Laboratory Depth. Flesh and metal fused in tanks. Things move within.", 
                sound: 'eerie',
                objects: {
                    'tanks': "Glass cylinders containing horrific hybrids of organic and mechanical parts.",
                    'flesh': "Pulsating tissue connected to wires and pipes.",
                    'things': "Shapes that press against the glass from inside the tanks."
                }
            },
            { 
                desc: "Necromancer's Sanctum. Black candles burn with green flame. Skulls line shelves.", 
                sound: 'eerie',
                objects: {
                    'candles': "Tapered black wax burning with unnatural green fire.",
                    'skulls': "Polished craniums arranged by size and species. Some still have flesh.",
                    'shelves': "Bookshelves holding forbidden texts and preserved organs."
                }
            },
            { 
                desc: "Wizard's Tower. Floating books and glowing orbs. Magic crackles in the air.", 
                sound: 'theme',
                objects: {
                    'books': "Tomes that drift through the air, pages turning on their own.",
                    'orbs': "Crystal spheres containing captured lightning that dances within.",
                    'magic': "Raw arcane energy that makes the hair on your arms stand up."
                }
            },
            { 
                desc: "Royal Treasury. Mountains of gold and jewels. A dragon skeleton guards it.", 
                sound: 'dungeon',
                objects: {
                    'gold': "Piles of coins, ingots, and jewelry worth a kingdom's ransom.",
                    'jewels': "Gemstones of every color glittering in the dim light.",
                    'dragon': {
                        desc: "The massive bones of a wyrm arranged as if still alive and watching.",
                        state: 'alert',
                        states: {
                            'alert': "The dragon bones rattle threateningly as you approach.",
                            'calm': "Wearing the Shadow Cloak, the dragon ignores you."
                        },
                        requiredItem: 'cloak',
                        action: 'sneak',
                        hiddenItem: 'dragon_bone'
                    },
                    'skeleton': "A complete dragon skeleton that seems to shift position when unobserved."
                }
            },
            { 
                desc: "Summit Chamber. The very top of the tower. Wind howls through broken windows. A final challenge awaits.", 
                sound: 'boss',
                objects: {
                    'windows': "Shattered panes letting in cold wind and moonlight.",
                    'wind': "A howling gale that carries whispers of long-dead voices.",
                    'summit': "The highest point of the Tower of Terror. There's no going back now.",
                    'chamber': "A circular room with a dais in the center, waiting for a master."
                }
            },
            // Secret Room 50: Hidden Vault (accessed from Throne Room)
            { 
                desc: "Hidden Vault. A secret chamber behind the throne. Ancient artifacts glow on pedestals.", 
                sound: 'theme',
                objects: {
                    'artifacts': "Magical items of great power rest here, untouched for centuries.",
                    'pedestals': "Stone columns holding treasures beyond imagination.",
                    'vault': "This room was meant to be found only by the worthy."
                }
            }
        ];

        // Generate 51 rooms (50 + secret room)
        function generateRooms() {
            const rooms = [];
            for (let i = 0; i < 51; i++) {
                const roomDesc = roomDescriptions[i] || { desc: "A mysterious room.", sound: 'eerie', objects: {} };
                rooms.push({
                    id: i,
                    desc: roomDesc.desc,
                    sound: roomDesc.sound,
                    objects: roomDesc.objects || {},
                    exits: i < 50 ? { 
                        n: i < 40 ? i + 10 : null, 
                        s: i >= 10 ? i - 10 : null, 
                        e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                        w: i % 10 !== 0 ? i - 1 : null 
                    } : { n: null, s: 15, e: null, w: null }, // Secret room connected to Throne Room
                    items: [],
                    enemy: null,
                    npc: null,
                    explored: false,
                    dark: i > 25 && i < 40,
                    locked: i === 36, // Royal Library locked
                    secret: i === 50
                });
            }

            // Place items, enemies, and NPCs with enemy instances
            rooms[1].items = ['dagger'];
            rooms[3].enemy = createEnemy('rat');
            rooms[5].items = ['potion'];
            rooms[7].enemy = createEnemy('spider');
            rooms[10].npc = 'merchant';
            rooms[12].enemy = createEnemy('skeleton');
            rooms[15].npc = 'wizard';
            rooms[17].items = ['skull'];
            rooms[20].enemy = createEnemy('ghost');
            rooms[22].npc = 'necromancer';
            rooms[25].items = ['tome'];
            rooms[28].enemy = createEnemy('spider');
            rooms[30].npc = 'priest';
            rooms[32].items = ['leather'];
            rooms[35].enemy = createEnemy('wraith');
            rooms[37].npc = 'thief';
            rooms[39].items = ['sword'];
            rooms[40].npc = 'guard_captain';
            rooms[42].enemy = createEnemy('guard');
            rooms[43].npc = 'prisoner';
            rooms[45].enemy = createEnemy('wraith');
            rooms[46].npc = 'blacksmith';
            rooms[47].items = ['amulet', 'gem'];
            rooms[49].enemy = createEnemy('boss');
            rooms[50].items = ['gem', 'gem', 'elixir', 'scroll_fireball']; // Secret room treasure
            
            return rooms;
        }

        // Initialize rooms
        let rooms = generateRooms();

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            stealth: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: false,
            moves: 0,
            poisoned: false,
            effects: [],
            blocking: 0,
            shield: 0,
            skeleton: null,
            knownPasswords: [],
            discoveredSecrets: []
        };

        // ==================== SAVE SYSTEM ====================
        const SAVE_SLOTS = {
            QUICK: 'tower_terror_quick',
            SLOT1: 'tower_terror_slot1',
            SLOT2: 'tower_terror_slot2',
            SLOT3: 'tower_terror_slot3'
        };

        function saveGame(slot = SAVE_SLOTS.SLOT1) {
            if (!gameStarted || !player.class) {
                print("No game in progress to save.", 'error');
                return;
            }
            
            const saveData = {
                player: JSON.parse(JSON.stringify(player)),
                rooms: JSON.parse(JSON.stringify(rooms)),
                gameStarted: gameStarted,
                currentBackground: currentBackground,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem(slot, JSON.stringify(saveData));
                print(`Game saved to slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                soundSystem.playSound('notification', 0.5);
            } catch (e) {
                print("Failed to save game: " + e.message, 'error');
            }
        }

        function quickSave() {
            saveGame(SAVE_SLOTS.QUICK);
        }

        function loadGame(slot = SAVE_SLOTS.SLOT1) {
            try {
                const saveData = localStorage.getItem(slot);
                if (!saveData) {
                    print(`No save found in slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}`, 'error');
                    return false;
                }
                
                const data = JSON.parse(saveData);
                
                // Restore player state
                player = data.player;
                
                // Restore rooms (need to recreate enemy instances)
                rooms = data.rooms;
                rooms.forEach(room => {
                    if (room.enemy && room.enemy.originalType) {
                        // Recreate enemy instance from template
                        const enemyInstance = createEnemy(room.enemy.originalType);
                        if (enemyInstance) {
                            // Keep current HP if enemy wasn't defeated
                            enemyInstance.hp = room.enemy.hp;
                            enemyInstance.stunned = room.enemy.stunned || 0;
                            enemyInstance.burning = room.enemy.burning || 0;
                            room.enemy = enemyInstance;
                        }
                    }
                });
                
                gameStarted = data.gameStarted;
                currentBackground = data.currentBackground;
                
                print(`Game loaded from slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                print(`Loaded save from ${new Date(data.timestamp).toLocaleString()}`, 'system');
                soundSystem.playSound('notification', 0.5);
                
                look();
                updateStatus();
                return true;
            } catch (e) {
                print("Failed to load game: " + e.message, 'error');
                return false;
            }
        }

        function quickLoad() {
            loadGame(SAVE_SLOTS.QUICK);
        }

        // ==================== GAME SYSTEMS ====================
        const lootTable = ['potion', 'manapot', 'dagger', 'torch', 'gem', 'skull', 'antidote', 'oil'];
        let gameStarted = false;
        let currentBackground = 'theme';
        const soundSystem = new SoundSystem();

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            // Play notification sound for important messages
            if (className === 'success' || className === 'loot' || className === 'quest') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            } else if (className === 'puzzle') {
                soundSystem.playSound('puzzle', 0.5);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            let statusText = `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} STE:${player.stealth} ` +
                `LVL:${player.level} GOLD:${player.gold}${combat}`;
                
            // Add status effects
            const effects = [];
            if (player.poisoned) effects.push('POISON');
            if (player.blocking > 0) effects.push(`BLOCK(${player.blocking})`);
            if (player.shield > 0) effects.push(`SHIELD(${player.shield})`);
            if (player.skeleton) effects.push('SKELETON');
            
            if (effects.length > 0) {
                statusText += `\nEFFECTS: ${effects.join(' ')}`;
            }
            
            status.textContent = statusText;
        }

        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            let baseStealth = classes[player.class].stealth;
            if (weapon.stealth) baseStealth += weapon.stealth;
            if (armor.stealth) baseStealth += armor.stealth;
            player.stealth = Math.max(0, baseStealth);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 100;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 15;
                player.hp = player.maxHp;
                player.maxMp += 8;
                player.mp = player.maxMp;
                player.str += 2;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        // ==================== ENHANCED OBJECT INTERACTION ====================
        function interactWithObject(objectName, action = null, param = null) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see anything!", 'error');
                return;
            }
            
            // Find the object
            let matchedObject = null;
            let objectKey = null;
            
            for (const key in room.objects) {
                if (key.toLowerCase().includes(objectName.toLowerCase()) || 
                    objectName.toLowerCase().includes(key.toLowerCase())) {
                    matchedObject = room.objects[key];
                    objectKey = key;
                    break;
                }
            }
            
            if (!matchedObject) {
                print(`You don't see a ${objectName} here.`, 'error');
                return;
            }
            
            // Simple object (string description)
            if (typeof matchedObject === 'string') {
                print(`You examine the ${objectKey}:`, 'system');
                print(matchedObject, 'system');
                soundSystem.playSound('notification', 0.3);
                return;
            }
            
            // Complex object (object with states)
            const obj = matchedObject;
            
            if (!action) {
                // Just examine
                print(`You examine the ${objectKey}:`, 'system');
                print(obj.desc, 'system');
                print(`Current state: ${obj.states[obj.state]}`, 'hint');
                
                if (obj.state === 'normal' && obj.action === 'examine') {
                    // Auto-examine if that's the action
                    performObjectAction(obj, objectKey, 'examine', param);
                }
                return;
            }
            
            // Perform specific action
            performObjectAction(obj, objectKey, action, param);
        }
        
        function performObjectAction(obj, objectKey, action, param) {
            const room = rooms[player.location];
            
            // Check if this action is valid for this object
            if (obj.action && obj.action !== action) {
                print(`You can't ${action} the ${objectKey}.`, 'error');
                return;
            }
            
            // Check if required item is needed
            if (obj.requiredItem && !player.inventory.includes(obj.requiredItem)) {
                print(`${obj.states[obj.state]}`, 'hint');
                if (obj.requiredItem === 'oil') {
                    print("Perhaps you need something to lubricate it...", 'hint');
                } else if (obj.requiredItem === 'torch') {
                    print("Maybe fire could clear this...", 'hint');
                } else if (obj.requiredItem === 'key') {
                    print("You need a key to unlock this.", 'hint');
                } else if (obj.requiredItem === 'clock_gear') {
                    print("The mechanism is missing a gear.", 'hint');
                } else if (obj.requiredItem === 'librarian_amulet') {
                    print("Powerful magic wards protect this.", 'hint');
                } else if (obj.requiredItem === 'cloak') {
                    print("Something about this requires stealth...", 'hint');
                } else if (obj.requiredItem === 'holy_water') {
                    print("This place needs purification.", 'hint');
                }
                return;
            }
            
            // Handle puzzle objects
            if (obj.puzzle) {
                handlePuzzle(obj, objectKey, action, param);
                return;
            }
            
            // Handle secret-triggering objects
            if (obj.triggersSecret && obj.state === 'normal') {
                obj.state = 'pressed';
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'puzzle');
                soundSystem.playSound('puzzle');
                
                // Open secret passage
                if (obj.secretRoom !== undefined) {
                    rooms[player.location].exits.secret = obj.secretRoom;
                    print("A hidden passage opens!", 'success');
                    soundSystem.playSound('secret');
                    player.discoveredSecrets.push(`Secret passage in room ${player.location}`);
                }
                return;
            }
            
            // Standard state transition
            if (obj.requiredItem && player.inventory.includes(obj.requiredItem)) {
                // Use the item
                if (obj.requiredItem !== 'small_key' && obj.requiredItem !== 'clock_gear') {
                    // Consume consumable items
                    const index = player.inventory.indexOf(obj.requiredItem);
                    if (index !== -1 && items[obj.requiredItem] && items[obj.requiredItem].type === 'tool') {
                        player.inventory.splice(index, 1);
                        print(`(You use the ${obj.requiredItem})`, 'system');
                    }
                }
                
                // Change state
                const oldState = obj.state;
                
                if (obj.state === 'sealed') obj.state = 'oiled';
                else if (obj.state === 'oiled') obj.state = 'open';
                else if (obj.state === 'rusted') obj.state = 'oiled';
                else if (obj.state === 'locked') obj.state = 'unlocked';
                else if (obj.state === 'warded') obj.state = 'unlocked';
                else if (obj.state === 'intact') obj.state = 'burned';
                else if (obj.state === 'cold') obj.state = 'burning';
                else if (obj.state === 'closed') obj.state = 'read';
                else if (obj.state === 'normal' && obj.action === 'search') obj.state = 'searched';
                else if (obj.state === 'normal' && obj.action === 'examine') obj.state = 'examined';
                else if (obj.state === 'alert') obj.state = 'calm';
                else if (obj.state === 'hostile') obj.state = 'calm';
                else if (obj.state === 'broken') obj.state = 'repaired';
                
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'success');
                soundSystem.playSound('notification', 0.5);
                
                // Check for hidden item
                if (obj.hiddenItem && obj.state === 'open' || obj.state === 'burned' || 
                    obj.state === 'searched' || obj.state === 'read' || obj.state === 'unlocked') {
                    
                    if (obj.hiddenItem === 'small_key' || obj.hiddenItem === 'clock_gear' || 
                        obj.hiddenItem === 'librarian_amulet' || obj.hiddenItem === 'dragon_bone') {
                        // Special items that go to inventory
                        player.inventory.push(obj.hiddenItem);
                        print(`You find: ${obj.hiddenItem}!`, 'loot');
                        soundSystem.playSound('pickup');
                    } else if (!room.items.includes(obj.hiddenItem)) {
                        room.items.push(obj.hiddenItem);
                        print(`You find: ${obj.hiddenItem}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                // Special cases
                if (objectKey === 'sword' && obj.state === 'oiled') {
                    // Sword can now be taken to blacksmith
                    print("The sword is now free from the tongs. Take it to the blacksmith for repair.", 'hint');
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 0) {
                    // Entrance door unlocks
                    print("The entrance door is now unlocked!", 'success');
                    soundSystem.playSound('door');
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 36) {
                    // Library door unwarded
                    print("The magical ward dissipates! The library door is now accessible.", 'success');
                    soundSystem.playSound('secret');
                    rooms[36].locked = false;
                }
                
                // Update player XP for solving puzzles
                player.xp += 10;
            } else {
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'system');
            }
        }
        
        function handlePuzzle(obj, objectKey, action, param) {
            if (objectKey === 'clock') {
                if (obj.state === 'broken') {
                    print("The clock mechanism is broken. It needs a replacement gear.", 'hint');
                } else if (obj.state === 'repaired') {
                    if (!param) {
                        print("The clock is repaired. You can now set the time. Use 'set clock [hour] [minute]'", 'puzzle');
                        print("Hint: Check the journal in the Guard Post.", 'hint');
                    } else {
                        const [hour, minute] = param.split(' ').map(Number);
                        if (hour === 7 && minute === 23) {
                            obj.state = 'set';
                            print(`You set the clock to ${hour}:${minute}.`, 'puzzle');
                            print("The clock chimes loudly! A secret compartment opens in the wall!", 'success');
                            soundSystem.playSound('secret');
                            
                            // Add skeleton key to room items
                            if (!rooms[player.location].items.includes('skeleton_key')) {
                                rooms[player.location].items.push('skeleton_key');
                                print("You find: skeleton_key!", 'loot');
                                soundSystem.playSound('pickup');
                            }
                            
                            player.xp += 25;
                            player.discoveredSecrets.push("Solved the Clock Tower puzzle");
                        } else {
                            print(`You set the clock to ${hour}:${minute}. Nothing happens.`, 'error');
                            print("Maybe that's not the right time...", 'hint');
                        }
                    }
                }
            } else if (objectKey === 'mirrors') {
                if (obj.state === 'hostile') {
                    print("The reflections attack as you approach!", 'enemy');
                    if (!player.inCombat) {
                        rooms[player.location].enemy = createEnemy('ghost');
                        player.inCombat = 'ghost';
                        print("A ghostly reflection emerges from the mirror!", 'enemy');
                    }
                } else if (obj.state === 'calm') {
                    print("Wearing the Shadow Cloak, the reflections show your true self.", 'success');
                    print("One mirror shatters, revealing a hidden compartment!", 'puzzle');
                    
                    if (!rooms[player.location].items.includes('mirror_shard')) {
                        rooms[player.location].items.push('mirror_shard');
                        print("You find: mirror_shard!", 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
            }
        }
        
        function setClock(timeStr) {
            const room = rooms[player.location];
            if (room.id !== 26) {
                print("There's no clock here to set.", 'error');
                return;
            }
            
            const obj = room.objects['clock'];
            if (!obj || !obj.puzzle) {
                print("You can't set the clock here.", 'error');
                return;
            }
            
            interactWithObject('clock', 'set', timeStr);
        }

        // ==================== DEEPENED NPC INTERACTION ====================
        function talkTo(npcName, topic = null) {
            const room = rooms[player.location];
            
            if (!room.npc) {
                print("There's no one here to talk to.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            
            if (npc.hostile && room.npc !== 'librarian_ghost') {
                print(`${npc.name}: "I have nothing to say to you, scum!"`, 'npc');
                return;
            }
            
            soundSystem.playSound('notification', 0.5);
            
            if (topic && npc.dialogueTopics && npc.dialogueTopics.includes(topic)) {
                // Specific topic
                print(`${npc.name}: "${npc.dialogue[topic]}"`, 'dialogue');
                
                // Special topic responses
                if (room.npc === 'thief' && topic === 'lockpicking') {
                    if (player.location === 41 && rooms[41].locked) {
                        if (player.inventory.includes('gem')) {
                            const gemIndex = player.inventory.indexOf('gem');
                            player.inventory.splice(gemIndex, 1);
                            rooms[41].locked = false;
                            print("Silent Sam picks the lock expertly.", 'success');
                            print("The door is now unlocked!", 'success');
                            soundSystem.playSound('door');
                        } else {
                            print("Silent Sam: 'I need a gem for that job.'", 'npc');
                        }
                    } else {
                        print("Silent Sam: 'No locked doors here that need picking.'", 'npc');
                    }
                }
                
                if (room.npc === 'wizard' && topic === 'library') {
                    // Wizard mentions librarian ghost
                    if (!rooms[44].npc) {
                        rooms[44].npc = 'librarian_ghost';
                        print("You feel a chill down your spine. Something has changed in the catacombs...", 'puzzle');
                    }
                }
                
                // Add topic to known topics
                if (!player.knownPasswords.includes(topic)) {
                    player.knownPasswords.push(topic);
                }
            } else if (topic) {
                // Unknown topic
                print(`${npc.name}: "I don't know anything about that."`, 'npc');
            } else {
                // General talk
                print(`${npc.name}: "${npc.dialog}"`, 'npc');
                
                // Show available topics
                if (npc.dialogueTopics) {
                    print(`You can ask about: ${npc.dialogueTopics.join(', ')}`, 'hint');
                    print("Use 'talk [npc] [topic]' to discuss specific topics.", 'system');
                }
            }
            
            // Quest information
            if (npc.quest) {
                if (npc.quest.completed) {
                    print(`${npc.name}: "Thank you again for your help."`, 'npc');
                } else if (npc.quest.item) {
                    if (npc.quest.count) {
                        const count = player.inventory.filter(item => item === npc.quest.item).length;
                        print(`${npc.name}: "I need ${npc.quest.count} ${npc.quest.item}s. You have ${count}."`, 'quest');
                    } else {
                        const hasItem = player.inventory.includes(npc.quest.item);
                        print(`${npc.name}: "Bring me the ${npc.quest.item}."`, 'quest');
                        if (hasItem) {
                            print(`You have the ${npc.quest.item}. Type 'give ${room.npc}' to complete the quest.`, 'quest');
                        }
                    }
                }
            }
            
            // Special NPC offers
            if (room.npc === 'thief') {
                print(`${npc.name}: "Want stealth training? 50 gold for +3 stealth."`, 'npc');
            } else if (room.npc === 'blacksmith') {
                print(`${npc.name}: "Bring me a gem and 50 gold, I'll forge you something special!"`, 'npc');
                if (player.inventory.includes('broken_sword')) {
                    print(`${npc.name}: "I can repair that broken sword for 30 gold."`, 'npc');
                }
                if (player.inventory.includes('dragon_bone')) {
                    print(`${npc.name}: "Dragon bone! I could make a legendary weapon from that! 100 gold."`, 'npc');
                }
            } else if (room.npc === 'priest' && player.inventory.includes('holy_water')) {
                print(`${npc.name}: "The holy water will help against undead. Use it in combat!"`, 'npc');
            }
        }

        // ==================== SKILL FUNCTIONS ====================
        function showSkills() {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            print(`=== ${player.class.toUpperCase()} SKILLS ===`, 'skill');
            
            classSkills.forEach(skillName => {
                const skill = skills[skillName];
                if (skill) {
                    print(`${skill.name} (${skill.mpCost} MP): ${skill.description}`, 'skill');
                }
            });
            
            print("Use 'skill [name]' in combat to use a skill.", 'system');
        }

        function useSkill(skillName) {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const room = rooms[player.location];
            if (!room.enemy || !player.inCombat) {
                print("You can only use skills in combat!", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            if (!classSkills.includes(skillName)) {
                print(`You don't have the ${skillName} skill!`, 'error');
                return;
            }
            
            const skill = skills[skillName];
            if (!skill) {
                print("Unknown skill.", 'error');
                return;
            }
            
            if (player.mp < skill.mpCost) {
                print(`Not enough MP! Need ${skill.mpCost}, have ${player.mp}.`, 'error');
                return;
            }
            
            player.mp -= skill.mpCost;
            print(`You use ${skill.name}! (-${skill.mpCost} MP)`, 'skill');
            
            const endsTurn = skill.effect(player, room.enemy);
            
            // Apply burning damage if enemy is burning
            if (room.enemy.burning && room.enemy.burning > 0) {
                const burnDamage = Math.floor(room.enemy.dmg * 0.3);
                room.enemy.hp -= burnDamage;
                room.enemy.burning--;
                print(`The enemy burns for ${burnDamage} damage!`, 'damage');
            }
            
            // Check if enemy is defeated
            if (room.enemy.hp <= 0) {
                const enemyType = room.enemy.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 10) + 1;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'boss') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have conquered the Tower of Terror!", 'success');
                    print("You are now the master of the tower!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
                updateStatus();
                return;
            }
            
            // If skill doesn't end turn, enemy doesn't attack
            if (endsTurn) {
                // Enemy turn if not stunned
                if (room.enemy.stunned && room.enemy.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    room.enemy.stunned--;
                } else {
                    enemyTurn(room.enemy);
                }
            }
            
            // Skeleton minion attack if exists
            if (player.skeleton) {
                const skeletonDmg = player.skeleton.dmg + Math.floor(Math.random() * 3);
                room.enemy.hp -= skeletonDmg;
                print(`Your skeleton minion attacks for ${skeletonDmg} damage!`, 'damage');
                soundSystem.playSound('attack', 0.3);
                
                if (room.enemy.hp <= 0) {
                    // Enemy defeated by skeleton
                    const enemyType = room.enemy.originalType;
                    const enemy = enemies[enemyType];
                    print(`Your skeleton minion defeats the ${enemy.name}!`, 'success');
                    player.gold += enemy.gold;
                    player.xp += enemy.xp;
                    print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                    soundSystem.playSound(enemy.sounds.death);
                    room.enemy = null;
                    player.inCombat = null;
                    checkLevelUp();
                }
            }
            
            updateStatus();
        }

        function enemyTurn(enemyData) {
            // Skeleton minion takes damage first if exists
            if (player.skeleton) {
                const enemyDmg = Math.max(enemyData.dmg - 2 + Math.floor(Math.random() * 3), 1);
                player.skeleton.hp -= enemyDmg;
                print(`The enemy attacks your skeleton minion for ${enemyDmg} damage!`, 'damage');
                soundSystem.playSound('playerHit', 0.5);
                
                if (player.skeleton.hp <= 0) {
                    player.skeleton = null;
                    print("Your skeleton minion is destroyed!", 'error');
                }
                return;
            }
            
            // Apply damage reduction if blocking
            let damageMultiplier = 1;
            if (player.blocking > 0) {
                damageMultiplier = 0.5;
                player.blocking--;
                if (player.blocking <= 0) {
                    print("Your defensive stance ends.", 'system');
                }
            }
            
            // Apply shield if exists
            let enemyDmg = Math.max(enemyData.dmg - player.def + Math.floor(Math.random() * 5), 1);
            enemyDmg = Math.floor(enemyDmg * damageMultiplier);
            
            if (player.shield > 0) {
                const absorbed = Math.min(player.shield, enemyDmg);
                enemyDmg -= absorbed;
                player.shield -= absorbed;
                print(`Your shield absorbs ${absorbed} damage.`, 'heal');
                
                if (player.shield <= 0) {
                    print("Your magical shield shatters!", 'system');
                }
            }
            
            if (enemyDmg > 0) {
                player.hp -= enemyDmg;
                print(`The enemy hits you for ${enemyDmg} damage.`, 'damage');
                soundSystem.playSound('playerHit', 0.5);
                
                // Apply poison if spider
                if (enemyData.originalType === 'spider' && Math.random() > 0.7) {
                    player.poisoned = true;
                    print("You have been poisoned!", 'error');
                }
                
                if (player.hp <= 0) {
                    print("You have been slain... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                }
            }
        }

        // ==================== GAME LOGIC ====================
        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.stealth = c.stealth;
            player.gold = 50;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['potion', 'torch'];
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.blocking = 0;
            player.shield = 0;
            player.skeleton = null;
            player.knownPasswords = [];
            player.discoveredSecrets = [];
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 50 gold, a potion, and a torch.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateStatus();
        }

        function look() {
            const room = rooms[player.location];
            
            // Update background music based on room
            if (room.enemy && room.enemy.bgSound) {
                currentBackground = room.enemy.bgSound;
            } else {
                currentBackground = room.sound;
            }
            soundSystem.playBackground(currentBackground);
            
            // Check if room is dark
            if (room.dark && !player.torch) {
                print("The room is pitch black. You can't see anything!", 'error');
                print("You need a light source.", 'error');
                return;
            }
            
            if (!room.explored) {
                room.explored = true;
                player.xp += 5;
                print(`+5 XP for exploring!`, 'system');
                soundSystem.playSound('notification', 0.5);
            }
            
            print(room.desc);
            
            // List interactive objects
            const objectKeys = Object.keys(room.objects);
            if (objectKeys.length > 0) {
                print(`You see: ${objectKeys.join(', ')}`, 'item');
                print("Use 'examine [object]' to look at something, or 'use [item] on [object]' to interact.", 'hint');
            }
            
            if (room.items.length > 0) {
                print(`Items here: ${room.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
            
            if (room.enemy) {
                const enemy = room.enemy;
                print(`${enemy.desc}`, 'enemy');
                const healthPercent = (enemy.hp / enemies[enemy.originalType].hp) * 100;
                if (healthPercent <= 25) {
                    print(`It looks critically wounded.`, 'enemy');
                } else if (healthPercent <= 50) {
                    print(`It looks badly wounded.`, 'enemy');
                } else if (healthPercent <= 75) {
                    print(`It looks wounded.`, 'enemy');
                } else {
                    print(`It looks healthy.`, 'enemy');
                }
            }
            
            if (room.npc) {
                const npc = npcs[room.npc];
                print(`${npc.name} is here. ${npc.desc}`, 'npc');
                print(`Use 'talk ${room.npc}' to speak with them.`, 'hint');
            }
            
            if (room.locked) {
                print("The door to this room is locked!", 'error');
            }
            
            let exits = [];
            for (let dir in room.exits) if (room.exits[dir] !== null) exits.push(dir);
            if (room.exits.secret) exits.push('secret');
            print(`Exits: ${exits.join(' ')}`);
            
            updateStatus();
        }

        function move(direction) {
            const room = rooms[player.location];
            const target = room.exits[direction];
            
            if (target === null) {
                print("You can't go that way.", 'error');
                soundSystem.playSound('click');
                return;
            }
            
            // Check for locked door
            const targetRoom = rooms[target];
            if (targetRoom.locked) {
                if (player.inventory.includes('skeleton_key')) {
                    targetRoom.locked = false;
                    print("You use the skeleton key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else if (player.inventory.includes('key')) {
                    targetRoom.locked = false;
                    print("You use the key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else {
                    print("The door is locked! You need a key.", 'error');
                    return;
                }
            }
            
            soundSystem.playSound('step', 0.3);
            
            // Check for random encounter
            player.moves++;
            if (player.moves % 3 === 0) {
                const encounterChance = Math.max(30 - player.stealth, 5);
                if (Math.random() * 100 < encounterChance) {
                    const randomEnemies = ['rat', 'spider', 'skeleton', 'ghost'];
                    const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
                    rooms[player.location].enemy = createEnemy(enemyType);
                    print(`A ${enemyType} ambushes you!`, 'enemy');
                    player.inCombat = enemyType;
                    soundSystem.playSound('attack', 0.5);
                    updateStatus();
                    return;
                }
            }
            
            player.location = target;
            print(`You go ${direction}.`, 'command');
            
            // Auto-save on movement
            quickSave();
            
            // Apply poison damage if poisoned
            if (player.poisoned) {
                const poisonDmg = Math.floor(player.maxHp * 0.05);
                player.hp -= poisonDmg;
                print(`Poison damages you for ${poisonDmg} HP!`, 'damage');
                soundSystem.playSound('playerHit', 0.3);
                if (player.hp <= 0) {
                    print("You succumb to poison... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                    return;
                }
            }
            
            // Check for dark room
            const newRoom = rooms[player.location];
            if (newRoom.dark && !player.torch) {
                print("You enter complete darkness. You can't see!", 'error');
            } else {
                look();
            }
            
            updateStatus();
        }

        function take(itemName) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            const index = room.items.indexOf(itemName);
            if (index === -1) {
                // Check if it's a special item from an object
                for (const key in room.objects) {
                    const obj = room.objects[key];
                    if (typeof obj === 'object' && obj.hiddenItem === itemName && 
                        (obj.state === 'open' || obj.state === 'burned' || obj.state === 'searched')) {
                        room.items.push(itemName);
                        print(`You take the ${itemName} from the ${key}.`, 'success');
                        soundSystem.playSound('pickup');
                        updateStatus();
                        return;
                    }
                }
                print("That item isn't here.", 'error');
                return;
            }
            
            room.items.splice(index, 1);
            player.inventory.push(itemName);
            print(`You take the ${itemName}.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function give(npcName) {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== npcName) {
                print("That NPC isn't here.", 'error');
                return;
            }
            
            const npc = npcs[npcName];
            
            if (!npc.quest || npc.quest.completed) {
                print(`${npc.name} doesn't want anything from you.`, 'npc');
                return;
            }
            
            if (npc.quest.count) {
                const items = player.inventory.filter(item => item === npc.quest.item);
                if (items.length >= npc.quest.count) {
                    for (let i = 0; i < npc.quest.count; i++) {
                        const index = player.inventory.indexOf(npc.quest.item);
                        player.inventory.splice(index, 1);
                    }
                    
                    npc.quest.completed = true;
                    player.gold += npc.quest.reward.gold;
                    player.xp += npc.quest.reward.xp;
                    if (npc.quest.reward.item) {
                        player.inventory.push(npc.quest.reward.item);
                    }
                    
                    print(`${npc.name}: "Excellent! Here is your reward."`, 'success');
                    print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                    if (npc.quest.reward.item) {
                        print(`You receive: ${npc.quest.reward.item}`, 'loot');
                    }
                    
                    soundSystem.playSound('victory');
                    checkLevelUp();
                } else {
                    print(`You need ${npc.quest.count} ${npc.quest.item}s. You only have ${items.length}.`, 'error');
                }
            } else {
                const index = player.inventory.indexOf(npc.quest.item);
                if (index === -1) {
                    print(`You don't have the ${npc.quest.item}.`, 'error');
                    return;
                }
                
                player.inventory.splice(index, 1);
                npc.quest.completed = true;
                player.gold += npc.quest.reward.gold;
                player.xp += npc.quest.reward.xp;
                if (npc.quest.reward.item) {
                    player.inventory.push(npc.quest.reward.item);
                }
                
                print(`${npc.name}: "Thank you! Here is your reward."`, 'success');
                print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                if (npc.quest.reward.item) {
                    print(`You receive: ${npc.quest.reward.item}`, 'loot');
                }
                
                soundSystem.playSound('victory');
                checkLevelUp();
            }
            
            updateStatus();
        }

        function trainStealth() {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== 'thief') {
                print("Silent Sam isn't here.", 'error');
                return;
            }
            
            if (player.gold < 50) {
                print("You need 50 gold for training.", 'error');
                return;
            }
            
            player.gold -= 50;
            player.stealth += 3;
            print("Silent Sam teaches you to move silently.", 'success');
            print("Stealth +3!", 'success');
            soundSystem.playSound('notification');
            updateStatus();
        }

        function forgeItem() {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== 'blacksmith') {
                print("The blacksmith isn't here.", 'error');
                return;
            }
            
            // Check what can be forged
            if (player.inventory.includes('broken_sword') && player.gold >= 30) {
                // Repair broken sword
                const index = player.inventory.indexOf('broken_sword');
                player.inventory.splice(index, 1);
                player.gold -= 30;
                player.inventory.push('sword');
                print("Grom repairs the broken sword into a fine weapon!", 'success');
                soundSystem.playSound('equip');
            } else if (player.inventory.includes('dragon_bone') && player.gold >= 100) {
                // Make dragon bone weapon
                const index = player.inventory.indexOf('dragon_bone');
                player.inventory.splice(index, 1);
                player.gold -= 100;
                const dragonWeapons = ['greatsword', 'fire_staff', 'amulet_warding'];
                const weapon = dragonWeapons[Math.floor(Math.random() * dragonWeapons.length)];
                player.inventory.push(weapon);
                print(`Grom forges the dragon bone into a legendary ${weapon}!`, 'success');
                soundSystem.playSound('secret');
            } else if (player.inventory.includes('gem') && player.gold >= 50) {
                // Standard forge
                const gemIndex = player.inventory.indexOf('gem');
                player.inventory.splice(gemIndex, 1);
                player.gold -= 50;
                
                const forgedItems = ['mace', 'scale', 'bow'];
                const item = forgedItems[Math.floor(Math.random() * forgedItems.length)];
                player.inventory.push(item);
                
                print("Grom hammers away at his anvil...", 'system');
                setTimeout(() => {
                    print(`Grom hands you a freshly forged ${item}!`, 'success');
                    print("The blacksmith nods approvingly.", 'npc');
                    soundSystem.playSound('equip');
                }, 1000);
            } else {
                print("You need materials and gold for forging.", 'error');
                print("Options: gem + 50 gold, broken_sword + 30 gold, or dragon_bone + 100 gold", 'hint');
                return;
            }
            
            updateStatus();
        }

        function listShop() {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            print(`${npc.name}'s Shop:`, 'npc');
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (item) {
                    const price = item.value;
                    print(`${item.name || itemName} - ${price} gold: ${item.desc}`, 'item');
                }
            });
            print("Sell items for 70% of value.", 'npc');
        }

        function buy(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            if (!npc.shopItems.includes(itemName)) {
                print("The merchant doesn't sell that.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                print("That item doesn't exist.", 'error');
                return;
            }
            
            if (player.gold < item.value) {
                print(`You need ${item.value} gold, but only have ${player.gold}.`, 'error');
                return;
            }
            
            player.gold -= item.value;
            player.inventory.push(itemName);
            print(`You buy ${item.name || itemName} for ${item.value} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function sell(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const index = player.inventory.indexOf(itemName);
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item || item.type === 'quest') {
                print("You can't sell that.", 'error');
                return;
            }
            
            const sellPrice = Math.floor(item.value * 0.7);
            player.gold += sellPrice;
            player.inventory.splice(index, 1);
            print(`You sell ${item.name || itemName} for ${sellPrice} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

        function attack(target) {
            const room = rooms[player.location];
            
            if (target) {
                if (room.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        room.enemy = createEnemy('guard');
                        room.npc = null;
                        player.inCombat = 'guard';
                        player.stealth = Math.max(0, player.stealth - 5);
                        print("Your reputation suffers! Stealth -5.", 'error');
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        room.npc = null;
                        player.stealth = Math.max(0, player.stealth - 10);
                        print("Your dark deed stains your soul! Stealth -10.", 'error');
                        player.xp += 20;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    return;
                }
            }
            
            if (!room.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyData = room.enemy;
            player.inCombat = enemyData.originalType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemyData.originalType}!`, 'command');
            
            // Player attack
            const playerDmg = player.dmg + Math.floor(Math.random() * 5);
            enemyData.hp -= playerDmg;
            print(`You hit for ${playerDmg} damage.`, 'damage');
            soundSystem.playSound(enemyData.sounds.hit, 0.5);
            
            // Apply burning damage if enemy is burning
            if (enemyData.burning && enemyData.burning > 0) {
                const burnDamage = Math.floor(enemyData.dmg * 0.3);
                enemyData.hp -= burnDamage;
                enemyData.burning--;
                print(`The enemy burns for ${burnDamage} damage!`, 'damage');
            }
            
            // Use holy water against undead
            if ((enemyData.originalType === 'skeleton' || enemyData.originalType === 'ghost' || enemyData.originalType === 'wraith') &&
                player.inventory.includes('holy_water')) {
                const holyDamage = 50;
                enemyData.hp -= holyDamage;
                print(`The holy water burns the undead for ${holyDamage} damage!`, 'damage');
                const waterIndex = player.inventory.indexOf('holy_water');
                player.inventory.splice(waterIndex, 1);
            }
            
            if (enemyData.hp <= 0) {
                const enemyType = enemyData.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 10) + 1;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'boss') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have conquered the Tower of Terror!", 'success');
                    print("You are now the master of the tower!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
            } else {
                print(`The ${enemyData.name} has ${enemyData.hp} HP left.`);
                
                // Check if enemy is stunned
                if (enemyData.stunned && enemyData.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    enemyData.stunned--;
                } else {
                    enemyTurn(enemyData);
                }
            }
            
            updateStatus();
        }

        function use(itemName) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(`You heal ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(`You restore ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.cure === 'poison') {
                    player.poisoned = false;
                    print("The poison is cured!", 'success');
                    soundSystem.playSound('notification', 0.3);
                }
                player.inventory.splice(index, 1);
                updateStatus();
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(player.torch ? "You light the torch." : "You extinguish the torch.", 'system');
                soundSystem.playSound('click');
            } else if (item.type === 'scroll') {
                print(`You read the ${itemName}...`, 'system');
                if (item.effect === 'fireball') {
                    const room = rooms[player.location];
                    if (room.enemy) {
                        const fireDmg = 30 + Math.floor(Math.random() * 20);
                        room.enemy.hp -= fireDmg;
                        print(`A massive fireball hits the ${room.enemy.originalType} for ${fireDmg} damage!`, 'damage');
                        soundSystem.playSound('attack');
                        if (room.enemy.hp <= 0) {
                            print(`The ${room.enemy.originalType} is incinerated!`, 'success');
                            room.enemy = null;
                            player.inCombat = null;
                        }
                    } else {
                        print("The fireball fizzles with no target.", 'error');
                    }
                    player.inventory.splice(index, 1);
                }
                updateStatus();
            } else {
                print("You can't use that now.");
            }
        }

        function showInventory() {
            if (player.inventory.length === 0) {
                print("Your inventory is empty.");
            } else {
                print("Inventory:");
                const counts = {};
                player.inventory.forEach(item => {
                    counts[item] = (counts[item] || 0) + 1;
                });
                
                Object.keys(counts).forEach(itemName => {
                    const item = weapons[itemName] || armors[itemName] || items[itemName];
                    const count = counts[itemName];
                    const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
                    print(`${itemName} x${count}: ${itemDesc}`, 'item');
                });
            }
            const weapon = weapons[player.equipped.weapon];
            const armor = armors[player.equipped.armor];
            print(`Equipped: ${weapon.name} (${weapon.dmg + player.str} DMG), ${armor.name} (${armor.def} DEF)`);
            print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.stealth} STEALTH`);
            
            // Show discovered secrets
            if (player.discoveredSecrets.length > 0) {
                print(`\nDiscovered Secrets:`, 'puzzle');
                player.discoveredSecrets.forEach(secret => {
                    print(`  ${secret}`, 'hint');
                });
            }
        }

        function examine(itemName) {
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                // Try to interact with object
                interactWithObject(itemName);
                return;
            }
            
            print(`${item.name || itemName}:`, 'item');
            print(`  ${item.desc}`);
            
            if (weapons[itemName]) {
                print(`  Damage: ${item.dmg}`);
                if (item.stealth) print(`  Stealth: ${item.stealth > 0 ? '+' : ''}${item.stealth}`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
            } else if (armors[itemName]) {
                print(`  Defense: ${item.def}`);
                if (item.stealth) print(`  Stealth: ${item.stealth > 0 ? '+' : ''}${item.stealth}`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
            } else if (items[itemName]) {
                print(`  Value: ${item.value} gold`);
            }
        }

        function help() {
            print("=== TOWER OF TERROR COMMANDS ===", 'command');
            print("MOVEMENT: n, s, e, w, look", 'system');
            print("OBJECT INTERACTION: examine [object], use [item] on [object], search [object]", 'system');
            print("PUZZLES: set clock [hour] [minute] (for Clock Tower)", 'system');
            print("COMBAT: attack [target], skill [name], use [item]", 'system');
            print("SKILLS: skills (to see available skills)", 'system');
            print("NPCS: talk [npc], talk [npc] [topic], give [npc], train, forge", 'system');
            print("MERCHANT: list, buy [item], sell [item]", 'system');
            print("ITEMS: take [item], equip [item], use [item], examine [item]", 'system');
            print("INVENTORY: inventory, status", 'system');
            print("SAVE/LOAD: save, load, qsave, qload", 'system');
            print("OTHER: help, quit", 'system');
            print("=== ADVENTURE GAME TIPS ===", 'command');
            print("- Examine EVERYTHING. Objects have multiple states.", 'system');
            print("- Talk to NPCs multiple times with different topics.", 'system');
            print("- Use items on objects: 'use oil on armor', 'use torch on cobwebs'", 'system');
            print("- Some doors require special keys found by solving puzzles", 'system');
            print("- The Clock Tower, Mirror Hall, and Throne Room have puzzles", 'system');
            print("- Keep notes! Puzzles require remembering clues.", 'system');
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            rooms = generateRooms();
            soundSystem.playBackground('theme');
            print("GAME OVER", 'error');
            print("Choose a class: warrior, wizard, necromancer.");
            updateStatus();
        }

        function quickCommand(cmd) {
            document.getElementById('input').value = cmd;
            const event = new KeyboardEvent('keydown', { key: 'Enter' });
            document.getElementById('input').dispatchEvent(event);
        }

        // ==================== COMMAND PARSER ====================
        input.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                const cmd = input.value.trim().toLowerCase();
                input.value = '';
                if (!cmd) return;

                soundSystem.playSound('click', 0.3);
                print(`> ${cmd}`, 'command');
                const parts = cmd.split(' ');
                const verb = parts[0];
                const arg = parts[1];
                const arg2 = parts[2];
                const arg3 = parts[3];
                const arg4 = parts[4];

                // Class selection
                if (!player.class && ['warrior', 'wizard', 'necromancer'].includes(verb)) {
                    startGame(verb);
                    return;
                }
                if (!player.class) {
                    print("Choose a class first: warrior, wizard, necromancer.", 'error');
                    return;
                }

                // Game commands
                switch (verb) {
                    case 'n': case 'north': move('n'); break;
                    case 's': case 'south': move('s'); break;
                    case 'e': case 'east': move('e'); break;
                    case 'w': case 'west': move('w'); break;
                    case 'secret': move('secret'); break;
                    case 'go': if (arg) move(arg); else print("Go where?"); break;
                    case 'l': case 'look': 
                        if (arg === 'at' && arg2) {
                            interactWithObject(arg2);
                        } else if (arg) {
                            interactWithObject(arg);
                        } else {
                            look();
                        }
                        break;
                    case 'examine': 
                        if (arg) examine(arg); 
                        else print("Examine what?"); 
                        break;
                    case 'search': 
                        if (arg) interactWithObject(arg, 'search'); 
                        else print("Search what?"); 
                        break;
                    case 'use': 
                        if (arg && arg2 === 'on' && arg3) {
                            // use item on object
                            if (player.inventory.includes(arg)) {
                                interactWithObject(arg3, 'use', arg);
                            } else {
                                print(`You don't have ${arg}.`, 'error');
                            }
                        } else if (arg) {
                            use(arg);
                        } else {
                            print("Use what?"); 
                        }
                        break;
                    case 'set':
                        if (arg === 'clock' && arg2 && arg3) {
                            setClock(`${arg2} ${arg3}`);
                        } else {
                            print("Set what?"); 
                        }
                        break;
                    case 'take': if (arg) take(arg); else print("Take what?"); break;
                    case 'talk': 
                        if (arg && arg2) {
                            talkTo(arg, arg2);
                        } else if (arg) {
                            talkTo(arg);
                        } else {
                            print("Talk to who?"); 
                        }
                        break;
                    case 'give': if (arg) give(arg); else print("Give to who?"); break;
                    case 'train': trainStealth(); break;
                    case 'forge': forgeItem(); break;
                    case 'list': listShop(); break;
                    case 'buy': if (arg) buy(arg); else print("Buy what?"); break;
                    case 'sell': if (arg) sell(arg); else print("Sell what?"); break;
                    case 'skill': if (arg) useSkill(arg); else print("Use which skill?"); break;
                    case 'skills': showSkills(); break;
                    case 'attack': if (arg) attack(arg); else attack(); break;
                    case 'equip': if (arg) equip(arg); else print("Equip what?"); break;
                    case 'i': case 'inventory': case 'inv': showInventory(); break;
                    case 'status': updateStatus(); break;
                    case 'save': saveGame(); break;
                    case 'load': loadGame(); break;
                    case 'qsave': quickSave(); break;
                    case 'qload': quickLoad(); break;
                    case 'help': case '?': help(); break;
                    case 'quit': resetGame(); break;
                    default: print("Unknown command. Type 'help'.", 'error');
                }
            }
        });

        // Sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundSystem.toggle();
        });

        // Initialize audio on first user interaction
        document.addEventListener('click', function initAudio() {
            soundSystem.resumeAudioContext();
            if (!gameStarted) {
                soundSystem.playBackground('theme');
            }
            document.removeEventListener('click', initAudio);
        }, { once: true });

        // ==================== INIT ====================
        print("TOWER OF TERROR (1984) - ENHANCED EDITION", 'success');
        print("NIGHTFALLS GAMES PRESENTS", 'system');
        print("", 'system');
        print("A TRUE TEXT ADVENTURE with puzzles, interactive objects, and deep NPCs!", 'system');
        print("Complete quests, solve puzzles, fight monsters, find treasure!", 'system');
        print("", 'system');
        print("KEY FEATURES:", 'puzzle');
        print("- Interactive objects with multiple states", 'system');
        print("- Deep NPC dialogue with topics to discuss", 'system');
        print("- Environmental puzzles in Clock Tower, Mirror Hall, etc.", 'system');
        print("- Use items on objects: 'use oil on armor'", 'system');
        print("- Secret passages and hidden rooms", 'system');
        print("", 'system');
        print("Touch sound button to toggle audio", 'system');
        print("Use quick buttons for mobile play", 'system');
        print("SAVE/LOAD buttons in top-left corner", 'system');
        print("", 'system');
        print("Choose your class: warrior, wizard, necromancer.", 'system');
        updateStatus();
        input.focus();
    </script>
</body>
</html>
