<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultima III: Exodus - Enhanced Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        body {
            margin: 0;
            padding: 20px;
            background-color: #000;
            color: #0f0;
            font-family: 'Press Start 2P', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: hidden;
        }
        #game-container {
            max-width: 1200px;
            margin: 0 auto;
            border: 4px double #0f0;
            padding: 10px;
            background-color: #111;
        }
        .screen {
            border: 2px solid #0a0;
            margin-bottom: 10px;
            padding: 15px;
            min-height: 200px;
            background-color: #000;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dotted #0a0;
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            flex-wrap: wrap;
        }
        .main-display {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 15px;
            min-height: 400px;
        }
        #view-map, #view-combat, #view-inventory, #view-town, #view-dungeon, #view-character, #view-spells, #view-shop {
            display: none;
        }
        .map-area {
            border: 1px solid #0a0;
            background-color: #030;
            position: relative;
            height: 350px;
            overflow: hidden;
        }
        .tile {
            position: absolute;
            width: 32px;
            height: 32px;
            text-align: center;
            line-height: 32px;
        }
        .party { background-color: #ff0; color: #000; }
        .town { background-color: #66f; color: #fff; }
        .forest { background-color: #080; color: #0a0; }
        .mountain { background-color: #888; color: #ddd; }
        .water { background-color: #00a; color: #aaf; }
        .enemy { background-color: #f00; color: #fff; }
        .dungeon { background-color: #500; color: #faa; }
        .castle { background-color: #a50; color: #ff0; }
        .moongate { background-color: #a0a; color: #fff; }
        .shrine { background-color: #ffcc00; color: #000; }
        .ruins { background-color: #8b4513; color: #ddd; }
        .bridge { background-color: #a0522d; color: #fff; }
        
        .info-panel {
            border: 1px solid #0a0;
            padding: 10px;
            overflow-y: auto;
            max-height: 350px;
        }
        .combat-grid {
            display: grid;
            grid-template-columns: repeat(8, 32px);
            grid-template-rows: repeat(8, 32px);
            gap: 2px;
            justify-content: center;
            margin: 20px auto;
            border: 2px solid #a00;
            padding: 10px;
            background-color: #300;
            width: fit-content;
        }
        .combat-cell {
            width: 32px;
            height: 32px;
            border: 1px solid #500;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .combat-cell.party:hover { background-color: #ff5; }
        .combat-cell.enemy:hover { background-color: #f55; }
        
        .menu {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .menu-large {
            grid-template-columns: repeat(4, 1fr);
        }
        button {
            background-color: #222;
            color: #0f0;
            border: 2px outset #0a0;
            padding: 10px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.1s;
        }
        button:hover {
            background-color: #333;
            border-style: inset;
        }
        button:active {
            background-color: #444;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .log {
            border-top: 1px dotted #0a0;
            margin-top: 15px;
            padding-top: 10px;
            font-size: 11px;
            color: #afa;
            height: 100px;
            overflow-y: auto;
            background-color: #020;
        }
        .party-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-top: 15px;
            gap: 10px;
        }
        .character-card {
            border: 1px solid #0a0;
            padding: 8px;
            margin: 5px;
            min-width: 180px;
            background-color: #020;
            cursor: pointer;
        }
        .character-card:hover {
            border-color: #0f0;
            background-color: #030;
        }
        .class-fighter { color: #f66; }
        .class-mage { color: #6af; }
        .class-cleric { color: #ff6; }
        .class-thief { color: #6f6; }
        
        h1, h2 {
            color: #0f0;
            text-align: center;
            text-shadow: 0 0 5px #0f0;
            margin: 10px 0;
        }
        .ascii-art {
            text-align: center;
            font-size: 10px;
            line-height: 1.2;
            color: #0a0;
            margin: 10px 0;
            white-space: pre;
        }
        
        /* New Styles for Enhanced Systems */
        .inventory-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            min-height: 400px;
        }
        .char-equipment {
            border: 1px solid #0a0;
            padding: 10px;
        }
        .char-equipment.active {
            border-color: #ff0;
            background-color: #031;
        }
        .equip-slot {
            border: 1px dashed #0a0;
            padding: 5px;
            margin: 5px 0;
            cursor: pointer;
            min-height: 30px;
        }
        .equip-slot:hover {
            background-color: #030;
        }
        .equip-slot.equipped {
            border-style: solid;
            background-color: #042;
        }
        .shared-inventory {
            border: 1px solid #0a0;
            padding: 10px;
        }
        .inventory-slots {
            display: grid;
            grid-template-columns: repeat(6, 50px);
            grid-template-rows: repeat(4, 50px);
            gap: 5px;
            margin: 10px 0;
        }
        .inventory-slot {
            border: 1px solid #0a0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            padding: 2px;
            cursor: pointer;
            overflow: hidden;
        }
        .inventory-slot:hover {
            background-color: #030;
        }
        .inventory-slot.filled {
            background-color: #042;
        }
        .inventory-slot.selected {
            border-color: #ff0;
            background-color: #330;
        }
        
        .town-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        .town-building {
            border: 2px solid #0a0;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .town-building:hover {
            background-color: #020;
            border-color: #0f0;
        }
        .building-icon {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .dungeon-view {
            border: 2px solid #a00;
            background-color: #300;
            padding: 20px;
            margin: 20px auto;
            width: 400px;
            height: 300px;
            overflow: hidden;
            font-family: monospace;
            white-space: pre;
            line-height: 1.2;
            color: #faa;
        }
        .dungeon-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px auto;
            width: 400px;
        }
        
        .spell-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .spell-card {
            border: 1px solid #0a0;
            padding: 10px;
            cursor: pointer;
        }
        .spell-card:hover {
            background-color: #020;
        }
        .spell-card.available {
            border-color: #6af;
        }
        .spell-card.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .shop-items {
            border: 1px solid #0a0;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .shop-item {
            border-bottom: 1px dotted #0a0;
            padding: 5px;
            cursor: pointer;
        }
        .shop-item:hover {
            background-color: #020;
        }
        
        .quest-log {
            border: 1px solid #0a0;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin: 10px 0;
        }
        .quest-entry {
            border-bottom: 1px dotted #0a0;
            padding: 5px 0;
        }
        
        .minimap {
            border: 1px solid #0a0;
            padding: 5px;
            margin: 10px 0;
            background-color: #020;
        }
        .minimap-grid {
            display: grid;
            grid-template-columns: repeat(5, 20px);
            grid-template-rows: repeat(5, 20px);
            gap: 1px;
            margin: 5px auto;
        }
        .minimap-cell {
            border: 1px solid #020;
            font-size: 8px;
            text-align: center;
            line-height: 20px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #000;
            border: 2px solid #0f0;
            padding: 10px;
            z-index: 1000;
            animation: fadeOut 3s forwards;
        }
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .tooltip {
            position: absolute;
            background-color: #000;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 10px;
            z-index: 100;
            max-width: 200px;
            pointer-events: none;
        }
        
        .flex-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
        }
        .progress-bar {
            height: 10px;
            background-color: #020;
            border: 1px solid #0a0;
            margin: 5px 0;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background-color: #0a0;
            transition: width 0.3s;
        }
        
        /* Combat Enhancements */
        .combat-ui {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .combat-actions {
            border: 1px solid #0a0;
            padding: 10px;
        }
        .combat-status {
            border: 1px solid #a00;
            padding: 10px;
            background-color: #200;
        }
        .combat-action-btn {
            margin: 5px;
            width: 120px;
        }
        .combat-target {
            background-color: #f005 !important;
        }
        .combat-turn-indicator {
            border: 2px solid #ff0;
            background-color: #330;
        }
        
        /* Character Selector */
        .char-selector {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .char-select-btn {
            padding: 5px;
            font-size: 10px;
            flex: 1;
            margin: 0 2px;
        }
        .char-select-btn.active {
            background-color: #0a0;
            border-color: #0f0;
        }
        
        /* Spell Memorization */
        .spell-memorization {
            border: 1px solid #0a0;
            padding: 15px;
            margin: 10px 0;
        }
        .spell-slots {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        .spell-slot {
            border: 1px dashed #0a0;
            padding: 10px;
            text-align: center;
            min-height: 60px;
            cursor: pointer;
        }
        .spell-slot.filled {
            border: 2px solid #6af;
            background-color: #114;
        }
        .spell-slot.empty {
            background-color: #020;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .main-display { grid-template-columns: 1fr; }
            .inventory-grid { grid-template-columns: 1fr; }
            .town-grid { grid-template-columns: 1fr; }
            .spell-grid { grid-template-columns: 1fr; }
            .shop-grid { grid-template-columns: 1fr; }
            .menu { grid-template-columns: 1fr; }
            .party-info { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="ascii-art">
   _____     _ _       ___          
  / / / |   (_) |     / / |_      
 / / /| |    _| | /| / /| |\ \   
< < < | |   | | |/ |/ / | | \ \  
 \ \ \| |___| | /|  /  | |  \ \ 
  \_\_\_____/_|_/ |_/  |_|   \_\
ULTIMA III: EXODUS - ENHANCED EDITION
        </div>
        
        <div class="status-bar">
            <span>GOLD: <span id="gold">150</span></span>
            <span>FOOD: <span id="food">100</span></span>
            <span>DAY: <span id="day">1</span></span>
            <span>TIME: <span id="time">MORNING</span></span>
            <span>LOC: <span id="location">BRITANNIA</span></span>
            <span>TURN: <span id="turn">1</span></span>
        </div>

        <!-- Character Creation Screen -->
        <div id="view-creation" class="screen">
            <h2>CREATE YOUR PARTY</h2>
            <p>Four heroes must stand against EXODUS, the demon-child of Mondain and Minax. Choose wisely.</p>
            <div id="party-creation"></div>
            <div class="menu">
                <button onclick="startGame()">BEGIN QUEST</button>
                <button onclick="resetParty()">RESET PARTY</button>
                <button onclick="loadGame()">LOAD GAME</button>
                <button onclick="showTutorial()">TUTORIAL</button>
            </div>
            <div class="log" id="creation-log">
                Welcome to Sosaria. Assemble four adventurers for your quest.
            </div>
        </div>

        <!-- Main Exploration Screen -->
        <div id="view-explore" class="screen" style="display:none;">
            <h2>SOSARIA - <span id="current-loc-name">BRITANNIA</span></h2>
            <div class="flex-row">
                <div class="minimap">
                    <div>MINIMAP</div>
                    <div class="minimap-grid" id="minimap"></div>
                </div>
                <div>
                    <button onclick="quickSave()">QUICK SAVE</button>
                    <button onclick="quickLoad()">QUICK LOAD</button>
                </div>
            </div>
            
            <div class="main-display">
                <div class="map-area" id="world-map"></div>
                <div class="info-panel">
                    <h3>COMMANDS</h3>
                    <div class="menu menu-large">
                        <button onclick="moveParty('north')">NORTH</button>
                        <button onclick="moveParty('south')">SOUTH</button>
                        <button onclick="moveParty('east')">EAST</button>
                        <button onclick="moveParty('west')">WEST</button>
                        <button onclick="enterLocation()">ENTER</button>
                        <button onclick="restParty()">REST</button>
                        <button onclick="searchArea()">SEARCH</button>
                        <button onclick="checkStatus()">STATUS</button>
                        <button onclick="switchView('inventory')">INVENTORY</button>
                        <button onclick="switchView('spells')">SPELLS</button>
                        <button onclick="switchView('character')">CHARACTER</button>
                        <button onclick="switchView('quests')">QUESTS</button>
                        <button onclick="saveGame()">SAVE</button>
                    </div>
                    <h3>PARTY STATUS</h3>
                    <div class="party-info" id="party-status"></div>
                </div>
            </div>
            <div class="log" id="explore-log"></div>
        </div>

        <!-- Enhanced Combat Screen -->
        <div id="view-combat" class="screen" style="display:none;">
            <h2>BATTLE! <span id="combat-turn-indicator">(Player's Turn)</span></h2>
            <div class="combat-grid" id="combat-grid"></div>
            
            <div class="combat-ui">
                <div class="combat-actions">
                    <h3>ACTIONS</h3>
                    <div>Current Action: <span id="current-action">Attack</span></div>
                    <div>Selected Character: <span id="selected-combat-char">None</span></div>
                    <div class="menu" id="combat-action-buttons">
                        <button onclick="setCombatAction('attack')" id="btn-attack">ATTACK</button>
                        <button onclick="setCombatAction('spell')" id="btn-spell">CAST SPELL</button>
                        <button onclick="setCombatAction('item')" id="btn-item">USE ITEM</button>
                        <button onclick="setCombatAction('defend')" id="btn-defend">DEFEND</button>
                        <button onclick="setCombatAction('flee')" id="btn-flee">FLEE</button>
                    </div>
                    <div id="spell-selector" style="display:none;">
                        <h4>SELECT SPELL:</h4>
                        <div id="combat-spells"></div>
                    </div>
                    <div id="item-selector" style="display:none;">
                        <h4>SELECT ITEM:</h4>
                        <div id="combat-items"></div>
                    </div>
                    <button onclick="executeCombatAction()" id="btn-execute">EXECUTE ACTION</button>
                </div>
                
                <div class="combat-status">
                    <h3>COMBAT STATUS</h3>
                    <div>TARGET: <span id="target-name">None</span></div>
                    <div id="enemy-status">
                        <h4>ENEMIES:</h4>
                        <div id="enemy-list"></div>
                    </div>
                    <div id="party-combat-status">
                        <h4>PARTY:</h4>
                        <div id="party-combat-list"></div>
                    </div>
                    <div class="log" id="combat-log"></div>
                </div>
            </div>
        </div>

        <!-- Inventory Screen -->
        <div id="view-inventory" class="screen" style="display:none;">
            <h2>INVENTORY</h2>
            <div class="char-selector">
                <button class="char-select-btn" id="char-btn-0" onclick="selectCharacter(0)">HERO 1</button>
                <button class="char-select-btn" id="char-btn-1" onclick="selectCharacter(1)">HERO 2</button>
                <button class="char-select-btn" id="char-btn-2" onclick="selectCharacter(2)">HERO 3</button>
                <button class="char-select-btn" id="char-btn-3" onclick="selectCharacter(3)">HERO 4</button>
            </div>
            <div class="inventory-grid">
                <div class="char-equipment active" id="char-equipment-0">
                    <h3><span id="char-name-0">Character 1</span></h3>
                    <div class="equip-slot" data-slot="weapon" onclick="equipItemToSlot(0, 'weapon')">
                        Weapon: <span id="weapon-0">None</span>
                    </div>
                    <div class="equip-slot" data-slot="armor" onclick="equipItemToSlot(0, 'armor')">
                        Armor: <span id="armor-0">None</span>
                    </div>
                    <div class="equip-slot" data-slot="shield" onclick="equipItemToSlot(0, 'shield')">
                        Shield: <span id="shield-0">None</span>
                    </div>
                    <div class="equip-slot" data-slot="accessory" onclick="equipItemToSlot(0, 'accessory')">
                        Accessory: <span id="accessory-0">None</span>
                    </div>
                    <div>Weight: <span id="weight-0">0/100</span></div>
                    <div>Attack Bonus: <span id="attack-bonus-0">+0</span></div>
                    <div>Defense Bonus: <span id="defense-bonus-0">+0</span></div>
                </div>
                
                <div class="char-equipment" id="char-equipment-1" style="display:none;">
                    <h3><span id="char-name-1">Character 2</span></h3>
                    <div class="equip-slot" data-slot="weapon" onclick="equipItemToSlot(1, 'weapon')">
                        Weapon: <span id="weapon-1">None</span>
                    </div>
                    <div class="equip-slot" data-slot="armor" onclick="equipItemToSlot(1, 'armor')">
                        Armor: <span id="armor-1">None</span>
                    </div>
                    <div class="equip-slot" data-slot="shield" onclick="equipItemToSlot(1, 'shield')">
                        Shield: <span id="shield-1">None</span>
                    </div>
                    <div class="equip-slot" data-slot="accessory" onclick="equipItemToSlot(1, 'accessory')">
                        Accessory: <span id="accessory-1">None</span>
                    </div>
                    <div>Weight: <span id="weight-1">0/100</span></div>
                    <div>Attack Bonus: <span id="attack-bonus-1">+0</span></div>
                    <div>Defense Bonus: <span id="defense-bonus-1">+0</span></div>
                </div>
                
                <div class="char-equipment" id="char-equipment-2" style="display:none;">
                    <h3><span id="char-name-2">Character 3</span></h3>
                    <div class="equip-slot" data-slot="weapon" onclick="equipItemToSlot(2, 'weapon')">
                        Weapon: <span id="weapon-2">None</span>
                    </div>
                    <div class="equip-slot" data-slot="armor" onclick="equipItemToSlot(2, 'armor')">
                        Armor: <span id="armor-2">None</span>
                    </div>
                    <div class="equip-slot" data-slot="shield" onclick="equipItemToSlot(2, 'shield')">
                        Shield: <span id="shield-2">None</span>
                    </div>
                    <div class="equip-slot" data-slot="accessory" onclick="equipItemToSlot(2, 'accessory')">
                        Accessory: <span id="accessory-2">None</span>
                    </div>
                    <div>Weight: <span id="weight-2">0/100</span></div>
                    <div>Attack Bonus: <span id="attack-bonus-2">+0</span></div>
                    <div>Defense Bonus: <span id="defense-bonus-2">+0</span></div>
                </div>
                
                <div class="char-equipment" id="char-equipment-3" style="display:none;">
                    <h3><span id="char-name-3">Character 4</span></h3>
                    <div class="equip-slot" data-slot="weapon" onclick="equipItemToSlot(3, 'weapon')">
                        Weapon: <span id="weapon-3">None</span>
                    </div>
                    <div class="equip-slot" data-slot="armor" onclick="equipItemToSlot(3, 'armor')">
                        Armor: <span id="armor-3">None</span>
                    </div>
                    <div class="equip-slot" data-slot="shield" onclick="equipItemToSlot(3, 'shield')">
                        Shield: <span id="shield-3">None</span>
                    </div>
                    <div class="equip-slot" data-slot="accessory" onclick="equipItemToSlot(3, 'accessory')">
                        Accessory: <span id="accessory-3">None</span>
                    </div>
                    <div>Weight: <span id="weight-3">0/100</span></div>
                    <div>Attack Bonus: <span id="attack-bonus-3">+0</span></div>
                    <div>Defense Bonus: <span id="defense-bonus-3">+0</span></div>
                </div>
                
                <div class="shared-inventory">
                    <h3>PARTY INVENTORY</h3>
                    <div>Gold: <span id="inventory-gold">150</span></div>
                    <div>Food: <span id="inventory-food">100</span></div>
                    <div>Keys: <span id="inventory-keys">0</span></div>
                    <div>Torches: <span id="inventory-torches">0</span></div>
                    <div class="inventory-slots" id="inventory-slots"></div>
                    <div class="menu">
                        <button onclick="sortInventory()">SORT</button>
                        <button onclick="switchView('explore')">BACK</button>
                        <button onclick="useSelectedItem()">USE</button>
                        <button onclick="dropSelectedItem()">DROP</button>
                        <button onclick="unequipAll()">UNEQUIP ALL</button>
                    </div>
                </div>
            </div>
            <div class="log" id="inventory-log"></div>
        </div>

        <!-- Town Screen -->
        <div id="view-town" class="screen" style="display:none;">
            <h2>TOWN OF <span id="town-name">BRITAIN</span></h2>
            <div class="town-grid">
                <div class="town-building" onclick="enterBuilding('tavern')">
                    <div class="building-icon">üç∫</div>
                    <div class="building-name">TAVERN</div>
                    <div class="building-desc">Rest & Information</div>
                </div>
                <div class="town-building" onclick="enterBuilding('weaponshop')">
                    <div class="building-icon">‚öîÔ∏è</div>
                    <div class="building-name">WEAPON SHOP</div>
                    <div class="building-desc">Buy/Sell Weapons</div>
                </div>
                <div class="town-building" onclick="enterBuilding('armorshop')">
                    <div class="building-icon">üõ°Ô∏è</div>
                    <div class="building-name">ARMOR SHOP</div>
                    <div class="building-desc">Buy/Sell Armor</div>
                </div>
                <div class="town-building" onclick="enterBuilding('magicshop')">
                    <div class="building-icon">üîÆ</div>
                    <div class="building-name">MAGIC SHOP</div>
                    <div class="building-desc">Spells & Potions</div>
                </div>
                <div class="town-building" onclick="enterBuilding('temple')">
                    <div class="building-icon">‚õ™</div>
                    <div class="building-name">TEMPLE</div>
                    <div class="building-desc">Healing & Resurrection</div>
                </div>
                <div class="town-building" onclick="enterBuilding('castle')">
                    <div class="building-icon">üè∞</div>
                    <div class="building-name">CASTLE</div>
                    <div class="building-desc">Quest Information</div>
                </div>
            </div>
            <div class="menu">
                <button onclick="switchView('explore')">LEAVE TOWN</button>
                <button onclick="gatherRumors()">GATHER RUMORS</button>
                <button onclick="donateToTemple()">DONATE</button>
            </div>
            <div class="log" id="town-log"></div>
        </div>

        <!-- Dungeon Screen -->
        <div id="view-dungeon" class="screen" style="display:none;">
            <h2>DUNGEON: <span id="dungeon-name">DESTARD</span> Level <span id="dungeon-level">1</span></h2>
            <div class="dungeon-view" id="dungeon-view"></div>
            <div class="dungeon-controls">
                <button onclick="moveDungeon('forward')">‚Üë FORWARD</button>
                <button onclick="turnDungeon('left')">‚Üê TURN LEFT</button>
                <button onclick="turnDungeon('right')">‚Üí TURN RIGHT</button>
                <button onclick="searchDungeon()">SEARCH</button>
                <button onclick="useTorch()">USE TORCH</button>
                <button onclick="retreatDungeon()">RETREAT</button>
            </div>
            <div class="log" id="dungeon-log"></div>
        </div>

        <!-- Character Sheet Screen -->
        <div id="view-character" class="screen" style="display:none;">
            <h2>CHARACTER SHEET</h2>
            <div id="character-sheet"></div>
            <div class="menu">
                <button onclick="prevCharacter()">PREV</button>
                <button onclick="nextCharacter()">NEXT</button>
                <button onclick="switchView('explore')">BACK</button>
                <button onclick="trainCharacter()">TRAIN</button>
            </div>
        </div>

        <!-- Spell Screen -->
        <div id="view-spells" class="screen" style="display:none;">
            <h2>SPELLBOOK</h2>
            <div class="spell-memorization" id="spell-memorization">
                <h3>SPELL MEMORIZATION</h3>
                <div>Available Slots: <span id="spell-slots-available">0</span></div>
                <div>Spell Slots:</div>
                <div class="spell-slots" id="spell-slots-container"></div>
                <div class="menu">
                    <button onclick="memorizeSelectedSpell()">MEMORIZE SELECTED</button>
                    <button onclick="clearSpellSlot()">CLEAR SLOT</button>
                    <button onclick="restToMemorize()">REST TO MEMORIZE</button>
                </div>
            </div>
            <div id="spellbook"></div>
            <div class="menu">
                <button onclick="switchView('explore')">BACK</button>
                <button onclick="researchSpell()">RESEARCH</button>
            </div>
        </div>

        <!-- Shop Screen -->
        <div id="view-shop" class="screen" style="display:none;">
            <h2><span id="shop-type">SHOP</span> - <span id="shop-name"></span></h2>
            <div class="shop-grid">
                <div class="shop-items" id="shop-items"></div>
                <div class="info-panel">
                    <h3>PARTY GOLD: <span id="shop-gold">0</span></h3>
                    <div id="shop-description">Select an item to view description</div>
                    <div class="menu">
                        <button onclick="buyItem()" id="buy-btn">BUY</button>
                        <button onclick="sellItem()" id="sell-btn">SELL</button>
                        <button onclick="exitShop()">EXIT</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quests Screen -->
        <div id="view-quests" class="screen" style="display:none;">
            <h2>QUEST LOG</h2>
            <div class="quest-log" id="quest-log"></div>
            <div class="menu">
                <button onclick="switchView('explore')">BACK</button>
                <button onclick="abandonQuest()">ABANDON</button>
            </div>
        </div>
    </div>

    <div id="notification-area" style="position:fixed;top:10px;right:10px;"></div>
    <div id="tooltip" class="tooltip" style="display:none;"></div>

    <script>
        // ====================
        // GAME STATE & DATA
        // ====================
        const gameState = {
            screen: 'creation',
            party: [],
            gold: 150,
            food: 100,
            turn: 1,
            day: 1,
            time: 'MORNING',
            location: { x: 5, y: 5, name: 'Britain', type: 'town' },
            worldMap: [],
            inCombat: false,
            enemies: [],
            currentEnemyTurn: 0,
            gameLog: [],
            inventory: [],
            selectedChar: 0,
            currentTown: null,
            currentDungeon: null,
            dungeonLevel: 1,
            dungeonPosition: { x: 0, y: 0 },
            dungeonDirection: 'north',
            quests: [],
            reputation: 0,
            timeCounter: 0,
            
            // Combat enhancements
            combatTurn: 0, // 0-3: player characters, -1: enemy turn
            combatAction: 'attack',
            combatSelectedChar: 0,
            combatSelectedTarget: null,
            combatSelectedSpell: null,
            combatSelectedItem: null,
            combatStatusEffects: [],
            combatRound: 1,
            
            // Inventory selection
            selectedInventoryItem: null,
            
            // Spell memorization
            memorizedSpells: [],
            spellSlots: 0,
            usedSpellSlots: 0
        };

        // Enhanced Races with combat bonuses and restrictions
        const races = [
            { 
                id: 'human', 
                name: 'HUMAN', 
                bonuses: { str: 1, wis: 1 },
                combatBonus: { critical: 5, hit: 2 },
                restrictions: { armor: 'none', weapons: 'none' },
                dialogue: ['Human villages welcome you.', 'Lord British favors humans.'],
                ability: 'Adaptable: +10% XP gain'
            },
            { 
                id: 'elven', 
                name: 'ELVEN', 
                bonuses: { dex: 2, int: 1 },
                combatBonus: { accuracy: 5, dodge: 5, magicResist: 10 },
                restrictions: { armor: 'no plate', weapons: 'no heavy' },
                dialogue: ['The forests speak to you.', 'Ancient magic flows in your veins.'],
                ability: 'Night Vision: See further in darkness'
            },
            { 
                id: 'dwarven', 
                name: 'DWARVEN', 
                bonuses: { str: 2, con: 1 },
                combatBonus: { damage: 2, hp: 10, poisonResist: 20 },
                restrictions: { armor: 'no leather', weapons: 'axes only +2' },
                dialogue: ['Stone and metal are your kin.', 'Mountains feel like home.'],
                ability: 'Mining: Find ore in mountains'
            },
            { 
                id: 'bobbit', 
                name: 'BOBBIT', 
                bonuses: { dex: 2, wis: 1 },
                combatBonus: { stealth: 15, dodge: 10, critical: 10 },
                restrictions: { armor: 'no heavy', weapons: 'no two-handed' },
                dialogue: ['Small folk are often overlooked.', 'The Shire is far from here.'],
                ability: 'Lucky: Find extra treasure'
            }
        ];

        // Expanded Classes
        const classes = [
            { 
                id: 'fighter', 
                name: 'FIGHTER', 
                hp: 30, 
                mp: 0, 
                str: 18, 
                dex: 12, 
                int: 8, 
                wis: 8,
                ac: 0,
                color: 'class-fighter',
                abilities: ['Cleave', 'Power Attack'],
                combatBonus: { accuracy: 5, damage: 2 },
                spellSlots: 0
            },
            { 
                id: 'mage', 
                name: 'MAGE', 
                hp: 18, 
                mp: 25, 
                str: 8, 
                dex: 10, 
                int: 18, 
                wis: 12,
                ac: 1,
                color: 'class-mage',
                abilities: ['Spell Research', 'Identify'],
                combatBonus: { spellPower: 3, mpRegen: 1 },
                spellSlots: 3
            },
            { 
                id: 'cleric', 
                name: 'CLERIC', 
                hp: 22, 
                mp: 20, 
                str: 10, 
                dex: 10, 
                int: 10, 
                wis: 18,
                ac: 2,
                color: 'class-cleric',
                abilities: ['Turn Undead', 'Healing Aura'],
                combatBonus: { healing: 3, undeadBonus: 5 },
                spellSlots: 2
            },
            { 
                id: 'thief', 
                name: 'THIEF', 
                hp: 20, 
                mp: 5, 
                str: 12, 
                dex: 18, 
                int: 12, 
                wis: 8,
                ac: 1,
                color: 'class-thief',
                abilities: ['Backstab', 'Pick Lock'],
                combatBonus: { critical: 10, dodge: 5 },
                spellSlots: 0
            }
        ];

        // Expanded Items Database
        const itemsDB = {
            weapons: [
                { id: 'dagger', name: 'Dagger', type: 'weapon', damage: '1d4', cost: 20, weight: 1, bonus: 0, hands: 1, raceRestriction: [] },
                { id: 'shortsword', name: 'Short Sword', type: 'weapon', damage: '1d6', cost: 50, weight: 3, bonus: 0, hands: 1, raceRestriction: [] },
                { id: 'longsword', name: 'Long Sword', type: 'weapon', damage: '1d8', cost: 150, weight: 4, bonus: 1, hands: 1, raceRestriction: ['bobbit'] },
                { id: 'battleaxe', name: 'Battle Axe', type: 'weapon', damage: '1d10', cost: 300, weight: 8, bonus: 2, hands: 2, raceRestriction: ['elven', 'bobbit'], dwarfBonus: 2 },
                { id: 'bow', name: 'Short Bow', type: 'weapon', damage: '1d6', cost: 100, weight: 3, bonus: 0, range: 5, hands: 2, raceRestriction: ['dwarven'] },
                { id: 'staff', name: 'Wizard Staff', type: 'weapon', damage: '1d4', cost: 75, weight: 4, bonus: 0, mp: 5, hands: 2, raceRestriction: [] },
                { id: 'mace', name: 'Mace', type: 'weapon', damage: '1d6', cost: 80, weight: 5, bonus: 0, hands: 1, vsUndead: 2, raceRestriction: [] }
            ],
            armor: [
                { id: 'leather', name: 'Leather Armor', type: 'armor', ac: 3, cost: 50, weight: 5, slot: 'body', raceRestriction: ['dwarven'] },
                { id: 'chain', name: 'Chain Mail', type: 'armor', ac: 5, cost: 300, weight: 15, slot: 'body', raceRestriction: [] },
                { id: 'plate', name: 'Plate Mail', type: 'armor', ac: 7, cost: 800, weight: 25, slot: 'body', penalty: -2, raceRestriction: ['elven', 'bobbit'] }
            ],
            shields: [
                { id: 'buckler', name: 'Buckler', type: 'shield', ac: 1, cost: 30, weight: 3, slot: 'offhand', raceRestriction: [] },
                { id: 'shield', name: 'Kite Shield', type: 'shield', ac: 2, cost: 150, weight: 8, slot: 'offhand', raceRestriction: ['bobbit'] }
            ],
            potions: [
                { id: 'heal', name: 'Healing Potion', type: 'potion', effect: 'heal:10', cost: 75, weight: 0.5 },
                { id: 'mana', name: 'Mana Potion', type: 'potion', effect: 'mp:15', cost: 100, weight: 0.5 },
                { id: 'antidote', name: 'Antidote', type: 'potion', effect: 'cure:poison', cost: 50, weight: 0.5 },
                { id: 'strength', name: 'Potion of Strength', type: 'potion', effect: 'str:2', cost: 150, weight: 0.5, duration: 10 }
            ],
            scrolls: [
                { id: 'identify', name: 'Scroll of Identify', type: 'scroll', effect: 'identify', cost: 200, weight: 0.1 },
                { id: 'teleport', name: 'Scroll of Teleport', type: 'scroll', effect: 'teleport', cost: 500, weight: 0.1 },
                { id: 'fireball', name: 'Scroll of Fireball', type: 'scroll', effect: 'fireball:6d6', cost: 400, weight: 0.1 }
            ],
            misc: [
                { id: 'key', name: 'Dungeon Key', type: 'key', cost: 100, weight: 0.1 },
                { id: 'torch', name: 'Torch', type: 'tool', effect: 'light:10', cost: 10, weight: 1 },
                { id: 'rations', name: 'Rations', type: 'food', effect: 'food:10', cost: 5, weight: 0.5 },
                { id: 'lockpick', name: 'Lockpick', type: 'tool', effect: 'picklock', cost: 50, weight: 0.1, uses: 10 }
            ]
        };

        // Enhanced Spells Database with memorization requirements
        const spellsDB = {
            fire: [
                { id: 'flamedart', name: 'Flame Dart', level: 1, mp: 3, damage: '2d4+2', target: 'single', school: 'fire', aoe: 0, memorizeTime: 1, difficulty: 1 },
                { id: 'fireball', name: 'Fireball', level: 2, mp: 8, damage: '4d6+4', target: 'area', school: 'fire', aoe: 3, memorizeTime: 2, difficulty: 2 },
                { id: 'inferno', name: 'Inferno', level: 3, mp: 20, damage: '8d8+8', target: 'all', school: 'fire', aoe: 5, memorizeTime: 3, difficulty: 3 }
            ],
            water: [
                { id: 'heal', name: 'Heal', level: 1, mp: 4, effect: 'heal:10+wis', target: 'single', school: 'water', memorizeTime: 1, difficulty: 1 },
                { id: 'curepoison', name: 'Cure Poison', level: 2, mp: 6, effect: 'cure:poison', target: 'single', school: 'water', memorizeTime: 2, difficulty: 2 },
                { id: 'resurrection', name: 'Resurrection', level: 3, mp: 30, effect: 'revive', target: 'single', school: 'water', memorizeTime: 4, difficulty: 4 },
                { id: 'regeneration', name: 'Regeneration', level: 2, mp: 5, effect: 'regen:2', target: 'single', school: 'water', duration: 5, memorizeTime: 2, difficulty: 2 }
            ],
            air: [
                { id: 'lightning', name: 'Lightning Bolt', level: 1, mp: 5, damage: '3d6+3', target: 'single', school: 'air', chain: 2, memorizeTime: 1, difficulty: 1 },
                { id: 'teleport', name: 'Teleport', level: 2, mp: 10, effect: 'teleport', target: 'self', school: 'air', memorizeTime: 3, difficulty: 2 },
                { id: 'haste', name: 'Haste', level: 2, mp: 8, effect: 'haste', target: 'single', school: 'air', duration: 3, memorizeTime: 2, difficulty: 2 }
            ],
            earth: [
                { id: 'stonearmor', name: 'Stone Armor', level: 1, mp: 4, effect: 'ac:4', target: 'single', school: 'earth', duration: 10, memorizeTime: 1, difficulty: 1 },
                { id: 'earthquake', name: 'Earthquake', level: 3, mp: 25, damage: '6d6+6', target: 'all', school: 'earth', stun: 1, memorizeTime: 3, difficulty: 3 },
                { id: 'entangle', name: 'Entangle', level: 2, mp: 6, effect: 'entangle', target: 'area', school: 'earth', duration: 3, memorizeTime: 2, difficulty: 2 }
            ]
        };

        // Enhanced Enemies
        const enemiesDB = [
            { name: 'GOBLIN', hp: 10, attack: 4, ac: 2, xp: 25, gold: '1d10', glyph: 'G', abilities: ['berserk'], resist: [], weak: ['fire'], raceDialogue: { dwarven: 'Ugly goblin!', elven: 'Filthy creature!' } },
            { name: 'SKELETON', hp: 15, attack: 6, ac: 4, xp: 50, gold: '2d10', glyph: 'S', abilities: ['undead'], resist: ['piercing'], weak: ['blunt', 'holy'], raceDialogue: { cleric: 'Back to the grave!', human: 'By the Virtues!' } },
            { name: 'BRIGAND', hp: 20, attack: 8, ac: 3, xp: 75, gold: '3d10', glyph: 'B', abilities: ['steal'], resist: [], weak: [] },
            { name: 'WISP', hp: 8, attack: 5, ac: 1, xp: 20, gold: '1d6', glyph: 'W', abilities: ['dodge'], resist: ['magic'], weak: ['physical'], raceDialogue: { elven: 'Ancient spirit...', mage: 'Magic essence!' } },
            { name: 'ORC', hp: 25, attack: 10, ac: 5, xp: 100, gold: '5d10', glyph: 'O', abilities: ['tough'], resist: [], weak: [], raceDialogue: { dwarven: 'Orc scum!', fighter: 'Prepare to die!' } },
            { name: 'DRAGON', hp: 100, attack: 20, ac: 10, xp: 500, gold: '10d20', glyph: 'D', abilities: ['firebreath', 'fear'], resist: ['fire'], weak: ['ice'] },
            { name: 'ZOMBIE', hp: 18, attack: 7, ac: 3, xp: 40, gold: '2d8', glyph: 'Z', abilities: ['undead', 'poison'], resist: ['poison'], weak: ['fire', 'holy'] },
            { name: 'WRAITH', hp: 30, attack: 12, ac: 6, xp: 150, gold: '5d12', glyph: 'W', abilities: ['undead', 'lifeleech'], resist: ['physical'], weak: ['holy'] }
        ];

        // New Map Features
        const mapFeatures = {
            shrine: {
                glyph: '‚úù',
                color: 'shrine',
                effects: ['bless', 'heal', 'cure', 'identify'],
                requirements: { gold: 10, item: 'offering' },
                dialogue: {
                    human: 'The Virtues watch over you.',
                    elven: 'Ancient spirits bless this place.',
                    dwarven: 'Solid stone foundations.',
                    bobbit: 'A quiet, holy place.'
                }
            },
            ruins: {
                glyph: '‚åÇ',
                color: 'ruins',
                loot: ['artifacts', 'scrolls', 'gold'],
                encounters: ['ghosts', 'bandits', 'wild animals'],
                dialogue: {
                    human: 'Civilization lost to time.',
                    elven: 'Memories of the past linger.',
                    dwarven: 'Could be mined for stone.',
                    bobbit: 'Spooky old place.'
                }
            },
            bridge: {
                glyph: '‚ïê',
                color: 'bridge',
                passable: true,
                special: ['troll encounter', 'toll', 'ambush'],
                dialogue: {
                    human: 'A well-built bridge.',
                    elven: 'Graceful arches.',
                    dwarven: 'Fine stonework.',
                    bobbit: 'Crossing carefully...'
                }
            }
        };

        // Dungeons Data
        const dungeonsDB = {
            destard: {
                name: 'Destard',
                levels: 3,
                monsters: ['DRAGON', 'WYVERN', 'SKELETON'],
                treasure: 'Dragon Slayer Sword',
                entrance: { x: 7, y: 3 },
                special: 'dragons'
            },
            shame: {
                name: 'Shame',
                levels: 4,
                monsters: ['LICH', 'WRAITH', 'SPECTRE'],
                treasure: 'Orb of the Moons',
                entrance: { x: 2, y: 8 },
                special: 'undead'
            },
            deceit: {
                name: 'Deceit',
                levels: 3,
                monsters: ['ILLUSION', 'TRICKSTER', 'WISP'],
                treasure: 'Mirror of Truth',
                entrance: { x: 15, y: 5 },
                special: 'illusions'
            }
        };

        // Quests Data
        const questsDB = [
            {
                id: 'marks',
                name: 'The Marks of Virtue',
                description: 'Find the eight Marks of the Virtues hidden throughout Sosaria',
                type: 'main',
                reward: { xp: 1000, gold: 5000, item: 'Amulet of Exodus' },
                objectives: [
                    { id: 'compassion', description: 'Find Mark of Compassion in Britain', completed: false },
                    { id: 'honor', description: 'Find Mark of Honor in Trinsic', completed: false },
                    { id: 'sacrifice', description: 'Find Mark of Sacrifice in Moonglow', completed: false },
                    { id: 'valor', description: 'Find Mark of Valor in Jhelom', completed: false }
                ]
            },
            {
                id: 'goblins',
                name: 'Goblin Menace',
                description: 'Clear the goblin camp near Britain',
                type: 'side',
                reward: { xp: 250, gold: 500 },
                objectives: [
                    { id: 'killgoblins', description: 'Defeat 10 goblins', completed: false, count: 0, needed: 10 }
                ]
            },
            {
                id: 'dragons',
                name: 'Dragon Slayer',
                description: 'Slay the dragon in Destard',
                type: 'side',
                reward: { xp: 1000, gold: 2000, item: 'Dragon Scale Armor' },
                objectives: [
                    { id: 'slaydragon', description: 'Slay the Dragon of Destard', completed: false }
                ]
            }
        ];

        // Towns Data
        const townsDB = {
            britain: {
                name: 'Britain',
                shops: ['weaponshop', 'armorshop', 'magicshop', 'tavern', 'temple', 'castle'],
                x: 5,
                y: 5,
                special: 'Mark of Compassion'
            },
            moonglow: {
                name: 'Moonglow',
                shops: ['magicshop', 'library', 'observatory'],
                x: 8,
                y: 2,
                special: 'Mark of Sacrifice'
            },
            trinsic: {
                name: 'Trinsic',
                shops: ['weaponshop', 'armorshop', 'tavern', 'temple'],
                x: 3,
                y: 10,
                special: 'Mark of Honor'
            }
        };

        // ====================
        // ENHANCED SYSTEMS
        // ====================
        class InventorySystem {
            constructor() {
                this.maxWeight = 200;
                this.currentWeight = 0;
                this.items = [];
                this.selectedItem = null;
            }
            
            addItem(item) {
                // Create a copy of the item
                const itemCopy = {};
                for (let key in item) {
                    itemCopy[key] = item[key];
                }
                
                // Ensure required properties
                if (!itemCopy.uid) {
                    itemCopy.uid = 'item_' + Date.now() + '_' + Math.random();
                }
                if (!itemCopy.quantity) {
                    itemCopy.quantity = 1;
                }
                
                // Check weight
                const itemWeight = itemCopy.weight || 0;
                if (this.currentWeight + itemWeight > this.maxWeight) {
                    return { success: false, message: 'Too heavy to carry!' };
                }
                
                // Check for stackable items
                const isStackable = itemCopy.type === 'potion' || 
                                   itemCopy.type === 'food' || 
                                   itemCopy.type === 'key' || 
                                   itemCopy.type === 'torch';
                
                if (isStackable) {
                    const existing = this.items.find(i => 
                        i.id === itemCopy.id && 
                        i.type === itemCopy.type
                    );
                    
                    if (existing) {
                        existing.quantity = (existing.quantity || 1) + itemCopy.quantity;
                        this.currentWeight += itemWeight;
                        return { success: true, message: `Added ${itemCopy.name} to stack` };
                    }
                }
                
                // Add new item
                this.items.push(itemCopy);
                this.currentWeight += itemWeight;
                
                return { success: true, message: `Got ${itemCopy.name}` };
            }
                            
            removeItem(itemUid) {
                const index = this.items.findIndex(i => i.uid === itemUid);
                if (index > -1) {
                    const item = this.items[index];
                    
                    if (item.quantity > 1) {
                        item.quantity--;
                        this.currentWeight -= item.weight || 0;
                        return { ...item, quantity: 1 };
                    } else {
                        this.currentWeight -= item.weight || 0;
                        return this.items.splice(index, 1)[0];
                    }
                }
                return null;
            }
            
            getItem(itemUid) {
                return this.items.find(i => i.uid === itemUid);
            }
            
            useItem(itemUid, character, target = null) {
                const item = this.getItem(itemUid);
                if (!item) return { success: false, message: 'Item not found' };
                
                switch(item.type) {
                    case 'potion':
                        return this.usePotion(item, character);
                    case 'scroll':
                        return this.useScroll(item, character, target);
                    case 'food':
                        return this.useFood(item, character);
                    default:
                        return { success: false, message: 'Cannot use this item' };
                }
            }
            
            usePotion(potion, character) {
                const effect = potion.effect.split(':');
                switch(effect[0]) {
                    case 'heal':
                        const healAmount = parseInt(effect[1]) + (character.wis || 0);
                        const oldHp = character.hp;
                        character.hp = Math.min(character.maxHp, character.hp + healAmount);
                        const actualHeal = character.hp - oldHp;
                        this.removeItem(potion.uid);
                        return { 
                            success: true, 
                            message: `${character.name} healed for ${actualHeal} HP!`,
                            data: { heal: actualHeal }
                        };
                    case 'mp':
                        const mpAmount = parseInt(effect[1]);
                        character.mp = Math.min(character.maxMp, character.mp + mpAmount);
                        this.removeItem(potion.uid);
                        return { 
                            success: true, 
                            message: `${character.name} restored ${mpAmount} MP!`,
                            data: { mp: mpAmount }
                        };
                    case 'str':
                        const strBonus = parseInt(effect[1]);
                        character.tempStr = (character.tempStr || 0) + strBonus;
                        this.removeItem(potion.uid);
                        return { 
                            success: true, 
                            message: `${character.name} gains +${strBonus} Strength!`,
                            data: { str: strBonus }
                        };
                }
                return { success: false, message: 'Potion effect unknown' };
            }
            
            useScroll(scroll, caster, target) {
                const effect = scroll.effect.split(':');
                switch(effect[0]) {
                    case 'fireball':
                        const damageRoll = effect[1];
                        const damage = rollDice(damageRoll);
                        if (target) {
                            target.hp -= damage;
                            this.removeItem(scroll.uid);
                            return {
                                success: true,
                                message: `${caster.name} reads scroll: Fireball hits ${target.name} for ${damage} damage!`,
                                data: { damage: damage }
                            };
                        }
                        break;
                }
                this.removeItem(scroll.uid);
                return { success: false, message: 'Scroll effect unknown' };
            }
            
            useFood(food, character) {
                gameState.food += 10;
                this.removeItem(food.uid);
                return {
                    success: true,
                    message: `${character.name} eats rations. Food +10.`
                };
            }
            
            sort() {
                this.items.sort((a, b) => {
                    if (a.type !== b.type) return a.type.localeCompare(b.type);
                    if (a.name !== b.name) return a.name.localeCompare(b.name);
                    return 0;
                });
            }
            
            getWeight() {
                return this.currentWeight;
            }
            
            getCapacity() {
                return this.maxWeight;
            }
            
            findItemById(itemId) {
                return this.items.find(item => item.id === itemId);
            }
        }

        class MagicSystem {
            constructor() {
                this.spellsKnown = {};
                this.activeEffects = [];
                this.memorizedSpells = {};
            }
            
            learnSpell(character, spellId) {
                if (!character.spells) character.spells = [];
                if (!character.spells.includes(spellId)) {
                    character.spells.push(spellId);
                }
            }
            
            getSpell(spellId) {
                for (const school in spellsDB) {
                    const spell = spellsDB[school].find(s => s.id === spellId);
                    if (spell) return spell;
                }
                return null;
            }
            
            canCast(character, spell) {
                if (character.mp < spell.mp) return false;
                if (spell.level > (character.level || 1)) return false;
                
                // Check if spell is memorized for this character
                if (!this.isSpellMemorized(character, spell.id)) {
                    return false;
                }
                
                return true;
            }
            
            isSpellMemorized(character, spellId) {
                if (!this.memorizedSpells[character.name]) return false;
                return this.memorizedSpells[character.name].includes(spellId);
            }
            
            memorizeSpell(character, spellId) {
                if (!character.spells || !character.spells.includes(spellId)) {
                    return { success: false, message: 'Spell not known' };
                }
                
                if (!this.memorizedSpells[character.name]) {
                    this.memorizedSpells[character.name] = [];
                }
                
                const spell = this.getSpell(spellId);
                const maxSlots = this.getSpellSlots(character);
                const usedSlots = this.memorizedSpells[character.name].length;
                
                if (usedSlots >= maxSlots) {
                    return { success: false, message: 'No more spell slots available' };
                }
                
                if (!this.memorizedSpells[character.name].includes(spellId)) {
                    this.memorizedSpells[character.name].push(spellId);
                    return { 
                        success: true, 
                        message: `${spell.name} memorized (${usedSlots + 1}/${maxSlots})` 
                    };
                }
                
                return { success: false, message: 'Spell already memorized' };
            }
            
            forgetSpell(character, spellId) {
                if (!this.memorizedSpells[character.name]) return false;
                
                const index = this.memorizedSpells[character.name].indexOf(spellId);
                if (index > -1) {
                    this.memorizedSpells[character.name].splice(index, 1);
                    return true;
                }
                return false;
            }
            
            getSpellSlots(character) {
                const charClass = classes.find(c => c.id === character.classId);
                return charClass ? charClass.spellSlots + Math.floor(character.level / 2) : 0;
            }
            
            getMemorizedSpells(character) {
                return this.memorizedSpells[character.name] || [];
            }
            
            castSpell(caster, spellId, target) {
                const spell = this.getSpell(spellId);
                if (!spell) return { success: false, message: 'Spell not known' };
                
                if (!this.canCast(caster, spell)) {
                    return { success: false, message: 'Cannot cast this spell' };
                }
                
                caster.mp -= spell.mp;
                
                if (spell.damage) {
                    return this.castDamageSpell(caster, spell, target);
                } else if (spell.effect) {
                    return this.castEffectSpell(caster, spell, target);
                }
                
                return { success: false, message: 'Spell effect unknown' };
            }
            
            castDamageSpell(caster, spell, target) {
                let damage = this.calculateSpellDamage(spell, caster);
                
                // Check resistances/weaknesses
                if (target.resist && target.resist.includes(spell.school)) {
                    damage = Math.floor(damage / 2);
                }
                if (target.weak && target.weak.includes(spell.school)) {
                    damage = Math.floor(damage * 1.5);
                }
                
                target.currentHp -= damage;
                
                // Handle area effect
                if (spell.aoe > 0 && gameState.enemies.length > 1) {
                    const nearby = gameState.enemies.filter(e => 
                        e !== target && 
                        Math.abs(e.x - target.x) <= spell.aoe && 
                        Math.abs(e.y - target.y) <= spell.aoe
                    );
                    
                    nearby.forEach(enemy => {
                        const aoeDamage = Math.floor(damage * 0.7);
                        enemy.currentHp -= aoeDamage;
                        addLog(`${enemy.name} takes ${aoeDamage} splash damage!`, 'combat');
                    });
                }
                
                return {
                    success: true,
                    message: `${caster.name} casts ${spell.name} on ${target.name} for ${damage} damage!`,
                    damage: damage
                };
            }
            
            castEffectSpell(caster, spell, target) {
                const effect = spell.effect.split(':');
                switch(effect[0]) {
                    case 'heal':
                        const healBase = parseInt(effect[1]);
                        const healBonus = caster.wis || 0;
                        const healAmount = healBase + healBonus;
                        target.hp = Math.min(target.maxHp, target.hp + healAmount);
                        return {
                            success: true,
                            message: `${caster.name} casts ${spell.name} on ${target.name}, healing ${healAmount} HP!`,
                            heal: healAmount
                        };
                    case 'ac':
                        const acBonus = parseInt(effect[1]);
                        target.tempAc = (target.tempAc || 0) + acBonus;
                        this.activeEffects.push({
                            type: 'ac',
                            target: target,
                            bonus: acBonus,
                            duration: spell.duration || 10
                        });
                        return {
                            success: true,
                            message: `${caster.name} casts ${spell.name} on ${target.name}, AC +${acBonus}!`
                        };
                    case 'haste':
                        target.tempSpeed = (target.tempSpeed || 0) + 1;
                        this.activeEffects.push({
                            type: 'haste',
                            target: target,
                            bonus: 1,
                            duration: spell.duration || 3
                        });
                        return {
                            success: true,
                            message: `${caster.name} casts ${spell.name} on ${target.name}, haste active!`
                        };
                }
                return { success: false, message: 'Spell effect unknown' };
            }
            
            calculateSpellDamage(spell, caster) {
                const dice = spell.damage.split('d');
                const rolls = parseInt(dice[0].replace(/\+/g, '').replace(/\-/g, ''));
                const sides = parseInt(dice[1].replace(/\+/g, '').replace(/\-/g, ''));
                
                let total = 0;
                for (let i = 0; i < rolls; i++) {
                    total += Math.floor(Math.random() * sides) + 1;
                }
                
                // Intelligence bonus
                total += Math.floor(caster.int / 3);
                
                return Math.max(1, total);
            }
            
            updateEffects() {
                for (let i = this.activeEffects.length - 1; i >= 0; i--) {
                    const effect = this.activeEffects[i];
                    effect.duration--;
                    
                    if (effect.duration <= 0) {
                        switch(effect.type) {
                            case 'ac':
                                effect.target.tempAc = (effect.target.tempAc || 0) - effect.bonus;
                                break;
                            case 'haste':
                                effect.target.tempSpeed = (effect.target.tempSpeed || 0) - effect.bonus;
                                break;
                        }
                        this.activeEffects.splice(i, 1);
                    }
                }
            }
        }

        class CombatSystem {
            constructor() {
                this.turnOrder = [];
                this.currentTurn = 0;
                this.combatants = [];
            }
            
            startCombat(party, enemies) {
                // Apply racial combat bonuses
                party.forEach(char => {
                    const race = races.find(r => r.id === char.raceId);
                    if (race && race.combatBonus) {
                        char.combatBonus = char.combatBonus || {};
                        Object.assign(char.combatBonus, race.combatBonus);
                    }
                });
                
                this.combatants = [
                    ...party.map((char, i) => ({ 
                        type: 'party', 
                        index: i, 
                        character: char,
                        initiative: this.calculateInitiative(char)
                    })),
                    ...enemies.map((enemy, i) => ({
                        type: 'enemy',
                        index: i,
                        character: enemy,
                        initiative: this.calculateInitiative(enemy)
                    }))
                ];
                
                // Sort by initiative
                this.combatants.sort((a, b) => b.initiative - a.initiative);
                this.turnOrder = this.combatants;
                this.currentTurn = 0;
                
                return this.turnOrder;
            }
            
            calculateInitiative(character) {
                let initiative = character.dex || 10;
                
                // Racial bonuses
                if (character.raceId === 'elven') initiative += 2;
                if (character.raceId === 'bobbit') initiative += 1;
                
                // Class bonuses
                if (character.classId === 'thief') initiative += 3;
                if (character.classId === 'fighter') initiative += 1;
                
                // Random element
                initiative += Math.floor(Math.random() * 10);
                
                return initiative;
            }
            
            nextTurn() {
                this.currentTurn = (this.currentTurn + 1) % this.turnOrder.length;
                return this.turnOrder[this.currentTurn];
            }
            
            getCurrentCombatant() {
                return this.turnOrder[this.currentTurn];
            }
            
            isPartyTurn() {
                const current = this.getCurrentCombatant();
                return current && current.type === 'party';
            }
            
            removeCombatant(type, index) {
                const idx = this.turnOrder.findIndex(c => c.type === type && c.index === index);
                if (idx > -1) {
                    this.turnOrder.splice(idx, 1);
                    if (this.currentTurn >= idx && this.currentTurn > 0) {
                        this.currentTurn--;
                    }
                }
            }
            
            calculateDamage(attacker, defender, isCritical = false) {
                let baseDamage = 1;
                let hitChance = 75;
                
                // Apply racial hit bonus
                if (attacker.raceId) {
                    const race = races.find(r => r.id === attacker.raceId);
                    if (race && race.combatBonus) {
                        hitChance += race.combatBonus.hit || 0;
                        baseDamage += race.combatBonus.damage || 0;
                    }
                }
                
                // Weapon damage
                if (attacker.equipment?.weapon) {
                    const weapon = attacker.equipment.weapon;
                    const dice = weapon.damage.split('d');
                    const rolls = parseInt(dice[0]);
                    const sides = parseInt(dice[1]);
                    
                    for (let i = 0; i < rolls; i++) {
                        baseDamage += Math.floor(Math.random() * sides) + 1;
                    }
                    
                    // Weapon bonus
                    baseDamage += weapon.bonus || 0;
                    
                    // Dwarf axe bonus
                    if (attacker.raceId === 'dwarven' && weapon.id.includes('axe')) {
                        baseDamage += 2;
                    }
                }
                
                // Strength bonus with racial adjustments
                const strBonus = Math.floor((attacker.str - 10) / 2);
                baseDamage += strBonus;
                
                // Class bonuses
                if (attacker.classId === 'fighter') {
                    baseDamage += 2;
                    hitChance += 5;
                }
                
                // Racial critical bonus
                let criticalChance = 0;
                if (attacker.raceId === 'bobbit') criticalChance += 10;
                if (attacker.raceId === 'human') criticalChance += 5;
                
                // Check for critical
                if (isCritical) {
                    baseDamage *= 2;
                } else if (Math.random() * 100 < criticalChance) {
                    baseDamage *= 1.5;
                    addLog(`${attacker.name} gets a racial critical hit!`, 'combat');
                }
                
                // Defender armor with racial dodge
                const defenderAC = defender.ac + (defender.tempAc || 0);
                let damageReduction = defenderAC * 0.5;
                
                // Racial dodge
                if (defender.raceId === 'elven' || defender.raceId === 'bobbit') {
                    damageReduction *= 0.8; // 20% less effective against agile races
                }
                
                baseDamage = Math.max(1, baseDamage - damageReduction);
                
                return {
                    damage: Math.floor(baseDamage),
                    hitChance: hitChance
                };
            }
            
            calculateHit(attacker, defender) {
                let hitChance = 75;
                
                // Dex bonus
                hitChance += (attacker.dex - 10);
                
                // Racial accuracy bonus
                if (attacker.raceId === 'elven') hitChance += 5;
                
                // Defender AC penalty
                const defenderAC = defender.ac + (defender.tempAc || 0);
                hitChance -= defenderAC * 5;
                
                // Racial dodge bonus
                if (defender.raceId === 'elven') hitChance -= 5;
                if (defender.raceId === 'bobbit') hitChance -= 10;
                
                const roll = Math.random() * 100;
                
                // Check for critical (natural 95-100)
                if (roll >= 95) return { hit: true, critical: true };
                
                // Racial lucky critical for bobbits
                if (attacker.raceId === 'bobbit' && roll >= 90) {
                    return { hit: true, critical: true };
                }
                
                return { 
                    hit: roll < hitChance, 
                    critical: false 
                };
            }
        }

        class QuestSystem {
            constructor() {
                this.quests = [];
            }
            
            addQuest(questId) {
                const questTemplate = questsDB.find(q => q.id === questId);
                if (!questTemplate) return;
                
                const quest = {
                    ...questTemplate,
                    objectives: questTemplate.objectives.map(obj => ({ ...obj })),
                    started: new Date(),
                    completed: false
                };
                
                this.quests.push(quest);
                return quest;
            }
            
            updateQuest(questId, objectiveId, data = {}) {
                const quest = this.quests.find(q => q.id === questId);
                if (!quest) return;
                
                const objective = quest.objectives.find(obj => obj.id === objectiveId);
                if (objective) {
                    if (objective.count !== undefined) {
                        objective.count = (objective.count || 0) + (data.amount || 1);
                        objective.completed = objective.count >= objective.needed;
                    } else {
                        objective.completed = true;
                    }
                    
                    // Check if all objectives completed
                    quest.completed = quest.objectives.every(obj => obj.completed);
                    
                    if (quest.completed) {
                        this.completeQuest(questId);
                    }
                }
            }
            
            completeQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (!quest) return;
                
                quest.completed = true;
                this.grantReward(quest);
                
                addLog(`Quest "${quest.name}" completed!`, 'explore');
                showNotification(`Quest Completed: ${quest.name}`);
            }
            
            grantReward(quest) {
                if (quest.reward) {
                    if (quest.reward.xp) {
                        gameState.party.forEach(char => {
                            char.xp = (char.xp || 0) + quest.reward.xp;
                            checkLevelUp(char);
                        });
                    }
                    
                    if (quest.reward.gold) {
                        gameState.gold += quest.reward.gold;
                    }
                    
                    if (quest.reward.item) {
                        inventorySystem.addItem({ name: quest.reward.item, type: 'artifact' });
                    }
                }
            }
            
            getActiveQuests() {
                return this.quests.filter(q => !q.completed);
            }
        }

        // Initialize systems
        const inventorySystem = new InventorySystem();
        const magicSystem = new MagicSystem();
        const combatSystem = new CombatSystem();
        const questSystem = new QuestSystem();
        let dungeonSystem = null;

        // ====================
        // UTILITY FUNCTIONS
        // ====================
        function rollDice(diceString) {
            const match = diceString.match(/(\d+)d(\d+)([+-]\d+)?/);
            if (!match) return 0;
            
            const rolls = parseInt(match[1]);
            const sides = parseInt(match[2]);
            const modifier = match[3] ? parseInt(match[3]) : 0;
            
            let total = 0;
            for (let i = 0; i < rolls; i++) {
                total += Math.floor(Math.random() * sides) + 1;
            }
            
            return total + modifier;
        }

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // ====================
        // GAME INITIALIZATION
        // ====================
        function initGame() {
            generateWorldMap();
            renderPartyCreation();
            setupEventListeners();
            
            // Clear inventory first
            inventorySystem.items = [];
            
            // Add starting items with proper structure
            const startingItems = [
                {...itemsDB.weapons[0], uid: 'start_weapon_1'},
                {...itemsDB.potions[0], uid: 'start_potion_1'},
                {...itemsDB.misc[1], uid: 'start_torch_1'},
                {...itemsDB.misc[2], quantity: 5, uid: 'start_rations_1'}
            ];
            
            startingItems.forEach(item => {
                inventorySystem.addItem(item);
            });
            
            // Add starting quest
            questSystem.addQuest('goblins');
            
            updateDisplay();
        }

        function generateWorldMap() {
            const terrainTypes = ['forest', 'forest', 'plains', 'plains', 'mountain', 'water', 'town', 'dungeon', 'castle', 'moongate', 'shrine', 'ruins', 'bridge'];
            gameState.worldMap = [];
            
            for (let y = 0; y < 20; y++) {
                const row = [];
                for (let x = 0; x < 20; x++) {
                    let type = 'plains';
                    
                    // Create interesting geography with new features
                    if (x === 5 && y === 5) type = 'town';
                    else if (x === 7 && y === 3) type = 'dungeon';
                    else if (x === 2 && y === 8) type = 'dungeon';
                    else if (x === 15 && y === 5) type = 'dungeon';
                    else if (x === 10 && y === 10) type = 'castle';
                    else if (x === 15 && y === 15) type = 'moongate';
                    else if (x === 8 && y === 2) type = 'town';
                    else if (x === 3 && y === 10) type = 'town';
                    else if (x > 12 && y > 12) type = 'water';
                    else if (x < 4 && y < 4) type = 'mountain';
                    else if (x + y < 10) type = 'forest';
                    else {
                        // Add new features
                        const rand = Math.random();
                        if (rand < 0.02) type = 'shrine';
                        else if (rand < 0.04) type = 'ruins';
                        else if (rand < 0.06 && (x > 0 && x < 19)) type = 'bridge';
                        else type = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
                    }
                    
                    row.push({ 
                        type, 
                        explored: false,
                        special: null,
                        encounterRate: type === 'forest' ? 0.4 : type === 'plains' ? 0.2 : 0.1,
                        featureData: type === 'shrine' ? { used: false, blessing: 'unused' } : 
                                     type === 'ruins' ? { looted: false, danger: Math.random() > 0.5 } : 
                                     type === 'bridge' ? { toll: Math.random() > 0.7, amount: getRandomInt(5, 50) } : null
                    });
                }
                gameState.worldMap.push(row);
            }
            
            gameState.worldMap[5][5].explored = true;
        }

        // ====================
        // PARTY CREATION
        // ====================
        function renderPartyCreation() {
            const container = document.getElementById('party-creation');
            container.innerHTML = '';
            
            for (let i = 0; i < 4; i++) {
                const char = gameState.party[i] || { classId: '', raceId: '', name: `Hero ${i + 1}` };
                const charClass = classes.find(c => c.id === char.classId);
                const charRace = races.find(r => r.id === char.raceId);
                
                container.innerHTML += `
                    <div class="character-card">
                        <strong>CHARACTER ${i + 1}</strong>
                        <div>
                            <input type="text" id="name-${i}" value="${char.name}" 
                                   onchange="updatePartyMember(${i}, 'name', this.value)" 
                                   placeholder="Name" style="width: 150px; margin: 5px 0;">
                        </div>
                        <div>
                            <label>CLASS:</label>
                            <select id="class-${i}" onchange="updatePartyMember(${i}, 'class', this.value)">
                                <option value="">--Choose--</option>
                                ${classes.map(c => 
                                    `<option value="${c.id}" ${char.classId === c.id ? 'selected' : ''}>
                                        ${c.name}
                                    </option>`
                                ).join('')}
                            </select>
                        </div>
                        <div>
                            <label>RACE:</label>
                            <select id="race-${i}" onchange="updatePartyMember(${i}, 'race', this.value)">
                                <option value="">--Choose--</option>
                                ${races.map(r => 
                                    `<option value="${r.id}" ${char.raceId === r.id ? 'selected' : ''}>
                                        ${r.name} (${r.ability})
                                    </option>`
                                ).join('')}
                            </select>
                        </div>
                        ${charClass ? `
                            <div class="${charClass.color}">
                                HP: ${charClass.hp} | MP: ${charClass.mp}<br>
                                STR: ${charClass.str} | DEX: ${charClass.dex}<br>
                                INT: ${charClass.int} | WIS: ${charClass.wis}<br>
                                Spell Slots: ${charClass.spellSlots}
                            </div>
                        ` : ''}
                        ${charRace ? `
                            <div style="color:#6af; font-size:10px; margin-top:5px;">
                                ${charRace.ability}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
        }

        function updatePartyMember(index, field, value) {
            if (!gameState.party[index]) {
                gameState.party[index] = { 
                    name: `Hero ${index + 1}`,
                    classId: '',
                    raceId: '',
                    hp: 0,
                    maxHp: 0,
                    mp: 0,
                    maxMp: 0,
                    xp: 0,
                    level: 1,
                    equipment: {},
                    spells: [],
                    tempAc: 0,
                    tempStr: 0,
                    tempSpeed: 0,
                    memorizedSpells: []
                };
            }
            
            gameState.party[index][field === 'name' ? 'name' : field + 'Id'] = value;
            
            if (field === 'class' || field === 'race') {
                const charClass = classes.find(c => c.id === gameState.party[index].classId);
                const charRace = races.find(r => r.id === gameState.party[index].raceId);
                
                if (charClass) {
                    gameState.party[index].hp = charClass.hp;
                    gameState.party[index].maxHp = charClass.hp;
                    gameState.party[index].mp = charClass.mp;
                    gameState.party[index].maxMp = charClass.mp;
                    gameState.party[index].str = charClass.str;
                    gameState.party[index].dex = charClass.dex;
                    gameState.party[index].int = charClass.int;
                    gameState.party[index].wis = charClass.wis;
                    gameState.party[index].ac = charClass.ac;
                    gameState.party[index].combatBonus = charClass.combatBonus;
                    gameState.party[index].spellSlots = charClass.spellSlots;
                }
                
                if (charRace && charRace.bonuses) {
                    Object.entries(charRace.bonuses).forEach(([stat, bonus]) => {
                        gameState.party[index][stat] += bonus;
                    });
                }
            }
            
            renderPartyCreation();
            addLog(`Character ${index + 1} updated.`, 'creation');
        }

        function resetParty() {
            gameState.party = [];
            renderPartyCreation();
            addLog('Party reset. Choose your four adventurers.', 'creation');
        }

        function startGame() {
            if (gameState.party.length < 4 || gameState.party.some(p => !p.classId || !p.raceId)) {
                addLog('You must create four complete characters!', 'creation');
                return;
            }
            
            // Initialize character stats fully
            gameState.party.forEach((char, index) => {
                char.hp = char.maxHp;
                char.mp = char.maxMp;
                char.xp = 0;
                char.level = 1;
                char.equipment = {};
                char.inventory = [];
                char.spells = [];
                char.position = index;
                char.memorizedSpells = [];
                
                // Give starting spells to magic users
                if (char.classId === 'mage') {
                    magicSystem.learnSpell(char, 'flamedart');
                    magicSystem.learnSpell(char, 'lightning');
                    // Auto-memorize starting spells
                    magicSystem.memorizeSpell(char, 'flamedart');
                } else if (char.classId === 'cleric') {
                    magicSystem.learnSpell(char, 'heal');
                    magicSystem.learnSpell(char, 'curepoison');
                    magicSystem.memorizeSpell(char, 'heal');
                }
            });
            
            switchView('explore');
            renderWorldMap();
            updatePartyStatus();
            updateMinimap();
            
            addLog('Your party begins the quest to defeat Exodus!', 'explore');
            addLog('Find the eight Marks of Virtue to gain entry to the final dungeon.', 'explore');
            
            // Show race-specific starting message
            const racesInParty = [...new Set(gameState.party.map(p => p.raceId))];
            racesInParty.forEach(raceId => {
                const race = races.find(r => r.id === raceId);
                if (race && race.dialogue) {
                    addLog(race.dialogue[0], 'explore');
                }
            });
        }

        // ====================
        // ENHANCED COMBAT SYSTEM
        // ====================
        function startRandomCombat() {
            const tile = gameState.worldMap[gameState.location.y][gameState.location.x];
            const numEnemies = Math.floor(Math.random() * 4) + 2;
            gameState.enemies = [];
            
            // Weighted enemy selection based on location
            let availableEnemies = [...enemiesDB];
            if (tile.type === 'forest') {
                availableEnemies = enemiesDB.filter(e => ['GOBLIN', 'WISP', 'ORC'].includes(e.name));
            } else if (tile.type === 'dungeon') {
                availableEnemies = enemiesDB.filter(e => ['SKELETON', 'ZOMBIE', 'WRAITH'].includes(e.name));
            }
            
            for (let i = 0; i < numEnemies; i++) {
                const enemyType = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
                gameState.enemies.push({
                    ...enemyType,
                    id: i,
                    x: Math.floor(Math.random() * 5) + 1,
                    y: Math.floor(Math.random() * 3),
                    maxHp: enemyType.hp,
                    currentHp: enemyType.hp,
                    dex: enemyType.dex || 10,
                    ac: enemyType.ac,
                    resist: enemyType.resist || [],
                    weak: enemyType.weak || [],
                    abilities: enemyType.abilities || []
                });
            }
            
            gameState.inCombat = true;
            gameState.combatTurn = 0;
            gameState.combatSelectedChar = 0;
            gameState.combatSelectedTarget = null;
            gameState.combatRound = 1;
            
            // Initialize combat system
            combatSystem.startCombat(gameState.party, gameState.enemies);
            
            switchView('combat');
            renderCombatGrid();
            updateCombatUI();
            
            // Race-specific combat dialogue
            const firstChar = gameState.party[0];
            const firstEnemy = gameState.enemies[0];
            if (firstChar && firstEnemy && firstEnemy.raceDialogue) {
                const raceDialogue = firstEnemy.raceDialogue[firstChar.raceId] || 
                                   firstEnemy.raceDialogue[firstChar.classId];
                if (raceDialogue) {
                    addLog(`${firstChar.name}: "${raceDialogue}"`, 'combat');
                }
            }
            
            addLog(`Ambushed by ${numEnemies} monsters!`, 'combat');
            updateCombatStatus();
        }

        function startDungeonCombat() {
            const dungeonMonsters = dungeonSystem.dungeon.monsters;
            const numEnemies = Math.floor(Math.random() * 3) + 1;
            gameState.enemies = [];
            
            for (let i = 0; i < numEnemies; i++) {
                const enemyType = dungeonMonsters[Math.floor(Math.random() * dungeonMonsters.length)];
                const enemy = enemiesDB.find(e => e.name === enemyType) || enemiesDB[0];
                
                gameState.enemies.push({
                    ...enemy,
                    id: i,
                    x: Math.floor(Math.random() * 5) + 1,
                    y: Math.floor(Math.random() * 3),
                    maxHp: enemy.hp + (dungeonSystem.currentLevel * 5),
                    currentHp: enemy.hp + (dungeonSystem.currentLevel * 5),
                    dex: enemy.dex || 10,
                    ac: enemy.ac + Math.floor(dungeonSystem.currentLevel / 2),
                    attack: enemy.attack + Math.floor(dungeonSystem.currentLevel / 2),
                    resist: enemy.resist || [],
                    weak: enemy.weak || [],
                    abilities: enemy.abilities || []
                });
            }
            
            gameState.inCombat = true;
            gameState.combatTurn = 0;
            gameState.combatSelectedChar = 0;
            gameState.combatSelectedTarget = null;
            gameState.combatRound = 1;
            
            combatSystem.startCombat(gameState.party, gameState.enemies);
            
            switchView('combat');
            renderCombatGrid();
            updateCombatUI();
            
            addLog(`A ${gameState.enemies[0].name} attacks!`, 'combat');
            updateCombatStatus();
        }

        function renderCombatGrid() {
            const grid = document.getElementById('combat-grid');
            grid.innerHTML = '';
            
            // Create 8x8 grid
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'combat-cell';
                    cell.id = `combat-${x}-${y}`;
                    cell.onclick = () => selectCombatTarget(x, y);
                    
                    // Add terrain
                    if (x < 3 && y < 3) {
                        cell.style.backgroundColor = '#633';
                    } else if (x > 5 && y > 5) {
                        cell.style.backgroundColor = '#336';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            // Place party (bottom rows)
            gameState.party.forEach((char, i) => {
                const row = Math.floor(i / 2) + 6;
                const col = (i % 2) * 2 + 3;
                const cell = document.getElementById(`combat-${col}-${row}`);
                if (cell) {
                    cell.textContent = (i + 1).toString();
                    cell.classList.add('party');
                    
                    // Add race/class info to tooltip
                    const race = races.find(r => r.id === char.raceId);
                    const charClass = classes.find(c => c.id === char.classId);
                    let tooltip = `${char.name}\n`;
                    tooltip += `Race: ${race?.name || 'Unknown'}\n`;
                    tooltip += `Class: ${charClass?.name || 'Unknown'}\n`;
                    tooltip += `HP: ${char.hp}/${char.maxHp}\n`;
                    tooltip += `MP: ${char.mp}/${char.maxMp}`;
                    cell.title = tooltip;
                    
                    // Highlight current character's turn
                    if (i === gameState.combatSelectedChar) {
                        cell.classList.add('combat-turn-indicator');
                    }
                }
            });
            
            // Place enemies
            gameState.enemies.forEach(enemy => {
                const cell = document.getElementById(`combat-${enemy.x}-${enemy.y}`);
                if (cell) {
                    cell.textContent = enemy.glyph;
                    cell.classList.add('enemy');
                    cell.title = `${enemy.name}\nHP: ${enemy.currentHp}/${enemy.maxHp}\nAC: ${enemy.ac}`;
                    
                    // Highlight selected target
                    if (gameState.combatSelectedTarget && gameState.combatSelectedTarget.id === enemy.id) {
                        cell.classList.add('combat-target');
                    }
                }
            });
        }

        function selectCombatTarget(x, y) {
            // Check for enemy click
            const enemy = gameState.enemies.find(e => e.x === x && e.y === y);
            if (enemy) {
                gameState.combatSelectedTarget = enemy;
                document.getElementById('target-name').textContent = enemy.name;
                addLog(`Selected ${enemy.name} as target.`, 'combat');
                renderCombatGrid();
                return;
            }
            
            // Check for party member click (for healing spells/items)
            for (let i = 0; i < gameState.party.length; i++) {
                const row = Math.floor(i / 2) + 6;
                const col = (i % 2) * 2 + 3;
                if (col === x && row === y) {
                    gameState.combatSelectedTarget = gameState.party[i];
                    document.getElementById('target-name').textContent = gameState.party[i].name;
                    addLog(`Selected ${gameState.party[i].name} as target.`, 'combat');
                    renderCombatGrid();
                    return;
                }
            }
        }

        function setCombatAction(action) {
            gameState.combatAction = action;
            document.getElementById('current-action').textContent = action.toUpperCase();
            
            // Show/hide selectors
            document.getElementById('spell-selector').style.display = action === 'spell' ? 'block' : 'none';
            document.getElementById('item-selector').style.display = action === 'item' ? 'block' : 'none';
            
            // Update action buttons
            ['attack', 'spell', 'item', 'defend', 'flee'].forEach(act => {
                document.getElementById(`btn-${act}`).style.backgroundColor = 
                    act === action ? '#444' : '#222';
            });
            
            if (action === 'spell') {
                renderCombatSpells();
            } else if (action === 'item') {
                renderCombatItems();
            }
            
            addLog(`Action set to: ${action}`, 'combat');
        }

        function setCombatCharacter(index) {
            if (index >= 0 && index < gameState.party.length) {
                gameState.combatSelectedChar = index;
                document.getElementById('selected-combat-char').textContent = gameState.party[index].name;
                renderCombatGrid();
                updateCombatUI();
            }
        }

        function executeCombatAction() {
            const character = gameState.party[gameState.combatSelectedChar];
            
            if (!character) {
                addLog('No character selected!', 'combat');
                return;
            }
            
            if (character.hp <= 0) {
                addLog(`${character.name} is unconscious!`, 'combat');
                return;
            }
            
            switch(gameState.combatAction) {
                case 'attack':
                    performAttack(character);
                    break;
                case 'spell':
                    performSpell(character);
                    break;
                case 'item':
                    performItemUse(character);
                    break;
                case 'defend':
                    performDefend(character);
                    break;
                case 'flee':
                    performFlee();
                    break;
            }
        }

        function performAttack(attacker) {
            if (!gameState.combatSelectedTarget || !gameState.combatSelectedTarget.currentHp) {
                addLog('Select a target first!', 'combat');
                return;
            }
            
            const target = gameState.combatSelectedTarget;
            const hitResult = combatSystem.calculateHit(attacker, target);
            
            if (hitResult.hit) {
                const damageResult = combatSystem.calculateDamage(attacker, target, hitResult.critical);
                const damage = damageResult.damage;
                
                target.currentHp -= damage;
                
                let message = `${attacker.name} hits ${target.name} for ${damage} damage`;
                if (hitResult.critical) {
                    message += ' (CRITICAL!)';
                }
                message += '!';
                
                addLog(message, 'combat');
                
                // Check for death
                if (target.currentHp <= 0) {
                    addLog(`${target.name} is defeated!`, 'combat');
                    
                    // Grant XP and gold with racial bonuses
                    let xp = target.xp || 25;
                    let goldRoll = target.gold || '1d10';
                    let gold = rollDice(goldRoll);
                    
                    // Human XP bonus
                    if (attacker.raceId === 'human') {
                        xp = Math.floor(xp * 1.1);
                    }
                    
                    // Bobbit gold bonus
                    if (attacker.raceId === 'bobbit') {
                        gold = Math.floor(gold * 1.2);
                    }
                    
                    attacker.xp += xp;
                    gameState.gold += gold;
                    
                    addLog(`Gained ${xp} XP and ${gold} gold!`, 'combat');
                    
                    // Remove enemy
                    const enemyIndex = gameState.enemies.findIndex(e => e.id === target.id);
                    if (enemyIndex > -1) {
                        gameState.enemies.splice(enemyIndex, 1);
                        combatSystem.removeCombatant('enemy', enemyIndex);
                    }
                    
                    // Update quest if killing goblins
                    if (target.name === 'GOBLIN') {
                        questSystem.updateQuest('goblins', 'killgoblins', { amount: 1 });
                    }
                    
                    if (gameState.enemies.length === 0) {
                        endCombat(true);
                        return;
                    }
                }
            } else {
                addLog(`${attacker.name} misses ${target.name}!`, 'combat');
            }
            
            // Move to next turn
            nextCombatTurn();
        }

        function performSpell(caster) {
            if (!gameState.combatSelectedSpell) {
                addLog('Select a spell first!', 'combat');
                return;
            }
            
            const spell = magicSystem.getSpell(gameState.combatSelectedSpell);
            if (!spell) return;
            
            if (!magicSystem.isSpellMemorized(caster, spell.id)) {
                addLog('Spell not memorized!', 'combat');
                return;
            }
            
            if (caster.mp < spell.mp) {
                addLog('Not enough MP!', 'combat');
                return;
            }
            
            let target = gameState.combatSelectedTarget;
            if (!target && spell.target !== 'self') {
                addLog('Select a target first!', 'combat');
                return;
            }
            
            // Default to caster for self-target spells
            if (!target && spell.target === 'self') {
                target = caster;
            }
            
            const result = magicSystem.castSpell(caster, spell.id, target);
            if (result.success) {
                addLog(result.message, 'combat');
                
                // Handle damage spells
                if (result.damage && target.currentHp <= 0) {
                    // Remove dead enemy
                    const enemyIndex = gameState.enemies.findIndex(e => e.id === target.id);
                    if (enemyIndex > -1) {
                        gameState.enemies.splice(enemyIndex, 1);
                        combatSystem.removeCombatant('enemy', enemyIndex);
                    }
                    
                    if (gameState.enemies.length === 0) {
                        endCombat(true);
                        return;
                    }
                }
                
                // Clear selected spell
                gameState.combatSelectedSpell = null;
            } else {
                addLog(result.message, 'combat');
            }
            
            nextCombatTurn();
        }

        function performItemUse(user) {
            if (!gameState.combatSelectedItem) {
                addLog('Select an item first!', 'combat');
                return;
            }
            
            const item = inventorySystem.getItem(gameState.combatSelectedItem);
            if (!item) return;
            
            let target = gameState.combatSelectedTarget;
            if (!target && item.type === 'potion' && item.effect.startsWith('heal')) {
                // Default to user for healing potions
                target = user;
                gameState.combatSelectedTarget = user;
            }
            
            if (!target) {
                addLog('Select a target first!', 'combat');
                return;
            }
            
            const result = inventorySystem.useItem(item.uid, target);
            if (result.success) {
                addLog(result.message, 'combat');
                
                // Clear selected item
                gameState.combatSelectedItem = null;
                document.getElementById('item-selector').style.display = 'none';
            } else {
                addLog(result.message, 'combat');
            }
            
            nextCombatTurn();
        }

        function performDefend(defender) {
            defender.tempAc = (defender.tempAc || 0) + 4;
            addLog(`${defender.name} takes defensive stance! AC +4`, 'combat');
            
            // Add temporary effect
            magicSystem.activeEffects.push({
                type: 'ac',
                target: defender,
                bonus: 4,
                duration: 1
            });
            
            nextCombatTurn();
        }

        function performFlee() {
            // Racial flee bonuses
            let fleeChance = 60;
            gameState.party.forEach(char => {
                fleeChance += char.dex;
                if (char.raceId === 'elven') fleeChance += 10;
                if (char.raceId === 'bobbit') fleeChance += 15;
            });
            
            fleeChance -= gameState.enemies.length * 10;
            
            const roll = Math.random() * 100;
            
            if (roll < fleeChance) {
                addLog('Your party escapes!', 'combat');
                endCombat(false);
            } else {
                addLog('Failed to escape!', 'combat');
                nextCombatTurn();
            }
        }

        function nextCombatTurn() {
            // Update effects
            magicSystem.updateEffects();
            
            // Move to next party member or start enemy turn
            gameState.combatSelectedChar = (gameState.combatSelectedChar + 1) % gameState.party.length;
            
            // Check if all party members have acted
            if (gameState.combatSelectedChar === 0) {
                // Enemy turn
                performEnemyTurn();
                gameState.combatRound++;
            }
            
            // Update UI
            updateCombatUI();
            renderCombatGrid();
            updateCombatStatus();
        }

        function performEnemyTurn() {
            addLog('--- Enemy Turn ---', 'combat');
            
            gameState.enemies.forEach((enemy, index) => {
                if (enemy.currentHp <= 0) return;
                
                // Choose target
                const aliveParty = gameState.party.filter(p => p.hp > 0);
                if (aliveParty.length === 0) return;
                
                const target = aliveParty[Math.floor(Math.random() * aliveParty.length)];
                
                // Calculate hit
                const hitResult = combatSystem.calculateHit(enemy, target);
                
                if (hitResult.hit) {
                    const damage = Math.floor(Math.random() * enemy.attack) + 1;
                    
                    // Apply AC reduction with racial considerations
                    let effectiveAC = target.ac + (target.tempAc || 0);
                    
                    // Elven magic resistance
                    if (target.raceId === 'elven' && enemy.abilities && enemy.abilities.includes('magic')) {
                        effectiveAC += 2;
                    }
                    
                    const reducedDamage = Math.max(1, damage - Math.floor(effectiveAC / 2));
                    
                    target.hp -= reducedDamage;
                    
                    let message = `${enemy.name} hits ${target.name} for ${reducedDamage} damage`;
                    if (hitResult.critical) {
                        message += ' (CRITICAL!)';
                    }
                    message += '!';
                    
                    addLog(message, 'combat');
                    
                    if (target.hp <= 0) {
                        addLog(`${target.name} has been defeated!`, 'combat');
                        
                        // Check for party wipe
                        if (gameState.party.every(p => p.hp <= 0)) {
                            addLog('Your party has been defeated...', 'combat');
                            setTimeout(() => {
                                alert('GAME OVER');
                                resetGame();
                            }, 2000);
                        }
                    }
                } else {
                    addLog(`${enemy.name} misses ${target.name}!`, 'combat');
                }
                
                // Special abilities
                if (enemy.abilities && enemy.abilities.includes('poison') && Math.random() < 0.3) {
                    // Dwarf poison resistance
                    if (target.raceId === 'dwarven' && Math.random() > 0.5) {
                        addLog(`${target.name} resists the poison!`, 'combat');
                    } else {
                        addLog(`${target.name} has been poisoned!`, 'combat');
                        target.poisoned = true;
                    }
                }
            });
            
            addLog('--- End Enemy Turn ---', 'combat');
        }

        function updateCombatUI() {
            const char = gameState.party[gameState.combatSelectedChar];
            if (char) {
                const race = races.find(r => r.id === char.raceId);
                document.getElementById('selected-combat-char').textContent = 
                    `${char.name} (${race?.name || ''} ${char.classId?.toUpperCase() || ''})`;
            }
            
            // Update turn indicator
            const turnText = gameState.combatSelectedChar === 0 && gameState.combatRound > 1 ? 
                `Round ${gameState.combatRound}` : 
                `${gameState.party[gameState.combatSelectedChar]?.name}'s Turn`;
            document.getElementById('combat-turn-indicator').textContent = turnText;
        }

        function updateCombatStatus() {
            const enemyList = document.getElementById('enemy-list');
            const partyList = document.getElementById('party-combat-list');
            
            enemyList.innerHTML = '';
            partyList.innerHTML = '';
            
            gameState.enemies.forEach(enemy => {
                const percent = Math.floor((enemy.currentHp / enemy.maxHp) * 100);
                enemyList.innerHTML += `
                    <div>${enemy.glyph} ${enemy.name}: ${enemy.currentHp}/${enemy.maxHp}
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percent}%"></div>
                        </div>
                    </div>
                `;
            });
            
            gameState.party.forEach((char, i) => {
                const hpPercent = Math.floor((char.hp / char.maxHp) * 100);
                const mpPercent = char.maxMp > 0 ? Math.floor((char.mp / char.maxMp) * 100) : 0;
                const race = races.find(r => r.id === char.raceId);
                
                partyList.innerHTML += `
                    <div class="${i === gameState.combatSelectedChar ? 'combat-turn-indicator' : ''}" 
                         style="padding: 5px; margin: 2px; cursor: pointer;" 
                         onclick="setCombatCharacter(${i})">
                        ${char.name} (${race?.name || ''} Lvl ${char.level})
                        <div>HP: ${char.hp}/${char.maxHp}
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${hpPercent}%"></div>
                            </div>
                        </div>
                        ${char.maxMp > 0 ? `
                            <div>MP: ${char.mp}/${char.maxMp}
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${mpPercent}%"></div>
                                </div>
                            </div>
                        ` : ''}
                        ${char.poisoned ? '<div style="color:#0f0">POISONED!</div>' : ''}
                        <div style="font-size:9px;color:#aaa">
                            Memorized: ${magicSystem.getMemorizedSpells(char).length}/${magicSystem.getSpellSlots(char)}
                        </div>
                    </div>
                `;
            });
        }

        function renderCombatSpells() {
            const container = document.getElementById('combat-spells');
            const char = gameState.party[gameState.combatSelectedChar];
            
            if (!char || !char.spells) {
                container.innerHTML = 'No spells known.';
                return;
            }
            
            container.innerHTML = '';
            const memorizedSpells = magicSystem.getMemorizedSpells(char);
            
            char.spells.forEach(spellId => {
                const spell = magicSystem.getSpell(spellId);
                if (spell) {
                    const isMemorized = memorizedSpells.includes(spellId);
                    const canCast = char.mp >= spell.mp && isMemorized;
                    
                    const btn = document.createElement('button');
                    btn.textContent = `${spell.name} (${spell.mp} MP)`;
                    btn.disabled = !canCast;
                    btn.style.width = '100%';
                    btn.style.margin = '2px 0';
                    btn.style.backgroundColor = isMemorized ? '#224' : '#422';
                    btn.onclick = () => {
                        if (isMemorized) {
                            gameState.combatSelectedSpell = spellId;
                            addLog(`Selected spell: ${spell.name}`, 'combat');
                        } else {
                            addLog(`${spell.name} is not memorized!`, 'combat');
                        }
                    };
                    container.appendChild(btn);
                }
            });
            
            if (container.children.length === 0) {
                container.innerHTML = 'No spells memorized.';
            }
        }

        function renderCombatItems() {
            const container = document.getElementById('combat-items');
            const usableItems = inventorySystem.items.filter(item => 
                item.type === 'potion' || item.type === 'scroll'
            );
            
            container.innerHTML = '';
            
            if (usableItems.length === 0) {
                container.innerHTML = 'No usable items.';
                return;
            }
            
            usableItems.forEach(item => {
                const btn = document.createElement('button');
                btn.textContent = `${item.name} x${item.quantity || 1}`;
                btn.style.width = '100%';
                btn.style.margin = '2px 0';
                btn.onclick = () => {
                    gameState.combatSelectedItem = item.uid;
                    addLog(`Selected item: ${item.name}`, 'combat');
                };
                container.appendChild(btn);
            });
        }

        function endCombat(victory) {
            gameState.inCombat = false;
            
            if (victory) {
                addLog('Victory!', 'combat');
                
                // Check for level ups
                gameState.party.forEach(char => {
                    checkLevelUp(char);
                });
                
                // Restore some MP
                gameState.party.forEach(char => {
                    char.mp = Math.min(char.maxMp, char.mp + Math.floor(char.maxMp * 0.1));
                });
                
                setTimeout(() => {
                    if (gameState.screen === 'dungeon') {
                        switchView('dungeon');
                    } else {
                        switchView('explore');
                    }
                }, 2000);
            } else {
                // Flee successful
                switchView('explore');
            }
        }

        // ====================
        // VIEW MANAGEMENT
        // ====================
        function switchView(viewName) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.style.display = 'none';
            });
            
            document.getElementById(`view-${viewName}`).style.display = 'block';
            gameState.screen = viewName;
            
            // Update view-specific content
            switch(viewName) {
                case 'explore':
                    renderWorldMap();
                    updatePartyStatus();
                    updateMinimap();
                    break;
                case 'inventory':
                    renderInventory();
                    break;
                case 'town':
                    renderTown();
                    break;
                case 'dungeon':
                    renderDungeon();
                    break;
                case 'character':
                    renderCharacterSheet();
                    break;
                case 'spells':
                    renderSpellbook();
                    renderSpellMemorization();
                    break;
                case 'quests':
                    renderQuestLog();
                    break;
                case 'combat':
                    updateCombatUI();
                    updateCombatStatus();
                    break;
            }
        }

        // ====================
        // EXPLORATION & MAP
        // ====================
        function renderWorldMap() {
            const container = document.getElementById('world-map');
            container.innerHTML = '';
            const tileSize = 24;
            const viewRadius = 5;
            
            // Get visible area
            const startX = Math.max(0, gameState.location.x - viewRadius);
            const startY = Math.max(0, gameState.location.y - viewRadius);
            const endX = Math.min(20, gameState.location.x + viewRadius + 1);
            const endY = Math.min(20, gameState.location.y + viewRadius + 1);
            
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const tile = gameState.worldMap[y][x];
                    if (Math.abs(x - gameState.location.x) <= viewRadius && 
                        Math.abs(y - gameState.location.y) <= viewRadius) {
                        
                        tile.explored = true;
                        const tileElem = document.createElement('div');
                        tileElem.className = `tile ${tile.type}`;
                        tileElem.style.left = `${(x - gameState.location.x + viewRadius) * tileSize}px`;
                        tileElem.style.top = `${(y - gameState.location.y + viewRadius) * tileSize}px`;
                        tileElem.textContent = getTileGlyph(tile.type);
                        tileElem.title = `${tile.type.toUpperCase()} (${x},${y})`;
                        container.appendChild(tileElem);
                    }
                }
            }
            
            // Draw party at center
            const partyTile = document.createElement('div');
            partyTile.className = 'tile party';
            partyTile.style.left = `${viewRadius * tileSize}px`;
            partyTile.style.top = `${viewRadius * tileSize}px`;
            partyTile.textContent = '@';
            partyTile.title = 'Your Party';
            container.appendChild(partyTile);
        }

        function updateMinimap() {
            const container = document.getElementById('minimap');
            if (!container) return;
            
            container.innerHTML = '';
            const size = 5;
            const center = Math.floor(size / 2);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const worldX = gameState.location.x + (x - center);
                    const worldY = gameState.location.y + (y - center);
                    
                    const cell = document.createElement('div');
                    cell.className = 'minimap-cell';
                    
                    if (worldX >= 0 && worldX < 20 && worldY >= 0 && worldY < 20) {
                        const tile = gameState.worldMap[worldY][worldX];
                        if (tile.explored) {
                            cell.textContent = getTileGlyph(tile.type).charAt(0);
                            cell.style.backgroundColor = getTileColor(tile.type);
                        }
                    }
                    
                    if (x === center && y === center) {
                        cell.style.backgroundColor = '#ff0';
                        cell.textContent = '@';
                    }
                    
                    container.appendChild(cell);
                }
            }
        }

        function getTileGlyph(type) {
            const glyphs = {
                town: 'T', forest: '#', mountain: '^', water: '~',
                plains: '.', dungeon: 'D', castle: 'C', moongate: 'O',
                shrine: '‚úù', ruins: '‚åÇ', bridge: '‚ïê'
            };
            return glyphs[type] || '.';
        }

        function getTileColor(type) {
            const colors = {
                town: '#66f', forest: '#080', mountain: '#888', water: '#00a',
                plains: '#030', dungeon: '#500', castle: '#a50', moongate: '#a0a',
                shrine: '#ffcc00', ruins: '#8b4513', bridge: '#a0522d'
            };
            return colors[type] || '#030';
        }

        function moveParty(direction) {
            if (gameState.inCombat) return;
            
            const newLoc = { ...gameState.location };
            switch(direction) {
                case 'north': newLoc.y--; break;
                case 'south': newLoc.y++; break;
                case 'east': newLoc.x++; break;
                case 'west': newLoc.x--; break;
            }
            
            // Check bounds
            if (newLoc.x < 0 || newLoc.x >= 20 || newLoc.y < 0 || newLoc.y >= 20) {
                addLog('You cannot move beyond the edge of the world.', 'explore');
                return;
            }
            
            const tile = gameState.worldMap[newLoc.y][newLoc.x];
            
            // Check if passable
            if (tile.type === 'water') {
                addLog('You need a ship to cross water.', 'explore');
                return;
            }
            
            // Update location
            gameState.location = newLoc;
            gameState.location.type = tile.type;
            gameState.location.name = getLocationName(newLoc.x, newLoc.y);
            
            // Update game state
            gameState.turn++;
            gameState.food -= 2;
            updateTime();
            
            // Check for events
            checkLocationEvents();
            
            // Update display
            updateDisplay();
            renderWorldMap();
            updateMinimap();
            
            addLog(`Moved ${direction}.`, 'explore');
            
            // Random encounter check
            if (Math.random() < tile.encounterRate && !['town', 'castle'].includes(tile.type)) {
                startRandomCombat();
            }
        }

        function getLocationName(x, y) {
            // Check for special locations
            if (x === 5 && y === 5) return 'BRITAIN';
            if (x === 7 && y === 3) return 'DESTARD';
            if (x === 2 && y === 8) return 'SHAME';
            if (x === 15 && y === 5) return 'DECEIT';
            if (x === 10 && y === 10) return 'CASTLE BRITANNIA';
            if (x === 15 && y === 15) return 'MOONGATE';
            if (x === 8 && y === 2) return 'MOONGLOW';
            if (x === 3 && y === 10) return 'TRINSIC';
            
            // Check for new features
            const tile = gameState.worldMap[y][x];
            if (tile.type === 'shrine') return 'ANCIENT SHRINE';
            if (tile.type === 'ruins') return 'FORGOTTEN RUINS';
            if (tile.type === 'bridge') return 'STONE BRIDGE';
            
            // Generate descriptive name
            const descriptors = {
                forest: ['Deepwood', 'Shadowwood', 'Eldritch Wood'],
                mountain: ['Dragon Spine', 'Stonepeak', 'Iron Mountain'],
                plains: ['Golden Fields', 'Whispering Plains', 'Endless Grass'],
                water: ['Sea of Storms', 'Azure Bay', 'Crystal Lake']
            };
            
            const names = descriptors[tile.type] || ['Unknown Region'];
            return names[Math.floor(Math.random() * names.length)];
        }

        function updateTime() {
            gameState.timeCounter++;
            
            if (gameState.timeCounter >= 8) {
                gameState.timeCounter = 0;
                gameState.day++;
                
                // Consume food each day
                gameState.food -= gameState.party.length * 2;
                if (gameState.food < 0) {
                    gameState.food = 0;
                    // Starvation damage
                    gameState.party.forEach(char => {
                        char.hp -= 5;
                        addLog(`${char.name} suffers from starvation!`, 'explore');
                    });
                }
            }
            
            const times = ['MORNING', 'NOON', 'AFTERNOON', 'EVENING', 'NIGHT', 'MIDNIGHT', 'LATE NIGHT', 'DAWN'];
            gameState.time = times[gameState.timeCounter % times.length];
        }

        function checkLocationEvents() {
            const tile = gameState.worldMap[gameState.location.y][gameState.location.x];
            
            switch(tile.type) {
                case 'town':
                    gameState.currentTown = getTownAtLocation(gameState.location.x, gameState.location.y);
                    addLog(`You arrive at ${gameState.currentTown?.name || 'a town'}.`, 'explore');
                    break;
                case 'dungeon':
                    addLog('You stand before a dark dungeon entrance.', 'explore');
                    break;
                case 'moongate':
                    addLog('A shimmering moongate stands before you.', 'explore');
                    break;
                case 'castle':
                    addLog('You approach a mighty castle.', 'explore');
                    break;
                case 'shrine':
                    handleShrine(tile);
                    break;
                case 'ruins':
                    handleRuins(tile);
                    break;
                case 'bridge':
                    handleBridge(tile);
                    break;
            }
        }

        function handleShrine(tile) {
            const feature = mapFeatures.shrine;
            const race = gameState.party[0]?.raceId || 'human';
            const dialogue = feature.dialogue[race] || feature.dialogue.human;
            
            addLog(`You find an ancient shrine. ${dialogue}`, 'explore');
            
            if (!tile.featureData.used) {
                addLog('The shrine radiates holy power.', 'explore');
                
                if (confirm('Would you like to pray at the shrine? (Cost: 10 gold)')) {
                    if (gameState.gold >= 10) {
                        gameState.gold -= 10;
                        tile.featureData.used = true;
                        
                        // Random blessing
                        const blessings = [
                            { effect: 'heal', message: 'Healing energy washes over the party!' },
                            { effect: 'bless', message: 'You feel blessed by divine power!' },
                            { effect: 'cure', message: 'All afflictions are cleansed!' }
                        ];
                        
                        const blessing = blessings[Math.floor(Math.random() * blessings.length)];
                        
                        switch(blessing.effect) {
                            case 'heal':
                                gameState.party.forEach(char => {
                                    char.hp = char.maxHp;
                                    char.mp = char.maxMp;
                                });
                                break;
                            case 'bless':
                                gameState.party.forEach(char => {
                                    char.tempAc = (char.tempAc || 0) + 2;
                                });
                                break;
                            case 'cure':
                                gameState.party.forEach(char => {
                                    char.poisoned = false;
                                });
                                break;
                        }
                        
                        addLog(blessing.message, 'explore');
                        updatePartyStatus();
                        updateDisplay();
                    } else {
                        addLog('You need 10 gold to make an offering.', 'explore');
                    }
                }
            } else {
                addLog('The shrine\'s power is spent for now.', 'explore');
            }
        }

        function handleRuins(tile) {
            const feature = mapFeatures.ruins;
            const race = gameState.party[0]?.raceId || 'human';
            const dialogue = feature.dialogue[race] || feature.dialogue.human;
            
            addLog(`You discover ancient ruins. ${dialogue}`, 'explore');
            
            if (!tile.featureData.looted) {
                addLog('The ruins may contain treasure... or danger.', 'explore');
                
                if (confirm('Would you like to explore the ruins?')) {
                    tile.featureData.looted = true;
                    
                    if (tile.featureData.danger) {
                        addLog('Bandits ambush you from the ruins!', 'explore');
                        setTimeout(() => startRandomCombat(), 1000);
                    } else {
                        // Find treasure
                        const gold = getRandomInt(50, 200);
                        gameState.gold += gold;
                        
                        // Dwarves find extra treasure
                        const dwarfCount = gameState.party.filter(p => p.raceId === 'dwarven').length;
                        const extraGold = dwarfCount * 25;
                        gameState.gold += extraGold;
                        
                        addLog(`You find ${gold} gold in the ruins!`, 'explore');
                        if (extraGold > 0) {
                            addLog(`Dwarven mining skill finds an extra ${extraGold} gold!`, 'explore');
                        }
                        
                        updateDisplay();
                    }
                }
            } else {
                addLog('These ruins have already been explored.', 'explore');
            }
        }

        function handleBridge(tile) {
            const feature = mapFeatures.bridge;
            const race = gameState.party[0]?.raceId || 'human';
            const dialogue = feature.dialogue[race] || feature.dialogue.human;
            
            addLog(`You come to a stone bridge. ${dialogue}`, 'explore');
            
            if (tile.featureData.toll) {
                addLog(`A troll demands a toll of ${tile.featureData.amount} gold!`, 'explore');
                
                if (confirm(`Pay ${tile.featureData.amount} gold to cross?`)) {
                    if (gameState.gold >= tile.featureData.amount) {
                        gameState.gold -= tile.featureData.amount;
                        addLog('The troll lets you pass.', 'explore');
                        updateDisplay();
                    } else {
                        addLog('You cannot afford the toll!', 'explore');
                    }
                } else {
                    addLog('You decide not to cross.', 'explore');
                    // Move back
                    gameState.location = { x: gameState.location.x - 1, y: gameState.location.y };
                    renderWorldMap();
                }
            }
        }

        function getTownAtLocation(x, y) {
            for (const townId in townsDB) {
                const town = townsDB[townId];
                if (town.x === x && town.y === y) {
                    return { id: townId, ...town };
                }
            }
            return null;
        }

        function enterLocation() {
            const tile = gameState.worldMap[gameState.location.y][gameState.location.x];
            
            switch(tile.type) {
                case 'town':
                    enterTown();
                    break;
                case 'dungeon':
                    enterDungeon();
                    break;
                case 'castle':
                    enterCastle();
                    break;
                case 'moongate':
                    useMoongate();
                    break;
                case 'shrine':
                    handleShrine(tile);
                    break;
                case 'ruins':
                    handleRuins(tile);
                    break;
                default:
                    addLog('There is nothing to enter here.', 'explore');
            }
        }

        // ====================
        // ENHANCED INVENTORY SYSTEM
        // ====================
        function renderInventory() {
            // Update gold and food
            document.getElementById('inventory-gold').textContent = gameState.gold;
            document.getElementById('inventory-food').textContent = gameState.food;
            
            // Count keys and torches
            const keys = inventorySystem.items.filter(i => i.type === 'key').length;
            const torches = inventorySystem.items.filter(i => i.id === 'torch')
                .reduce((sum, item) => sum + (item.quantity || 1), 0);
            
            document.getElementById('inventory-keys').textContent = keys;
            document.getElementById('inventory-torches').textContent = torches;
            
            // Update all character equipment displays
            for (let i = 0; i < 4; i++) {
                const char = gameState.party[i];
                if (char) {
                    // Update character name
                    const charNameElem = document.getElementById(`char-name-${i}`);
                    if (charNameElem) charNameElem.textContent = char.name;
                    
                    // Update equipment slots
                    updateCharacterEquipmentDisplay(i);
                }
            }
            
            // Clear and rebuild inventory slots
            const slotsContainer = document.getElementById('inventory-slots');
            slotsContainer.innerHTML = '';
            
            // Show ALL items in inventory
            inventorySystem.items.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot filled';
                slot.id = `slot-${index}`;
                slot.setAttribute('data-item-uid', item.uid);
                slot.setAttribute('data-item-index', index);
                
                // Create display text
                let displayText = item.name.substring(0, 6);
                
                // Add quantity if more than 1
                if (item.quantity && item.quantity > 1) {
                    displayText += `x${item.quantity}`;
                }
                
                slot.textContent = displayText;
                
                // Create tooltip
                let tooltip = `${item.name}`;
                if (item.type) tooltip += `\nType: ${item.type}`;
                if (item.damage) tooltip += `\nDamage: ${item.damage}`;
                if (item.ac) tooltip += `\nAC: +${item.ac}`;
                if (item.effect) tooltip += `\nEffect: ${item.effect}`;
                if (item.weight) tooltip += `\nWeight: ${item.weight}`;
                if (item.bonus) tooltip += `\nBonus: +${item.bonus}`;
                if (item.raceRestriction && item.raceRestriction.length > 0) {
                    tooltip += `\nRestricted: ${item.raceRestriction.join(', ')}`;
                }
                
                slot.title = tooltip;
                
                // Add click handler
                slot.onclick = function(e) {
                    e.stopPropagation();
                    
                    // Remove highlight from all slots
                    document.querySelectorAll('.inventory-slot').forEach(s => {
                        s.classList.remove('selected');
                    });
                    
                    // Highlight this slot
                    this.classList.add('selected');
                    
                    // Select this item
                    gameState.selectedInventoryItem = item.uid;
                    
                    // Show message
                    addLog(`Selected ${item.name}.`, 'inventory');
                };
                
                slotsContainer.appendChild(slot);
            });
            
            // Fill remaining empty slots
            const maxSlots = 24;
            const currentSlots = slotsContainer.children.length;
            
            for (let i = currentSlots; i < maxSlots; i++) {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'inventory-slot';
                emptySlot.id = `slot-${i}`;
                emptySlot.textContent = '';
                emptySlot.onclick = function() {
                    gameState.selectedInventoryItem = null;
                    document.querySelectorAll('.inventory-slot').forEach(s => {
                        s.classList.remove('selected');
                    });
                };
                slotsContainer.appendChild(emptySlot);
            }
            
            // Update character selector buttons
            updateCharacterSelector();
        }

        function updateCharacterEquipmentDisplay(charIndex) {
            const char = gameState.party[charIndex];
            if (!char) return;
            
            // Update equipment display
            const weaponElem = document.getElementById(`weapon-${charIndex}`);
            const armorElem = document.getElementById(`armor-${charIndex}`);
            const shieldElem = document.getElementById(`shield-${charIndex}`);
            const accessoryElem = document.getElementById(`accessory-${charIndex}`);
            const weightElem = document.getElementById(`weight-${charIndex}`);
            const attackBonusElem = document.getElementById(`attack-bonus-${charIndex}`);
            const defenseBonusElem = document.getElementById(`defense-bonus-${charIndex}`);
            
            if (weaponElem) weaponElem.textContent = char.equipment?.weapon?.name || 'None';
            if (armorElem) armorElem.textContent = char.equipment?.armor?.name || 'None';
            if (shieldElem) shieldElem.textContent = char.equipment?.shield?.name || 'None';
            if (accessoryElem) accessoryElem.textContent = char.equipment?.accessory?.name || 'None';
            
            // Calculate weight
            let charWeight = 0;
            let attackBonus = 0;
            let defenseBonus = 0;
            
            if (char.equipment) {
                if (char.equipment.weapon) {
                    charWeight += char.equipment.weapon.weight || 0;
                    attackBonus += char.equipment.weapon.bonus || 0;
                    
                    // Dwarf axe bonus
                    if (char.raceId === 'dwarven' && char.equipment.weapon.id.includes('axe')) {
                        attackBonus += 2;
                    }
                }
                if (char.equipment.armor) {
                    charWeight += char.equipment.armor.weight || 0;
                    defenseBonus += char.equipment.armor.ac || 0;
                }
                if (char.equipment.shield) {
                    charWeight += char.equipment.shield.weight || 0;
                    defenseBonus += char.equipment.shield.ac || 0;
                }
                if (char.equipment.accessory) {
                    charWeight += char.equipment.accessory.weight || 0;
                }
            }
            
            if (weightElem) weightElem.textContent = `${charWeight}/100`;
            if (attackBonusElem) attackBonusElem.textContent = `+${attackBonus}`;
            if (defenseBonusElem) defenseBonusElem.textContent = `+${defenseBonus}`;
        }

        function selectCharacter(index) {
            if (index < 0 || index >= gameState.party.length) return;
            
            gameState.selectedChar = index;
            
            // Update character selector buttons
            updateCharacterSelector();
            
            // Show the selected character's equipment panel
            for (let i = 0; i < 4; i++) {
                const equipmentPanel = document.getElementById(`char-equipment-${i}`);
                if (equipmentPanel) {
                    if (i === index) {
                        equipmentPanel.style.display = 'block';
                        equipmentPanel.classList.add('active');
                    } else {
                        equipmentPanel.style.display = 'none';
                        equipmentPanel.classList.remove('active');
                    }
                }
            }
            
            addLog(`Now viewing ${gameState.party[index].name}'s equipment.`, 'inventory');
        }

        function updateCharacterSelector() {
            for (let i = 0; i < 4; i++) {
                const btn = document.getElementById(`char-btn-${i}`);
                if (btn) {
                    btn.classList.toggle('active', i === gameState.selectedChar);
                    
                    // Update button text with character name if available
                    if (gameState.party[i]) {
                        btn.textContent = gameState.party[i].name.substring(0, 8);
                    }
                }
            }
        }

        function equipItemToSlot(charIndex, slotType) {
            if (!gameState.selectedInventoryItem) {
                addLog('Select an item from inventory first!', 'inventory');
                return;
            }
            
            const char = gameState.party[charIndex];
            if (!char) {
                addLog('Character not found!', 'inventory');
                return;
            }
            
            const item = inventorySystem.getItem(gameState.selectedInventoryItem);
            if (!item) {
                addLog('Item not found!', 'inventory');
                return;
            }
            
            // Check race restrictions
            if (item.raceRestriction && item.raceRestriction.includes(char.raceId)) {
                addLog(`${char.name} cannot use ${item.name} due to race restrictions!`, 'inventory');
                return;
            }
            
            // Check if item can be equipped in this slot
            if (!canEquipInSlot(item, slotType)) {
                addLog(`${item.name} cannot be equipped in ${slotType} slot.`, 'inventory');
                return;
            }
            
            // Check for two-handed weapon with shield
            if (slotType === 'weapon' && item.hands === 2 && char.equipment?.shield) {
                addLog('Cannot equip two-handed weapon while holding a shield!', 'inventory');
                return;
            }
            
            // Check if shield is equipped with two-handed weapon
            if (slotType === 'shield' && char.equipment?.weapon?.hands === 2) {
                addLog('Cannot equip shield while wielding a two-handed weapon!', 'inventory');
                return;
            }
            
            // Unequip current item if any
            if (char.equipment && char.equipment[slotType]) {
                const oldItem = char.equipment[slotType];
                inventorySystem.addItem(oldItem);
                addLog(`Unequipped ${oldItem.name}.`, 'inventory');
            }
            
            // Equip new item
            if (!char.equipment) char.equipment = {};
            char.equipment[slotType] = item;
            
            // Remove from inventory
            inventorySystem.removeItem(item.uid);
            
            // Clear selection
            gameState.selectedInventoryItem = null;
            document.querySelectorAll('.inventory-slot').forEach(s => {
                s.classList.remove('selected');
            });
            
            addLog(`${char.name} equips ${item.name} as ${slotType}.`, 'inventory');
            
            // Update displays
            updateCharacterEquipmentDisplay(charIndex);
            renderInventory();
            updatePartyStatus();
        }

        function canEquipInSlot(item, slotType) {
            switch(slotType) {
                case 'weapon':
                    return item.type === 'weapon';
                case 'armor':
                    return item.type === 'armor';
                case 'shield':
                    return item.type === 'shield';
                case 'accessory':
                    return ['potion', 'scroll', 'key', 'tool', 'food', 'accessory'].includes(item.type);
                default:
                    return false;
            }
        }

        function unequipItem(charIndex, slotType) {
            const char = gameState.party[charIndex];
            if (!char || !char.equipment || !char.equipment[slotType]) {
                addLog('Nothing to unequip!', 'inventory');
                return;
            }
            
            const item = char.equipment[slotType];
            const result = inventorySystem.addItem(item);
            
            if (result.success) {
                delete char.equipment[slotType];
                addLog(`${char.name} unequips ${item.name}.`, 'inventory');
                updateCharacterEquipmentDisplay(charIndex);
                renderInventory();
                updatePartyStatus();
            }
        }

        function unequipAll() {
            const char = gameState.party[gameState.selectedChar];
            if (!char || !char.equipment) {
                addLog('Nothing to unequip!', 'inventory');
                return;
            }
            
            let unequippedCount = 0;
            for (const slotType in char.equipment) {
                const item = char.equipment[slotType];
                if (item) {
                    inventorySystem.addItem(item);
                    unequippedCount++;
                }
            }
            
            char.equipment = {};
            addLog(`Unequipped ${unequippedCount} items from ${char.name}.`, 'inventory');
            
            updateCharacterEquipmentDisplay(gameState.selectedChar);
            renderInventory();
            updatePartyStatus();
        }

        function useSelectedItem() {
            if (!gameState.selectedInventoryItem) {
                addLog('Select an item first!', 'inventory');
                return;
            }
            
            const char = gameState.party[gameState.selectedChar];
            const item = inventorySystem.getItem(gameState.selectedInventoryItem);
            
            if (!item || !char) {
                addLog('Cannot use item!', 'inventory');
                return;
            }
            
            const result = inventorySystem.useItem(item.uid, char);
            
            if (result.success) {
                addLog(result.message, 'inventory');
                updatePartyStatus();
                renderInventory();
            } else {
                addLog(result.message, 'inventory');
            }
        }

        function dropSelectedItem() {
            if (!gameState.selectedInventoryItem) {
                addLog('Select an item first!', 'inventory');
                return;
            }
            
            const item = inventorySystem.removeItem(gameState.selectedInventoryItem);
            if (item) {
                addLog(`Dropped ${item.name}.`, 'inventory');
                gameState.selectedInventoryItem = null;
                renderInventory();
            }
        }

        // ====================
        // CHARACTER SYSTEM
        // ====================
        function renderCharacterSheet() {
            const container = document.getElementById('character-sheet');
            const char = gameState.party[gameState.selectedChar || 0];
            
            if (!char) {
                container.innerHTML = 'No character selected.';
                return;
            }
            
            const xpNeeded = char.level * 1000;
            const xpPercent = Math.min(100, (char.xp / xpNeeded) * 100);
            const charClass = classes.find(c => c.id === char.classId);
            const charRace = races.find(r => r.id === char.raceId);
            
            // Calculate bonuses from equipment
            let attackBonus = 0;
            let defenseBonus = 0;
            
            if (char.equipment) {
                if (char.equipment.weapon) attackBonus += char.equipment.weapon.bonus || 0;
                if (char.equipment.armor) defenseBonus += char.equipment.armor.ac || 0;
                if (char.equipment.shield) defenseBonus += char.equipment.shield.ac || 0;
            }
            
            container.innerHTML = `
                <div class="character-card ${charClass?.color || ''}">
                    <h3>${char.name}</h3>
                    <div>Level ${char.level} ${charRace?.name || ''} ${charClass?.name || ''}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${xpPercent}%"></div>
                    </div>
                    <div>XP: ${char.xp}/${xpNeeded}</div>
                    <hr>
                    <div><strong>RACIAL TRAITS</strong></div>
                    <div>${charRace?.ability || 'None'}</div>
                    <hr>
                    <div><strong>STATS</strong></div>
                    <div>HP: ${char.hp}/${char.maxHp}</div>
                    <div>MP: ${char.mp}/${char.maxMp}</div>
                    <div>STR: ${char.str}${char.tempStr ? ` (+${char.tempStr})` : ''}</div>
                    <div>DEX: ${char.dex}</div>
                    <div>INT: ${char.int}</div>
                    <div>WIS: ${char.wis}</div>
                    <div>AC: ${char.ac + defenseBonus + (char.tempAc || 0)}</div>
                    <hr>
                    <div><strong>EQUIPMENT</strong></div>
                    <div>Weapon: ${char.equipment?.weapon?.name || 'None'} ${char.equipment?.weapon?.bonus ? `(+${char.equipment.weapon.bonus})` : ''}</div>
                    <div>Armor: ${char.equipment?.armor?.name || 'None'} ${char.equipment?.armor?.ac ? `(+${char.equipment.armor.ac})` : ''}</div>
                    <div>Shield: ${char.equipment?.shield?.name || 'None'} ${char.equipment?.shield?.ac ? `(+${char.equipment.shield.ac})` : ''}</div>
                    <div>Accessory: ${char.equipment?.accessory?.name || 'None'}</div>
                    <hr>
                    <div><strong>BONUSES</strong></div>
                    <div>Attack: +${attackBonus}</div>
                    <div>Defense: +${defenseBonus}</div>
                    <hr>
                    <div><strong>ABILITIES</strong></div>
                    <div>${charClass?.abilities?.join(', ') || 'None'}</div>
                    <hr>
                    <div><strong>SPELLS</strong></div>
                    <div>Known: ${char.spells?.map(s => magicSystem.getSpell(s)?.name).filter(Boolean).join(', ') || 'None'}</div>
                    <div>Memorized: ${magicSystem.getMemorizedSpells(char).map(s => magicSystem.getSpell(s)?.name).filter(Boolean).join(', ') || 'None'}</div>
                    <div>Slots: ${magicSystem.getMemorizedSpells(char).length}/${magicSystem.getSpellSlots(char)}</div>
                </div>
            `;
        }

        function checkLevelUp(character) {
            const xpNeeded = character.level * 1000;
            if (character.xp >= xpNeeded) {
                character.level++;
                character.xp -= xpNeeded;
                
                // Improve stats
                character.maxHp += 10 + Math.floor(character.str / 4);
                character.maxMp += 5 + Math.floor(character.int / 4);
                character.hp = character.maxHp;
                character.mp = character.maxMp;
                
                // Base stat increases
                if (character.level % 3 === 0) {
                    switch(character.classId) {
                        case 'fighter':
                            character.str += 1;
                            character.dex += 1;
                            break;
                        case 'mage':
                            character.int += 2;
                            break;
                        case 'cleric':
                            character.wis += 2;
                            break;
                        case 'thief':
                            character.dex += 2;
                            break;
                    }
                }
                
                // Learn new spells for mages/clerics
                if ((character.classId === 'mage' || character.classId === 'cleric') && character.level % 2 === 0) {
                    const availableSpells = Object.values(spellsDB).flat()
                        .filter(s => s.level <= Math.ceil(character.level / 2));
                    if (availableSpells.length > 0) {
                        const newSpell = availableSpells[Math.floor(Math.random() * availableSpells.length)];
                        if (!character.spells.includes(newSpell.id)) {
                            magicSystem.learnSpell(character, newSpell.id);
                            addLog(`${character.name} learns ${newSpell.name}!`, 'explore');
                        }
                    }
                }
                
                addLog(`${character.name} advanced to level ${character.level}!`, 'explore');
                updatePartyStatus();
                return true;
            }
            return false;
        }

        // ====================
        // SPELL SYSTEM
        // ====================
        function renderSpellbook() {
            const container = document.getElementById('spellbook');
            const char = gameState.party[gameState.selectedChar || 0];
            
            if (!char) {
                container.innerHTML = 'No character selected.';
                return;
            }
            
            if (!char.spells || char.spells.length === 0) {
                container.innerHTML = '<div style="text-align:center;padding:20px;">No spells known.</div>';
                return;
            }
            
            container.innerHTML = '<h3>KNOWN SPELLS</h3>';
            
            // Group spells by school
            const spellsBySchool = {};
            char.spells.forEach(spellId => {
                const spell = magicSystem.getSpell(spellId);
                if (spell) {
                    if (!spellsBySchool[spell.school]) {
                        spellsBySchool[spell.school] = [];
                    }
                    spellsBySchool[spell.school].push(spell);
                }
            });
            
            // Display spells by school
            for (const school in spellsBySchool) {
                container.innerHTML += `<h4>${school.toUpperCase()} SPELLS</h4>`;
                spellsBySchool[school].forEach(spell => {
                    const isMemorized = magicSystem.isSpellMemorized(char, spell.id);
                    const canMemorize = magicSystem.getMemorizedSpells(char).length < magicSystem.getSpellSlots(char);
                    
                    container.innerHTML += `
                        <div class="spell-card ${isMemorized ? 'available' : canMemorize ? '' : 'unavailable'}" 
                             onclick="selectSpellForMemorization('${spell.id}')">
                            <strong>${spell.name}</strong><br>
                            Level: ${spell.level} | MP: ${spell.mp}<br>
                            ${spell.damage ? `Damage: ${spell.damage}` : `Effect: ${spell.effect}`}<br>
                            ${isMemorized ? '<em>MEMORIZED</em>' : canMemorize ? 'Click to memorize' : 'No slots available'}
                        </div>
                    `;
                });
            }
        }

        function renderSpellMemorization() {
            const char = gameState.party[gameState.selectedChar || 0];
            if (!char) return;
            
            const totalSlots = magicSystem.getSpellSlots(char);
            const usedSlots = magicSystem.getMemorizedSpells(char).length;
            
            document.getElementById('spell-slots-available').textContent = totalSlots - usedSlots;
            
            const container = document.getElementById('spell-slots-container');
            container.innerHTML = '';
            
            for (let i = 0; i < totalSlots; i++) {
                const slot = document.createElement('div');
                slot.className = `spell-slot ${i < usedSlots ? 'filled' : 'empty'}`;
                slot.id = `spell-slot-${i}`;
                slot.onclick = () => selectSpellSlot(i);
                
                if (i < usedSlots) {
                    const spellId = magicSystem.getMemorizedSpells(char)[i];
                    const spell = magicSystem.getSpell(spellId);
                    slot.textContent = spell ? spell.name.substring(0, 4) : '???';
                    slot.title = spell ? spell.name : 'Unknown spell';
                } else {
                    slot.textContent = 'Empty';
                    slot.title = 'Empty spell slot';
                }
                
                container.appendChild(slot);
            }
        }

        function selectSpellForMemorization(spellId) {
            gameState.selectedSpell = spellId;
            const spell = magicSystem.getSpell(spellId);
            if (spell) {
                addLog(`Selected ${spell.name} for memorization.`, 'spells');
            }
        }

        function memorizeSelectedSpell() {
            const char = gameState.party[gameState.selectedChar || 0];
            if (!char || !gameState.selectedSpell) {
                addLog('Select a spell first!', 'spells');
                return;
            }
            
            const result = magicSystem.memorizeSpell(char, gameState.selectedSpell);
            addLog(result.message, 'spells');
            
            if (result.success) {
                renderSpellbook();
                renderSpellMemorization();
            }
        }

        function clearSpellSlot() {
            const char = gameState.party[gameState.selectedChar || 0];
            if (!char) return;
            
            const memorizedSpells = magicSystem.getMemorizedSpells(char);
            if (memorizedSpells.length === 0) {
                addLog('No spells to clear!', 'spells');
                return;
            }
            
            // Clear the last memorized spell
            const lastSpellId = memorizedSpells[memorizedSpells.length - 1];
            const success = magicSystem.forgetSpell(char, lastSpellId);
            
            if (success) {
                const spell = magicSystem.getSpell(lastSpellId);
                addLog(`Forgot ${spell?.name || 'spell'}.`, 'spells');
                renderSpellbook();
                renderSpellMemorization();
            }
        }

        function restToMemorize() {
            if (confirm('Rest for 8 hours to memorize spells?')) {
                gameState.party.forEach(char => {
                    char.hp = char.maxHp;
                    char.mp = char.maxMp;
                });
                addLog('Party rests. Spells can now be memorized.', 'spells');
                updatePartyStatus();
                updateDisplay();
            }
        }

        // ====================
        // QUEST SYSTEM
        // ====================
        function renderQuestLog() {
            const container = document.getElementById('quest-log');
            const activeQuests = questSystem.getActiveQuests();
            
            container.innerHTML = '';
            
            if (activeQuests.length === 0) {
                container.innerHTML = '<div style="text-align:center;padding:20px;">No active quests.</div>';
                return;
            }
            
            activeQuests.forEach(quest => {
                const progress = quest.objectives.filter(obj => obj.completed).length;
                const total = quest.objectives.length;
                const percent = Math.floor((progress / total) * 100);
                
                container.innerHTML += `
                    <div class="quest-entry">
                        <strong>${quest.name}</strong><br>
                        ${quest.description}<br>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${percent}%"></div>
                        </div>
                        Progress: ${progress}/${total} (${percent}%)<br>
                        ${quest.objectives.map(obj => 
                            `<div style="margin-left:10px;">- ${obj.description} ${obj.completed ? '‚úì' : 
                              obj.count !== undefined ? `(${obj.count || 0}/${obj.needed})` : ''}</div>`
                        ).join('')}
                        ${quest.reward ? `<br>Reward: ${quest.reward.xp || 0} XP, ${quest.reward.gold || 0} gold${quest.reward.item ? `, ${quest.reward.item}` : ''}` : ''}
                    </div>
                `;
            });
        }

        // ====================
        // TOWN FUNCTIONS
        // ====================
        function enterTown() {
            if (!gameState.currentTown) {
                gameState.currentTown = { name: 'Unknown Town', shops: ['tavern', 'weaponshop'] };
            }
            
            switchView('town');
            
            // Race-specific town greeting
            const firstChar = gameState.party[0];
            if (firstChar) {
                const race = races.find(r => r.id === firstChar.raceId);
                if (race && race.dialogue && race.dialogue[1]) {
                    addLog(race.dialogue[1], 'town');
                }
            }
            
            addLog(`Welcome to ${gameState.currentTown.name}!`, 'town');
        }

        function renderTown() {
            document.getElementById('town-name').textContent = gameState.currentTown?.name || 'UNKNOWN';
            
            // Show available buildings
            const buildings = gameState.currentTown?.shops || [];
            document.querySelectorAll('.town-building').forEach(building => {
                const buildingType = building.querySelector('.building-name').textContent
                    .toLowerCase().replace(' ', '');
                building.style.display = buildings.includes(buildingType) ? 'flex' : 'none';
            });
        }

        function enterBuilding(buildingType) {
            switch(buildingType) {
                case 'tavern':
                    enterTavern();
                    break;
                case 'weaponshop':
                case 'armorshop':
                case 'magicshop':
                    enterShop(buildingType);
                    break;
                case 'temple':
                    enterTemple();
                    break;
                case 'castle':
                    enterCastle();
                    break;
            }
        }

        function enterTavern() {
            addLog('The tavern is filled with adventurers and the smell of ale.', 'town');
            addLog('"Rumor has it Exodus hides in the deepest dungeon..."', 'town');
            addLog('"The Marks of Virtue are hidden in special locations."', 'town');
            
            // Rest option
            if (confirm('Rest at the tavern for 10 gold?')) {
                if (gameState.gold >= 10) {
                    gameState.gold -= 10;
                    gameState.party.forEach(char => {
                        char.hp = char.maxHp;
                        char.mp = char.maxMp;
                        char.poisoned = false;
                    });
                    addLog('Your party is fully rested and healed!', 'town');
                    updateDisplay();
                    updatePartyStatus();
                } else {
                    addLog('Not enough gold!', 'town');
                }
            }
        }

        function enterShop(shopType) {
            gameState.currentShop = shopType;
            renderShop();
            switchView('shop');
        }

        function renderShop() {
            const shopName = gameState.currentShop.toUpperCase();
            document.getElementById('shop-type').textContent = shopName;
            document.getElementById('shop-name').textContent = `${gameState.currentTown?.name || 'Town'}`;
            document.getElementById('shop-gold').textContent = gameState.gold;
            
            const itemsContainer = document.getElementById('shop-items');
            itemsContainer.innerHTML = '';
            
            let items = [];
            switch(gameState.currentShop) {
                case 'weaponshop':
                    items = itemsDB.weapons;
                    break;
                case 'armorshop':
                    items = [...itemsDB.armor, ...itemsDB.shields];
                    break;
                case 'magicshop':
                    items = [...itemsDB.potions, ...itemsDB.scrolls, ...itemsDB.misc];
                    break;
            }
            
            items.forEach(item => {
                const itemElem = document.createElement('div');
                itemElem.className = 'shop-item';
                itemElem.innerHTML = `${item.name} - ${item.cost} gold`;
                itemElem.onclick = () => selectShopItem(item);
                itemsContainer.appendChild(itemElem);
            });
        }

        function selectShopItem(item) {
            let description = `<strong>${item.name}</strong><br>`;
            description += `${item.type.toUpperCase()}<br>`;
            description += `${item.damage ? `Damage: ${item.damage}<br>` : ''}`;
            description += `${item.ac ? `AC: +${item.ac}<br>` : ''}`;
            description += `${item.effect ? `Effect: ${item.effect}<br>` : ''}`;
            description += `${item.hands ? `Hands: ${item.hands}<br>` : ''}`;
            description += `${item.bonus ? `Bonus: +${item.bonus}<br>` : ''}`;
            description += `${item.raceRestriction && item.raceRestriction.length > 0 ? `Restricted: ${item.raceRestriction.join(', ')}<br>` : ''}`;
            description += `Weight: ${item.weight || 0}<br>`;
            description += `Price: ${item.cost} gold`;
            
            document.getElementById('shop-description').innerHTML = description;
            
            gameState.selectedShopItem = item;
        }

        function buyItem() {
            if (!gameState.selectedShopItem) {
                addLog('Select an item first!', 'shop');
                return;
            }
            
            const item = gameState.selectedShopItem;
            
            // Check race restrictions
            const canBuy = gameState.party.some(char => 
                !item.raceRestriction || !item.raceRestriction.includes(char.raceId)
            );
            
            if (!canBuy) {
                addLog('No one in your party can use this item!', 'shop');
                return;
            }
            
            if (gameState.gold >= item.cost) {
                // Create a complete item copy
                const newItem = JSON.parse(JSON.stringify(item));
                
                // Ensure required properties
                newItem.uid = 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                if (!newItem.quantity) newItem.quantity = 1;
                
                // Add to inventory
                const result = inventorySystem.addItem(newItem);
                
                if (result.success) {
                    gameState.gold -= item.cost;
                    addLog(`Bought ${item.name} for ${item.cost} gold.`, 'shop');
                    
                    // Update displays
                    updateDisplay();
                    renderShop();
                    renderInventory();
                } else {
                    addLog(result.message, 'shop');
                }
            } else {
                addLog('Not enough gold!', 'shop');
            }
        }

        function sellItem() {
            if (!gameState.selectedInventoryItem) {
                addLog('Select an item from inventory first!', 'shop');
                return;
            }
            
            const item = inventorySystem.getItem(gameState.selectedInventoryItem);
            if (!item) {
                addLog('Item not found!', 'shop');
                return;
            }
            
            const sellPrice = Math.floor((item.cost || 10) * 0.5);
            gameState.gold += sellPrice;
            inventorySystem.removeItem(item.uid);
            
            addLog(`Sold ${item.name} for ${sellPrice} gold.`, 'shop');
            updateDisplay();
            renderShop();
            renderInventory();
        }

        function exitShop() {
            // Clear shop selection
            gameState.selectedShopItem = null;
            gameState.selectedInventoryItem = null;
            
            // Go back to town
            switchView('town');
            addLog('You leave the shop.', 'town');
            
            // Force update inventory display
            setTimeout(() => {
                if (gameState.screen === 'inventory') {
                    renderInventory();
                }
            }, 100);
        }

        function enterTemple() {
            addLog('The temple is a place of peace and healing.', 'town');
            
            const healCost = 50;
            const cureCost = 100;
            const resCost = 500;
            
            const choice = prompt('Choose: 1) Heal (50g), 2) Cure Poison (100g), 3) Resurrect (500g)');
            
            switch(choice) {
                case '1':
                    if (gameState.gold >= healCost) {
                        gameState.gold -= healCost;
                        gameState.party.forEach(char => {
                            char.hp = char.maxHp;
                            char.mp = char.maxMp;
                        });
                        addLog('Your party is completely healed!', 'town');
                        updateDisplay();
                        updatePartyStatus();
                    } else {
                        addLog('Not enough gold for healing!', 'town');
                    }
                    break;
                case '2':
                    if (gameState.gold >= cureCost) {
                        gameState.gold -= cureCost;
                        gameState.party.forEach(char => {
                            char.poisoned = false;
                        });
                        addLog('All poisons cured!', 'town');
                        updateDisplay();
                    } else {
                        addLog('Not enough gold!', 'town');
                    }
                    break;
                case '3':
                    addLog('Resurrection not implemented yet.', 'town');
                    break;
            }
        }

        function enterCastle() {
            addLog('You stand before the throne of Lord British.', 'town');
            addLog('"Welcome, brave adventurers! Seek the Marks of Virtue to defeat Exodus."', 'town');
            
            // Offer quest if not already taken
            if (!questSystem.quests.find(q => q.id === 'marks')) {
                if (confirm('Accept the quest to find the Marks of Virtue?')) {
                    questSystem.addQuest('marks');
                    addLog('Quest accepted: Find the eight Marks of Virtue!', 'town');
                }
            }
            
            // Offer dragon slayer quest if in Britain
            if (gameState.currentTown.name === 'Britain' && !questSystem.quests.find(q => q.id === 'dragons')) {
                if (confirm('Accept quest to slay the dragon in Destard?')) {
                    questSystem.addQuest('dragons');
                    addLog('Quest accepted: Slay the Dragon of Destard!', 'town');
                }
            }
        }

        // ====================
        // DUNGEON FUNCTIONS
        // ====================
        function enterDungeon() {
            // Find which dungeon we're at
            let dungeonId = null;
            for (const id in dungeonsDB) {
                const dungeon = dungeonsDB[id];
                if (dungeon.entrance.x === gameState.location.x && 
                    dungeon.entrance.y === gameState.location.y) {
                    dungeonId = id;
                    break;
                }
            }
            
            if (!dungeonId) {
                dungeonId = 'destard'; // Default
            }
            
            dungeonSystem = new DungeonSystem(dungeonId);
            gameState.currentDungeon = dungeonId;
            
            switchView('dungeon');
            addLog(`You enter ${dungeonSystem.dungeon.name}.`, 'dungeon');
        }

        function renderDungeon() {
            document.getElementById('dungeon-name').textContent = dungeonSystem.dungeon.name;
            document.getElementById('dungeon-level').textContent = dungeonSystem.currentLevel;
            
            const view = dungeonSystem.renderView();
            document.getElementById('dungeon-view').textContent = view;
        }

        function moveDungeon(action) {
            if (action === 'forward') {
                if (dungeonSystem.moveForward()) {
                    addLog('You move forward.', 'dungeon');
                    
                    // Check for traps
                    if (Math.random() < 0.2) {
                        const trapDamage = Math.floor(Math.random() * 10) + 5;
                        gameState.party[0].hp -= trapDamage;
                        addLog(`Triggered a trap! ${gameState.party[0].name} takes ${trapDamage} damage!`, 'dungeon');
                        updatePartyStatus();
                    }
                    
                    // Check for encounters
                    if (Math.random() < 0.4) {
                        startDungeonCombat();
                    }
                } else {
                    addLog('You cannot move in that direction.', 'dungeon');
                }
            }
            
            renderDungeon();
        }

        function turnDungeon(direction) {
            if (direction === 'left') {
                dungeonSystem.turnLeft();
                addLog('You turn left.', 'dungeon');
            } else {
                dungeonSystem.turnRight();
                addLog('You turn right.', 'dungeon');
            }
            
            renderDungeon();
        }

        function searchDungeon() {
            addLog('You search the area...', 'dungeon');
            
            const roll = Math.random();
            if (roll < 0.3) {
                const gold = Math.floor(Math.random() * 100) + 50;
                gameState.gold += gold;
                addLog(`Found ${gold} gold!`, 'dungeon');
                updateDisplay();
            } else if (roll < 0.4) {
                const potionIndex = Math.floor(Math.random() * itemsDB.potions.length);
                const potion = {...itemsDB.potions[potionIndex]};
                potion.uid = 'item_' + Date.now() + '_' + Math.random();
                potion.quantity = 1;
                const result = inventorySystem.addItem(potion);
                if (result.success) {
                    addLog(`Found a ${potion.name}!`, 'dungeon');
                    renderInventory();
                }
            } else if (roll < 0.45) {
                const weaponIndex = Math.floor(Math.random() * itemsDB.weapons.length);
                const weapon = {...itemsDB.weapons[weaponIndex]};
                weapon.uid = 'item_' + Date.now() + '_' + Math.random();
                weapon.quantity = 1;
                const result = inventorySystem.addItem(weapon);
                if (result.success) {
                    addLog(`Found a ${weapon.name}!`, 'dungeon');
                    renderInventory();
                }
            } else {
                addLog('You find nothing of value.', 'dungeon');
            }
        }

        function retreatDungeon() {
            if (confirm('Retreat from the dungeon?')) {
                switchView('explore');
                addLog('You exit the dungeon.', 'explore');
            }
        }

        // ====================
        // DUNGEON SYSTEM CLASS
        // ====================
        class DungeonSystem {
            constructor(dungeonId) {
                this.dungeon = dungeonsDB[dungeonId];
                this.currentLevel = 1;
                this.playerPosition = { x: 0, y: 0 };
                this.direction = 'north';
                this.map = this.generateLevel();
                this.visited = new Set();
                this.lightRadius = 3;
                this.torchDuration = 0;
            }
            
            generateLevel() {
                const size = 16;
                let map = Array(size).fill().map(() => Array(size).fill('#'));
                
                // Generate rooms
                this.generateRooms(map);
                // Generate corridors
                this.generateCorridors(map);
                // Place features
                this.placeFeatures(map);
                
                return map;
            }
            
            generateRooms(map) {
                const rooms = [];
                const numRooms = 5 + Math.floor(Math.random() * 4);
                
                for (let i = 0; i < numRooms; i++) {
                    const width = 3 + Math.floor(Math.random() * 4);
                    const height = 3 + Math.floor(Math.random() * 4);
                    const x = 1 + Math.floor(Math.random() * (14 - width));
                    const y = 1 + Math.floor(Math.random() * (14 - height));
                    
                    rooms.push({ x, y, width, height });
                    
                    // Carve room
                    for (let dx = 0; dx < width; dx++) {
                        for (let dy = 0; dy < height; dy++) {
                            map[y + dy][x + dx] = '.';
                        }
                    }
                }
                
                this.rooms = rooms;
            }
            
            generateCorridors(map) {
                // Simple corridor generation (connect rooms)
                for (let i = 1; i < this.rooms.length; i++) {
                    const prev = this.rooms[i-1];
                    const curr = this.rooms[i];
                    
                    const startX = Math.floor(prev.x + prev.width / 2);
                    const startY = Math.floor(prev.y + prev.height / 2);
                    const endX = Math.floor(curr.x + curr.width / 2);
                    const endY = Math.floor(curr.y + curr.height / 2);
                    
                    // Horizontal then vertical
                    for (let x = Math.min(startX, endX); x <= Math.max(startX, endX); x++) {
                        map[startY][x] = '.';
                    }
                    for (let y = Math.min(startY, endY); y <= Math.max(startY, endY); y++) {
                        map[y][endX] = '.';
                    }
                }
            }
            
            placeFeatures(map) {
                // Place stairs down
                const firstRoom = this.rooms[0];
                const stairX = Math.floor(firstRoom.x + firstRoom.width / 2);
                const stairY = Math.floor(firstRoom.y + firstRoom.height / 2);
                map[stairY][stairX] = '>';
                
                // Place stairs up (if not first level)
                if (this.currentLevel > 1) {
                    const lastRoom = this.rooms[this.rooms.length - 1];
                    const upX = Math.floor(lastRoom.x + lastRoom.width / 2);
                    const upY = Math.floor(lastRoom.y + lastRoom.height / 2);
                    map[upY][upX] = '<';
                }
                
                // Place treasure
                for (let i = 0; i < 3; i++) {
                    const room = this.rooms[Math.floor(Math.random() * this.rooms.length)];
                    const x = room.x + Math.floor(Math.random() * room.width);
                    const y = room.y + Math.floor(Math.random() * room.height);
                    map[y][x] = '$';
                }
            }
            
            moveForward() {
                const newPos = { ...this.playerPosition };
                switch(this.direction) {
                    case 'north': newPos.y--; break;
                    case 'south': newPos.y++; break;
                    case 'east': newPos.x++; break;
                    case 'west': newPos.x--; break;
                }
                
                if (this.isPassable(newPos)) {
                    this.playerPosition = newPos;
                    this.visited.add(`${newPos.x},${newPos.y}`);
                    
                    // Check for special features
                    const cell = this.map[newPos.y][newPos.x];
                    if (cell === '>') {
                        this.goDown();
                        return false;
                    } else if (cell === '<') {
                        this.goUp();
                        return false;
                    } else if (cell === '$') {
                        this.findTreasure(newPos);
                    }
                    
                    return true;
                }
                return false;
            }
            
            turnLeft() {
                const directions = ['north', 'west', 'south', 'east'];
                const currentIndex = directions.indexOf(this.direction);
                this.direction = directions[(currentIndex + 1) % 4];
            }
            
            turnRight() {
                const directions = ['north', 'east', 'south', 'west'];
                const currentIndex = directions.indexOf(this.direction);
                this.direction = directions[(currentIndex + 1) % 4];
            }
            
            isPassable(pos) {
                if (pos.x < 0 || pos.x >= 16 || pos.y < 0 || pos.y >= 16) return false;
                return this.map[pos.y][pos.x] !== '#';
            }
            
            renderView() {
                let view = '';
                const depth = 8;
                
                for (let d = 0; d < depth; d++) {
                    let line = '';
                    for (let offset = -2; offset <= 2; offset++) {
                        const cell = this.getCellAt(d, offset);
                        line += this.getCellChar(cell, d);
                    }
                    view += line + '\n';
                }
                
                // Add player indicator
                view += '\nDirection: ' + this.direction.toUpperCase();
                view += '\nLevel: ' + this.currentLevel;
                if (this.torchDuration > 0) {
                    view += '\nTorch: ' + this.torchDuration + ' turns';
                }
                
                return view;
            }
            
            getCellAt(distance, offset) {
                let x = this.playerPosition.x;
                let y = this.playerPosition.y;
                
                // Calculate position based on direction and offset
                for (let step = 0; step < distance; step++) {
                    switch(this.direction) {
                        case 'north':
                            y--;
                            x += offset;
                            break;
                        case 'south':
                            y++;
                            x += offset;
                            break;
                        case 'east':
                            x++;
                            y += offset;
                            break;
                        case 'west':
                            x--;
                            y += offset;
                            break;
                    }
                }
                
                if (x < 0 || x >= 16 || y < 0 || y >= 16) return '#';
                return this.map[y][x];
            }
            
            getCellChar(cell, distance) {
                const visible = this.torchDuration > 0 ? distance <= this.lightRadius + 2 : distance <= this.lightRadius;
                
                if (!visible) {
                    const chars = ['  ', '  ', '¬∑¬∑', '¬∑¬∑', '‚ñë‚ñë', '‚ñí‚ñí', '‚ñì‚ñì', '‚ñà‚ñà'];
                    return chars[Math.min(distance, 7)];
                }
                
                const chars = {
                    '#': ['‚ñì‚ñì', '‚ñì‚ñì', '‚ñí‚ñí', '‚ñí‚ñí', '‚ñë‚ñë', '¬∑¬∑', '¬∑¬∑', '  '],
                    '.': ['  ', '  ', '  ', '  ', '  ', '  ', '  ', '  '],
                    '>': ['‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì', '‚Üì‚Üì'],
                    '<': ['‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë', '‚Üë‚Üë'],
                    '$': ['$$', '$$', '$$', '$$', '$$', '$$', '$$', '$$'],
                    '@': ['@@', '@@', '@@', '@@', '@@', '@@', '@@', '@@']
                };
                
                const index = Math.min(distance, 7);
                return chars[cell] ? chars[cell][index] : '??';
            }
            
            goDown() {
                if (this.currentLevel < this.dungeon.levels) {
                    this.currentLevel++;
                    this.playerPosition = { x: 0, y: 0 };
                    this.map = this.generateLevel();
                    addLog(`Descended to level ${this.currentLevel}`, 'dungeon');
                } else {
                    addLog('This is the deepest level!', 'dungeon');
                }
            }
            
            goUp() {
                if (this.currentLevel > 1) {
                    this.currentLevel--;
                    this.playerPosition = { x: 0, y: 0 };
                    this.map = this.generateLevel();
                    addLog(`Ascended to level ${this.currentLevel}`, 'dungeon');
                } else {
                    switchView('explore');
                    addLog('You exit the dungeon.', 'explore');
                }
            }
            
            findTreasure(pos) {
                this.map[pos.y][pos.x] = '.';
                
                const treasure = Math.random();
                if (treasure < 0.6) {
                    const gold = Math.floor(Math.random() * 200) + 100;
                    gameState.gold += gold;
                    addLog(`Found ${gold} gold!`, 'dungeon');
                    updateDisplay();
                } else if (treasure < 0.9) {
                    const itemType = Math.random() < 0.5 ? 'potion' : 'weapon';
                    const items = itemType === 'potion' ? itemsDB.potions : itemsDB.weapons;
                    const item = {...items[Math.floor(Math.random() * items.length)]};
                    item.uid = 'item_' + Date.now() + '_' + Math.random();
                    item.quantity = 1;
                    const result = inventorySystem.addItem(item);
                    if (result.success) {
                        addLog(`Found a ${item.name}!`, 'dungeon');
                        renderInventory();
                    }
                } else {
                    const specialItem = { 
                        id: 'artifact' + Date.now(), 
                        name: 'Ancient Artifact', 
                        type: 'artifact', 
                        weight: 1,
                        uid: 'item_' + Date.now() + '_' + Math.random(),
                        quantity: 1
                    };
                    const result = inventorySystem.addItem(specialItem);
                    if (result.success) {
                        addLog('Found an ancient artifact!', 'dungeon');
                        renderInventory();
                    }
                }
            }
        }

        // ====================
        // UTILITY FUNCTIONS
        // ====================
        function updateDisplay() {
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('food').textContent = gameState.food;
            document.getElementById('turn').textContent = gameState.turn;
            document.getElementById('day').textContent = gameState.day;
            document.getElementById('time').textContent = gameState.time;
            document.getElementById('location').textContent = gameState.location.name;
            document.getElementById('current-loc-name').textContent = gameState.location.name;
        }

        function updatePartyStatus() {
            const container = document.getElementById('party-status');
            container.innerHTML = '';
            
            gameState.party.forEach((char, index) => {
                const charClass = classes.find(c => c.id === char.classId);
                const charRace = races.find(r => r.id === char.raceId);
                const hpPercent = Math.floor((char.hp / char.maxHp) * 100);
                const mpPercent = char.maxMp > 0 ? Math.floor((char.mp / char.maxMp) * 100) : 0;
                
                container.innerHTML += `
                    <div class="character-card ${charClass?.color || ''}" onclick="selectCharacter(${index})">
                        <strong>${char.name}</strong> Lvl ${char.level}<br>
                        ${charRace?.name || ''} ${charClass?.name || ''}<br>
                        HP: <div class="progress-bar"><div class="progress-fill" style="width: ${hpPercent}%"></div></div>
                        ${char.maxMp > 0 ? 
                            `MP: <div class="progress-bar"><div class="progress-fill" style="width: ${mpPercent}%"></div></div>` : ''}
                        XP: ${char.xp}<br>
                        ${char.equipment?.weapon?.name || 'Unarmed'}
                        ${char.poisoned ? '<div style="color:#0f0">POISONED</div>' : ''}
                        <div style="font-size:9px;color:#6af">
                            Spells: ${magicSystem.getMemorizedSpells(char).length}/${magicSystem.getSpellSlots(char)}
                        </div>
                    </div>
                `;
            });
        }

        function addLog(message, screen) {
            const logElem = document.getElementById(`${screen}-log`);
            if (logElem) {
                logElem.innerHTML += `> ${message}<br>`;
                logElem.scrollTop = logElem.scrollHeight;
            }
            
            // Also show notification for important messages
            if (screen === 'explore' || screen === 'combat') {
                showNotification(message);
            }
        }

        function showNotification(message) {
            const notificationArea = document.getElementById('notification-area');
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notificationArea.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function saveGame() {
            const saveData = {
                party: gameState.party,
                gold: gameState.gold,
                food: gameState.food,
                turn: gameState.turn,
                day: gameState.day,
                time: gameState.time,
                location: gameState.location,
                worldMap: gameState.worldMap,
                inventory: inventorySystem.items,
                quests: questSystem.quests,
                reputation: gameState.reputation,
                timestamp: Date.now()
            };
            
            localStorage.setItem('ultima3_save', JSON.stringify(saveData));
            addLog('Game saved successfully!', 'explore');
        }

        function loadGame() {
            const saveData = JSON.parse(localStorage.getItem('ultima3_save'));
            if (!saveData) {
                addLog('No save game found!', 'creation');
                return;
            }
            
            // Restore game state
            Object.assign(gameState, saveData);
            
            // Restore systems
            inventorySystem.items = saveData.inventory || [];
            inventorySystem.currentWeight = saveData.inventory.reduce((sum, item) => sum + (item.weight || 0), 0);
            questSystem.quests = saveData.quests || [];
            
            addLog(`Game loaded from ${new Date(saveData.timestamp).toLocaleString()}`, 'creation');
            renderPartyCreation();
            updateDisplay();
        }

        function quickSave() {
            saveGame();
            showNotification('Quick Save Complete!');
        }

        function quickLoad() {
            if (confirm('Load last saved game? Progress since last save will be lost.')) {
                loadGame();
                switchView('explore');
                renderWorldMap();
                updatePartyStatus();
                updateMinimap();
            }
        }

        function resetGame() {
            gameState.party = [];
            gameState.gold = 150;
            gameState.food = 100;
            gameState.turn = 1;
            gameState.day = 1;
            gameState.time = 'MORNING';
            gameState.location = { x: 5, y: 5, name: 'Britain', type: 'town' };
            gameState.inCombat = false;
            
            inventorySystem.items = [];
            inventorySystem.currentWeight = 0;
            questSystem.quests = [];
            magicSystem.memorizedSpells = {};
            
            generateWorldMap();
            switchView('creation');
            renderPartyCreation();
            updateDisplay();
            
            addLog('Game reset to beginning.', 'creation');
        }

        function setupEventListeners() {
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (gameState.screen === 'explore') {
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            moveParty('north');
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            moveParty('south');
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            moveParty('west');
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            moveParty('east');
                            break;
                        case 'i':
                        case 'I':
                            switchView('inventory');
                            break;
                        case 'c':
                        case 'C':
                            switchView('character');
                            break;
                        case 'q':
                        case 'Q':
                            switchView('quests');
                            break;
                        case ' ':
                        case 'Enter':
                            enterLocation();
                            break;
                        case 's':
                        case 'S':
                            if (e.ctrlKey) saveGame();
                            break;
                    }
                } else if (gameState.screen === 'dungeon') {
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            moveDungeon('forward');
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            turnDungeon('left');
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            turnDungeon('right');
                            break;
                    }
                } else if (gameState.screen === 'combat') {
                    switch(e.key) {
                        case '1':
                            setCombatAction('attack');
                            break;
                        case '2':
                            setCombatAction('spell');
                            break;
                        case '3':
                            setCombatAction('item');
                            break;
                        case '4':
                            setCombatAction('defend');
                            break;
                        case '5':
                            setCombatAction('flee');
                            break;
                        case ' ':
                        case 'Enter':
                            executeCombatAction();
                            break;
                        case 'Tab':
                            setCombatCharacter((gameState.combatSelectedChar + 1) % gameState.party.length);
                            break;
                    }
                }
            });
            
            // Tooltip system
            document.addEventListener('mousemove', (e) => {
                const tooltip = document.getElementById('tooltip');
                const target = e.target;
                
                if (target.title && target.title !== '') {
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.pageX + 10) + 'px';
                    tooltip.style.top = (e.pageY + 10) + 'px';
                    tooltip.textContent = target.title;
                } else {
                    tooltip.style.display = 'none';
                }
            });
        }

        // ====================
        // START THE GAME
        // ====================
        window.onload = initGame;

        // Export functions to global scope
        window.startGame = startGame;
        window.resetParty = resetParty;
        window.loadGame = loadGame;
        window.switchView = switchView;
        window.moveParty = moveParty;
        window.enterLocation = enterLocation;
        window.exitShop = exitShop;
        window.restParty = function() {
            if (gameState.inCombat) {
                addLog('Cannot rest while in combat!', 'explore');
                return;
            }
            
            gameState.party.forEach(char => {
                char.hp = Math.min(char.maxHp, char.hp + Math.floor(char.maxHp * 0.2));
                char.mp = Math.min(char.maxMp, char.mp + Math.floor(char.maxMp * 0.3));
            });
            
            gameState.food -= 5;
            updateTime();
            addLog('Party rests for a while.', 'explore');
            updatePartyStatus();
            updateDisplay();
        };
        window.searchArea = function() {
            const tile = gameState.worldMap[gameState.location.y][gameState.location.x];
            const roll = Math.random();
            
            if (roll < 0.3) {
                const gold = Math.floor(Math.random() * 50) + 10;
                gameState.gold += gold;
                addLog(`Found ${gold} gold while searching!`, 'explore');
                updateDisplay();
            } else if (roll < 0.35) {
                const potionIndex = Math.floor(Math.random() * itemsDB.potions.length);
                const potion = {...itemsDB.potions[potionIndex]};
                potion.uid = 'item_' + Date.now() + '_' + Math.random();
                potion.quantity = 1;
                const result = inventorySystem.addItem(potion);
                if (result.success) {
                    addLog(`Found a ${potion.name}!`, 'explore');
                    renderInventory();
                }
            } else {
                addLog('You find nothing of value.', 'explore');
            }
        };
        window.checkStatus = function() {
            let status = 'Party Status:\n';
            gameState.party.forEach(char => {
                const race = races.find(r => r.id === char.raceId);
                status += `${char.name}: ${race?.name || ''} Level ${char.level}\n`;
                status += `HP: ${char.hp}/${char.maxHp}, MP: ${char.mp}/${char.maxMp}\n`;
                status += `Spells: ${magicSystem.getMemorizedSpells(char).length}/${magicSystem.getSpellSlots(char)}\n`;
            });
            status += `\nGold: ${gameState.gold}\nFood: ${gameState.food}\nDay: ${gameState.day}`;
            alert(status);
        };
        window.playerAttack = function() {
            setCombatAction('attack');
        };
        window.playerCastSpell = function() {
            setCombatAction('spell');
        };
        window.playerUseItem = function() {
            setCombatAction('item');
        };
        window.playerFlee = function() {
            setCombatAction('flee');
        };
        window.playerDefend = function() {
            setCombatAction('defend');
        };
        window.saveGame = saveGame;
        window.quickSave = quickSave;
        window.quickLoad = quickLoad;
        window.selectCharacter = selectCharacter;
        window.prevCharacter = function() {
            gameState.selectedChar = (gameState.selectedChar - 1 + gameState.party.length) % gameState.party.length;
            renderCharacterSheet();
        };
        window.nextCharacter = function() {
            gameState.selectedChar = (gameState.selectedChar + 1) % gameState.party.length;
            renderCharacterSheet();
        };
        window.trainCharacter = function() {
            const cost = 100 * gameState.party[gameState.selectedChar].level;
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                const char = gameState.party[gameState.selectedChar];
                char.xp += 500;
                if (checkLevelUp(char)) {
                    addLog('Training successful!', 'character');
                } else {
                    addLog('Training complete.', 'character');
                }
                updateDisplay();
                renderCharacterSheet();
            } else {
                addLog(`Need ${cost} gold for training!`, 'character');
            }
        };
        window.enterBuilding = enterBuilding;
        window.gatherRumors = function() {
            const rumors = [
                'Exodus waits in the deepest dungeon.',
                'The Marks open the way to the final battle.',
                'Beware the dragon in Destard!',
                'Moongates can transport you instantly.',
                'Keep your torches lit in dungeons.',
                'The undead fear holy weapons.',
                'Potions can save your life in battle.',
                'Upgrade your equipment regularly.'
            ];
            const rumor = rumors[Math.floor(Math.random() * rumors.length)];
            addLog(`Rumor: "${rumor}"`, 'town');
        };
        window.donateToTemple = function() {
            const donateAmount = 100;
            if (gameState.gold >= donateAmount) {
                gameState.gold -= donateAmount;
                gameState.reputation += 10;
                addLog(`Donated ${donateAmount} gold. Reputation +10!`, 'town');
                updateDisplay();
            } else {
                addLog(`Need ${donateAmount} gold to donate.`, 'town');
            }
        };
        window.buyItem = buyItem;
        window.sellItem = sellItem;
        window.moveDungeon = moveDungeon;
        window.turnDungeon = turnDungeon;
        window.searchDungeon = searchDungeon;
        window.useTorch = function() {
            const torch = inventorySystem.items.find(i => i.id === 'torch');
            if (torch) {
                dungeonSystem.torchDuration = 20;
                dungeonSystem.lightRadius = 5;
                inventorySystem.removeItem(torch.uid);
                addLog('Torch lit! Visibility increased.', 'dungeon');
                renderDungeon();
                renderInventory();
            } else {
                addLog('No torches in inventory!', 'dungeon');
            }
        };
        window.retreatDungeon = retreatDungeon;
        window.sortInventory = function() {
            inventorySystem.sort();
            renderInventory();
            addLog('Inventory sorted.', 'inventory');
        };
        window.useSelectedItem = useSelectedItem;
        window.dropSelectedItem = dropSelectedItem;
        window.unequip = function(charIndex, slotType) {
            unequipItem(charIndex, slotType);
        };
        window.unequipAll = unequipAll;
        window.equipItemToSlot = equipItemToSlot;
        window.memorizeSpells = function() {
            addLog('Use the spell memorization section above.', 'spells');
        };
        window.researchSpell = function() {
            addLog('Spell research requires a magic laboratory.', 'spells');
        };
        window.abandonQuest = function() {
            const activeQuests = questSystem.getActiveQuests();
            if (activeQuests.length > 0) {
                const questNames = activeQuests.map(q => q.name).join(', ');
                if (confirm(`Abandon which quest?\n${questNames}`)) {
                    addLog('Quest abandoned.', 'quests');
                }
            } else {
                addLog('No quests to abandon.', 'quests');
            }
        };
        window.showTutorial = function() {
            alert(`ULTIMA III ENHANCED - CONTROLS:
            
Exploration:
Arrow Keys or WASD - Move party
Space or Enter - Enter locations/towns
I - Inventory
C - Character Sheet
Q - Quest Log
R - Rest

Inventory:
Click items to select
Click character buttons (1-4) to switch heroes
Click equipment slots to equip selected item
Use/Drop buttons for selected item

Combat:
1-5 - Select action (Attack, Spell, Item, Defend, Flee)
Tab - Cycle through party members
Click - Select targets
Space/Enter - Execute action

Dungeons:
Arrow Keys - Move/Turn
Space - Search
T - Use Torch

Spells:
Characters must MEMORIZE spells before casting
Rest to refresh memorization slots
Different races have different abilities

Racial Traits:
Humans: +10% XP gain
Elves: Magic resistance, night vision
Dwarves: Poison resistance, axe bonuses
Bobbits: Extra treasure, stealth bonuses

General:
Ctrl+S - Quick Save
F5 - Quick Load
Save often!
Watch food and encumbrance.`);
        };
        window.setCombatAction = setCombatAction;
        window.setCombatCharacter = setCombatCharacter;
        window.executeCombatAction = executeCombatAction;
        window.selectCombatTarget = selectCombatTarget;
        window.selectSpellForMemorization = selectSpellForMemorization;
        window.memorizeSelectedSpell = memorizeSelectedSpell;
        window.clearSpellSlot = clearSpellSlot;
        window.restToMemorize = restToMemorize;
        window.selectSpellSlot = function(index) {
            // Handle spell slot selection if needed
        };

        // Debug function
        window.debugInventory = function() {
            console.log('=== INVENTORY DEBUG ===');
            console.log('Items:', inventorySystem.items);
            console.log('Count:', inventorySystem.items.length);
            console.log('Weight:', inventorySystem.getWeight(), '/', inventorySystem.getCapacity());
            console.log('Gold:', gameState.gold);
            console.log('Food:', gameState.food);
            alert(`Inventory Debug:\nItems: ${inventorySystem.items.length}\nWeight: ${inventorySystem.getWeight()}/${inventorySystem.getCapacity()}`);
        };
    </script>
</body>
</html>
