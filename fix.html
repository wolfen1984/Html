 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Binder's Legacy - Complete Necromancer RPG</title>
    <style>
        /* All existing styles remain the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background-color: black;
            color: #2bed4e;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(138, 43, 232, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(75, 0, 130, 0.1) 0%, transparent 20%);
        }
        
        #game-container {
            width: 100%;
            max-width: 500px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border: 2px solid #149c2d;
            background-color: black;
            position: relative;
            box-shadow: 0 0 20px rgba(138, 43, 232, 0.5);
            overflow: hidden;
        }
        
        .screen {
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            padding: 10px;
            overflow-y: auto;
        }
        
        .active {
            display: flex;
        }
        
        h1, h2, h3 {
            color: #8a2be8;
            text-align: center;
            margin: 10px 0;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(138, 43, 232, 0.7);
        }
        
        .button {
            background-color: #0f0f1a;
            color: #8a2be8;
            border: 1px solid #8a2be8;
            padding: 10px;
            margin: 5px 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .button:hover {
            background-color: #8a2be8;
            color: #0f0f1a;
            box-shadow: 0 0 10px rgba(138, 43, 232, 0.7);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .button.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            border-bottom: 1px dashed #8a2be8;
            padding-bottom: 10px;
        }
        
        .log {
            border: 1px solid #8a2be8;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            font-size: 14px;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .log-entry {
            margin: 5px 0;
        }
        
        .inventory-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .item {
            border: 1px solid #8a2be8;
            padding: 8px;
            cursor: pointer;
            position: relative;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .item-stats {
            font-size: 12px;
            margin-top: 5px;
        }
        
        .equipment-slots {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .equipment-slot {
            border: 1px solid #8a2be8;
            padding: 8px;
            min-height: 60px;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .equipment-stats {
            font-size: 12px;
            margin-top: 5px;
        }
        
        .enemy {
            text-align: center;
            margin: 20px 0;
            font-size: 24px;
            position: relative;
        }
        
        .battle-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .spell-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
            margin: 10px 0;
        }
        
        .spell-item {
            border: 1px solid #8a2be8;
            padding: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .spell-info {
            flex: 1;
        }
        
        .spell-cost {
            color: #00ffff;
            margin-left: 10px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #000;
            border: 1px solid #8a2be8;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }
        
        .hp-bar .progress-fill {
            background-color: #ff5555;
        }
        
        .mana-bar .progress-fill {
            background-color: #5555ff;
        }
        
        .souls-bar .progress-fill {
            background-color: #4b0082;
        }
        
        .class-select {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }
        
        .class-option {
            border: 1px solid #8a2be8;
            padding: 15px;
            cursor: pointer;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .class-option:hover {
            background-color: #8a2be8;
            color: #0f0f1a;
        }
        
        .minion-display {
            display: flex;
            justify-content: space-around;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .minion-slot {
            border: 1px solid #8a2be8;
            padding: 5px;
            margin: 5px;
            min-width: 80px;
            text-align: center;
            background-color: rgba(15, 15, 26, 0.8);
            position: relative;
        }
        
        .minion-health {
            font-size: 10px;
            color: #ff5555;
        }
        
        .minion-level {
            font-size: 10px;
            color: #00ffff;
        }
        
        .soul-counter {
            color: #00ffff;
            font-weight: bold;
        }
        
        .necromancy-button {
            background: linear-gradient(45deg, #4b0082, #8a2be8);
            color: white;
            border: 1px solid #00ffff;
        }
        
        .floating-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            z-index: 100;
            animation: floatUp 1s ease-out forwards;
        }
        
        .damage-text {
            color: #ff5555;
        }
        
        .heal-text {
            color: #55ff55;
        }
        
        .soul-text {
            color: #00ffff;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .rarity-common { color: #fff; }
        .rarity-uncommon { color: #1eff00; }
        .rarity-rare { color: #0070dd; }
        .rarity-epic { color: #a335ee; }
        .rarity-legendary { color: #ff8000; }
        .rarity-mythic { color: #e5cc80; }
        
        .tooltip {
            position: absolute;
            background: #0f0f1a;
            border: 1px solid #8a2be8;
            padding: 8px;
            z-index: 1000;
            max-width: 250px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip.show {
            opacity: 1;
        }
        
        .battle-bars {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin: 10px 0;
        }
        
        .battle-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .battle-bar-label {
            width: 60px;
            font-size: 12px;
        }
        
        .battle-bar {
            flex: 1;
            height: 15px;
            background-color: #000;
            border: 1px solid #8a2be8;
            position: relative;
            overflow: hidden;
        }
        
        .battle-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .hp-fill {
            background-color: #ff5555;
        }
        
        .mana-fill {
            background-color: #5555ff;
        }
        
        /* Minion Management Styles */
        .minion-management {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .minion-details {
            border: 1px solid #8a2be8;
            padding: 10px;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .minion-equipment {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        
        .minion-equip-slot {
            border: 1px dashed #8a2be8;
            padding: 5px;
            text-align: center;
            font-size: 10px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Enchanting Styles */
        .enchanting-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .enchant-slot {
            border: 1px solid #8a2be8;
            padding: 10px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(15, 15, 26, 0.8);
            cursor: pointer;
        }
        
        .enchant-slot.selected {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        
        .enchant-preview {
            border: 1px solid #00ffff;
            padding: 10px;
            margin: 10px 0;
            background-color: rgba(0, 255, 255, 0.1);
        }
        
        /* Rune Styles */
        .rune-socket {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 1px solid #8a2be8;
            border-radius: 50%;
            margin: 0 2px;
            position: relative;
            background: #1a1a2a;
        }
        
        .rune-socket.filled {
            background: radial-gradient(circle, #8a2be8, #4b0082);
        }
        
        .rune-item {
            border: 1px solid #8a2be8;
            padding: 5px;
            margin: 2px;
            font-size: 10px;
            text-align: center;
            cursor: pointer;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #8a2be8;
            margin-bottom: 10px;
        }
        
        .tab {
            padding: 8px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 5px;
        }
        
        .tab.active {
            border-color: #8a2be8;
            background-color: rgba(138, 43, 232, 0.2);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .enhanced-button {
            background: linear-gradient(45deg, #4b0082, #8a2be8);
            color: white;
            border: 1px solid #00ffff;
            position: relative;
            overflow: hidden;
        }
        
        .enhanced-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .enhanced-button:hover::before {
            left: 100%;
        }
        
        /* Rune Socketing Modal */
        .rune-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0f0f1a;
            border: 2px solid #8a2be8;
            padding: 20px;
            z-index: 1000;
            max-width: 90%;
            max-height: 80%;
            overflow: auto;
            box-shadow: 0 0 20px rgba(138, 43, 232, 0.7);
        }
        
        .socketable-item {
            border: 1px solid #8a2be8;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .socketable-item:hover {
            background-color: rgba(138, 43, 232, 0.3);
        }
        
        /* Enchantable Items Grid */
        .enchantable-items-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .enchantable-item {
            border: 1px solid #8a2be8;
            padding: 8px;
            cursor: pointer;
            background-color: rgba(15, 15, 26, 0.8);
        }
        
        .enchantable-item:hover {
            border-color: #00ffff;
        }
        
        .enchantable-item.selected {
            border-color: #00ffff;
            background-color: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        /* Minion Management Modal Styles */
        .minion-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0f0f1a;
            border: 2px solid #8a2be8;
            padding: 20px;
            z-index: 1000;
            max-width: 90%;
            max-height: 80%;
            overflow: auto;
            box-shadow: 0 0 20px rgba(138, 43, 232, 0.7);
        }

      /* Necropolis Styles */
.city-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin: 10px 0;
    border-bottom: 1px dashed #8a2be8;
    padding-bottom: 10px;
}

.building-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin: 10px 0;
    max-height: 300px;
    overflow-y: auto;
}

.building-slot {
    border: 1px solid #8a2be8;
    padding: 15px;
    background-color: rgba(15, 15, 26, 0.8);
    text-align: center;
    min-height: 120px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.building-slot.under-construction {
    border-color: #00ffff;
    background-color: rgba(0, 255, 255, 0.1);
    animation: pulse 2s infinite;
}

.building-slot.unlocked {
    border-color: #1eff00;
}

.building-slot.locked {
    opacity: 0.6;
    background-color: rgba(15, 15, 26, 0.5);
}

.building-level {
    color: #00ffff;
    font-weight: bold;
}

.building-production {
    color: #1eff00;
    font-size: 12px;
}

.building-cost {
    color: #ff5555;
    font-size: 12px;
}

.construction-progress {
    height: 5px;
    background: #000;
    margin: 5px 0;
    border: 1px solid #8a2be8;
}

.construction-progress-fill {
    height: 100%;
    background: #00ffff;
    width: 0%;
    transition: width 0.3s;
}

.passive-income {
    border: 1px solid #8a2be8;
    padding: 10px;
    background-color: rgba(15, 15, 26, 0.8);
    margin: 10px 0;
}

.income-item {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    font-size: 14px;
}
      
        .minion-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .minion-stat {
            border: 1px solid #8a2be8;
            padding: 5px;
            text-align: center;
        }
        
        .minion-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .equipment-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0f0f1a;
            border: 2px solid #8a2be8;
            padding: 20px;
            z-index: 1000;
            max-width: 90%;
            max-height: 80%;
            overflow: auto;
            box-shadow: 0 0 20px rgba(138, 43, 232, 0.7);
        }
        
        .equipment-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Audio Controls */
        .audio-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .audio-btn {
            background: rgba(15, 15, 26, 0.8);
            border: 1px solid #8a2be8;
            color: #8a2be8;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .audio-btn:hover {
            background: #8a2be8;
            color: #0f0f1a;
        }
        
        /* NEW: Accessibility Controls */
        .accessibility-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        
        .accessibility-btn {
            background: rgba(15, 15, 26, 0.8);
            border: 1px solid #8a2be8;
            color: #8a2be8;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .accessibility-btn:hover {
            background: #8a2be8;
            color: #0f0f1a;
        }
        
        /* NEW: Font Size Classes */
        .font-small {
            font-size: 12px;
        }
        
        .font-medium {
            font-size: 14px;
        }
        
        .font-large {
            font-size: 16px;
        }
        
        .font-xlarge {
            font-size: 18px;
        }
        
        /* NEW: Tutorial Styles */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tutorial-box {
            background: #0f0f1a;
            border: 2px solid #8a2be8;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(138, 43, 232, 0.7);
        }
        
        .tutorial-highlight {
            position: relative;
            z-index: 1999;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5), 0 0 10px 2px #00ffff;
        }
        
        .tutorial-progress {
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            color: #8a2be8;
        }
        
        /* NEW: Health/Mana Warning Animations */
        .health-low {
            animation: pulse-warning 1s infinite;
        }
        
        .mana-low {
            animation: pulse-blue 1s infinite;
        }
        
        @keyframes pulse-warning {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(255, 0, 0, 0.2); }
        }
        
        @keyframes pulse-blue {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(0, 100, 255, 0.2); }
        }
        
        /* NEW: Defeat Screen Styles */
        #defeat-screen h2 {
            color: #ff5555;
            animation: pulse 2s infinite;
        }
        
        .defeat-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        
        .defeat-penalty {
            color: #ff5555;
            font-weight: bold;
        }
        
        .defeat-message {
            color: #8a2be8;
            text-align: center;
            margin: 10px 0;
        }

        /* UPDATED: Bigger runes display to match artifacts */
#runes-display {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px; /* Increased gap */
    margin: 10px 0;
}

#runes-display .rune-item {
    min-height: 100px; /* Match artifacts height */
    padding: 15px; /* Match artifacts padding */
    font-size: 16px; /* Match artifacts font size */
    border: 1px solid #8a2be8;
    text-align: center;
    cursor: pointer;
    background-color: rgba(15, 15, 26, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

/* NEW: Class-specific styling */
.class-deathknight { border-color: #aa0000; }
.class-shadowweaver { border-color: #333333; }
.class-fleshshaper { border-color: #ff6600; }

.class-deathknight:hover { background-color: #aa0000; }
.class-shadowweaver:hover { background-color: #333333; }
.class-fleshshaper:hover { background-color: #ff6600; }

/* NEW: Set item glow */
.set-item {
    border: 1px solid #ffd700 !important;
    box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
}

/* NEW: Legendary item animation */
.legendary-item {
    border: 2px solid #ff8000 !important;
    animation: legendary-glow 2s infinite alternate;
    box-shadow: 0 0 10px rgba(255, 128, 0, 0.7);
}

@keyframes legendary-glow {
    0% { box-shadow: 0 0 5px rgba(255, 128, 0, 0.5); }
    100% { box-shadow: 0 0 15px rgba(255, 128, 0, 1); }
}
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Audio Controls -->
        <div class="audio-controls">
            <button class="audio-btn" id="music-toggle">Music: ON</button>
            <button class="audio-btn" id="sfx-toggle">SFX: ON</button>
        </div>
        
        <!-- NEW: Accessibility Controls -->
        <div class="accessibility-controls">
            <button class="accessibility-btn" id="font-size-btn">Font: Medium</button>
            <button class="accessibility-btn" id="tutorial-btn">Tutorial</button>
        </div>
        
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <h1>SOUL BINDER'S LEGACY</h1>
            <h3>Necromancer RPG - PHASE 1 EXPANDED</h3>
            <div style="margin: 40px 0; text-align: center;">
                <p>In the shadowed halls of the forgotten necropolis,</p>
                <p>you awaken to the call of ancient powers.</p>
                <p>Master the arts of death and command the fallen.</p>
                <p style="color: #ff5555; margin-top: 20px;">NEW: 3 Classes • 20+ Spells • 5 Minion Types • Set Items</p>
            </div>
            <div class="button enhanced-button" id="start-button">BEGIN DARK JOURNEY</div>
            <div class="button" id="load-button">CONTINUE LEGACY</div>
        </div>
        
        <!-- Class Selection Screen -->
        <div id="class-screen" class="screen">
            <h1>CHOOSE YOUR PATH</h1>
            <div class="class-select">
                <div class="class-option" data-class="soulbinder">
                    <h3>SOUL BINDER</h3>
                    <p>Master of soul manipulation</p>
                    <p>Commands powerful spirits</p>
                    <p>Starts with Soul Bolt and Soul Shield</p>
                </div>
                <div class="class-option" data-class="boneweaver">
                    <h3>BONE WEAVER</h3>
                    <p>Creator of undead minions</p>
                    <p>Can raise skeletal warriors</p>
                    <p>Starts with Raise Skeleton and Bone Armor</p>
                </div>
                <div class="class-option" data-class="plaguemaster">
                    <h3>PLAGUE MASTER</h3>
                    <p>Wielder of decay and disease</p>
                    <p>Poisons and curses enemies</p>
                    <p>Starts with Plague Bolt and Decaying Touch</p>
                </div>
                <!-- NEW CLASSES -->
                <div class="class-option class-deathknight" data-class="deathknight">
                    <h3>DEATH KNIGHT</h3>
                    <p>Warrior-Necromancer hybrid</p>
                    <p>Frontline fighter with undead minions</p>
                    <p>Starts with Death Coil and Bone Shield</p>
                </div>
                <div class="class-option class-shadowweaver" data-class="shadowweaver">
                    <h3>SHADOW WEAVER</h3>
                    <p>Assassin of darkness</p>
                    <p>Stealth and soul manipulation</p>
                    <p>Starts with Shadow Step and Phantom Strike</p>
                </div>
                <div class="class-option class-fleshshaper" data-class="fleshshaper">
                    <h3>FLESH SHAPER</h3>
                    <p>Master of mutation and flesh</p>
                    <p>Creates abominations and warped minions</p>
                    <p>Starts with Flesh Warp and Mutagenic Blast</p>
                </div>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="screen">
            <h2>NECROPOLIS OF SOULS</h2>
            <div class="stats">
                <div>
                    <div>Level: <span id="player-level">1</span></div>
                    <div>HP: <span id="player-hp">100</span>/<span id="player-max-hp">100</span></div>
                    <div>Mana: <span id="player-mp">80</span>/<span id="player-max-mp">80</span></div>
                </div>
                <div>
                    <div>Souls: <span id="player-souls" class="soul-counter">0</span></div>
                    <div>EXP: <span id="player-exp">0</span>/<span id="player-exp-needed">100</span></div>
                </div>
            </div>
            
            <div class="progress-bar hp-bar">
                <div id="hp-bar" class="progress-fill" style="width: 100%"></div>
            </div>
            <div class="progress-bar mana-bar">
                <div id="mana-bar" class="progress-fill" style="width: 100%"></div>
            </div>
            <div class="progress-bar">
                <div id="exp-bar" class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-bar souls-bar">
                <div id="souls-bar" class="progress-fill" style="width: 0%"></div>
            </div>
            
            <h3>ACTIVE MINIONS</h3>
            <div class="minion-display" id="minion-display">
                <div class="minion-slot">Empty</div>
                <div class="minion-slot">Empty</div>
            </div>
            
            <div class="button enhanced-button" id="explore-button">EXPLORE NECROPOLIS</div>
            <div class="button" id="inventory-button">DARK ARTIFACTS</div>
            <div class="button" id="spells-button">NECROMANTIC ARTS</div>
            <div class="button" id="raise-button">RAISE THE DEAD</div>
            <div class="button" id="rituals-button">DARK RITUALS</div>
            <div class="button" id="minion-management-button">MINION MANAGEMENT</div>
            <div class="button" id="enchanting-button">SOUL ENCHANTING</div>
            <div class="button" id="necropolis-button">BUILD NECROPOLIS</div>
            <div class="button" id="save-button">BIND SOUL</div>
            
            <div class="log" id="game-log">
                <div class="log-entry">You stand amidst ancient tombs, the air thick with spiritual energy...</div>
            </div>
        </div>
        
        <!-- Battle Screen -->
        <div id="battle-screen" class="screen">
            <h2>BATTLE IN THE SHADOWS</h2>
            
            <div class="battle-bars">
                <div class="battle-bar-container">
                    <div class="battle-bar-label">HP:</div>
                    <div class="battle-bar">
                        <div id="battle-hp-bar" class="battle-bar-fill hp-fill" style="width: 100%"></div>
                    </div>
                </div>
                <div class="battle-bar-container">
                    <div class="battle-bar-label">Mana:</div>
                    <div class="battle-bar">
                        <div id="battle-mana-bar" class="battle-bar-fill mana-fill" style="width: 100%"></div>
                    </div>
                </div>
                <div class="battle-bar-container">
                    <div class="battle-bar-label">Enemy HP:</div>
                    <div class="battle-bar">
                        <div id="enemy-hp-bar" class="battle-bar-fill hp-fill" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="stats">
                <div>
                    <div>HP: <span id="battle-player-hp">100</span>/<span id="battle-player-max-hp">100</span></div>
                    <div>Mana: <span id="battle-player-mp">80</span>/<span id="battle-player-max-mp">80</span></div>
                </div>
                <div>
                    <div>Souls: <span id="battle-player-souls" class="soul-counter">0</span></div>
                    <div><span id="enemy-name">Spectral Apparition</span></div>
                </div>
            </div>
            
            <h3>YOUR MINIONS</h3>
            <div class="minion-display" id="battle-minion-display">
            </div>
            
            <div class="enemy" id="enemy-display">[ENEMY]</div>
            
            <div class="log" id="battle-log">
                <div class="log-entry">A hostile spirit manifests before you!</div>
            </div>
            
            <div class="battle-actions">
                <div class="button" id="attack-button">DARK BOLT</div>
                <div class="button" id="spell-button">NECROMANCY</div>
                <div class="button" id="minion-button">COMMAND MINIONS</div>
                <div class="button" id="soul-button">HARVEST SOUL</div>
            </div>
        </div>
        
        <!-- Spell Selection Screen -->
        <div id="spell-select-screen" class="screen">
            <h2>NECROMANTIC ARTS</h2>
            <div class="stats">
                <div>Mana: <span id="spell-select-mp">80</span>/<span id="spell-select-max-mp">80</span></div>
                <div>Souls: <span id="spell-select-souls" class="soul-counter">0</span></div>
            </div>
            <div id="spell-select-list" class="spell-list">
            </div>
            <div class="button" id="back-from-spell-select">BACK</div>
        </div>
        
        <!-- Minion Command Screen -->
        <div id="minion-command-screen" class="screen">
            <h2>COMMAND YOUR MINIONS</h2>
            <div id="minion-command-list" class="spell-list">
            </div>
            <div class="button" id="back-from-minion-command">BACK</div>
        </div>
        
        <!-- Minion Management Screen -->
        <div id="minion-management-screen" class="screen">
            <h2>MINION MANAGEMENT</h2>
            <div class="tab-container">
                <div class="tab active" data-tab="minions">Minions</div>
                <div class="tab" data-tab="equipment">Equipment</div>
                <div class="tab" data-tab="evolution">Evolution</div>
            </div>
            
            <div class="tab-content active" id="minions-tab">
                <div id="minion-management-list" class="spell-list">
                </div>
            </div>
            
            <div class="tab-content" id="equipment-tab">
                <h3>MINION EQUIPMENT</h3>
                <div id="minion-equipment-display">
                </div>
            </div>
            
            <div class="tab-content" id="evolution-tab">
                <h3>MINION EVOLUTION</h3>
                <div id="minion-evolution-display">
                </div>
            </div>
            
            <div class="button" id="back-from-minion-management">BACK</div>
        </div>
        
        <!-- Raise Dead Screen -->
        <div id="raise-screen" class="screen">
            <h2>RAISE THE DEAD</h2>
            <div class="stats">
                <div>Souls: <span id="raise-souls" class="soul-counter">0</span></div>
                <div>Remains: <span id="player-remains">0</span></div>
            </div>
            <div id="raise-options" class="spell-list">
            </div>
            <div class="button" id="back-from-raise">BACK</div>
        </div>
        
        <!-- Inventory Screen -->
        <div id="inventory-screen" class="screen">
            <h2>DARK ARTIFACTS</h2>
            <div class="tab-container">
                <div class="tab active" data-tab="items">Items</div>
                <div class="tab" data-tab="runes">Runes</div>
                <div class="tab" data-tab="artifacts">Artifacts</div>
                <div class="tab" data-tab="sets">Set Items</div> <!-- NEW TAB -->
            </div>
            
            <div class="tab-content active" id="items-tab">
                <div class="inventory-grid" id="inventory-items">
                </div>
            </div>
            
            <div class="tab-content" id="runes-tab">
                <h3>RUNES</h3>
                <div id="runes-display" class="inventory-grid">
                </div>
            </div>
            
            <div class="tab-content" id="artifacts-tab">
                <h3>ARTIFACTS</h3>
                <div id="artifacts-display" class="inventory-grid">
                </div>
            </div>
            
            <!-- NEW: Set Items Tab -->
            <div class="tab-content" id="sets-tab">
                <h3>SET ITEMS</h3>
                <div id="set-items-display">
                    <div class="set-bonus-info">
                        <h4>Equip matching set pieces for powerful bonuses!</h4>
                    </div>
                    <div id="sets-grid" class="inventory-grid">
                    </div>
                </div>
            </div>
            
            <div class="button" id="back-from-inventory">BACK</div>
        </div>
        
        <!-- Enchanting Screen -->
        <div id="enchanting-screen" class="screen">
            <h2>SOUL ENCHANTING</h2>
            <div class="stats">
                <div>Souls: <span id="enchant-souls" class="soul-counter">0</span></div>
                <div>Enchanting Dust: <span id="enchant-dust">0</span></div>
            </div>
            
            <h3>SELECT ITEM TO ENHANCE</h3>
            <div class="enchanting-grid">
                <div class="enchant-slot" id="enchant-item-slot">Place Item Here</div>
                <div class="enchant-slot" id="enchant-material-slot">Place Material Here</div>
            </div>
            
            <div class="enchant-preview" id="enchant-preview">
                Select an item to see enchantment preview
            </div>
            
            <div class="button enhanced-button" id="enchant-button">ENCHANT ITEM (50 Souls)</div>
            
            <h3>AVAILABLE ITEMS FOR ENCHANTING</h3>
            <div id="enchantable-items" class="enchantable-items-grid">
                <!-- Enchantable items will appear here -->
            </div>
            
            <h3>AVAILABLE ENCHANTMENTS</h3>
            <div id="enchantments-list" class="spell-list">
            </div>
            
            <div class="button" id="back-from-enchanting">BACK</div>
        </div>

      <!-- Necropolis Construction Screen -->
<div id="necropolis-screen" class="screen">
    <h2>NECROPOLIS CONSTRUCTION</h2>
    <div class="city-stats">
        <div>Population: <span id="undead-population">0</span>/<span id="max-population">10</span></div>
        <div>Souls: <span id="city-souls" class="soul-counter">0</span></div>
        <div>Building Materials: <span id="building-materials">0</span></div>
        <div>City Level: <span id="city-level">1</span></div>
    </div>
    
    <div class="progress-bar">
        <div id="city-exp-bar" class="progress-fill" style="width: 0%"></div>
    </div>
    <div>City EXP: <span id="city-exp">0</span>/<span id="city-exp-needed">100</span></div>
    
    <h3>CITY BUILDINGS</h3>
    <div class="building-grid" id="building-grid">
        <!-- Buildings will be dynamically added here -->
    </div>
    
    <h3>PASSIVE INCOME (PER BATTLE)</h3>
    <div class="passive-income" id="passive-income">
        <!-- Passive income display -->
    </div>
    
    <div class="button" id="back-from-necropolis">BACK</div>
</div>
        
        <!-- Rituals Screen -->
        <div id="rituals-screen" class="screen">
            <h2>DARK RITUALS</h2>
            <div id="rituals-list" class="spell-list">
            </div>
            <div class="button" id="back-from-rituals">BACK</div>
        </div>
        
        <!-- Loot Screen -->
        <div id="loot-screen" class="screen">
            <h2>VICTORY!</h2>
            <div class="log">
                <div class="log-entry">You have defeated your enemy!</div>
                <div class="log-entry">You gained <span id="exp-gained">0</span> experience!</div>
                <div class="log-entry">You collected <span id="souls-gained">0</span> souls!</div>
                <div class="log-entry">You found:</div>
                <div id="loot-items">
                </div>
            </div>
            <div class="button" id="take-loot">CONTINUE</div>
        </div>
        
        <!-- NEW: Defeat Screen -->
        <div id="defeat-screen" class="screen">
            <h2>DEFEAT</h2>
            <div class="log">
                <div class="log-entry">Your necromantic powers have failed you...</div>
                <div class="log-entry" id="defeat-message"></div>
                <div class="log-entry" id="souls-lost-message"></div>
                <div class="log-entry">Dark energy revives you, but at a cost.</div>
            </div>
            <div class="defeat-options">
                <div class="button enhanced-button" id="continue-from-defeat">CONTINUE JOURNEY</div>
                <div class="button" id="return-to-menu-from-defeat">MAIN MENU</div>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Game State
        const gameState = {
            currentScreen: 'start',
            player: {
                class: null,
                level: 1,
                exp: 0,
                expNeeded: 100,
                hp: 100,
                maxHp: 100,
                mp: 80,
                maxMp: 80,
                souls: 0,
                maxSouls: 100,
                strength: 8,
                defense: 6,
                magic: 12,
                intelligence: 14,
                remains: 5,
                enchantingDust: 0,
                equipment: {
                    head: null,
                    chest: null,
                    hands: null,
                    mainhand: null,
                    offhand: null
                },
                inventory: [],
                runes: [],
                artifacts: [],
                spells: [],
                minions: [],
                statusEffects: [],
                skillPoints: 0,
                skills: [],
                setBonuses: [] // NEW: Track equipped set bonuses
            },
            currentEnemy: null,
            battleLog: [],
            gameLog: [],
            enemyMaxHp: 0,
            enchanting: {
                selectedItem: null,
                selectedMaterial: null
            },
            phylacteryUsed: false,
            audioEnabled: {
                music: true,
                sfx: true
            },
            minionManagement: {
                selectedMinion: null,
                selectedEquipment: null
            },
            // NEW: Accessibility settings
            accessibility: {
                fontSize: 'medium', // small, medium, large, xlarge
                tutorialEnabled: true,
                completedTutorials: []
            }
        };

      // Necropolis System
const necropolisSystem = {
    buildings: {
        soul_well: {
            name: "Soul Well",
            description: "Generates souls from the spiritual energy of the necropolis",
            baseCost: 50,
            costMultiplier: 1.5,
            baseProduction: { souls: 2 },
            productionMultiplier: 1.2,
            constructionTime: 1,
            unlockLevel: 1,
            maxLevel: 10
        },
        bone_quarry: {
            name: "Bone Quarry",
            description: "Mines skeletal remains from the ancient catacombs",
            baseCost: 75,
            costMultiplier: 1.6,
            baseProduction: { remains: 1 },
            productionMultiplier: 1.15,
            constructionTime: 2,
            unlockLevel: 2,
            maxLevel: 8
        },
        haunted_library: {
            name: "Haunted Library",
            description: "Ancient tomes contain forbidden knowledge and spells",
            baseCost: 100,
            costMultiplier: 1.8,
            baseProduction: { enchantingDust: 1 },
            productionMultiplier: 1.25,
            constructionTime: 3,
            unlockLevel: 3,
            maxLevel: 6,
            special: "unlocks_spells"
        },
        spirit_barracks: {
            name: "Spirit Barracks",
            description: "Trains and houses additional undead minions",
            baseCost: 150,
            costMultiplier: 2.0,
            baseProduction: { population: 2 },
            productionMultiplier: 1.1,
            constructionTime: 2,
            unlockLevel: 4,
            maxLevel: 5,
            special: "increases_population"
        }
    },

    init: function() {
        console.log("Initializing Necropolis system...");
        if (!gameState.necropolis) {
            gameState.necropolis = {
                level: 1,
                exp: 0,
                expNeeded: 100,
                population: 0,
                maxPopulation: 10,
                buildings: {},
                constructionQueue: [],
                materials: 0,
                totalBattles: 0
            };
        }
        
        // Initialize all buildings
        Object.keys(this.buildings).forEach(buildingId => {
            if (!gameState.necropolis.buildings[buildingId]) {
                gameState.necropolis.buildings[buildingId] = {
                    level: 0,
                    constructionProgress: 0,
                    constructionTime: 0
                };
            }
        });
        console.log("Necropolis initialized:", gameState.necropolis);
    },

    getBuildingCost: function(buildingId, currentLevel) {
        const building = this.buildings[buildingId];
        return Math.floor(building.baseCost * Math.pow(building.costMultiplier, currentLevel));
    },

    getBuildingProduction: function(buildingId, level) {
        const building = this.buildings[buildingId];
        const production = {};
        
        Object.keys(building.baseProduction).forEach(resource => {
            production[resource] = Math.floor(
                building.baseProduction[resource] * Math.pow(building.productionMultiplier, level - 1)
            );
        });
        
        return production;
    },

    canBuild: function(buildingId) {
        const building = this.buildings[buildingId];
        const buildingState = gameState.necropolis.buildings[buildingId];
        
        // Check level requirement
        if (gameState.necropolis.level < building.unlockLevel) {
            return { canBuild: false, reason: `Requires City Level ${building.unlockLevel}` };
        }
        
        // Check max level
        if (buildingState.level >= building.maxLevel) {
            return { canBuild: false, reason: 'Maximum level reached' };
        }
        
        // Check population for population buildings
        if (building.special === 'increases_population') {
            const newPopulation = this.calculateTotalPopulation();
            if (newPopulation > gameState.necropolis.maxPopulation) {
                return { canBuild: false, reason: 'Maximum population reached' };
            }
        }
        
        // Check cost
        const cost = this.getBuildingCost(buildingId, buildingState.level);
        if (gameState.player.souls < cost) {
            return { canBuild: false, reason: `Need ${cost} souls` };
        }
        
        return { canBuild: true, cost: cost };
    },

    buildOrUpgrade: function(buildingId) {
        const check = this.canBuild(buildingId);
        if (!check.canBuild) {
            addToGameLog(`Cannot build: ${check.reason}`);
            return false;
        }

        const building = this.buildings[buildingId];
        const buildingState = gameState.necropolis.buildings[buildingId];
        const cost = check.cost;

        // Pay cost
        gameState.player.souls -= cost;

        // Add to construction queue
        gameState.necropolis.constructionQueue.push({
            buildingId: buildingId,
            progress: 0,
            totalTime: building.constructionTime,
            isNew: buildingState.level === 0
        });

        buildingState.constructionProgress = 0;
        buildingState.constructionTime = building.constructionTime;

        addToGameLog(`Started construction: ${building.name} ${buildingState.level > 0 ? 'Level ' + (buildingState.level + 1) : ''}`);
        audioSystem.playSound('ritual');

        updatePlayerStats();
        updateNecropolisDisplay();

        return true;
    },

    processConstruction: function() {
        // Process construction queue
        gameState.necropolis.constructionQueue = gameState.necropolis.constructionQueue.filter(job => {
            job.progress++;
            
            const buildingState = gameState.necropolis.buildings[job.buildingId];
            buildingState.constructionProgress = (job.progress / job.totalTime) * 100;
            
            if (job.progress >= job.totalTime) {
                // Construction complete
                buildingState.level++;
                buildingState.constructionProgress = 0;
                buildingState.constructionTime = 0;
                
                const building = this.buildings[job.buildingId];
                addToGameLog(`Construction complete: ${building.name} ${job.isNew ? '' : 'Level ' + buildingState.level}`);
                
                // Apply special effects
                this.applyBuildingEffects(job.buildingId, buildingState.level);
                
                return false; // Remove from queue
            }
            
            return true;
        });
    },

    applyBuildingEffects: function(buildingId, level) {
        const building = this.buildings[buildingId];
        
        switch(building.special) {
            case 'increases_population':
                // Population is handled in calculateTotalPopulation
                break;
            case 'unlocks_spells':
                if (level === 1) {
                    // Unlock a new spell when library is built
                    this.unlockNewSpell();
                }
                break;
        }
    },

    unlockNewSpell: function() {
        // Find a spell the player doesn't have yet
        const availableSpells = Object.keys(spells).filter(spellId => 
            !gameState.player.spells.includes(spellId) && 
            spells[spellId].levelReq <= gameState.player.level
        );
        
        if (availableSpells.length > 0) {
            const randomSpell = availableSpells[Math.floor(Math.random() * availableSpells.length)];
            gameState.player.spells.push(randomSpell);
            addToGameLog(`Haunted Library uncovered ancient knowledge: ${spells[randomSpell].name}!`);
        }
    },

    calculateTotalPopulation: function() {
        let population = 0;
        Object.keys(gameState.necropolis.buildings).forEach(buildingId => {
            const building = this.buildings[buildingId];
            const buildingState = gameState.necropolis.buildings[buildingId];
            
            if (building.special === 'increases_population' && buildingState.level > 0) {
                population += this.getBuildingProduction(buildingId, buildingState.level).population;
            }
        });
        return population;
    },

    collectIncome: function() {
        let income = {
            souls: 0,
            remains: 0,
            enchantingDust: 0,
            materials: 0,
            cityExp: 0
        };

        // Collect from all buildings
        Object.keys(gameState.necropolis.buildings).forEach(buildingId => {
            const buildingState = gameState.necropolis.buildings[buildingId];
            if (buildingState.level > 0) {
                const production = this.getBuildingProduction(buildingId, buildingState.level);
                Object.keys(production).forEach(resource => {
                    income[resource] += production[resource];
                });
            }
        });

        // Apply income to player
        if (income.souls > 0) {
            gameState.player.souls = Math.min(gameState.player.maxSouls, gameState.player.souls + income.souls);
        }
        if (income.remains > 0) {
            gameState.player.remains += income.remains;
        }
        if (income.enchantingDust > 0) {
            gameState.player.enchantingDust += income.enchantingDust;
        }
        if (income.materials > 0) {
            gameState.necropolis.materials += income.materials;
        }
        if (income.cityExp > 0) {
            this.addCityExp(income.cityExp);
        }

        return income;
    },

    addCityExp: function(exp) {
        gameState.necropolis.exp += exp;
        if (gameState.necropolis.exp >= gameState.necropolis.expNeeded) {
            this.levelUpCity();
        }
    },

    levelUpCity: function() {
        gameState.necropolis.level++;
        gameState.necropolis.exp -= gameState.necropolis.expNeeded;
        gameState.necropolis.expNeeded = Math.floor(gameState.necropolis.expNeeded * 1.5);
        gameState.necropolis.maxPopulation += 5;

        addToGameLog(`Necropolis reached Level ${gameState.necropolis.level}!`);
        addToGameLog(`Maximum population increased to ${gameState.necropolis.maxPopulation}`);
        audioSystem.playSound('levelup');

        updateNecropolisDisplay();
    },

    getTotalPassiveIncome: function() {
        let income = {
            souls: 0,
            remains: 0,
            enchantingDust: 0,
            materials: 0,
            cityExp: 0
        };

        Object.keys(gameState.necropolis.buildings).forEach(buildingId => {
            const buildingState = gameState.necropolis.buildings[buildingId];
            if (buildingState.level > 0) {
                const production = this.getBuildingProduction(buildingId, buildingState.level);
                Object.keys(production).forEach(resource => {
                    income[resource] += production[resource];
                });
            }
        });

        return income;
    }
};

// Add event listeners
const necropolisButton = document.getElementById('necropolis-button');
if (necropolisButton) {
    console.log("Found necropolis button, adding event listener");
    necropolisButton.addEventListener('click', function() {
        console.log("Necropolis button clicked");
        audioSystem.playSound('click');
        showNecropolisScreen();
    });
} else {
    console.error("Necropolis button not found!");
}

// Add back button listener
const backButton = document.getElementById('back-from-necropolis');
if (backButton) {
    console.log("Found necropolis back button, adding event listener");
    backButton.addEventListener('click', function() {
        console.log("Necropolis back button clicked");
        audioSystem.playSound('click');
        showGameScreen();
    });
} else {
    console.error("Necropolis back button not found!");
}

// Update the battle system to process necropolis after battles
const originalEnemyDefeated = enemyDefeated;
enemyDefeated = function() {
    originalEnemyDefeated.apply(this, arguments);
    
    // Process necropolis after battle
    if (gameState.necropolis) {
        gameState.necropolis.totalBattles++;
        necropolisSystem.processConstruction();
        const income = necropolisSystem.collectIncome();
        
        // Log income if any
        if (income.souls > 0 || income.remains > 0 || income.enchantingDust > 0) {
            let incomeMessage = "Necropolis generated:";
            if (income.souls > 0) incomeMessage += ` ${income.souls} souls`;
            if (income.remains > 0) incomeMessage += ` ${income.remains} remains`;
            if (income.enchantingDust > 0) incomeMessage += ` ${income.enchantingDust} enchanting dust`;
            addToGameLog(incomeMessage);
        }
    }
};

// Display Functions
function updateNecropolisDisplay() {
    console.log("Updating necropolis display...");
    if (!gameState.necropolis) {
        console.log("No necropolis state found, initializing...");
        necropolisSystem.init();
    }

    // Update stats
    document.getElementById('undead-population').textContent = necropolisSystem.calculateTotalPopulation();
    document.getElementById('max-population').textContent = gameState.necropolis.maxPopulation;
    document.getElementById('city-souls').textContent = gameState.player.souls;
    document.getElementById('building-materials').textContent = gameState.necropolis.materials;
    document.getElementById('city-level').textContent = gameState.necropolis.level;
    document.getElementById('city-exp').textContent = gameState.necropolis.exp;
    document.getElementById('city-exp-needed').textContent = gameState.necropolis.expNeeded;

    // Update exp bar
    const expPercent = (gameState.necropolis.exp / gameState.necropolis.expNeeded) * 100;
    document.getElementById('city-exp-bar').style.width = `${expPercent}%`;

    // Update building grid
    const buildingGrid = document.getElementById('building-grid');
    if (!buildingGrid) {
        console.error("Building grid element not found!");
        return;
    }
    
    buildingGrid.innerHTML = '';

    Object.keys(necropolisSystem.buildings).forEach(buildingId => {
        const building = necropolisSystem.buildings[buildingId];
        const buildingState = gameState.necropolis.buildings[buildingId];
        const canBuildCheck = necropolisSystem.canBuild(buildingId);

        const buildingElement = document.createElement('div');
        buildingElement.className = 'building-slot';
        
        if (buildingState.level >= building.maxLevel) {
            buildingElement.classList.add('locked');
        } else if (gameState.necropolis.level >= building.unlockLevel) {
            buildingElement.classList.add('unlocked');
        }

        if (buildingState.constructionProgress > 0) {
            buildingElement.classList.add('under-construction');
        }

        let buttonHTML = '';
        if (buildingState.constructionProgress > 0) {
            buttonHTML = `
                <div class="construction-progress">
                    <div class="construction-progress-fill" style="width: ${buildingState.constructionProgress}%"></div>
                </div>
                <div>Under Construction</div>
            `;
        } else if (canBuildCheck.canBuild) {
            const cost = necropolisSystem.getBuildingCost(buildingId, buildingState.level);
            buttonHTML = `<div class="button" onclick="necropolisSystem.buildOrUpgrade('${buildingId}')">BUILD (${cost} Souls)</div>`;
        } else {
            buttonHTML = `<div class="button disabled">${canBuildCheck.reason}</div>`;
        }

        const production = buildingState.level > 0 ? 
            necropolisSystem.getBuildingProduction(buildingId, buildingState.level) :
            necropolisSystem.getBuildingProduction(buildingId, 1);
            
        let productionText = '';
        Object.keys(production).forEach(resource => {
            productionText += `+${production[resource]} ${resource}<br>`;
        });

        buildingElement.innerHTML = `
            <div>
                <h4>${building.name} <span class="building-level">Lvl ${buildingState.level}</span></h4>
                <p>${building.description}</p>
                <div class="building-production">${productionText}</div>
                <div class="building-cost">Construction: ${building.constructionTime} battles</div>
            </div>
            ${buttonHTML}
        `;

        buildingGrid.appendChild(buildingElement);
    });

    // Update passive income display
    const passiveIncome = document.getElementById('passive-income');
    const totalIncome = necropolisSystem.getTotalPassiveIncome();
    
    let incomeHTML = '';
    Object.keys(totalIncome).forEach(resource => {
        if (totalIncome[resource] > 0) {
            incomeHTML += `<div class="income-item">
                <span>${resource.charAt(0).toUpperCase() + resource.slice(1)}:</span>
                <span>+${totalIncome[resource]}/battle</span>
            </div>`;
        }
    });

    passiveIncome.innerHTML = incomeHTML || '<div>No passive income yet. Build structures to generate resources!</div>';
    
    console.log("Necropolis display updated successfully");
}

function showNecropolisScreen() {
    console.log("Showing necropolis screen...");
    showScreen('necropolis');
    updateNecropolisDisplay();
}

// Initialize necropolis when the page loads
function initializeNecropolis() {
    console.log("Initializing Necropolis system...");
    necropolisSystem.init();
}

window.addEventListener('load', function() {
    console.log("Page loaded, initializing necropolis...");
    // Initialize after a short delay to ensure everything is loaded
    setTimeout(initializeNecropolis, 100);
});

        // NEW: Tutorial System - FIXED VERSION
        const tutorialSystem = {
            currentTutorial: null,
            tutorials: {
                welcome: {
                    id: 'welcome',
                    title: 'Welcome to Soul Binder\'s Legacy',
                    message: 'You are a necromancer, a master of death magic. Explore the necropolis, raise undead minions, and grow your power.',
                    condition: () => gameState.player.class !== null && !gameState.accessibility.completedTutorials.includes('welcome'),
                    highlight: null,
                    completed: false
                },
                first_battle: {
                    id: 'first_battle',
                    title: 'Combat Basics',
                    message: 'Click "Explore Necropolis" to find enemies. In battle, use Dark Bolt to attack, Necromancy for spells, Command Minions to direct your undead, and Harvest Soul to gather energy.',
                    condition: () => gameState.player.level >= 1 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('first_battle'),
                    highlight: '#explore-button',
                    completed: false
                },
                minions: {
                    id: 'minions',
                    title: 'Raising Minions',
                    message: 'Use "Raise the Dead" to create undead servants. They will fight for you and absorb damage in battle. Manage them in the Minion Management screen.',
                    condition: () => gameState.player.minions.length > 0 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('minions'),
                    highlight: '#raise-button',
                    completed: false
                },
                inventory: {
                    id: 'inventory',
                    title: 'Equipment and Items',
                    message: 'Check your "Dark Artifacts" to view and equip items. Better gear will make you more powerful in combat.',
                    condition: () => gameState.player.inventory.length > 0 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('inventory'),
                    highlight: '#inventory-button',
                    completed: false
                },
                spells: {
                    id: 'spells',
                    title: 'Necromantic Arts',
                    message: 'Your "Necromantic Arts" contain powerful spells. Different necromancer classes have access to different spells.',
                    condition: () => gameState.player.spells.length > 0 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('spells'),
                    highlight: '#spells-button',
                    completed: false
                },
                rituals: {
                    id: 'rituals',
                    title: 'Dark Rituals',
                    message: 'Perform "Dark Rituals" to permanently enhance your abilities. They cost souls but provide lasting benefits.',
                    condition: () => gameState.player.souls >= 40 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('rituals'),
                    highlight: '#rituals-button',
                    completed: false
                },
                enchanting: {
                    id: 'enchanting',
                    title: 'Soul Enchanting',
                    message: 'Use "Soul Enchanting" to imbue your gear with magical properties. This can give you powerful advantages in battle.',
                    condition: () => gameState.player.souls >= 50 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('enchanting'),
                    highlight: '#enchanting-button',
                    completed: false
                },
                necropolis: {
                    id: 'necropolis',
                    title: 'Necropolis Construction',
                    message: 'Build and upgrade structures in your Necropolis to generate passive income of souls, remains, and other resources after each battle.',
                    condition: () => gameState.player.level >= 3 && 
                                 gameState.currentScreen === 'game' &&
                                 !gameState.accessibility.completedTutorials.includes('necropolis'),
                    highlight: '#necropolis-button',
                    completed: false
                }
            },
            
            init: function() {
                // Don't check tutorials immediately - wait for player to actually start playing
                console.log("Tutorial system initialized - waiting for game start");
            },
            
            checkTutorials: function() {
                // Only check tutorials if we're in the game screen and not already showing a tutorial
                if (gameState.currentScreen !== 'game' || this.currentTutorial) {
                    return;
                }
                
                Object.values(this.tutorials).forEach(tutorial => {
                    if (!tutorial.completed && 
                        !gameState.accessibility.completedTutorials.includes(tutorial.id) &&
                        tutorial.condition()) {
                        this.showTutorial(tutorial);
                        return; // Only show one tutorial at a time
                    }
                });
            },
            
            showTutorial: function(tutorial) {
                this.currentTutorial = tutorial;
                
                // Create tutorial overlay
                const overlay = document.createElement('div');
                overlay.className = 'tutorial-overlay';
                overlay.id = 'tutorial-overlay';
                
                const tutorialBox = document.createElement('div');
                tutorialBox.className = 'tutorial-box';
                tutorialBox.innerHTML = `
                    <h3>${tutorial.title}</h3>
                    <p>${tutorial.message}</p>
                    <div class="button" id="tutorial-next">Continue</div>
                    <div class="tutorial-progress">Tutorial ${Object.keys(this.tutorials).indexOf(tutorial.id) + 1} of ${Object.keys(this.tutorials).length}</div>
                `;
                
                overlay.appendChild(tutorialBox);
                document.body.appendChild(overlay);
                
                // Highlight element if specified
                if (tutorial.highlight) {
                    const element = document.querySelector(tutorial.highlight);
                    if (element) {
                        element.classList.add('tutorial-highlight');
                    }
                }
                
                // Add event listener for continue button
                document.getElementById('tutorial-next').addEventListener('click', () => {
                    this.completeTutorial(tutorial.id);
                });
            },
            
            completeTutorial: function(tutorialId) {
                // Remove overlay
                const overlay = document.getElementById('tutorial-overlay');
                if (overlay) {
                    overlay.remove();
                }
                
                // Remove highlight
                if (this.tutorials[tutorialId].highlight) {
                    const element = document.querySelector(this.tutorials[tutorialId].highlight);
                    if (element) {
                        element.classList.remove('tutorial-highlight');
                    }
                }
                
                // Mark as completed
                this.tutorials[tutorialId].completed = true;
                gameState.accessibility.completedTutorials.push(tutorialId);
                this.currentTutorial = null;
                
                addToGameLog("Tutorial completed. Check the Tutorial button for help.");
            },
            
            showTutorialMenu: function() {
                const overlay = document.createElement('div');
                overlay.className = 'tutorial-overlay';
                overlay.id = 'tutorial-menu';
                
                let tutorialHTML = '<h3>Tutorials</h3>';
                
                Object.values(this.tutorials).forEach(tutorial => {
                    const completed = gameState.accessibility.completedTutorials.includes(tutorial.id);
                    tutorialHTML += `
                        <div class="spell-item ${completed ? 'disabled' : ''}">
                            <strong>${tutorial.title}</strong>
                            <div>${completed ? 'COMPLETED' : 'NOT COMPLETED'}</div>
                            ${!completed ? `<div class="button" data-tutorial="${tutorial.id}">Learn</div>` : ''}
                        </div>
                    `;
                });
                
                tutorialHTML += '<div class="button" id="close-tutorial-menu">Close</div>';
                
                const tutorialBox = document.createElement('div');
                tutorialBox.className = 'tutorial-box';
                tutorialBox.innerHTML = tutorialHTML;
                
                overlay.appendChild(tutorialBox);
                document.body.appendChild(overlay);
                
                // Add event listeners
                document.querySelectorAll('[data-tutorial]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const tutorialId = e.target.getAttribute('data-tutorial');
                        overlay.remove();
                        this.showTutorial(this.tutorials[tutorialId]);
                    });
                });
                
                document.getElementById('close-tutorial-menu').addEventListener('click', () => {
                    overlay.remove();
                });
            },
            
            resetTutorials: function() {
                Object.values(this.tutorials).forEach(tutorial => {
                    tutorial.completed = false;
                });
                gameState.accessibility.completedTutorials = [];
                addToGameLog("Tutorials have been reset.");
            }
        };

        // NEW: Font Size System
        const fontSizeSystem = {
            sizes: ['small', 'medium', 'large', 'xlarge'],
            currentSize: 1, // medium is default
            
            init: function() {
                // Load saved font size preference
                const savedSize = localStorage.getItem('necromancerFontSize');
                if (savedSize) {
                    this.currentSize = parseInt(savedSize);
                    this.applyFontSize();
                }
            },
            
            cycleSize: function() {
                this.currentSize = (this.currentSize + 1) % this.sizes.length;
                this.applyFontSize();
                // Save preference
                localStorage.setItem('necromancerFontSize', this.currentSize.toString());
                return this.sizes[this.currentSize];
            },
            
            applyFontSize: function() {
                const sizeClass = this.sizes[this.currentSize];
                document.body.className = '';
                document.body.classList.add(`font-${sizeClass}`);
            },
            
            getCurrentSizeName: function() {
                return this.sizes[this.currentSize].charAt(0).toUpperCase() + this.sizes[this.currentSize].slice(1);
            }
        };

        // NEW: Save Game Optimization
        const saveSystem = {
            // Compress game state for storage
            compressSave: function(state) {
                const compressed = {
                    // Only save essential player data
                    p: {
                        c: state.player.class,
                        l: state.player.level,
                        e: state.player.exp,
                        en: state.player.expNeeded,
                        h: state.player.hp,
                        mh: state.player.maxHp,
                        mp: state.player.mp,
                        mm: state.player.maxMp,
                        s: state.player.souls,
                        ms: state.player.maxSouls,
                        st: state.player.strength,
                        d: state.player.defense,
                        mg: state.player.magic,
                        i: state.player.intelligence,
                        r: state.player.remains,
                        ed: state.player.enchantingDust
                    },
                    // Compress inventory counts
                    i: this.compressInventory(state.player.inventory),
                    // Equipment
                    eq: state.player.equipment,
                    // Spells, runes, artifacts as arrays
                    sp: state.player.spells,
                    ru: state.player.runes,
                    ar: state.player.artifacts,
                    // Minions with compressed data
                    mn: state.player.minions.map(m => ({
                        t: m.type,
                        h: m.hp,
                        mh: m.maxHp,
                        a: m.attack,
                        d: m.defense,
                        l: m.level || 1,
                        e: m.exp || 0
                    })),
                    // Accessibility settings
                    a: state.accessibility
                };
                
                return compressed;
            },
            
            // Decompress save data
            decompressSave: function(compressed) {
                const state = JSON.parse(JSON.stringify(gameState)); // Start with default state
                
                if (compressed.p) {
                    state.player.class = compressed.p.c;
                    state.player.level = compressed.p.l;
                    state.player.exp = compressed.p.e;
                    state.player.expNeeded = compressed.p.en;
                    state.player.hp = compressed.p.h;
                    state.player.maxHp = compressed.p.mh;
                    state.player.mp = compressed.p.mp;
                    state.player.maxMp = compressed.p.mm;
                    state.player.souls = compressed.p.s;
                    state.player.maxSouls = compressed.p.ms;
                    state.player.strength = compressed.p.st;
                    state.player.defense = compressed.p.d;
                    state.player.magic = compressed.p.mg;
                    state.player.intelligence = compressed.p.i;
                    state.player.remains = compressed.p.r;
                    state.player.enchantingDust = compressed.p.ed;
                }
                
                if (compressed.i) {
                    state.player.inventory = this.decompressInventory(compressed.i);
                }
                
                if (compressed.eq) {
                    state.player.equipment = compressed.eq;
                }
                
                if (compressed.sp) {
                    state.player.spells = compressed.sp;
                }
                
                if (compressed.ru) {
                    state.player.runes = compressed.ru;
                }
                
                if (compressed.ar) {
                    state.player.artifacts = compressed.ar;
                }
                
                if (compressed.mn) {
                    state.player.minions = compressed.mn.map(m => {
                        const minionData = minions[m.t];
                        return {
                            ...minionData,
                            id: Date.now() + Math.random(),
                            type: m.t,
                            hp: m.h,
                            maxHp: m.mh,
                            attack: m.a,
                            defense: m.d,
                            level: m.l,
                            exp: m.e,
                            expNeeded: 100
                        };
                    });
                }
                
                if (compressed.a) {
                    state.accessibility = compressed.a;
                }
                
                return state;
            },
            
            // Compress inventory by counting duplicates
            compressInventory: function(inventory) {
                const counts = {};
                inventory.forEach(itemId => {
                    counts[itemId] = (counts[itemId] || 0) + 1;
                });
                return counts;
            },
            
            // Decompress inventory from counts
            decompressInventory: function(compressed) {
                const inventory = [];
                Object.keys(compressed).forEach(itemId => {
                    for (let i = 0; i < compressed[itemId]; i++) {
                        inventory.push(itemId);
                    }
                });
                return inventory;
            },
            
            // Save game with compression
            saveGame: function() {
                const compressed = this.compressSave(gameState);
                localStorage.setItem('necromancerSave', JSON.stringify(compressed));
                return true;
            },
            
            // Load game with decompression
            loadGame: function() {
                const saveData = localStorage.getItem('necromancerSave');
                if (saveData) {
                    try {
                        const compressed = JSON.parse(saveData);
                        const loadedState = this.decompressSave(compressed);
                        Object.assign(gameState, loadedState);
                        return true;
                    } catch (e) {
                        console.error('Error loading save:', e);
                        return false;
                    }
                }
                return false;
            }
        };

        
            // NEW: Web Audio API Sound System
const audioSystem = {
    audioContext: null,
    oscillators: {},
    backgroundMusic: null,
    
    init: function() {
        // Create audio context
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create sound presets
        this.createSoundPresets();
        
        // Start background music if enabled
        if (gameState.audioEnabled.music) {
            this.playBackgroundMusic();
        }
    },
    
    createSoundPresets: function() {
        // Define different oscillator settings for each sound type
        this.soundPresets = {
            click: { type: 'sine', frequency: 800, duration: 0.1, volume: 0.3 },
            notification: { type: 'square', frequency: 600, duration: 0.2, volume: 0.4 },
            battle: { type: 'sawtooth', frequency: 200, duration: 0.3, volume: 0.5 },
            spell: { type: 'sine', frequency: 1000, duration: 0.5, volume: 0.4 },
            enchant: { type: 'triangle', frequency: 1200, duration: 0.3, volume: 0.4 },
            levelup: { type: 'sine', frequency: [800, 1200, 1500], duration: 0.2, volume: 0.5 },
            victory: { type: 'sine', frequency: [600, 800, 1000, 1200], duration: 0.15, volume: 0.5 },
            defeat: { type: 'sawtooth', frequency: 150, duration: 1, volume: 0.4 },
            ritual: { type: 'square', frequency: 400, duration: 0.5, volume: 0.4 },
            summon: { type: 'sine', frequency: 300, duration: 0.5, volume: 0.4 }
        };
    },
    
    playSound: function(soundName) {
        if (!gameState.audioEnabled.sfx || !this.audioContext) return;
        
        const preset = this.soundPresets[soundName];
        if (!preset) return;
        
        try {
            if (Array.isArray(preset.frequency)) {
                // Play a sequence of tones
                this.playToneSequence(preset.frequency, preset.duration, preset.type, preset.volume);
            } else {
                // Play a single tone
                this.playTone(preset.frequency, preset.duration, preset.type, preset.volume);
            }
        } catch (e) {
            console.warn('Audio error:', e);
        }
    },
    
    playTone: function(frequency, duration, type = 'sine', volume = 0.5) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.type = type;
        oscillator.frequency.value = frequency;
        
        gainNode.gain.value = volume;
        
        // Fade out to avoid clicks
        const now = this.audioContext.currentTime;
        gainNode.gain.setValueAtTime(volume, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        oscillator.start(now);
        oscillator.stop(now + duration);
        
        // Clean up
        oscillator.onended = () => {
            oscillator.disconnect();
            gainNode.disconnect();
        };
    },
    
    playToneSequence: function(frequencies, durationPerTone, type = 'sine', volume = 0.5) {
        const now = this.audioContext.currentTime;
        
        frequencies.forEach((freq, index) => {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.value = freq;
            
            const startTime = now + (index * durationPerTone);
            
            gainNode.gain.setValueAtTime(volume, startTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + durationPerTone);
            
            oscillator.start(startTime);
            oscillator.stop(startTime + durationPerTone);
            
            // Clean up
            oscillator.onended = () => {
                oscillator.disconnect();
                gainNode.disconnect();
            };
        });
    },
    
    playBackgroundMusic: function() {
        if (!gameState.audioEnabled.music || !this.audioContext) return;
        
        // Create a simple ambient background music using oscillators
        const playAmbientLoop = () => {
            const now = this.audioContext.currentTime;
            
            // Create multiple oscillators for a richer sound
            const oscillators = [];
            const frequencies = [220, 277.18, 329.63]; // A, C#, E
            
            frequencies.forEach((freq, index) => {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                
                // Create a gentle volume envelope
                gainNode.gain.setValueAtTime(0.05, now + (index * 0.5));
                gainNode.gain.exponentialRampToValueAtTime(0.02, now + 4 + (index * 0.5));
                
                oscillator.start(now + (index * 0.5));
                oscillator.stop(now + 8);
                
                oscillators.push({ oscillator, gainNode });
            });
            
            // Schedule the next loop
            setTimeout(playAmbientLoop, 8000);
        };
        
        playAmbientLoop();
    },
    
    toggleMusic: function() {
        gameState.audioEnabled.music = !gameState.audioEnabled.music;
        if (gameState.audioEnabled.music) {
            this.playBackgroundMusic();
        } else {
            // Stop all oscillators (in a real implementation, we'd track them)
            // For now, we'll just note that music is off
        }
        return gameState.audioEnabled.music;
    },
    
    toggleSFX: function() {
        gameState.audioEnabled.sfx = !gameState.audioEnabled.sfx;
        return gameState.audioEnabled.sfx;
    }
};

        // ================================================
        // PHASE 1: CORE EXPANSION - UPDATED GAME CONTENT
        // ================================================

        // Necromancer Classes - UPDATED WITH 3 NEW CLASSES
        const classes = {
            soulbinder: {
                name: "Soul Binder",
                hp: 90,
                mp: 100,
                souls: 0,
                maxSouls: 120,
                strength: 6,
                defense: 8,
                magic: 16,
                intelligence: 16,
                startingItems: ['soul_crystal', 'tattered_robe', 'soul_shard'],
                startingSpells: ['soul_bolt', 'soul_shield']
            },
            boneweaver: {
                name: "Bone Weaver",
                hp: 110,
                mp: 70,
                souls: 0,
                maxSouls: 80,
                strength: 10,
                defense: 12,
                magic: 14,
                intelligence: 12,
                startingItems: ['bone_staff', 'bone_armor', 'skeleton_hand'],
                startingSpells: ['raise_skeleton', 'bone_armor']
            },
            plaguemaster: {
                name: "Plague Master",
                hp: 100,
                mp: 90,
                souls: 0,
                maxSouls: 100,
                strength: 8,
                defense: 10,
                magic: 15,
                intelligence: 14,
                startingItems: ['plague_dagger', 'rotten_robe', 'vial_of_poison'],
                startingSpells: ['plague_bolt', 'decaying_touch']
            },
            // NEW CLASS 1: Death Knight
            deathknight: {
                name: "Death Knight",
                hp: 130,
                mp: 60,
                souls: 0,
                maxSouls: 90,
                strength: 16,
                defense: 14,
                magic: 8,
                intelligence: 10,
                startingItems: ['reaper_scythe', 'death_plate', 'death_shield'],
                startingSpells: ['death_coil', 'bone_shield', 'unholy_strike'],
                passive: "Unholy Aura - Minions gain +20% attack and defense",
                specialAbility: "Raise Fallen Enemy - Chance to raise defeated enemies"
            },
            // NEW CLASS 2: Shadow Weaver
            shadowweaver: {
                name: "Shadow Weaver",
                hp: 85,
                mp: 110,
                souls: 0,
                maxSouls: 130,
                strength: 5,
                defense: 6,
                magic: 18,
                intelligence: 17,
                startingItems: ['shadow_dagger', 'phantom_cloak', 'nightshade_vial'],
                startingSpells: ['shadow_step', 'phantom_strike', 'veil_of_darkness'],
                passive: "Shadowmeld - 15% chance to avoid attacks",
                specialAbility: "Soul Assassination - Critical hits harvest extra souls"
            },
            // NEW CLASS 3: Flesh Shaper
            fleshshaper: {
                name: "Flesh Shaper",
                hp: 120,
                mp: 70,
                souls: 0,
                maxSouls: 80,
                strength: 12,
                defense: 10,
                magic: 15,
                intelligence: 13,
                startingItems: ['flesh_renders', 'mutagenic_robe', 'organic_catalyst'],
                startingSpells: ['flesh_warp', 'mutagenic_blast', 'regenerative_aura'],
                passive: "Organic Evolution - Minions gain random mutations",
                specialAbility: "Absorb Minion - Consume minion for permanent stat boost"
            }
        };

        // Expanded Necromancy Spells - ADDED 20+ NEW SPELLS
        const spells = {
            // Original Spells
            soul_bolt: { 
                name: "Soul Bolt", 
                cost: 5, 
                damage: { min: 12, max: 18 },
                type: "attack",
                description: "Launch a bolt of pure soul energy",
                classReq: "soulbinder"
            },
            soul_shield: { 
                name: "Soul Shield", 
                cost: 10, 
                power: 15, 
                type: "defense",
                description: "Create a protective barrier of soul energy",
                duration: 3,
                classReq: "soulbinder"
            },
            soul_harvest: {
                name: "Soul Harvest",
                cost: 8,
                damage: { min: 8, max: 12 },
                type: "attack",
                description: "Damage enemy and collect their soul energy",
                soulGain: 5,
                classReq: "soulbinder",
                levelReq: 3
            },
            soul_explosion: {
                name: "Soul Explosion",
                cost: 25,
                damage: { min: 30, max: 45 },
                type: "attack",
                description: "Release stored soul energy in a devastating blast",
                classReq: "soulbinder",
                levelReq: 8
            },
            raise_skeleton: { 
                name: "Raise Skeleton", 
                cost: 15, 
                souls: 10,
                type: "minion",
                description: "Raise a skeleton warrior from remains",
                minion: "skeleton_warrior",
                classReq: "boneweaver"
            },
            bone_armor: { 
                name: "Bone Armor", 
                cost: 12, 
                power: 20, 
                type: "defense",
                description: "Surround yourself with protective bones",
                duration: 4,
                classReq: "boneweaver"
            },
            bone_spear: {
                name: "Bone Spear",
                cost: 10,
                damage: { min: 15, max: 22 },
                type: "attack",
                description: "Launch a sharpened bone at your enemy",
                classReq: "boneweaver",
                levelReq: 3
            },
            bone_storm: {
                name: "Bone Storm",
                cost: 35,
                damage: { min: 40, max: 60 },
                type: "attack",
                description: "Create a whirlwind of razor-sharp bones",
                classReq: "boneweaver",
                levelReq: 10
            },
            plague_bolt: { 
                name: "Plague Bolt", 
                cost: 7, 
                damage: { min: 10, max: 15 },
                type: "attack",
                description: "Inflict disease upon your enemy",
                effect: { type: "poison", damage: 3, duration: 3, chance: 0.7 },
                classReq: "plaguemaster"
            },
            decaying_touch: { 
                name: "Decaying Touch", 
                cost: 12, 
                damage: { min: 8, max: 12 },
                type: "attack",
                description: "Weaken enemy defenses with decay",
                effect: { type: "defense_down", value: 5, duration: 3, chance: 0.8 },
                classReq: "plaguemaster"
            },
            corpse_explosion: {
                name: "Corpse Explosion",
                cost: 20,
                souls: 15,
                type: "attack",
                description: "Cause a fallen minion to explode",
                damage: { min: 25, max: 35 },
                classReq: "plaguemaster",
                levelReq: 5
            },
            epidemic: {
                name: "Epidemic",
                cost: 30,
                damage: { min: 20, max: 30 },
                type: "attack",
                description: "Spread plague to all enemies",
                effect: { type: "poison", damage: 5, duration: 4, chance: 0.9 },
                classReq: "plaguemaster",
                levelReq: 12
            },
            
            // NEW SPELLS FOR DEATH KNIGHT CLASS
            death_coil: {
                name: "Death Coil",
                cost: 12,
                damage: { min: 18, max: 25 },
                type: "attack",
                description: "Unleash a coil of death energy that heals you",
                effect: { type: "lifesteal", amount: 0.3, chance: 1.0 },
                classReq: "deathknight"
            },
            unholy_strike: {
                name: "Unholy Strike",
                cost: 8,
                damage: { min: 15, max: 20 },
                type: "attack",
                description: "Strike with unholy energy that empowers minions",
                effect: { type: "minion_boost", amount: 10, duration: 2 },
                classReq: "deathknight",
                levelReq: 3
            },
            army_of_dead: {
                name: "Army of the Dead",
                cost: 40,
                souls: 30,
                type: "minion",
                description: "Summon multiple skeletal warriors at once",
                minion: "skeleton_warrior",
                count: 3,
                classReq: "deathknight",
                levelReq: 7
            },
            death_grip: {
                name: "Death Grip",
                cost: 15,
                damage: { min: 10, max: 15 },
                type: "utility",
                description: "Pull enemy closer and stun them",
                effect: { type: "stun", duration: 1, chance: 0.8 },
                classReq: "deathknight",
                levelReq: 5
            },
            
            // NEW SPELLS FOR SHADOW WEAVER CLASS
            shadow_step: {
                name: "Shadow Step",
                cost: 10,
                type: "utility",
                description: "Teleport behind enemy and attack",
                damage: { min: 12, max: 18 },
                effect: { type: "dodge", duration: 2 },
                classReq: "shadowweaver"
            },
            phantom_strike: {
                name: "Phantom Strike",
                cost: 15,
                damage: { min: 20, max: 30 },
                type: "attack",
                description: "Attack from the shadows with guaranteed critical",
                effect: { type: "critical", multiplier: 1.5, chance: 1.0 },
                classReq: "shadowweaver",
                levelReq: 3
            },
            veil_of_darkness: {
                name: "Veil of Darkness",
                cost: 20,
                type: "defense",
                description: "Shroud yourself in darkness, becoming untargetable",
                duration: 3,
                effect: { type: "invisible", chance: 1.0 },
                classReq: "shadowweaver",
                levelReq: 6
            },
            soul_dagger: {
                name: "Soul Dagger",
                cost: 12,
                damage: { min: 15, max: 22 },
                type: "attack",
                description: "Throw a dagger that steals souls",
                soulGain: 10,
                classReq: "shadowweaver",
                levelReq: 4
            },
            
            // NEW SPELLS FOR FLESH SHAPER CLASS
            flesh_warp: {
                name: "Flesh Warp",
                cost: 15,
                type: "attack",
                description: "Warp enemy flesh, dealing damage over time",
                damage: { min: 8, max: 12 },
                effect: { type: "bleed", damage: 5, duration: 3, chance: 0.9 },
                classReq: "fleshshaper"
            },
            mutagenic_blast: {
                name: "Mutagenic Blast",
                cost: 18,
                damage: { min: 20, max: 30 },
                type: "attack",
                description: "Blast enemy with mutating energy",
                effect: { type: "random_debuff", duration: 3, chance: 0.7 },
                classReq: "fleshshaper",
                levelReq: 3
            },
            regenerative_aura: {
                name: "Regenerative Aura",
                cost: 25,
                type: "defense",
                description: "Create an aura that regenerates health for you and minions",
                power: 10,
                duration: 4,
                classReq: "fleshshaper",
                levelReq: 5
            },
            abomination_form: {
                name: "Abomination Form",
                cost: 35,
                type: "transformation",
                description: "Temporarily transform into an abomination",
                effect: { 
                    type: "stat_boost", 
                    stats: { hp: 50, attack: 20, defense: 15 }, 
                    duration: 5 
                },
                classReq: "fleshshaper",
                levelReq: 8
            },
            
            // NEW GENERAL SPELLS (Available to multiple classes)
            soul_siphon: {
                name: "Soul Siphon",
                cost: 8,
                type: "utility",
                description: "Drain mana from enemy and convert to your mana",
                manaSteal: 15,
                classReq: "soulbinder",
                levelReq: 4
            },
            bone_wall: {
                name: "Bone Wall",
                cost: 20,
                type: "defense",
                description: "Create a wall of bones that blocks attacks",
                power: 25,
                duration: 4,
                classReq: "boneweaver",
                levelReq: 6
            },
            plague_cloud: {
                name: "Plague Cloud",
                cost: 22,
                type: "attack",
                description: "Create a cloud of plague that affects all enemies",
                damage: { min: 10, max: 15 },
                effect: { type: "poison", damage: 4, duration: 4, chance: 0.8 },
                classReq: "plaguemaster",
                levelReq: 7
            },
            shadow_clone: {
                name: "Shadow Clone",
                cost: 30,
                type: "minion",
                description: "Create a shadow clone of yourself",
                minion: "shadow_clone",
                souls: 20,
                classReq: "shadowweaver",
                levelReq: 9
            },
            flesh_golem: {
                name: "Flesh Golem",
                cost: 40,
                type: "minion",
                description: "Create a powerful flesh golem",
                minion: "flesh_golem",
                souls: 25,
                remains: 10,
                classReq: "fleshshaper",
                levelReq: 10
            }
        };

        // Enhanced Minions - ADDED 5 NEW MINION TYPES WITH EVOLUTION TREES
        const minions = {
            // Original Minions
            skeleton_warrior: {
                name: "Skeleton Warrior",
                hp: 30,
                attack: 8,
                defense: 5,
                cost: 10,
                remains: 1,
                abilities: ["basic_attack"],
                description: "A basic undead soldier",
                evolution: "skeleton_champion",
                equipmentSlots: ["weapon", "armor"],
                baseStats: { hp: 30, attack: 8, defense: 5 }
            },
            skeleton_champion: {
                name: "Skeleton Champion",
                hp: 50,
                attack: 15,
                defense: 10,
                cost: 25,
                remains: 3,
                abilities: ["basic_attack", "bone_shatter"],
                description: "An elite skeletal warrior",
                evolution: "skeleton_lord",
                equipmentSlots: ["weapon", "armor", "helmet"],
                baseStats: { hp: 50, attack: 15, defense: 10 }
            },
            skeleton_lord: {
                name: "Skeleton Lord",
                hp: 80,
                attack: 25,
                defense: 18,
                cost: 50,
                remains: 8,
                abilities: ["basic_attack", "bone_shatter", "fear_aura"],
                description: "A powerful commander of the undead",
                equipmentSlots: ["weapon", "armor", "helmet", "amulet"],
                baseStats: { hp: 80, attack: 25, defense: 18 }
            },
            spectral_archer: {
                name: "Spectral Archer",
                hp: 25,
                attack: 12,
                defense: 3,
                cost: 15,
                remains: 1,
                abilities: ["ranged_attack"],
                description: "A ghostly archer that attacks from distance",
                levelReq: 3,
                evolution: "phantom_marksman",
                equipmentSlots: ["weapon"],
                baseStats: { hp: 25, attack: 12, defense: 3 }
            },
            phantom_marksman: {
                name: "Phantom Marksman",
                hp: 40,
                attack: 20,
                defense: 5,
                cost: 35,
                remains: 5,
                abilities: ["ranged_attack", "piercing_shot"],
                description: "An elite spectral archer with deadly accuracy",
                equipmentSlots: ["weapon", "quiver"],
                baseStats: { hp: 40, attack: 20, defense: 5 }
            },
            zombie_brute: {
                name: "Zombie Brute",
                hp: 50,
                attack: 10,
                defense: 8,
                cost: 20,
                remains: 2,
                abilities: ["heavy_attack"],
                description: "A slow but durable undead tank",
                levelReq: 5,
                evolution: "abomination",
                equipmentSlots: ["armor"],
                baseStats: { hp: 50, attack: 10, defense: 8 }
            },
            abomination: {
                name: "Abomination",
                hp: 90,
                attack: 18,
                defense: 15,
                cost: 45,
                remains: 7,
                abilities: ["heavy_attack", "disease_cloud"],
                description: "A massive, horrifying undead creature",
                equipmentSlots: ["armor", "gauntlets"],
                baseStats: { hp: 90, attack: 18, defense: 15 }
            },
            ghost_scholar: {
                name: "Ghost Scholar",
                hp: 20,
                attack: 5,
                defense: 2,
                cost: 25,
                remains: 2,
                abilities: ["mana_siphon", "arcane_boost"],
                description: "A spectral scholar that enhances your magic",
                levelReq: 7,
                equipmentSlots: ["tome"],
                baseStats: { hp: 20, attack: 5, defense: 2 }
            },
            
            // NEW MINION TYPE 1: Death Knight Minion
            death_knight_minion: {
                name: "Death Knight",
                hp: 70,
                attack: 22,
                defense: 15,
                cost: 35,
                remains: 3,
                souls: 20,
                abilities: ["unholy_strike", "death_aura", "taunt"],
                description: "A fallen knight raised to serve you",
                evolution: "lich_knight",
                equipmentSlots: ["weapon", "armor", "shield"],
                baseStats: { hp: 70, attack: 22, defense: 15 },
                classReq: "deathknight"
            },
            lich_knight: {
                name: "Lich Knight",
                hp: 110,
                attack: 35,
                defense: 25,
                cost: 60,
                remains: 8,
                souls: 40,
                abilities: ["unholy_strike", "death_aura", "taunt", "raise_ally"],
                description: "A death knight empowered with lich magic",
                equipmentSlots: ["weapon", "armor", "shield", "amulet"],
                baseStats: { hp: 110, attack: 35, defense: 25 }
            },
            
            // NEW MINION TYPE 2: Shadow Stalker
            shadow_stalker: {
                name: "Shadow Stalker",
                hp: 25,
                attack: 18,
                defense: 4,
                cost: 30,
                remains: 2,
                souls: 15,
                abilities: ["backstab", "shadowmeld", "poison_dagger"],
                description: "A stealthy assassin from the shadows",
                evolution: "void_assassin",
                equipmentSlots: ["weapon"],
                baseStats: { hp: 25, attack: 18, defense: 4 },
                classReq: "shadowweaver"
            },
            void_assassin: {
                name: "Void Assassin",
                hp: 45,
                attack: 30,
                defense: 8,
                cost: 55,
                remains: 5,
                souls: 30,
                abilities: ["backstab", "shadowmeld", "poison_dagger", "phase_shift"],
                description: "An assassin that walks through the void",
                equipmentSlots: ["weapon", "cloak"],
                baseStats: { hp: 45, attack: 30, defense: 8 }
            },
            
            // NEW MINION TYPE 3: Flesh Abomination
            flesh_abomination: {
                name: "Flesh Abomination",
                hp: 100,
                attack: 25,
                defense: 20,
                cost: 45,
                remains: 5,
                souls: 25,
                abilities: ["tentacle_whip", "acid_spit", "regenerate"],
                description: "A horrifying creature of stitched flesh",
                evolution: "eldritch_horror",
                equipmentSlots: ["armor"],
                baseStats: { hp: 100, attack: 25, defense: 20 },
                classReq: "fleshshaper"
            },
            eldritch_horror: {
                name: "Eldritch Horror",
                hp: 150,
                attack: 40,
                defense: 30,
                cost: 80,
                remains: 12,
                souls: 50,
                abilities: ["tentacle_whip", "acid_spit", "regenerate", "madness_aura"],
                description: "A creature from beyond comprehension",
                equipmentSlots: ["armor", "tentacle"],
                baseStats: { hp: 150, attack: 40, defense: 30 }
            },
            
            // NEW MINION TYPE 4: Soul Wraith
            soul_wraith: {
                name: "Soul Wraith",
                hp: 35,
                attack: 15,
                defense: 5,
                cost: 25,
                remains: 2,
                souls: 10,
                abilities: ["soul_drain", "ethereal_form", "haunting_wail"],
                description: "A wraith that feeds on souls",
                evolution: "soul_reaper",
                equipmentSlots: [],
                baseStats: { hp: 35, attack: 15, defense: 5 },
                classReq: "soulbinder"
            },
            soul_reaper: {
                name: "Soul Reaper",
                hp: 60,
                attack: 28,
                defense: 10,
                cost: 50,
                remains: 5,
                souls: 25,
                abilities: ["soul_drain", "ethereal_form", "haunting_wail", "reap_soul"],
                description: "A powerful wraith that harvests souls",
                equipmentSlots: ["scythe"],
                baseStats: { hp: 60, attack: 28, defense: 10 }
            },
            
            // NEW MINION TYPE 5: Plague Drone
            plague_drone: {
                name: "Plague Drone",
                hp: 20,
                attack: 10,
                defense: 2,
                cost: 20,
                remains: 1,
                souls: 10,
                abilities: ["poison_sting", "disease_cloud", "swarm"],
                description: "A flying insectoid that spreads disease",
                evolution: "plague_hive",
                equipmentSlots: [],
                baseStats: { hp: 20, attack: 10, defense: 2 },
                classReq: "plaguemaster"
            },
            plague_hive: {
                name: "Plague Hive",
                hp: 50,
                attack: 20,
                defense: 8,
                cost: 45,
                remains: 3,
                souls: 25,
                abilities: ["poison_sting", "disease_cloud", "swarm", "spawn_drones"],
                description: "A living hive that spawns plague drones",
                equipmentSlots: ["hive_core"],
                baseStats: { hp: 50, attack: 20, defense: 8 }
            },
            
            // Special Minions from Spells
            shadow_clone: {
                name: "Shadow Clone",
                hp: 50,
                attack: gameState.player.magic,
                defense: gameState.player.defense,
                cost: 0,
                remains: 0,
                souls: 0,
                abilities: ["mirror_attack", "shadow_copy"],
                description: "A shadowy copy of yourself",
                equipmentSlots: [],
                baseStats: { hp: 50, attack: 15, defense: 10 },
                temporary: true // Will disappear after battle
            },
            flesh_golem: {
                name: "Flesh Golem",
                hp: 120,
                attack: 35,
                defense: 25,
                cost: 0,
                remains: 0,
                souls: 0,
                abilities: ["crushing_blow", "regenerate", "shockwave"],
                description: "A massive golem of stitched flesh",
                equipmentSlots: ["armor", "gauntlets"],
                baseStats: { hp: 120, attack: 35, defense: 25 }
            }
        };

        // Expanded Items with rune sockets - ADDED SET ITEMS & LEGENDARY ARTIFACTS
        const items = {
            soul_crystal: { 
                name: "Soul Crystal", 
                type: "weapon", 
                slot: "mainhand", 
                damage: { min: 5, max: 8 },
                magic: 5,
                intelligence: 3,
                value: 20,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true
            },
            tattered_robe: { 
                name: "Tattered Robe", 
                type: "armor", 
                slot: "chest", 
                defense: 3, 
                magic: 3,
                value: 15,
                rarity: "common",
                runeSockets: 0,
                enchantable: true
            },
            soul_shard: { 
                name: "Soul Shard", 
                type: "consumable", 
                effect: "restore_souls", 
                power: 20, 
                value: 10,
                rarity: "common",
                enchantable: false
            },
            bone_staff: { 
                name: "Bone Staff", 
                type: "weapon", 
                slot: "mainhand", 
                damage: { min: 8, max: 12 },
                strength: 2,
                magic: 3,
                value: 25,
                rarity: "uncommon",
                runeSockets: 2,
                enchantable: true
            },
            bone_armor: { 
                name: "Bone Armor", 
                type: "armor", 
                slot: "chest", 
                defense: 8,
                value: 30,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true
            },
            skeleton_hand: { 
                name: "Skeleton Hand", 
                type: "consumable", 
                effect: "create_remains", 
                power: 1, 
                value: 5,
                rarity: "common",
                enchantable: false
            },
            plague_dagger: { 
                name: "Plague Dagger", 
                type: "weapon", 
                slot: "mainhand", 
                damage: { min: 6, max: 10 },
                agility: 3,
                effect: { type: "poison", damage: 2, duration: 2, chance: 0.3 },
                value: 22,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true
            },
            rotten_robe: { 
                name: "Rotten Robe", 
                type: "armor", 
                slot: "chest", 
                defense: 4, 
                magic: 2,
                value: 18,
                rarity: "common",
                runeSockets: 0,
                enchantable: true
            },
            vial_of_poison: { 
                name: "Vial of Poison", 
                type: "consumable", 
                effect: "apply_poison", 
                power: 5, 
                duration: 3,
                value: 12,
                rarity: "common",
                enchantable: false
            },
            health_potion: { 
                name: "Health Potion", 
                type: "consumable", 
                effect: "heal", 
                power: 30, 
                value: 10,
                rarity: "common",
                enchantable: false
            },
            mana_potion: { 
                name: "Mana Potion", 
                type: "consumable", 
                effect: "restore_mana", 
                power: 25, 
                value: 10,
                rarity: "common",
                enchantable: false
            },
            ancient_skull: {
                name: "Ancient Skull",
                type: "artifact",
                effect: "soul_boost",
                power: 10,
                value: 50,
                rarity: "rare",
                enchantable: false
            },
            rusty_sword: {
                name: "Rusty Sword",
                type: "minion_weapon",
                slot: "weapon",
                damage: { min: 3, max: 6 },
                value: 5,
                rarity: "common",
                enchantable: true
            },
            skeletal_bow: {
                name: "Skeletal Bow",
                type: "minion_weapon", 
                slot: "weapon",
                damage: { min: 4, max: 8 },
                value: 8,
                rarity: "uncommon",
                enchantable: true
            },
            bone_shield: {
                name: "Bone Shield",
                type: "minion_armor",
                slot: "armor",
                defense: 5,
                value: 10,
                rarity: "uncommon",
                enchantable: true
            },
            minion_helmet: {
                name: "Rusty Helmet",
                type: "minion_armor",
                slot: "helmet",
                defense: 3,
                value: 5,
                rarity: "common",
                enchantable: true
            },
            necrotic_staff: {
                name: "Necrotic Staff",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 12, max: 18 },
                magic: 8,
                intelligence: 5,
                value: 60,
                rarity: "rare",
                runeSockets: 3,
                enchantable: true
            },
            death_robe: {
                name: "Death Robe",
                type: "armor",
                slot: "chest",
                defense: 12,
                magic: 6,
                value: 45,
                rarity: "rare",
                runeSockets: 2,
                enchantable: true
            },
            soul_eater_sword: {
                name: "Soul Eater Sword",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 15, max: 22 },
                strength: 5,
                effect: { type: "life_steal", amount: 10, chance: 0.2 },
                value: 75,
                rarity: "epic",
                runeSockets: 2,
                enchantable: true
            },
            
            // NEW: DEATH KNIGHT STARTING GEAR
            reaper_scythe: {
                name: "Reaper's Scythe",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 12, max: 18 },
                strength: 6,
                magic: 2,
                effect: { type: "execute", threshold: 0.2, chance: 0.3 },
                value: 35,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true,
                classReq: "deathknight"
            },
            death_plate: {
                name: "Death Plate",
                type: "armor",
                slot: "chest",
                defense: 10,
                strength: 3,
                value: 30,
                rarity: "uncommon",
                runeSockets: 0,
                enchantable: true,
                classReq: "deathknight"
            },
            death_shield: {
                name: "Death Shield",
                type: "armor",
                slot: "offhand",
                defense: 8,
                value: 25,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true,
                classReq: "deathknight"
            },
            
            // NEW: SHADOW WEAVER STARTING GEAR
            shadow_dagger: {
                name: "Shadow Dagger",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 8, max: 15 },
                agility: 5,
                effect: { type: "backstab", multiplier: 1.5, chance: 0.25 },
                value: 30,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true,
                classReq: "shadowweaver"
            },
            phantom_cloak: {
                name: "Phantom Cloak",
                type: "armor",
                slot: "chest",
                defense: 4,
                agility: 4,
                magic: 2,
                effect: { type: "dodge_chance", amount: 10 },
                value: 28,
                rarity: "uncommon",
                runeSockets: 0,
                enchantable: true,
                classReq: "shadowweaver"
            },
            nightshade_vial: {
                name: "Nightshade Vial",
                type: "consumable",
                effect: "apply_poison",
                power: 8,
                duration: 4,
                value: 15,
                rarity: "common",
                enchantable: false,
                classReq: "shadowweaver"
            },
            
            // NEW: FLESH SHAPER STARTING GEAR
            flesh_renders: {
                name: "Flesh Renders",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 10, max: 16 },
                strength: 3,
                effect: { type: "bleed", damage: 3, duration: 3, chance: 0.4 },
                value: 32,
                rarity: "uncommon",
                runeSockets: 1,
                enchantable: true,
                classReq: "fleshshaper"
            },
            mutagenic_robe: {
                name: "Mutagenic Robe",
                type: "armor",
                slot: "chest",
                defense: 6,
                magic: 4,
                effect: { type: "hp_regen", amount: 5 },
                value: 30,
                rarity: "uncommon",
                runeSockets: 0,
                enchantable: true,
                classReq: "fleshshaper"
            },
            organic_catalyst: {
                name: "Organic Catalyst",
                type: "consumable",
                effect: "mutate_minion",
                power: 1,
                value: 20,
                rarity: "common",
                enchantable: false,
                classReq: "fleshshaper"
            },
            
            // ================================================
            // NEW: SET ITEMS
            // ================================================
            
            // LICH ARMOR SET
            lich_crown: {
                name: "Lich Crown",
                type: "armor",
                slot: "head",
                defense: 5,
                magic: 8,
                intelligence: 5,
                value: 75,
                rarity: "epic",
                runeSockets: 2,
                enchantable: true,
                set: "lich_armor",
                setPiece: "helmet"
            },
            lich_robes: {
                name: "Lich Robes",
                type: "armor",
                slot: "chest",
                defense: 12,
                magic: 10,
                intelligence: 8,
                value: 120,
                rarity: "epic",
                runeSockets: 3,
                enchantable: true,
                set: "lich_armor",
                setPiece: "chest"
            },
            lich_staff: {
                name: "Lich Staff",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 20, max: 30 },
                magic: 12,
                intelligence: 10,
                effect: { type: "life_steal", amount: 15, chance: 0.25 },
                value: 150,
                rarity: "epic",
                runeSockets: 3,
                enchantable: true,
                set: "lich_armor",
                setPiece: "weapon"
            },
            lich_phylactery: {
                name: "Lich's Phylactery",
                type: "artifact",
                slot: "accessory",
                effect: "auto_revive",
                power: 1,
                value: 200,
                rarity: "legendary",
                set: "lich_armor",
                setPiece: "accessory"
            },
            
            // DEATH KNIGHT SET
            death_knight_helmet: {
                name: "Death Knight Helmet",
                type: "armor",
                slot: "head",
                defense: 8,
                strength: 6,
                value: 60,
                rarity: "rare",
                runeSockets: 1,
                enchantable: true,
                set: "death_knight",
                setPiece: "helmet"
            },
            death_knight_plate: {
                name: "Death Knight Plate",
                type: "armor",
                slot: "chest",
                defense: 15,
                strength: 8,
                value: 100,
                rarity: "rare",
                runeSockets: 2,
                enchantable: true,
                set: "death_knight",
                setPiece: "chest"
            },
            reaper_greatsword: {
                name: "Reaper Greatsword",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 25, max: 35 },
                strength: 10,
                effect: { type: "execute", threshold: 0.25, chance: 0.4 },
                value: 125,
                rarity: "epic",
                runeSockets: 2,
                enchantable: true,
                set: "death_knight",
                setPiece: "weapon"
            },
            
            // SHADOW SET
            shadow_hood: {
                name: "Shadow Hood",
                type: "armor",
                slot: "head",
                defense: 3,
                agility: 8,
                effect: { type: "dodge_chance", amount: 15 },
                value: 55,
                rarity: "rare",
                runeSockets: 1,
                enchantable: true,
                set: "shadow_set",
                setPiece: "helmet"
            },
            shadow_assassin_robe: {
                name: "Shadow Assassin Robe",
                type: "armor",
                slot: "chest",
                defense: 6,
                agility: 10,
                magic: 4,
                effect: { type: "critical_chance", amount: 10 },
                value: 90,
                rarity: "rare",
                runeSockets: 2,
                enchantable: true,
                set: "shadow_set",
                setPiece: "chest"
            },
            twin_shadow_daggers: {
                name: "Twin Shadow Daggers",
                type: "weapon",
                slot: "mainhand",
                damage: { min: 12, max: 20 },
                agility: 12,
                effect: { type: "double_attack", chance: 0.3 },
                value: 110,
                rarity: "epic",
                runeSockets: 2,
                enchantable: true,
                set: "shadow_set",
                setPiece: "weapon"
            },
            
            // ================================================
            // NEW: LEGENDARY ARTIFACTS
            // ================================================
            eternity_clock: {
                name: "Clock of Eternity",
                type: "artifact",
                effect: "freeze_time",
                power: 2, // 2 turns of frozen time
                description: "Once per battle, freeze time for 2 turns",
                value: 250,
                rarity: "legendary",
                special: "During frozen time, only you and your minions can act"
            },
            abyssal_mirror: {
                name: "Abyssal Mirror",
                type: "artifact",
                effect: "damage_reflect",
                power: 30, // Reflect 30% damage
                description: "Reflect 30% of damage back to attackers",
                value: 180,
                rarity: "legendary",
                special: "Chance to create a mirror image that fights for you"
            },
            crown_of_the_undying_king: {
                name: "Crown of the Undying King",
                type: "artifact",
                effect: "sacrifice_minion",
                power: 1,
                description: "When you would die, instead sacrifice a minion",
                value: 220,
                rarity: "legendary",
                special: "If no minions are available, become a wraith with 1 HP"
            },
            soul_harvester: {
                name: "Soul Harvester",
                type: "artifact", 
                effect: "soul_boost",
                power: 0.5,
                description: "Gain 50% more souls from defeated enemies",
                value: 150,
                rarity: "epic"
            },
            necromancer_tome: {
                name: "Tome of the Undying",
                type: "artifact",
                effect: "spell_power",
                power: 10,
                description: "Increases all spell damage by 10%",
                value: 120,
                rarity: "rare"
            },
            crown_of_darkness: {
                name: "Crown of Darkness",
                type: "artifact",
                effect: "minion_boost",
                power: 15,
                description: "Increases all minion stats by 15%",
                value: 180,
                rarity: "epic"
            },
            amulet_of_souls: {
                name: "Amulet of Souls",
                type: "artifact",
                effect: "max_souls_boost",
                power: 50,
                description: "Increases maximum soul capacity by 50",
                value: 100,
                rarity: "rare"
            }
        };

        // SET BONUSES
        const setBonuses = {
            lich_armor: {
                name: "Lich Armor Set",
                pieces: ["lich_crown", "lich_robes", "lich_staff", "lich_phylactery"],
                bonuses: {
                    2: "+20% spell damage",
                    3: "Minions gain +15% to all stats",
                    4: "Gain ability: 'Become Lich' - Transform into a lich for 5 turns"
                }
            },
            death_knight: {
                name: "Death Knight Set",
                pieces: ["death_knight_helmet", "death_knight_plate", "reaper_greatsword"],
                bonuses: {
                    2: "+25% physical damage",
                    3: "Death Coil heals for 50% more, minions gain +20% defense"
                }
            },
            shadow_set: {
                name: "Shadow Set",
                pieces: ["shadow_hood", "shadow_assassin_robe", "twin_shadow_daggers"],
                bonuses: {
                    2: "+30% critical strike chance",
                    3: "Shadow Step costs 50% less mana and grants 2 attacks"
                }
            }
        };

        // Rune System
        const runes = {
            rune_power: {
                name: "Rune of Power",
                type: "offensive",
                effect: "damage_boost",
                power: 10,
                description: "Increases weapon damage by 10%",
                rarity: "common"
            },
            rune_protection: {
                name: "Rune of Protection", 
                type: "defensive",
                effect: "defense_boost",
                power: 10,
                description: "Increases armor defense by 10%",
                rarity: "common"
            },
            rune_soul: {
                name: "Rune of Souls",
                type: "utility",
                effect: "soul_gain",
                power: 15,
                description: "Gain 15% more souls from enemies",
                rarity: "uncommon"
            },
            rune_necrosis: {
                name: "Rune of Necrosis",
                type: "offensive",
                effect: "life_steal",
                power: 8,
                description: "Steal 8% of damage as health",
                rarity: "rare"
            },
            rune_eternity: {
                name: "Rune of Eternity",
                type: "utility",
                effect: "mana_regen",
                power: 5,
                description: "Regenerate 5% of max mana per turn",
                rarity: "rare"
            },
            rune_decay: {
                name: "Rune of Decay",
                type: "offensive",
                effect: "poison_chance",
                power: 20,
                description: "20% chance to poison enemies on hit",
                rarity: "uncommon"
            }
        };

        // Enchantments
        const enchantments = {
            soulbound: {
                name: "Soulbound",
                cost: 50,
                effect: "soul_gain_on_kill",
                power: 5,
                description: "Gain 5 souls when you kill an enemy"
            },
            vampiric: {
                name: "Vampiric",
                cost: 75,
                effect: "life_steal",
                power: 10,
                description: "Heal for 10% of damage dealt"
            },
            necrotic: {
                name: "Necrotic",
                cost: 60,
                effect: "bonus_undead_damage",
                power: 15,
                description: "Deal 15% more damage to undead enemies"
            },
            fortified: {
                name: "Fortified",
                cost: 40,
                effect: "bonus_defense",
                power: 8,
                description: "Increase defense by 8"
            },
            cursed: {
                name: "Cursed",
                cost: 80,
                effect: "curse_chance",
                power: 15,
                description: "15% chance to curse enemies, reducing their damage"
            },
            spectral: {
                name: "Spectral",
                cost: 65,
                effect: "dodge_chance",
                power: 10,
                description: "10% chance to dodge enemy attacks"
            }
        };

        // Expanded Enemies - ADDED NEW ENEMIES FOR NEW CLASSES
        const enemies = {
            level1: [
                { 
                    name: "Spectral Apparition", 
                    type: "undead",
                    hp: 40, 
                    attack: 10, 
                    defense: 3, 
                    exp: 25, 
                    souls: 8,
                    loot: [
                        { id: 'soul_shard', chance: 0.6 }
                    ]
                },
                { 
                    name: "Grave Robber", 
                    type: "human",
                    hp: 50, 
                    attack: 12, 
                    defense: 5, 
                    exp: 30, 
                    souls: 5,
                    loot: [
                        { id: 'health_potion', chance: 0.7 }
                    ]
                },
                { 
                    name: "Cursed Guardian", 
                    type: "undead",
                    hp: 45, 
                    attack: 14, 
                    defense: 6, 
                    exp: 35, 
                    souls: 10,
                    loot: [
                        { id: 'skeleton_hand', chance: 0.5 }
                    ]
                },
                // NEW ENEMY FOR PHASE 1
                { 
                    name: "Shadow Stalker", 
                    type: "undead",
                    hp: 35, 
                    attack: 16, 
                    defense: 4, 
                    exp: 30, 
                    souls: 12,
                    special: "high_critical",
                    loot: [
                        { id: 'shadow_dagger', chance: 0.1 },
                        { id: 'nightshade_vial', chance: 0.4 }
                    ]
                }
            ],
            level2: [
                { 
                    name: "Wraith", 
                    type: "undead",
                    hp: 70, 
                    attack: 16, 
                    defense: 4, 
                    exp: 45, 
                    souls: 15,
                    loot: [
                        { id: 'soul_shard', chance: 0.8 },
                        { id: 'vial_of_poison', chance: 0.4 }
                    ]
                },
                { 
                    name: "Necrotic Abomination", 
                    type: "undead",
                    hp: 90, 
                    attack: 18, 
                    defense: 8, 
                    exp: 60, 
                    souls: 12,
                    loot: [
                        { id: 'bone_armor', chance: 0.3 }
                    ]
                },
                // NEW ENEMY FOR PHASE 1
                { 
                    name: "Flesh Warper", 
                    type: "abomination",
                    hp: 80, 
                    attack: 20, 
                    defense: 10, 
                    exp: 55, 
                    souls: 18,
                    special: "regenerate",
                    loot: [
                        { id: 'flesh_renders', chance: 0.1 },
                        { id: 'organic_catalyst', chance: 0.3 }
                    ]
                }
            ],
            level3: [
                { 
                    name: "Death Knight", 
                    type: "undead",
                    hp: 120, 
                    attack: 22, 
                    defense: 15, 
                    exp: 80, 
                    souls: 25,
                    special: "life_steal",
                    loot: [
                        { id: 'necrotic_staff', chance: 0.2 },
                        { id: 'health_potion', chance: 0.8 }
                    ]
                },
                { 
                    name: "Bone Golem", 
                    type: "undead",
                    hp: 150, 
                    attack: 20, 
                    defense: 20, 
                    exp: 90, 
                    souls: 20,
                    special: "high_defense",
                    loot: [
                        { id: 'bone_shield', chance: 0.4 },
                        { id: 'skeleton_hand', chance: 0.9 }
                    ]
                },
                // NEW ENEMY FOR PHASE 1
                { 
                    name: "Soul Reaper", 
                    type: "undead",
                    hp: 100, 
                    attack: 25, 
                    defense: 12, 
                    exp: 85, 
                    souls: 30,
                    special: "soul_drain",
                    loot: [
                        { id: 'soul_eater_sword', chance: 0.15 },
                        { id: 'soul_shard', chance: 1.0 }
                    ]
                }
            ],
            miniBosses: [
                {
                    name: "Necromancer Apprentice",
                    type: "human",
                    hp: 100,
                    attack: 18,
                    defense: 12,
                    exp: 60,
                    souls: 20,
                    spells: ["dark_bolt", "summon_undead"],
                    loot: [
                        { id: 'death_robe', chance: 0.3 },
                        { id: 'mana_potion', chance: 0.8 }
                    ]
                },
                // NEW MINI BOSS FOR PHASE 1
                {
                    name: "Shadow Assassin",
                    type: "human",
                    hp: 80,
                    attack: 25,
                    defense: 8,
                    exp: 70,
                    souls: 25,
                    special: "high_critical",
                    loot: [
                        { id: 'twin_shadow_daggers', chance: 0.2 },
                        { id: 'shadow_hood', chance: 0.3 }
                    ]
                }
            ],
            bosses: [
                {
                    name: "Lich King",
                    type: "undead",
                    hp: 200,
                    attack: 30,
                    defense: 18,
                    exp: 200,
                    souls: 75,
                    isBoss: true,
                    spells: ["soul_bolt", "raise_skeleton", "bone_armor"],
                    loot: [
                        { id: 'lich_phylactery', chance: 1.0 },
                        { id: 'soul_eater_sword', chance: 0.5 }
                    ]
                },
                // NEW BOSS FOR PHASE 1
                {
                    name: "Flesh Titan",
                    type: "abomination",
                    hp: 250,
                    attack: 35,
                    defense: 25,
                    exp: 220,
                    souls: 80,
                    isBoss: true,
                    special: "regenerate_rage",
                    loot: [
                        { id: 'crown_of_darkness', chance: 0.8 },
                        { id: 'flesh_renders', chance: 0.6 },
                        { id: 'eternity_clock', chance: 0.1 }
                    ]
                }
            ]
        };

        // Rituals
        const rituals = {
            soul_infusion: {
                name: "Soul Infusion",
                cost: 50,
                description: "Permanently infuse your body with soul energy, increasing your maximum health.",
                effect: "increase_max_hp",
                power: 20
            },
            mana_siphon: {
                name: "Mana Siphon",
                cost: 40,
                description: "Create a permanent connection to the spirit realm, increasing your maximum mana.",
                effect: "increase_max_mp",
                power: 15
            },
            soul_well: {
                name: "Soul Well",
                cost: 60,
                description: "Construct a spiritual reservoir to increase your soul capacity.",
                effect: "increase_max_souls",
                power: 30
            },
            necrotic_empowerment: {
                name: "Necrotic Empowerment",
                cost: 75,
                description: "Channel dark energies to permanently enhance your magical abilities.",
                effect: "increase_magic",
                power: 3
            },
            bone_fortification: {
                name: "Bone Fortification",
                cost: 55,
                description: "Strengthen your skeletal structure, permanently increasing defense.",
                effect: "increase_defense",
                power: 4
            },
            eternal_darkness: {
                name: "Eternal Darkness",
                cost: 100,
                description: "Embrace the void, permanently increasing all stats slightly.",
                effect: "increase_all_stats",
                power: 2
            }
        };

        // Rune Application System
        const runeSystem = {
            socketedRunes: {},
            
            socketRune: function(itemId, runeId, socketIndex = 0) {
                const item = items[itemId];
                
                if (!item.runeSockets || item.runeSockets === 0) {
                    addToGameLog(`${item.name} has no rune sockets!`);
                    return false;
                }
                
                const socketKey = `${itemId}_${socketIndex}`;
                if (this.socketedRunes[socketKey]) {
                    addToGameLog(`That socket is already occupied!`);
                    return false;
                }
                
                const runeIndex = gameState.player.runes.indexOf(runeId);
                if (runeIndex === -1) {
                    addToGameLog(`You don't have that rune!`);
                    return false;
                }
                
                // Store base stats before modifying
                if (item.damage && !item.baseDamage) {
                    item.baseDamage = {...item.damage};
                }
                if (item.defense && !item.baseDefense) {
                    item.baseDefense = item.defense;
                }
                
                this.socketedRunes[socketKey] = runeId;
                gameState.player.runes.splice(runeIndex, 1);
                
                this.applyRuneEffects(itemId, runeId);
                
                addToGameLog(`You socket ${runes[runeId].name} into ${item.name}!`);
                audioSystem.playSound('enchant');
                
                return true;
            },
            
            removeRune: function(itemId, socketIndex = 0) {
                const socketKey = `${itemId}_${socketIndex}`;
                const runeId = this.socketedRunes[socketKey];
                
                if (!runeId) {
                    addToGameLog(`No rune in that socket!`);
                    return false;
                }
                
                gameState.player.runes.push(runeId);
                this.removeRuneEffects(itemId, runeId);
                delete this.socketedRunes[socketKey];
                
                addToGameLog(`You remove ${runes[runeId].name} from ${items[itemId].name}.`);
                return true;
            },
            
            applyRuneEffects: function(itemId, runeId) {
                const rune = runes[runeId];
                const item = items[itemId];
                
                switch(rune.effect) {
                    case 'damage_boost':
                        if (item.damage && item.baseDamage) {
                            item.damage.min = Math.floor(item.baseDamage.min * (1 + rune.power/100));
                            item.damage.max = Math.floor(item.baseDamage.max * (1 + rune.power/100));
                        }
                        break;
                    case 'defense_boost':
                        if (item.defense && item.baseDefense) {
                            item.defense = Math.floor(item.baseDefense * (1 + rune.power/100));
                        }
                        break;
                }
                
                updatePlayerStats();
            },
            
            removeRuneEffects: function(itemId, runeId) {
                const rune = runes[runeId];
                const item = items[itemId];
                
                switch(rune.effect) {
                    case 'damage_boost':
                        if (item.damage && item.baseDamage) {
                            item.damage.min = item.baseDamage.min;
                            item.damage.max = item.baseDamage.max;
                        }
                        break;
                    case 'defense_boost':
                        if (item.defense && item.baseDefense) {
                            item.defense = item.baseDefense;
                        }
                        break;
                }
                
                updatePlayerStats();
            },
            
            getRuneBonuses: function() {
                let bonuses = {
                    damage: 0,
                    defense: 0,
                    soulGain: 0,
                    lifeSteal: 0
                };
                
                Object.values(this.socketedRunes).forEach(runeId => {
                    const rune = runes[runeId];
                    switch(rune.effect) {
                        case 'damage_boost':
                            bonuses.damage += rune.power;
                            break;
                        case 'defense_boost':
                            bonuses.defense += rune.power;
                            break;
                        case 'soul_gain':
                            bonuses.soulGain += rune.power;
                            break;
                        case 'life_steal':
                            bonuses.lifeSteal += rune.power;
                            break;
                    }
                });
                
                return bonuses;
            }
        };

        // Enhanced Enchanting System
        const enchantingSystem = {
            enchantItem: function(itemId, enchantmentId) {
                const item = items[itemId];
                const enchantment = enchantments[enchantmentId];
                
                if (!item.enchantable) {
                    addToGameLog(`${item.name} cannot be enchanted!`);
                    return false;
                }
                
                if (gameState.player.souls < enchantment.cost) {
                    addToGameLog(`Not enough souls to enchant! Need ${enchantment.cost} souls.`);
                    return false;
                }
                
                // Apply the enchantment
                if (!item.enchants) {
                    item.enchants = [];
                }
                
                item.enchants.push(enchantmentId);
                gameState.player.souls -= enchantment.cost;
                
                // Apply enchantment effects
                this.applyEnchantmentEffect(itemId, enchantmentId);
                
                addToGameLog(`You successfully enchanted ${item.name} with ${enchantment.name}!`);
                audioSystem.playSound('enchant');
                
                updatePlayerStats();
                updateEnchantingDisplay();
                
                return true;
            },
            
            applyEnchantmentEffect: function(itemId, enchantmentId) {
                const item = items[itemId];
                const enchantment = enchantments[enchantmentId];
                
                switch(enchantment.effect) {
                    case 'soul_gain_on_kill':
                        if (!item.soulGain) item.soulGain = 0;
                        item.soulGain += enchantment.power;
                        break;
                    case 'life_steal':
                        if (!item.lifeSteal) item.lifeSteal = 0;
                        item.lifeSteal += enchantment.power;
                        break;
                    case 'bonus_undead_damage':
                        if (!item.undeadDamage) item.undeadDamage = 0;
                        item.undeadDamage += enchantment.power;
                        break;
                    case 'bonus_defense':
                        if (!item.defense) item.defense = 0;
                        item.defense += enchantment.power;
                        break;
                }
            },
            
            getEnchantmentPreview: function(itemId, enchantmentId) {
                const item = items[itemId];
                const enchantment = enchantments[enchantmentId];
                
                let preview = `Enchanting: ${item.name}\n`;
                preview += `With: ${enchantment.name}\n`;
                preview += `Effect: ${enchantment.description}\n`;
                preview += `Cost: ${enchantment.cost} souls\n\n`;
                
                // Show current stats
                if (item.damage) {
                    preview += `Current Damage: ${item.damage.min}-${item.damage.max}\n`;
                }
                if (item.defense) {
                    preview += `Current Defense: ${item.defense}\n`;
                }
                
                // Show expected changes
                switch(enchantment.effect) {
                    case 'soul_gain_on_kill':
                        preview += `After: Gain +${enchantment.power} souls per kill`;
                        break;
                    case 'life_steal':
                        preview += `After: ${enchantment.power}% life steal`;
                        break;
                    case 'bonus_undead_damage':
                        preview += `After: +${enchantment.power}% damage vs undead`;
                        break;
                    case 'bonus_defense':
                        preview += `After: +${enchantment.power} defense`;
                        break;
                }
                
                return preview;
            },
            
            hasEnchantment: function(itemId, enchantmentId) {
                const item = items[itemId];
                return item.enchants && item.enchants.includes(enchantmentId);
            }
        };

        // Minion Management System
        const minionManagementSystem = {
            showMinionDetails: function(minionIndex) {
    const minion = gameState.player.minions[minionIndex];
    const minionData = minions[minion.type];
    
    // Create modal for minion details - FIXED: Append to body
    const modal = document.createElement('div');
    modal.className = 'minion-modal';
    modal.innerHTML = `
        <h3>${minion.name} - Level ${minion.level || 1}</h3>
        <div class="minion-stats">
            <div class="minion-stat">HP: ${minion.hp}/${minion.maxHp}</div>
            <div class="minion-stat">Attack: ${minion.attack}</div>
            <div class="minion-stat">Defense: ${minion.defense}</div>
            <div class="minion-stat">EXP: ${minion.exp || 0}/${minion.expNeeded || 100}</div>
        </div>
        <div class="minion-equipment">
            <h4>Equipment</h4>
            ${this.getMinionEquipmentDisplay(minion)}
        </div>
        <div class="minion-actions">
            <div class="button" id="heal-minion">Heal (10 Souls)</div>
            <div class="button" id="equip-minion">Equip Item</div>
            <div class="button" id="dismiss-minion">Dismiss</div>
            <div class="button" id="close-minion-modal">Close</div>
        </div>
    `;
    
    // FIX: Append to body instead of minion-management-screen
    document.body.appendChild(modal);
    
    // Add event listeners for actions
    document.getElementById('heal-minion').addEventListener('click', () => {
        this.healMinion(minionIndex);
        modal.remove();
    });
    
    document.getElementById('equip-minion').addEventListener('click', () => {
        modal.remove();
        this.showEquipmentOptions(minionIndex);
    });
    
    document.getElementById('dismiss-minion').addEventListener('click', () => {
        this.dismissMinion(minionIndex);
        modal.remove();
    });
    
    document.getElementById('close-minion-modal').addEventListener('click', () => {
        modal.remove();
    });
},
            
            getMinionEquipmentDisplay: function(minion) {
    let equipmentHTML = '';
    
    // FIX: Ensure equipment and equipmentSlots are properly initialized
    if (!minion.equipment) {
        minion.equipment = {};
    }
    
    // FIX: Use minionData to get proper equipment slots
    const minionData = minions[minion.type];
    
    minionData.equipmentSlots.forEach(slot => {
        if (!minion.equipment[slot]) {
            minion.equipment[slot] = null;
        }
        
        const item = minion.equipment[slot];
        equipmentHTML += `
            <div class="minion-equip-slot">
                ${slot.toUpperCase()}: ${item ? items[item].name : 'Empty'}
            </div>
        `;
    });
    
    return equipmentHTML;
},
            
            healMinion: function(minionIndex) {
                const minion = gameState.player.minions[minionIndex];
                
                if (minion.hp >= minion.maxHp) {
                    addToGameLog(`${minion.name} is already at full health!`);
                    return;
                }
                
                if (gameState.player.souls < 10) {
                    addToGameLog(`You need 10 souls to heal ${minion.name}!`);
                    return;
                }
                
                gameState.player.souls -= 10;
                minion.hp = minion.maxHp;
                
                addToGameLog(`You heal ${minion.name} to full health for 10 souls.`);
                updatePlayerStats();
                updateMinionManagementDisplay();
            },
            
            dismissMinion: function(minionIndex) {
                const minion = gameState.player.minions[minionIndex];
                
                // Return some resources when dismissing
                const returnedSouls = Math.floor(minion.cost * 0.5);
                const returnedRemains = Math.floor(minion.remains * 0.5);
                
                gameState.player.souls += returnedSouls;
                gameState.player.remains += returnedRemains;
                
                // Remove minion
                gameState.player.minions.splice(minionIndex, 1);
                
                addToGameLog(`You dismiss ${minion.name} and recover ${returnedSouls} souls and ${returnedRemains} remains.`);
                updatePlayerStats();
                updateMinionManagementDisplay();
                updateMinionDisplay();
            },
            
            showEquipmentOptions: function(minionIndex) {
    const minion = gameState.player.minions[minionIndex];
    const minionData = minions[minion.type];
    
    // Get minion equipment from inventory
    const minionEquipment = gameState.player.inventory.filter(itemId => {
        const item = items[itemId];
        return item.type && item.type.startsWith('minion_');
    });
    
    if (minionEquipment.length === 0) {
        addToGameLog("You don't have any minion equipment!");
        return;
    }
    
    // Create modal for equipment options - FIXED: Append to body instead of minion-management-screen
    const modal = document.createElement('div');
    modal.className = 'equipment-modal';
    modal.innerHTML = `
        <h3>Equip ${minion.name}</h3>
        <p>Select an item to equip:</p>
        <div class="equipment-options" id="equipment-options">
        </div>
        <div class="button" id="close-equipment-modal" style="margin-top: 10px;">Cancel</div>
    `;
    
    // FIX: Append to body instead of minion-management-screen
    document.body.appendChild(modal);
    
    const equipmentOptions = document.getElementById('equipment-options');
    
    minionEquipment.forEach(itemId => {
        const item = items[itemId];
        const option = document.createElement('div');
        option.className = 'socketable-item';
        option.innerHTML = `
            <strong>${item.name}</strong><br>
            <small>${getItemStatsDisplay(itemId)}</small>
        `;
        
        option.addEventListener('click', () => {
            this.equipItemToMinion(minionIndex, itemId);
            modal.remove();
        });
        
        equipmentOptions.appendChild(option);
    });
    
    document.getElementById('close-equipment-modal').addEventListener('click', () => {
        modal.remove();
        // FIX: Reopen minion details after closing equipment modal
        this.showMinionDetails(minionIndex);
    });
},
            
            equipItemToMinion: function(minionIndex, itemId) {
                const minion = gameState.player.minions[minionIndex];
                const item = items[itemId];
                const minionData = minions[minion.type];
                
                // Check if minion can equip this item type
                if (!minionData.equipmentSlots.includes(item.slot)) {
                    addToGameLog(`${minion.name} cannot equip ${item.name}!`);
                    return;
                }
                
                // Remove item from inventory
                const itemIndex = gameState.player.inventory.indexOf(itemId);
                if (itemIndex !== -1) {
                    gameState.player.inventory.splice(itemIndex, 1);
                }
                
                // If minion already has an item in this slot, return it to inventory
                if (minion.equipment[item.slot]) {
                    gameState.player.inventory.push(minion.equipment[item.slot]);
                }
                
                // Equip the new item
                minion.equipment[item.slot] = itemId;
                
                // Apply item stats to minion
                this.applyItemStatsToMinion(minion, itemId);
                
                addToGameLog(`You equip ${item.name} to ${minion.name}.`);
                updateMinionManagementDisplay();
                updateInventoryDisplay();
            },
            
            applyItemStatsToMinion: function(minion, itemId) {
    const minionData = minions[minion.type];
    
    // Reset minion stats to base
    minion.hp = minionData.baseStats.hp;
    minion.maxHp = minionData.baseStats.hp;
    minion.attack = minionData.baseStats.attack;
    minion.defense = minionData.baseStats.defense;
    
    // Apply equipment stats
    Object.values(minion.equipment).forEach(eqItemId => {
        if (eqItemId) {
            const eqItem = items[eqItemId];
            
            if (eqItem.damage) {
                minion.attack += Math.floor((eqItem.damage.min + eqItem.damage.max) / 2);
            }
            
            if (eqItem.defense) {
                minion.defense += eqItem.defense;
                minion.maxHp += eqItem.defense * 2; // Defense also increases HP
                minion.hp = Math.min(minion.hp, minion.maxHp); // Ensure HP doesn't exceed max
            }
        }
    });
    
    // FIX: Update the display after applying stats
    updateMinionManagementDisplay();
    updateMinionDisplay();
},
            
            unequipItemFromMinion: function(minionIndex, slot) {
                const minion = gameState.player.minions[minionIndex];
                
                if (!minion.equipment[slot]) {
                    addToGameLog(`${minion.name} doesn't have anything equipped in that slot!`);
                    return;
                }
                
                const itemId = minion.equipment[slot];
                gameState.player.inventory.push(itemId);
                minion.equipment[slot] = null;
                
                // Recalculate minion stats
                this.applyItemStatsToMinion(minion, null);
                
                addToGameLog(`You unequip ${items[itemId].name} from ${minion.name}.`);
                updateMinionManagementDisplay();
                updateInventoryDisplay();
            }
        };

        // NEW: Set Bonus System
        const setBonusSystem = {
            checkSetBonuses: function() {
                gameState.player.setBonuses = [];
                
                Object.keys(setBonuses).forEach(setId => {
                    const set = setBonuses[setId];
                    let equippedCount = 0;
                    
                    // Check how many pieces of this set are equipped
                    set.pieces.forEach(itemId => {
                        // Check if item is equipped or in inventory (for artifacts)
                        const item = items[itemId];
                        if (item.type === 'artifact') {
                            if (gameState.player.artifacts.includes(itemId)) {
                                equippedCount++;
                            }
                        } else {
                            // Check equipment slots
                            Object.values(gameState.player.equipment).forEach(equippedItemId => {
                                if (equippedItemId === itemId) {
                                    equippedCount++;
                                }
                            });
                        }
                    });
                    
                    // Apply bonuses based on how many pieces are equipped
                    if (equippedCount >= 2 && set.bonuses[2]) {
                        gameState.player.setBonuses.push({
                            setName: set.name,
                            pieces: equippedCount,
                            bonus: set.bonuses[2]
                        });
                    }
                    if (equippedCount >= 3 && set.bonuses[3]) {
                        gameState.player.setBonuses.push({
                            setName: set.name,
                            pieces: equippedCount,
                            bonus: set.bonuses[3]
                        });
                    }
                    if (equippedCount >= 4 && set.bonuses[4]) {
                        gameState.player.setBonuses.push({
                            setName: set.name,
                            pieces: equippedCount,
                            bonus: set.bonuses[4]
                        });
                    }
                });
            },
            
            getSetBonusEffects: function() {
                let effects = {
                    spellDamage: 0,
                    physicalDamage: 0,
                    minionBoost: 0,
                    criticalChance: 0,
                    specialAbilities: []
                };
                
                gameState.player.setBonuses.forEach(bonus => {
                    if (bonus.bonus.includes('spell damage')) {
                        const match = bonus.bonus.match(/(\d+)%/);
                        if (match) effects.spellDamage += parseInt(match[1]);
                    }
                    if (bonus.bonus.includes('physical damage')) {
                        const match = bonus.bonus.match(/(\d+)%/);
                        if (match) effects.physicalDamage += parseInt(match[1]);
                    }
                    if (bonus.bonus.includes('minion') && bonus.bonus.includes('%')) {
                        const match = bonus.bonus.match(/(\d+)%/);
                        if (match) effects.minionBoost += parseInt(match[1]);
                    }
                    if (bonus.bonus.includes('critical')) {
                        const match = bonus.bonus.match(/(\d+)%/);
                        if (match) effects.criticalChance += parseInt(match[1]);
                    }
                    if (bonus.bonus.includes('Become Lich') || bonus.bonus.includes('Shadow Step')) {
                        effects.specialAbilities.push(bonus.bonus);
                    }
                });
                
                return effects;
            },
            
            applySetBonuses: function() {
                const effects = this.getSetBonusEffects();
                
                // Apply stat bonuses in combat
                if (effects.spellDamage > 0) {
                    // This would be applied in damage calculations
                }
                if (effects.minionBoost > 0) {
                    // This would be applied to minion stats
                }
                
                return effects;
            }
        };

        // DOM Elements - FIXED VERSION
const screens = {
    start: document.getElementById('start-screen'),
    class: document.getElementById('class-screen'),
    game: document.getElementById('game-screen'),
    battle: document.getElementById('battle-screen'),
    spellSelect: document.getElementById('spell-select-screen'),
    minionCommand: document.getElementById('minion-command-screen'),
    minionManagement: document.getElementById('minion-management-screen'),
    enchanting: document.getElementById('enchanting-screen'),
    necropolis: document.getElementById('necropolis-screen'),
    raise: document.getElementById('raise-screen'),
    inventory: document.getElementById('inventory-screen'),
    rituals: document.getElementById('rituals-screen'),
    loot: document.getElementById('loot-screen'),
    defeat: document.getElementById('defeat-screen')
};

        // Initialize game
        function initGame() {
            // Initialize audio system
            audioSystem.init();
            
            // Initialize font size system
            fontSizeSystem.init();
            
            // Initialize tutorial system
            tutorialSystem.init();
            
            // Set up event listeners
            document.getElementById('start-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showClassSelection();
            });
            
            document.getElementById('load-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                loadGame();
            });
            
            // Audio controls
            document.getElementById('music-toggle').addEventListener('click', () => {
                const musicOn = audioSystem.toggleMusic();
                document.getElementById('music-toggle').textContent = `Music: ${musicOn ? 'ON' : 'OFF'}`;
            });
            
            document.getElementById('sfx-toggle').addEventListener('click', () => {
                const sfxOn = audioSystem.toggleSFX();
                document.getElementById('sfx-toggle').textContent = `SFX: ${sfxOn ? 'ON' : 'OFF'}`;
            });
            
            // NEW: Accessibility controls
            document.getElementById('font-size-btn').addEventListener('click', () => {
                const newSize = fontSizeSystem.cycleSize();
                document.getElementById('font-size-btn').textContent = `Font: ${fontSizeSystem.getCurrentSizeName()}`;
            });
            
            document.getElementById('tutorial-btn').addEventListener('click', () => {
                tutorialSystem.showTutorialMenu();
            });
            
            const classOptions = document.querySelectorAll('.class-option');
            classOptions.forEach(option => {
                option.addEventListener('click', () => {
                    audioSystem.playSound('click');
                    selectClass(option.dataset.class);
                });
            });
            
            document.getElementById('explore-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                startBattle();
            });
            
            document.getElementById('inventory-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showInventory();
            });
            
            document.getElementById('spells-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showSpellSelection();
            });
            
            document.getElementById('raise-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showRaiseScreen();
            });
            
            document.getElementById('rituals-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showRitualsScreen();
            });
            
            document.getElementById('minion-management-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showMinionManagement();
            });
            
            document.getElementById('enchanting-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showEnchantingScreen();
            });
            
            document.getElementById('save-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                saveGame();
                addToGameLog("Your progress has been preserved in the soul ledger.");
            });
            
            // Battle buttons
            document.getElementById('attack-button').addEventListener('click', () => {
                audioSystem.playSound('battle');
                playerAttack();
            });
            document.getElementById('spell-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showSpellSelection();
            });
            document.getElementById('minion-button').addEventListener('click', () => {
                audioSystem.playSound('click');
                showMinionCommand();
            });
            document.getElementById('soul-button').addEventListener('click', () => {
                audioSystem.playSound('spell');
                harvestSoul();
            });
            
            // Back buttons
            document.getElementById('back-from-spell-select').addEventListener('click', () => {
                audioSystem.playSound('click');
                if (gameState.currentScreen === 'spellSelect') {
                    showGameScreen();
                }
            });
            
            document.getElementById('back-from-minion-command').addEventListener('click', () => {
                audioSystem.playSound('click');
                showBattleScreen();
            });
            
            document.getElementById('back-from-minion-management').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
            });
            
            document.getElementById('back-from-raise').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
            });
            
            document.getElementById('back-from-inventory').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
            });
            
            document.getElementById('back-from-enchanting').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
            });
            
            document.getElementById('back-from-rituals').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
            });
            
            document.getElementById('take-loot').addEventListener('click', () => {
                audioSystem.playSound('click');
                takeLoot();
            });
            
            // NEW: Defeat screen buttons
            document.getElementById('continue-from-defeat').addEventListener('click', () => {
                audioSystem.playSound('click');
                showGameScreen();
                addToGameLog("You continue your dark journey, wiser from defeat.");
            });
            
            document.getElementById('return-to-menu-from-defeat').addEventListener('click', () => {
                audioSystem.playSound('click');
                showScreen('start');
            });
            
            // Tab system
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    tab.classList.add('active');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                    
                    // Update specific tab content when switching
                    if (tabName === 'minions') {
                        updateMinionManagementDisplay();
                    } else if (tabName === 'equipment') {
                        updateMinionEquipmentDisplay();
                    } else if (tabName === 'evolution') {
                        updateMinionEvolutionDisplay();
                    } else if (tabName === 'sets') {
                        updateSetItemsDisplay();
                    }
                });
            });
            
            // Initialize enchanting
            document.getElementById('enchant-button').addEventListener('click', performEnchantment);
            
            // Initialize game log
            addToGameLog("You stand amidst ancient tombs, the air thick with spiritual energy...");
            
            // NEW: Check for low health/mana and apply visual warnings
            setInterval(() => {
                checkLowResources();
            }, 1000);
        }

        // NEW: Check for low resources and apply visual warnings
        function checkLowResources() {
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            const mpPercent = (gameState.player.mp / gameState.player.maxMp) * 100;
            
            const hpBar = document.getElementById('hp-bar');
            const mpBar = document.getElementById('mana-bar');
            const battleHpBar = document.getElementById('battle-hp-bar');
            const battleMpBar = document.getElementById('battle-mana-bar');
            
            // Apply/remove health warning
            if (hpPercent <= 25) {
                hpBar.classList.add('health-low');
                if (battleHpBar) battleHpBar.classList.add('health-low');
            } else {
                hpBar.classList.remove('health-low');
                if (battleHpBar) battleHpBar.classList.remove('health-low');
            }
            
            // Apply/remove mana warning
            if (mpPercent <= 25) {
                mpBar.classList.add('mana-low');
                if (battleMpBar) battleMpBar.classList.add('mana-low');
            } else {
                mpBar.classList.remove('mana-low');
                if (battleMpBar) battleMpBar.classList.remove('mana-low');
            }
        }

        // Screen management
        function showScreen(screenName) {
            Object.values(screens).forEach(screen => {
                screen.classList.remove('active');
            });
            
            screens[screenName].classList.add('active');
            gameState.currentScreen = screenName;
            
            // REMOVED: Don't automatically check tutorials when switching screens
            // Tutorials will be triggered by specific game events instead
        }

        function showClassSelection() {
            showScreen('class');
        }

        function selectClass(className) {
            gameState.player.class = className;
            const classData = classes[className];
            
            gameState.player.maxHp = classData.hp;
            gameState.player.hp = classData.hp;
            gameState.player.maxMp = classData.mp;
            gameState.player.mp = classData.mp;
            gameState.player.maxSouls = classData.maxSouls;
            gameState.player.souls = classData.souls;
            gameState.player.strength = classData.strength;
            gameState.player.defense = classData.defense;
            gameState.player.magic = classData.magic;
            gameState.player.intelligence = classData.intelligence;
            
            classData.startingItems.forEach(itemId => {
                gameState.player.inventory.push(itemId);
            });
            
            classData.startingSpells.forEach(spellId => {
                gameState.player.spells.push(spellId);
            });
            
            // Equip starting items based on class
            if (className === 'soulbinder') {
                equipItem('soul_crystal', 'mainhand');
                equipItem('tattered_robe', 'chest');
            } else if (className === 'boneweaver') {
                equipItem('bone_staff', 'mainhand');
                equipItem('bone_armor', 'chest');
            } else if (className === 'plaguemaster') {
                equipItem('plague_dagger', 'mainhand');
                equipItem('rotten_robe', 'chest');
            } else if (className === 'deathknight') {
                equipItem('reaper_scythe', 'mainhand');
                equipItem('death_plate', 'chest');
                equipItem('death_shield', 'offhand');
            } else if (className === 'shadowweaver') {
                equipItem('shadow_dagger', 'mainhand');
                equipItem('phantom_cloak', 'chest');
            } else if (className === 'fleshshaper') {
                equipItem('flesh_renders', 'mainhand');
                equipItem('mutagenic_robe', 'chest');
            }
            
            // Add some minion equipment to inventory for testing
            gameState.player.inventory.push('rusty_sword');
            gameState.player.inventory.push('bone_shield');
            
            updatePlayerStats();
            showGameScreen();
            
            addToGameLog(`You have embraced the path of the ${classData.name}.`);
            addToGameLog("The dead whisper secrets to you as you explore the necropolis...");
            
            // NEW: Trigger welcome tutorial after class selection
            if (gameState.accessibility.tutorialEnabled) {
                setTimeout(() => {
                    tutorialSystem.showTutorial(tutorialSystem.tutorials.welcome);
                }, 500);
            }
        }

        function showGameScreen() {
            showScreen('game');
            updatePlayerStats();
            updateMinionDisplay();
        }

        function showBattleScreen() {
            showScreen('battle');
            updateBattleStats();
            updateBattleMinionDisplay();
        }

        function showSpellSelection() {
            showScreen('spellSelect');
            updateSpellSelectionDisplay();
        }

        function showMinionCommand() {
            showScreen('minionCommand');
            updateMinionCommandDisplay();
        }

        function showMinionManagement() {
            showScreen('minionManagement');
            updateMinionManagementDisplay();
        }

        function showRaiseScreen() {
            showScreen('raise');
            updateRaiseDisplay();
        }

        function showInventory() {
            showScreen('inventory');
            updateInventoryDisplay();
        }

        function showEnchantingScreen() {
            showScreen('enchanting');
            updateEnchantingDisplay();
        }

        function showRitualsScreen() {
            showScreen('rituals');
            updateRitualsDisplay();
        }

        // NEW: Show defeat screen
        function showDefeatScreen(soulsLost, minionsLost) {
            showScreen('defeat');
            
            // Update defeat messages
            document.getElementById('defeat-message').textContent = 
                `You lost ${minionsLost} minion${minionsLost !== 1 ? 's' : ''} in the battle.`;
            document.getElementById('souls-lost-message').textContent = 
                `You lost ${soulsLost} souls.`;
        }

        // Apply artifact effects to gameplay
        function applyArtifactEffects() {
            const effects = {
                soulBoost: 0,
                spellPower: 0,
                autoRevive: false,
                minionBoost: 0,
                maxSoulsBoost: 0,
                damageReflect: 0,
                freezeTime: false,
                sacrificeMinion: false
            };
            
            gameState.player.artifacts.forEach(artifactId => {
                const artifact = artifacts[artifactId];
                
                switch(artifact.effect) {
                    case 'soul_boost':
                        effects.soulBoost += artifact.power;
                        break;
                    case 'spell_power':
                        effects.spellPower += artifact.power;
                        break;
                    case 'auto_revive':
                        effects.autoRevive = true;
                        break;
                    case 'minion_boost':
                        effects.minionBoost += artifact.power;
                        break;
                    case 'max_souls_boost':
                        effects.maxSoulsBoost += artifact.power;
                        break;
                    case 'damage_reflect':
                        effects.damageReflect += artifact.power;
                        break;
                    case 'freeze_time':
                        effects.freezeTime = true;
                        break;
                    case 'sacrifice_minion':
                        effects.sacrificeMinion = true;
                        break;
                }
            });
            
            // Apply set bonuses
            const setEffects = setBonusSystem.applySetBonuses();
            effects.spellPower += setEffects.spellDamage;
            effects.minionBoost += setEffects.minionBoost;
            
            return effects;
        }
        
        // NEW: Update set items display
        function updateSetItemsDisplay() {
            const setsGrid = document.getElementById('sets-grid');
            setsGrid.innerHTML = '';
            
            // Show equipped set pieces
            let hasSetItems = false;
            
            Object.keys(setBonuses).forEach(setId => {
                const set = setBonuses[setId];
                let equippedCount = 0;
                const equippedPieces = [];
                
                set.pieces.forEach(itemId => {
                    const item = items[itemId];
                    let isEquipped = false;
                    
                    if (item.type === 'artifact') {
                        isEquipped = gameState.player.artifacts.includes(itemId);
                    } else {
                        Object.values(gameState.player.equipment).forEach(equippedItemId => {
                            if (equippedItemId === itemId) {
                                isEquipped = true;
                            }
                        });
                    }
                    
                    if (isEquipped) {
                        equippedCount++;
                        equippedPieces.push(item.name);
                    }
                });
                
                if (equippedCount > 0) {
                    hasSetItems = true;
                    const setElement = document.createElement('div');
                    setElement.className = 'item set-item';
                    setElement.innerHTML = `
                        <h4>${set.name}</h4>
                        <p>Equipped: ${equippedCount}/${set.pieces.length}</p>
                        <p>Pieces: ${equippedPieces.join(', ')}</p>
                        <div class="item-stats">
                            ${equippedCount >= 2 ? `<div>2 Pieces: ${set.bonuses[2]}</div>` : ''}
                            ${equippedCount >= 3 && set.bonuses[3] ? `<div>3 Pieces: ${set.bonuses[3]}</div>` : ''}
                            ${equippedCount >= 4 && set.bonuses[4] ? `<div>4 Pieces: ${set.bonuses[4]}</div>` : ''}
                        </div>
                    `;
                    setsGrid.appendChild(setElement);
                }
            });
            
            if (!hasSetItems) {
                setsGrid.innerHTML = '<div>No set items equipped. Collect matching pieces for powerful bonuses!</div>';
            }
        }
        
        // Enhanced Enchanting Display
        function updateEnchantingDisplay() {
            document.getElementById('enchant-souls').textContent = gameState.player.souls;
            document.getElementById('enchant-dust').textContent = gameState.player.enchantingDust;
            
            // Update item slot display
            const itemSlot = document.getElementById('enchant-item-slot');
            if (gameState.enchanting.selectedItem) {
                const item = items[gameState.enchanting.selectedItem];
                itemSlot.innerHTML = `
                    <strong>${item.name}</strong><br>
                    <small>${getItemStatsDisplay(gameState.enchanting.selectedItem)}</small>
                `;
                itemSlot.classList.add('selected');
            } else {
                itemSlot.innerHTML = "Place Item Here";
                itemSlot.classList.remove('selected');
            }
            
            // Update material slot (currently not used but kept for future)
            const materialSlot = document.getElementById('enchant-material-slot');
            materialSlot.innerHTML = "Place Material Here";
            
            // Update enchantable items grid
            updateEnchantableItemsGrid();
            
            // Update enchantments list
            const enchantmentsList = document.getElementById('enchantments-list');
            enchantmentsList.innerHTML = '';
            
            Object.keys(enchantments).forEach(enchantId => {
                const enchant = enchantments[enchantId];
                const enchantElement = document.createElement('div');
                enchantElement.className = 'spell-item';
                
                const canEnchant = gameState.enchanting.selectedItem && 
                                 !enchantingSystem.hasEnchantment(gameState.enchanting.selectedItem, enchantId);
                
                if (!canEnchant) {
                    enchantElement.classList.add('disabled');
                }
                
                enchantElement.innerHTML = `
                    <strong>${enchant.name}</strong><br>
                    <small>${enchant.description}</small><br>
                    <small>Cost: ${enchant.cost} Souls</small>
                `;
                
                if (canEnchant) {
                    enchantElement.addEventListener('click', () => {
                        showEnchantmentPreview(enchantId);
                    });
                }
                
                enchantmentsList.appendChild(enchantElement);
            });
            
            // Update enchant button state
            const enchantButton = document.getElementById('enchant-button');
            if (gameState.enchanting.selectedItem) {
                enchantButton.classList.remove('disabled');
            } else {
                enchantButton.classList.add('disabled');
            }
        }

        // Update enchantable items grid
        function updateEnchantableItemsGrid() {
            const enchantableItemsGrid = document.getElementById('enchantable-items');
            enchantableItemsGrid.innerHTML = '';
            
            // Get all enchantable items from inventory and equipment
            const enchantableItems = [];
            
            // Check equipped items
            Object.values(gameState.player.equipment).forEach(itemId => {
                if (itemId && items[itemId].enchantable) {
                    enchantableItems.push({
                        id: itemId,
                        name: items[itemId].name,
                        equipped: true
                    });
                }
            });
            
            // Check inventory items
            gameState.player.inventory.forEach(itemId => {
                if (items[itemId].enchantable) {
                    enchantableItems.push({
                        id: itemId,
                        name: items[itemId].name,
                        equipped: false
                    });
                }
            });
            
            if (enchantableItems.length === 0) {
                enchantableItemsGrid.innerHTML = '<div>No enchantable items available.</div>';
                return;
            }
            
            enchantableItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'enchantable-item';
                
                if (gameState.enchanting.selectedItem === item.id) {
                    itemElement.classList.add('selected');
                }
                
                itemElement.innerHTML = `
                    <strong>${item.name}</strong><br>
                    <small>${item.equipped ? '(Equipped)' : '(Inventory)'}</small>
                `;
                
                itemElement.addEventListener('click', () => {
                    selectItemForEnchanting(item.id);
                });
                
                enchantableItemsGrid.appendChild(itemElement);
            });
        }

        // Select item for enchanting
        function selectItemForEnchanting(itemId) {
            gameState.enchanting.selectedItem = itemId;
            updateEnchantingDisplay();
            
            // Update preview
            document.getElementById('enchant-preview').textContent = 
                `Selected: ${items[itemId].name}\nChoose an enchantment from the list below.`;
        }

        // Show enchantment preview
        function showEnchantmentPreview(enchantmentId) {
            if (!gameState.enchanting.selectedItem) return;
            
            const preview = enchantingSystem.getEnchantmentPreview(
                gameState.enchanting.selectedItem, 
                enchantmentId
            );
            document.getElementById('enchant-preview').textContent = preview;
            
            // Set current enchantment for the enchant button
            gameState.enchanting.selectedEnchantment = enchantmentId;
        }

        // Perform the enchantment
        function performEnchantment() {
            if (!gameState.enchanting.selectedItem || !gameState.enchanting.selectedEnchantment) {
                addToGameLog("Please select both an item and an enchantment first!");
                return;
            }
            
            const success = enchantingSystem.enchantItem(
                gameState.enchanting.selectedItem,
                gameState.enchanting.selectedEnchantment
            );
            
            if (success) {
                // Reset selection after successful enchantment
                gameState.enchanting.selectedItem = null;
                gameState.enchanting.selectedEnchantment = null;
                updateEnchantingDisplay();
            }
        }

        // Battle system
        function startBattle() {
            let enemyPool;
            const playerLevel = gameState.player.level;
            
            if (playerLevel <= 2) {
                enemyPool = enemies.level1;
            } else if (playerLevel <= 5) {
                enemyPool = [...enemies.level1, ...enemies.level2];
            } else if (playerLevel <= 8) {
                enemyPool = [...enemies.level2, ...enemies.level3];
            } else {
                enemyPool = [...enemies.level2, ...enemies.level3, ...enemies.miniBosses];
                if (playerLevel >= 10 && Math.random() < 0.1) {
                    enemyPool = enemies.bosses;
                }
            }
            
            const randomIndex = Math.floor(Math.random() * enemyPool.length);
            gameState.currentEnemy = { ...enemyPool[randomIndex] };
            gameState.enemyMaxHp = gameState.currentEnemy.hp;
            
            gameState.battleLog = [];
            addToBattleLog(`A ${gameState.currentEnemy.name} appears from the shadows!`);
            
            // Reset phylactery for new battle
            gameState.phylacteryUsed = false;
            
            updateBattleStats();
            
            const enemyDisplay = document.getElementById('enemy-display');
            enemyDisplay.textContent = `[${gameState.currentEnemy.name.toUpperCase()}]`;
            
            showScreen('battle');
        }

        function playerAttack() {
            if (!gameState.currentEnemy) return;
            
            const playerMagic = gameState.player.magic;
            const weapon = gameState.player.equipment.mainhand ? items[gameState.player.equipment.mainhand] : null;
            const baseDamage = weapon ? 
                Math.floor(Math.random() * (weapon.damage.max - weapon.damage.min + 1)) + weapon.damage.min :
                5;
                
            const magicBonus = Math.floor(playerMagic / 4);
            let damage = baseDamage + magicBonus;
            
            // Apply rune bonuses
            const runeBonuses = runeSystem.getRuneBonuses();
            if (runeBonuses.damage > 0) {
                damage = Math.floor(damage * (1 + runeBonuses.damage/100));
            }
            
            // Apply weapon enchantments
            let enchantmentHeal = 0;
            let extraSouls = 0;
            
            if (weapon && weapon.enchants) {
                weapon.enchants.forEach(enchantId => {
                    const enchant = enchantments[enchantId];
                    
                    switch(enchant.effect) {
                        case 'bonus_undead_damage':
                            // Check if enemy is undead
                            if (isEnemyUndead(gameState.currentEnemy.name)) {
                                const bonusDamage = Math.floor(damage * (enchant.power/100));
                                damage += bonusDamage;
                                addToBattleLog(`Necrotic enchantment: +${bonusDamage} damage to undead!`);
                                showFloatingText(bonusDamage, document.getElementById('enemy-display'), 'damage-text');
                            }
                            break;
                            
                        case 'life_steal':
                            enchantmentHeal += Math.floor(damage * (enchant.power/100));
                            break;
                            
                        case 'soul_gain_on_kill':
                            extraSouls = enchant.power; // Store for when enemy is defeated
                            break;
                    }
                });
            }
            
            const enemyDefense = gameState.currentEnemy.defense;
            damage = Math.max(1, damage - Math.floor(enemyDefense / 2));
            
            // Apply life steal from runes
            if (runeBonuses.lifeSteal > 0) {
                const lifeSteal = Math.floor(damage * (runeBonuses.lifeSteal/100));
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + lifeSteal);
                if (lifeSteal > 0) {
                    addToBattleLog(`Life steal: +${lifeSteal} HP!`);
                    updatePlayerHP();
                }
            }
            
            // Apply enchantment life steal
            if (enchantmentHeal > 0) {
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + enchantmentHeal);
                addToBattleLog(`Vampiric enchantment: You heal for ${enchantmentHeal} HP!`);
                showFloatingText(enchantmentHeal, document.getElementById('battle-player-hp').parentElement, 'heal-text');
                updatePlayerHP();
            }
            
            gameState.currentEnemy.hp -= damage;
            
            addToBattleLog(`You strike the ${gameState.currentEnemy.name} with dark energy for ${damage} damage!`);
            showFloatingText(damage, document.getElementById('enemy-display'), 'damage-text');
            
            updateEnemyHP();
            
            if (gameState.currentEnemy.hp <= 0) {
                // Apply soul gain enchantment on kill
                if (extraSouls > 0) {
                    gameState.player.souls = Math.min(gameState.player.maxSouls, gameState.player.souls + extraSouls);
                    addToBattleLog(`Soulbound enchantment: +${extraSouls} souls!`);
                    updatePlayerSouls();
                }
                enemyDefeated();
                return;
            }
            
            enemyAttack();
        }

        // Helper function to determine if enemy is undead
        function isEnemyUndead(enemyName) {
            const undeadEnemies = [
                'Spectral Apparition', 'Cursed Guardian', 'Wraith', 
                'Necrotic Abomination', 'Lich King', 'Death Knight',
                'Bone Golem', 'Soul Reaper', 'Shadow Stalker'
            ];
            return undeadEnemies.includes(enemyName);
        }
                
        // Calculate total player defense including equipment and enchantments
        function calculatePlayerDefense() {
            let totalDefense = gameState.player.defense;
            
            // Add defense from equipped items
            Object.values(gameState.player.equipment).forEach(itemId => {
                if (itemId && items[itemId]) {
                    const item = items[itemId];
                    
                    // Add base defense from item
                    if (item.defense) {
                        totalDefense += item.defense;
                    }
                    
                    // Add defense from fortified enchantment
                    if (item.enchants) {
                        item.enchants.forEach(enchantId => {
                            const enchant = enchantments[enchantId];
                            if (enchant.effect === 'bonus_defense') {
                                totalDefense += enchant.power;
                            }
                        });
                    }
                }
            });
            
            return totalDefense;
        }
                
        function enemyAttack() {
            if (!gameState.currentEnemy) return;
            
            const enemyAttack = gameState.currentEnemy.attack;
            const baseDamage = Math.floor(Math.random() * 5) + enemyAttack - 2;
            
            const playerDefense = calculatePlayerDefense();
            
            let damage = Math.max(1, baseDamage - Math.floor(playerDefense / 2));
            
            if (gameState.player.minions.length > 0) {
                const minion = gameState.player.minions[0];
                if (minion.hp > damage) {
                    minion.hp -= damage;
                    addToBattleLog(`Your ${minion.name} takes the blow for you!`);
                    updateBattleMinionDisplay();
                    return;
                } else {
                    damage -= minion.hp;
                    addToBattleLog(`Your ${minion.name} is destroyed!`);
                    gameState.player.minions.shift();
                    updateBattleMinionDisplay();
                }
            }
            
            gameState.player.hp -= damage;
            addToBattleLog(`The ${gameState.currentEnemy.name} attacks you for ${damage} damage!`);
            updatePlayerHP();
            
            if (gameState.player.hp <= 0) {
                playerDefeated();
            }
        }

        function castSpell(spellId) {
            const spell = spells[spellId];
            
            if (gameState.player.mp < spell.cost) {
                addToBattleLog(`Not enough mana to cast ${spell.name}!`);
                showBattleScreen();
                return;
            }
            
            gameState.player.mp -= spell.cost;
            updatePlayerMP();
            
            if (spell.type === 'attack') {
                const minDamage = spell.damage.min + Math.floor(gameState.player.magic / 3);
                const maxDamage = spell.damage.max + Math.floor(gameState.player.magic / 2);
                let damage = Math.floor(Math.random() * (maxDamage - minDamage + 1)) + minDamage;
                
                // Apply artifact spell power boost
                const artifactEffects = applyArtifactEffects();
                if (artifactEffects.spellPower > 0) {
                    const bonusDamage = Math.floor(damage * (artifactEffects.spellPower/100));
                    damage += bonusDamage;
                    addToBattleLog(`Tome of the Undying: +${bonusDamage} spell damage!`);
                }
                
                gameState.currentEnemy.hp -= damage;
                addToBattleLog(`You cast ${spell.name} for ${damage} damage!`);
                showFloatingText(damage, document.getElementById('enemy-display'), 'damage-text');
                updateEnemyHP();
                
                if (gameState.currentEnemy.hp <= 0) {
                    enemyDefeated();
                    return;
                }
            } else if (spell.type === 'defense') {
                const healAmount = spell.power;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addToBattleLog(`You cast ${spell.name} and restore ${healAmount} HP!`);
                showFloatingText(healAmount, document.getElementById('battle-player-hp').parentElement, 'heal-text');
                updatePlayerHP();
            } else if (spell.type === 'minion') {
                if (gameState.player.souls < spell.souls) {
                    addToBattleLog(`Not enough souls to summon!`);
                    showBattleScreen();
                    return;
                }
                
                if (gameState.player.remains < minions[spell.minion].remains) {
                    addToBattleLog(`Not enough remains to summon a ${minions[spell.minion].name}!`);
                    showBattleScreen();
                    return;
                }
                
                gameState.player.souls -= spell.souls;
                gameState.player.remains -= minions[spell.minion].remains;
                
                const newMinion = {
                    ...minions[spell.minion],
                    id: Date.now(),
                    maxHp: minions[spell.minion].hp,
                    level: 1,
                    exp: 0,
                    expNeeded: 100,
                    type: spell.minion
                };
                
                gameState.player.minions.push(newMinion);
                addToBattleLog(`You summon a ${newMinion.name}!`);
                audioSystem.playSound('summon');
                updatePlayerSouls();
                updateBattleMinionDisplay();
            }
            
            enemyAttack();
            showBattleScreen();
        }

        function commandMinion(minionIndex, command) {
            const minion = gameState.player.minions[minionIndex];
            
            if (command === 'attack') {
                const damage = minion.attack;
                gameState.currentEnemy.hp -= damage;
                addToBattleLog(`Your ${minion.name} attacks for ${damage} damage!`);
                showFloatingText(damage, document.getElementById('enemy-display'), 'damage-text');
                updateEnemyHP();
                
                if (gameState.currentEnemy.hp <= 0) {
                    enemyDefeated();
                    return;
                }
            }
            
            enemyAttack();
            showBattleScreen();
        }

        function harvestSoul() {
            if (!gameState.currentEnemy) return;
            
            const soulsGained = 5 + Math.floor(gameState.player.intelligence / 5);
            gameState.player.souls = Math.min(gameState.player.maxSouls, gameState.player.souls + soulsGained);
            addToBattleLog(`You harvest ${soulsGained} souls from the ${gameState.currentEnemy.name}!`);
            showFloatingText(soulsGained, document.getElementById('battle-player-souls').parentElement, 'soul-text');
            updatePlayerSouls();
            enemyAttack();
        }

        // NEW: Updated playerDefeated function with defeat screen
        function playerDefeated() {
            // Check for Lich's Phylactery auto-revive
            const artifactEffects = applyArtifactEffects();
            if (artifactEffects.autoRevive && !gameState.phylacteryUsed) {
                gameState.phylacteryUsed = true;
                gameState.player.hp = Math.floor(gameState.player.maxHp / 2);
                gameState.player.mp = Math.floor(gameState.player.maxMp / 2);
                
                addToBattleLog("The Lich's Phylactery shatters, reviving you from death!");
                addToBattleLog("You are revived with 50% HP and MP!");
                
                // Remove the artifact after use
                const phylacteryIndex = gameState.player.artifacts.indexOf('lich_phylactery');
                if (phylacteryIndex !== -1) {
                    gameState.player.artifacts.splice(phylacteryIndex, 1);
                    addToBattleLog("The Lich's Phylactery is consumed!");
                }
                
                updatePlayerHP();
                updatePlayerMP();
                return;
            }
            
            // Calculate penalties
            const soulsLost = Math.floor(gameState.player.souls * 0.3);
            const minionsLost = gameState.player.minions.length;
            
            // Apply penalties
            gameState.player.hp = Math.floor(gameState.player.maxHp / 2);
            gameState.player.mp = Math.floor(gameState.player.maxMp / 2);
            gameState.player.souls -= soulsLost;
            gameState.player.minions = [];
            
            // Show defeat screen
            showDefeatScreen(soulsLost, minionsLost);
            audioSystem.playSound('defeat');
        }
            
        function enemyDefeated() {
            addToBattleLog(`You defeated the ${gameState.currentEnemy.name}!`);
            audioSystem.playSound('victory');
            
            const expGained = gameState.currentEnemy.exp;
            gameState.player.exp += expGained;
            
            // Apply soul gain bonuses
            const runeBonuses = runeSystem.getRuneBonuses();
            let soulsGained = gameState.currentEnemy.souls;
            
            // Apply rune bonuses
            if (runeBonuses.soulGain > 0) {
                soulsGained = Math.floor(soulsGained * (1 + runeBonuses.soulGain/100));
                addToBattleLog(`Rune bonus: +${runeBonuses.soulGain}% souls!`);
            }
            
            // Apply artifact soul boost
            const artifactEffects = applyArtifactEffects();
            if (artifactEffects.soulBoost > 0) {
                soulsGained = Math.floor(soulsGained * (1 + artifactEffects.soulBoost));
                addToBattleLog(`Soul Harvester: +${Math.floor(artifactEffects.soulBoost * 100)}% souls!`);
            }
            
            // Apply soulbound enchantment from weapon
            const weapon = gameState.player.equipment.mainhand ? items[gameState.player.equipment.mainhand] : null;
            if (weapon && weapon.enchants) {
                weapon.enchants.forEach(enchantId => {
                    const enchant = enchantments[enchantId];
                    if (enchant.effect === 'soul_gain_on_kill') {
                        soulsGained += enchant.power;
                        addToBattleLog(`Soulbound enchantment: +${enchant.power} souls!`);
                    }
                });
            }
            
            gameState.player.souls = Math.min(gameState.player.maxSouls + artifactEffects.maxSoulsBoost, gameState.player.souls + soulsGained);
            
            if (gameState.player.exp >= gameState.player.expNeeded) {
                levelUp();
            }
            
            const loot = getEnhancedLoot(gameState.currentEnemy);
            
            loot.forEach(itemId => {
                if (itemId.startsWith('rune_')) {
                    const runeId = itemId.replace('rune_', '');
                    gameState.player.runes.push(runeId);
                } else if (itemId.startsWith('artifact_')) {
                    const artifactId = itemId.replace('artifact_', '');
                    gameState.player.artifacts.push(artifactId);
                } else {
                    gameState.player.inventory.push(itemId);
                }
            });
            
            document.getElementById('exp-gained').textContent = expGained;
            document.getElementById('souls-gained').textContent = soulsGained;
            
            const lootItemsElement = document.getElementById('loot-items');
            lootItemsElement.innerHTML = '';
            
            loot.forEach(itemId => {
                let itemName, itemRarity;
                
                if (itemId.startsWith('rune_')) {
                    const runeId = itemId.replace('rune_', '');
                    itemName = runes[runeId].name;
                    itemRarity = runes[runeId].rarity;
                } else if (itemId.startsWith('artifact_')) {
                    const artifactId = itemId.replace('artifact_', '');
                    itemName = artifacts[artifactId].name;
                    itemRarity = artifacts[artifactId].rarity;
                } else {
                    itemName = items[itemId].name;
                    itemRarity = items[itemId].rarity;
                }
                
                const itemElement = document.createElement('div');
                itemElement.className = `log-entry loot-item rarity-${itemRarity}`;
                itemElement.textContent = itemName;
                lootItemsElement.appendChild(itemElement);
            });
            
            showScreen('loot');
        }

        function takeLoot() {
            showGameScreen();
            updatePlayerStats();
            addToGameLog("You continue exploring the necropolis...");
        }

        // Level system
        function levelUp() {
            gameState.player.level++;
            gameState.player.exp -= gameState.player.expNeeded;
            gameState.player.expNeeded = Math.floor(gameState.player.expNeeded * 1.5);
            
            const classData = classes[gameState.player.class];
            
            gameState.player.maxHp += 15;
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.maxMp += 10;
            gameState.player.mp = gameState.player.maxMp;
            gameState.player.maxSouls += 20;
            gameState.player.magic += 2;
            gameState.player.intelligence += 2;
            
            if (gameState.player.level % 3 === 0) {
                gameState.player.skillPoints++;
                addToGameLog("You gained a skill point!");
            }
            
            addToGameLog(`You reached level ${gameState.player.level}!`);
            addToGameLog("Your necromantic powers have grown!");
            audioSystem.playSound('levelup');
            
            updatePlayerStats();
        }

        // Minion system
        function raiseMinion(minionType) {
            const minion = minions[minionType];
            
            // Check class requirements
            if (minion.classReq && minion.classReq !== gameState.player.class) {
                addToGameLog(`Only ${classes[minion.classReq].name}s can raise ${minion.name}s!`);
                return;
            }
            
            if (gameState.player.souls < minion.cost) {
                addToGameLog(`Not enough souls to raise a ${minion.name}!`);
                return;
            }
            
            if (gameState.player.remains < minion.remains) {
                addToGameLog(`Not enough remains to raise a ${minion.name}!`);
                return;
            }
            
            if (gameState.player.minions.length >= 2) {
                addToGameLog("You can only control 2 minions at once!");
                return;
            }
            
            gameState.player.souls -= minion.cost;
            gameState.player.remains -= minion.remains;
            
            const newMinion = {
                ...minion,
                id: Date.now(),
                maxHp: minion.hp,
                level: 1,
                exp: 0,
                expNeeded: 100,
                type: minionType
            };
            
            gameState.player.minions.push(newMinion);
            addToGameLog(`You raise a ${newMinion.name} from the remains!`);
            audioSystem.playSound('summon');
            
            updatePlayerStats();
            updateMinionDisplay();
            showGameScreen();
        }

        // Rituals
        function performRitual(ritualId) {
            const ritual = rituals[ritualId];
            
            if (gameState.player.souls >= ritual.cost) {
                gameState.player.souls -= ritual.cost;
                
                if (ritual.effect === 'increase_max_hp') {
                    gameState.player.maxHp += ritual.power;
                    gameState.player.hp = gameState.player.maxHp;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing your vitality by ${ritual.power}!`);
                } else if (ritual.effect === 'increase_max_mp') {
                    gameState.player.maxMp += ritual.power;
                    gameState.player.mp = gameState.player.maxMp;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing your mana capacity by ${ritual.power}!`);
                } else if (ritual.effect === 'increase_max_souls') {
                    gameState.player.maxSouls += ritual.power;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing your soul capacity by ${ritual.power}!`);
                } else if (ritual.effect === 'increase_magic') {
                    gameState.player.magic += ritual.power;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing your magic power by ${ritual.power}!`);
                } else if (ritual.effect === 'increase_defense') {
                    gameState.player.defense += ritual.power;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing your defense by ${ritual.power}!`);
                } else if (ritual.effect === 'increase_all_stats') {
                    gameState.player.strength += ritual.power;
                    gameState.player.defense += ritual.power;
                    gameState.player.magic += ritual.power;
                    gameState.player.intelligence += ritual.power;
                    addToGameLog(`You perform ${ritual.name}, permanently increasing all your stats by ${ritual.power}!`);
                }
                
                audioSystem.playSound('ritual');
                updatePlayerStats();
                showGameScreen();
            } else {
                addToGameLog("You don't have enough souls for this ritual!");
            }
        }

        // Inventory system
        function updateInventoryDisplay() {
            const inventoryElement = document.getElementById('inventory-items');
            inventoryElement.innerHTML = '';
            
            const itemCounts = {};
            gameState.player.inventory.forEach(itemId => {
                itemCounts[itemId] = (itemCounts[itemId] || 0) + 1;
            });
            
            Object.keys(itemCounts).forEach(itemId => {
                const itemElement = document.createElement('div');
                itemElement.className = `item rarity-${items[itemId].rarity}`;
                
                // Add set item styling
                if (items[itemId].set) {
                    itemElement.classList.add('set-item');
                }
                // Add legendary item styling
                if (items[itemId].rarity === 'legendary') {
                    itemElement.classList.add('legendary-item');
                }
                
                const itemName = document.createElement('div');
                itemName.textContent = `${items[itemId].name} (x${itemCounts[itemId]})`;
                
                const itemStats = document.createElement('div');
                itemStats.className = 'item-stats';
                itemStats.innerHTML = getItemStatsDisplay(itemId);
                
                itemElement.appendChild(itemName);
                itemElement.appendChild(itemStats);
                
                itemElement.addEventListener('click', () => {
                    audioSystem.playSound('click');
                    if (items[itemId].type === 'consumable') {
                        useItem(itemId);
                    } else {
                        equipItem(itemId, items[itemId].slot);
                    }
                });
                
                inventoryElement.appendChild(itemElement);
            });
            
            // Update runes display
            const runesDisplay = document.getElementById('runes-display');
            runesDisplay.innerHTML = '';
            
            const runeCounts = {};
            gameState.player.runes.forEach(runeId => {
                runeCounts[runeId] = (runeCounts[runeId] || 0) + 1;
            });
            
            Object.keys(runeCounts).forEach(runeId => {
                const runeElement = document.createElement('div');
                runeElement.className = `rune-item rarity-${runes[runeId].rarity}`;
                
                runeElement.innerHTML = `
                    <strong>${runes[runeId].name}</strong><br>
                    <small>${runes[runeId].description}</small><br>
                    <small>Owned: ${runeCounts[runeId]}</small>
                `;
                
                runeElement.addEventListener('click', () => {
                    showRuneSocketingOptions(runeId);
                });
                
                runesDisplay.appendChild(runeElement);
            });
            
            if (gameState.player.runes.length === 0) {
                runesDisplay.innerHTML = '<div>No runes available. Defeat enemies to find runes!</div>';
            }
            
            // Update artifacts display
            const artifactsDisplay = document.getElementById('artifacts-display');
            artifactsDisplay.innerHTML = '';
            
            gameState.player.artifacts.forEach(artifactId => {
                const artifactElement = document.createElement('div');
                artifactElement.className = `item rarity-${artifacts[artifactId].rarity}`;
                if (artifacts[artifactId].rarity === 'legendary') {
                    artifactElement.classList.add('legendary-item');
                }
                artifactElement.innerHTML = `
                    <strong>${artifacts[artifactId].name}</strong><br>
                    <small>${artifacts[artifactId].description}</small>
                `;
                artifactsDisplay.appendChild(artifactElement);
            });
            
            // Update set bonuses
            setBonusSystem.checkSetBonuses();
        }

        // Rune Socketing System
        function showRuneSocketingOptions(runeId) {
            const socketableItems = [];
            
            // Check equipped items
            Object.keys(gameState.player.equipment).forEach(slot => {
                const itemId = gameState.player.equipment[slot];
                if (itemId) {
                    const item = items[itemId];
                    if (item.runeSockets > 0) {
                        for (let i = 0; i < item.runeSockets; i++) {
                            const socketKey = `${itemId}_${i}`;
                            if (!runeSystem.socketedRunes[socketKey]) {
                                socketableItems.push({
                                    itemId: itemId,
                                    slot: slot,
                                    socketIndex: i,
                                    item: item
                                });
                            }
                        }
                    }
                }
            });
            
            // Check inventory items
            gameState.player.inventory.forEach(itemId => {
                const item = items[itemId];
                if (item.runeSockets > 0) {
                    for (let i = 0; i < item.runeSockets; i++) {
                        const socketKey = `${itemId}_${i}`;
                        if (!runeSystem.socketedRunes[socketKey]) {
                            socketableItems.push({
                                itemId: itemId,
                                slot: 'inventory',
                                socketIndex: i,
                                item: item
                            });
                        }
                    }
                }
            });
            
            if (socketableItems.length === 0) {
                addToGameLog("No items with empty rune sockets available!");
                return;
            }
            
            const socketingModal = document.createElement('div');
            socketingModal.className = 'rune-modal';
            socketingModal.innerHTML = `
                <h3>Socket ${runes[runeId].name}</h3>
                <p>Choose an item to socket this rune into:</p>
                <div id="socketing-options"></div>
                <div class="button" id="close-socketing" style="margin-top: 10px;">Cancel</div>
            `;
            
            document.getElementById('inventory-screen').appendChild(socketingModal);
            
            const socketingOptions = document.getElementById('socketing-options');
            
            socketableItems.forEach(socketable => {
                const option = document.createElement('div');
                option.className = 'socketable-item';
                option.innerHTML = `
                    <strong>${socketable.item.name}</strong><br>
                    <small>${socketable.slot === 'inventory' ? 'In Inventory' : 'Equipped'}</small><br>
                    <small>Socket ${socketable.socketIndex + 1}</small>
                `;
                
                option.addEventListener('click', () => {
                    runeSystem.socketRune(socketable.itemId, runeId, socketable.socketIndex);
                    socketingModal.remove();
                    updateInventoryDisplay();
                });
                
                socketingOptions.appendChild(option);
            });
            
            document.getElementById('close-socketing').addEventListener('click', () => {
                socketingModal.remove();
            });
        }

        // Enhanced item display with rune sockets
        function getItemStatsDisplay(itemId) {
            const item = items[itemId];
            let statsHTML = '';
            
            if (item.type === 'weapon') {
                statsHTML = `DMG: ${item.damage.min}-${item.damage.max}`;
                if (item.magic) statsHTML += ` | MAG: ${item.magic}`;
                if (item.strength) statsHTML += ` | STR: ${item.strength}`;
                if (item.agility) statsHTML += ` | AGI: ${item.agility}`;
                if (item.runeSockets > 0) {
                    statsHTML += ` | Sockets: `;
                    for (let i = 0; i < item.runeSockets; i++) {
                        const socketKey = `${itemId}_${i}`;
                        if (runeSystem.socketedRunes[socketKey]) {
                            const runeId = runeSystem.socketedRunes[socketKey];
                            statsHTML += `<span class="rune-socket filled" title="${runes[runeId].name}">●</span>`;
                        } else {
                            statsHTML += `<span class="rune-socket">○</span>`;
                        }
                    }
                }
                // Show enchantments
                if (item.enchants && item.enchants.length > 0) {
                    statsHTML += `<br>Enchants: `;
                    item.enchants.forEach(ench => {
                        statsHTML += `<small>${enchantments[ench].name}</small> `;
                    });
                }
                // Show set info
                if (item.set) {
                    statsHTML += `<br><small>Set: ${setBonuses[item.set].name}</small>`;
                }
            } else if (item.type === 'armor') {
                statsHTML = `DEF: ${item.defense}`;
                if (item.magic) statsHTML += ` | MAG: ${item.magic}`;
                if (item.strength) statsHTML += ` | STR: ${item.strength}`;
                if (item.agility) statsHTML += ` | AGI: ${item.agility}`;
                if (item.runeSockets > 0) {
                    statsHTML += ` | Sockets: `;
                    for (let i = 0; i < item.runeSockets; i++) {
                        const socketKey = `${itemId}_${i}`;
                        if (runeSystem.socketedRunes[socketKey]) {
                            const runeId = runeSystem.socketedRunes[socketKey];
                            statsHTML += `<span class="rune-socket filled" title="${runes[runeId].name}">●</span>`;
                        } else {
                            statsHTML += `<span class="rune-socket">○</span>`;
                        }
                    }
                }
                // Show enchantments
                if (item.enchants && item.enchants.length > 0) {
                    statsHTML += `<br>Enchants: `;
                    item.enchants.forEach(ench => {
                        statsHTML += `<small>${enchantments[ench].name}</small> `;
                    });
                }
                // Show set info
                if (item.set) {
                    statsHTML += `<br><small>Set: ${setBonuses[item.set].name}</small>`;
                }
            } else if (item.type === 'consumable') {
                if (item.effect === 'heal') {
                    statsHTML = `Heals: ${item.power} HP`;
                } else if (item.effect === 'restore_mana') {
                    statsHTML = `Restores: ${item.power} MP`;
                } else if (item.effect === 'restore_souls') {
                    statsHTML = `Restores: ${item.power} Souls`;
                } else if (item.effect === 'create_remains') {
                    statsHTML = `Creates: ${item.power} Remains`;
                } else if (item.effect === 'apply_poison') {
                    statsHTML = `Poison: ${item.power} damage for ${item.duration} turns`;
                }
            }
            
            return statsHTML;
        }

        function equipItem(itemId, slot) {
            // Check class requirements
            const item = items[itemId];
            if (item.classReq && item.classReq !== gameState.player.class) {
                addToGameLog(`Only ${classes[item.classReq].name}s can equip ${item.name}!`);
                return;
            }
            
            if (gameState.player.equipment[slot]) {
                gameState.player.inventory.push(gameState.player.equipment[slot]);
            }
            
            const itemIndex = gameState.player.inventory.indexOf(itemId);
            if (itemIndex !== -1) {
                gameState.player.inventory.splice(itemIndex, 1);
            }
            
            gameState.player.equipment[slot] = itemId;
            updatePlayerStats();
            updateInventoryDisplay();
            addToGameLog(`You equip ${items[itemId].name}.`);
            
            // Check set bonuses after equipping
            setBonusSystem.checkSetBonuses();
        }

        function useItem(itemId) {
            const item = items[itemId];
            
            if (item.type === 'consumable') {
                if (item.effect === 'heal') {
                    gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + item.power);
                    addToGameLog(`You use ${item.name} and restore ${item.power} HP.`);
                } else if (item.effect === 'restore_mana') {
                    gameState.player.mp = Math.min(gameState.player.maxMp, gameState.player.mp + item.power);
                    addToGameLog(`You use ${item.name} and restore ${item.power} MP.`);
                } else if (item.effect === 'restore_souls') {
                    gameState.player.souls = Math.min(gameState.player.maxSouls, gameState.player.souls + item.power);
                    addToGameLog(`You use ${item.name} and restore ${item.power} souls.`);
                } else if (item.effect === 'create_remains') {
                    gameState.player.remains += item.power;
                    addToGameLog(`You use ${item.name} and gain ${item.power} remains.`);
                } else if (item.effect === 'apply_poison') {
                    // This would be used in battle
                    addToGameLog(`You prepare ${item.name} for use in battle.`);
                } else if (item.effect === 'mutate_minion') {
                    if (gameState.player.minions.length > 0) {
                        const minion = gameState.player.minions[0];
                        minion.attack += 5;
                        minion.maxHp += 10;
                        minion.hp = Math.min(minion.hp, minion.maxHp);
                        addToGameLog(`You mutate ${minion.name} with ${item.name}, increasing its power!`);
                    } else {
                        addToGameLog(`You need a minion to use ${item.name}!`);
                        return;
                    }
                }
                
                const itemIndex = gameState.player.inventory.indexOf(itemId);
                if (itemIndex !== -1) {
                    gameState.player.inventory.splice(itemIndex, 1);
                }
                
                updatePlayerStats();
                updateInventoryDisplay();
            }
        }

        // Display updates
        function updateSpellSelectionDisplay() {
            document.getElementById('spell-select-mp').textContent = gameState.player.mp;
            document.getElementById('spell-select-max-mp').textContent = gameState.player.maxMp;
            document.getElementById('spell-select-souls').textContent = gameState.player.souls;
            
            const spellSelectElement = document.getElementById('spell-select-list');
            spellSelectElement.innerHTML = '';
            
            gameState.player.spells.forEach(spellId => {
                const spell = spells[spellId];
                const spellElement = document.createElement('div');
                spellElement.className = 'spell-item';
                
                if (gameState.player.mp < spell.cost) {
                    spellElement.classList.add('disabled');
                }
                
                if (spell.type === 'minion' && gameState.player.souls < spell.souls) {
                    spellElement.classList.add('disabled');
                }
                
                const spellInfo = document.createElement('div');
                spellInfo.className = 'spell-info';
                spellInfo.innerHTML = `
                    <strong>${spell.name}</strong><br>
                    <small>${spell.description}</small>
                `;
                
                const spellCost = document.createElement('div');
                spellCost.className = 'spell-cost';
                if (spell.type === 'minion') {
                    spellCost.textContent = `${spell.cost} MP, ${spell.souls} Souls`;
                } else {
                    spellCost.textContent = `${spell.cost} MP`;
                }
                
                spellElement.appendChild(spellInfo);
                spellElement.appendChild(spellCost);
                
                if (gameState.player.mp >= spell.cost) {
                    if (spell.type !== 'minion' || gameState.player.souls >= spell.souls) {
                        spellElement.addEventListener('click', () => {
                            audioSystem.playSound('spell');
                            castSpell(spellId);
                        });
                    }
                }
                
                spellSelectElement.appendChild(spellElement);
            });
        }

        function updateMinionCommandDisplay() {
            const minionCommandElement = document.getElementById('minion-command-list');
            minionCommandElement.innerHTML = '';
            
            if (gameState.player.minions.length === 0) {
                minionCommandElement.innerHTML = '<div>You have no minions to command.</div>';
                return;
            }
            
            gameState.player.minions.forEach((minion, index) => {
                const minionElement = document.createElement('div');
                minionElement.className = 'spell-item';
                
                const minionInfo = document.createElement('div');
                minionInfo.className = 'spell-info';
                minionInfo.innerHTML = `
                    <strong>${minion.name}</strong><br>
                    <small>HP: ${minion.hp}/${minion.maxHp} | ATK: ${minion.attack}</small>
                `;
                
                const attackButton = document.createElement('div');
                attackButton.className = 'button';
                attackButton.textContent = 'ATTACK';
                attackButton.addEventListener('click', () => {
                    audioSystem.playSound('battle');
                    commandMinion(index, 'attack');
                });
                
                minionElement.appendChild(minionInfo);
                minionElement.appendChild(attackButton);
                
                minionCommandElement.appendChild(minionElement);
            });
        }

        // Enhanced Minion Management Display
        function updateMinionManagementDisplay() {
            const managementList = document.getElementById('minion-management-list');
            managementList.innerHTML = '';
            
            if (gameState.player.minions.length === 0) {
                managementList.innerHTML = '<div>You have no minions to manage.</div>';
                return;
            }
            
            gameState.player.minions.forEach((minion, index) => {
                const minionElement = document.createElement('div');
                minionElement.className = 'spell-item';
                
                const minionInfo = document.createElement('div');
                minionInfo.className = 'spell-info';
                minionInfo.innerHTML = `
                    <strong>${minion.name} (Lvl ${minion.level || 1})</strong><br>
                    <small>HP: ${minion.hp}/${minion.maxHp} | ATK: ${minion.attack} | DEF: ${minion.defense}</small><br>
                    <small>EXP: ${minion.exp || 0}/${minion.expNeeded || 100}</small>
                `;
                
                const manageButton = document.createElement('div');
                manageButton.className = 'button';
                manageButton.textContent = 'MANAGE';
                manageButton.addEventListener('click', () => {
                    minionManagementSystem.showMinionDetails(index);
                });
                
                minionElement.appendChild(minionInfo);
                minionElement.appendChild(manageButton);
                
                managementList.appendChild(minionElement);
            });
        }

        function updateMinionEquipmentDisplay() {
            const equipmentDisplay = document.getElementById('minion-equipment-display');
            equipmentDisplay.innerHTML = '';
            
            const minionEquipment = gameState.player.inventory.filter(itemId => 
                items[itemId].type && items[itemId].type.startsWith('minion_')
            );
            
            if (minionEquipment.length === 0) {
                equipmentDisplay.innerHTML = '<div>No minion equipment available.</div>';
                return;
            }
            
            minionEquipment.forEach(itemId => {
                const itemElement = document.createElement('div');
                itemElement.className = `item rarity-${items[itemId].rarity}`;
                itemElement.textContent = items[itemId].name;
                equipmentDisplay.appendChild(itemElement);
            });
        }

        function updateMinionEvolutionDisplay() {
            const evolutionDisplay = document.getElementById('minion-evolution-display');
            evolutionDisplay.innerHTML = '';
            
            gameState.player.minions.forEach((minion, index) => {
                const minionData = minions[minion.type];
                if (minionData.evolution && (minion.level || 1) >= 5) {
                    const evolutionElement = document.createElement('div');
                    evolutionElement.className = 'spell-item';
                    
                    evolutionElement.innerHTML = `
                        <strong>Evolve ${minion.name}</strong><br>
                        <small>Cost: 50 Souls, 5 Remains</small>
                    `;
                    
                    const evolveButton = document.createElement('div');
                    evolveButton.className = 'button';
                    evolveButton.textContent = 'EVOLVE';
                    evolveButton.addEventListener('click', () => {
                        evolveMinion(index);
                    });
                    
                    evolutionElement.appendChild(evolveButton);
                    evolutionDisplay.appendChild(evolutionElement);
                }
            });
            
            if (evolutionDisplay.innerHTML === '') {
                evolutionDisplay.innerHTML = '<div>No minions ready for evolution.</div>';
            }
        }

        function evolveMinion(minionIndex) {
            const minion = gameState.player.minions[minionIndex];
            const minionData = minions[minion.type];
            
            if (gameState.player.souls >= 50 && gameState.player.remains >= 5) {
                gameState.player.souls -= 50;
                gameState.player.remains -= 5;
                
                const newMinionType = minionData.evolution;
                const newMinionData = minions[newMinionType];
                
                minion.type = newMinionType;
                minion.name = newMinionData.name;
                minion.maxHp = newMinionData.hp;
                minion.hp = newMinionData.hp;
                minion.attack = newMinionData.attack;
                minion.defense = newMinionData.defense;
                minion.abilities = newMinionData.abilities;
                
                addToGameLog(`Your ${minionData.name} evolves into a ${newMinionData.name}!`);
                audioSystem.playSound('enchant');
                updatePlayerStats();
                updateMinionManagementDisplay();
            } else {
                addToGameLog("Not enough souls or remains to evolve this minion!");
            }
        }

        function updateRaiseDisplay() {
            document.getElementById('raise-souls').textContent = gameState.player.souls;
            document.getElementById('player-remains').textContent = gameState.player.remains;
            
            const raiseOptionsElement = document.getElementById('raise-options');
            raiseOptionsElement.innerHTML = '';
            
            Object.keys(minions).forEach(minionType => {
                const minion = minions[minionType];
                const minionElement = document.createElement('div');
                minionElement.className = 'spell-item';
                
                // Check class requirements
                const hasClassReq = !minion.classReq || minion.classReq === gameState.player.class;
                
                const canRaise = hasClassReq && 
                                gameState.player.souls >= minion.cost && 
                                gameState.player.remains >= minion.remains &&
                                gameState.player.minions.length < 2;
                
                if (!canRaise) {
                    minionElement.classList.add('disabled');
                }
                
                const minionInfo = document.createElement('div');
                minionInfo.className = 'spell-info';
                let requirementText = '';
                if (minion.classReq) {
                    requirementText = `<br><small>Requires: ${classes[minion.classReq].name}</small>`;
                }
                minionInfo.innerHTML = `
                    <strong>${minion.name}</strong>
                    ${requirementText}
                    <br><small>${minion.description}</small>
                    <br><small>HP: ${minion.hp} | ATK: ${minion.attack} | DEF: ${minion.defense}</small>
                `;
                
                const minionCost = document.createElement('div');
                minionCost.className = 'spell-cost';
                minionCost.textContent = `${minion.cost} Souls, ${minion.remains} Remains`;
                
                const raiseButton = document.createElement('div');
                raiseButton.className = 'button';
                raiseButton.textContent = 'RAISE';
                if (canRaise) {
                    raiseButton.addEventListener('click', () => {
                        audioSystem.playSound('spell');
                        raiseMinion(minionType);
                    });
                }
                
                minionElement.appendChild(minionInfo);
                minionElement.appendChild(minionCost);
                minionElement.appendChild(raiseButton);
                
                raiseOptionsElement.appendChild(minionElement);
            });
        }

        function updateRitualsDisplay() {
            const ritualsElement = document.getElementById('rituals-list');
            ritualsElement.innerHTML = '';
            
            Object.keys(rituals).forEach(ritualId => {
                const ritual = rituals[ritualId];
                const ritualElement = document.createElement('div');
                ritualElement.className = 'spell-item';
                
                const ritualInfo = document.createElement('div');
                ritualInfo.className = 'spell-info';
                ritualInfo.innerHTML = `
                    <strong>${ritual.name}</strong><br>
                    <small>${ritual.description}</small>
                `;
                
                const ritualCost = document.createElement('div');
                ritualCost.className = 'spell-cost';
                ritualCost.textContent = `${ritual.cost} Souls`;
                
                const performButton = document.createElement('div');
                performButton.className = 'button';
                performButton.textContent = 'PERFORM';
                if (gameState.player.souls >= ritual.cost) {
                    performButton.addEventListener('click', () => {
                        audioSystem.playSound('ritual');
                        performRitual(ritualId);
                    });
                } else {
                    performButton.classList.add('disabled');
                }
                
                ritualElement.appendChild(ritualInfo);
                ritualElement.appendChild(ritualCost);
                ritualElement.appendChild(performButton);
                
                ritualsElement.appendChild(ritualElement);
            });
        }

        function updateMinionDisplay() {
            const minionDisplay = document.getElementById('minion-display');
            minionDisplay.innerHTML = '';
            
            if (gameState.player.minions.length === 0) {
                minionDisplay.innerHTML = '<div class="minion-slot">Empty</div><div class="minion-slot">Empty</div>';
                return;
            }
            
            gameState.player.minions.forEach(minion => {
                const minionElement = document.createElement('div');
                minionElement.className = 'minion-slot';
                minionElement.innerHTML = `
                    ${minion.name}<br>
                    <span class="minion-health">HP: ${minion.hp}/${minion.maxHp}</span><br>
                    <span class="minion-level">Lvl ${minion.level || 1}</span>
                `;
                minionDisplay.appendChild(minionElement);
            });
            
            for (let i = gameState.player.minions.length; i < 2; i++) {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'minion-slot';
                emptySlot.textContent = 'Empty';
                minionDisplay.appendChild(emptySlot);
            }
        }

        function updateBattleMinionDisplay() {
            const minionDisplay = document.getElementById('battle-minion-display');
            minionDisplay.innerHTML = '';
            
            if (gameState.player.minions.length === 0) {
                minionDisplay.innerHTML = '<div class="minion-slot">No Minions</div>';
                return;
            }
            
            gameState.player.minions.forEach(minion => {
                const minionElement = document.createElement('div');
                minionElement.className = 'minion-slot';
                minionElement.innerHTML = `
                    ${minion.name}<br>
                    <span class="minion-health">HP: ${minion.hp}/${minion.maxHp}</span>
                `;
                minionDisplay.appendChild(minionElement);
            });
        }

        // UI updates
        function updatePlayerStats() {
            document.getElementById('player-level').textContent = gameState.player.level;
            document.getElementById('player-hp').textContent = gameState.player.hp;
            document.getElementById('player-max-hp').textContent = gameState.player.maxHp;
            document.getElementById('player-mp').textContent = gameState.player.mp;
            document.getElementById('player-max-mp').textContent = gameState.player.maxMp;
            document.getElementById('player-souls').textContent = gameState.player.souls;
            document.getElementById('player-exp').textContent = gameState.player.exp;
            document.getElementById('player-exp-needed').textContent = gameState.player.expNeeded;
            
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${hpPercent}%`;
            
            const manaPercent = (gameState.player.mp / gameState.player.maxMp) * 100;
            document.getElementById('mana-bar').style.width = `${manaPercent}%`;
            
            const expPercent = (gameState.player.exp / gameState.player.expNeeded) * 100;
            document.getElementById('exp-bar').style.width = `${expPercent}%`;
            
            const soulsPercent = (gameState.player.souls / gameState.player.maxSouls) * 100;
            document.getElementById('souls-bar').style.width = `${soulsPercent}%`;
        }

        function updateBattleStats() {
            document.getElementById('enemy-name').textContent = gameState.currentEnemy.name;
            document.getElementById('battle-player-hp').textContent = gameState.player.hp;
            document.getElementById('battle-player-max-hp').textContent = gameState.player.maxHp;
            document.getElementById('battle-player-mp').textContent = gameState.player.mp;
            document.getElementById('battle-player-max-mp').textContent = gameState.player.maxMp;
            document.getElementById('battle-player-souls').textContent = gameState.player.souls;
            
            const playerHpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            document.getElementById('battle-hp-bar').style.width = `${playerHpPercent}%`;
            
            const playerManaPercent = (gameState.player.mp / gameState.player.maxMp) * 100;
            document.getElementById('battle-mana-bar').style.width = `${playerManaPercent}%`;
            
            const enemyHpPercent = (gameState.currentEnemy.hp / gameState.enemyMaxHp) * 100;
            document.getElementById('enemy-hp-bar').style.width = `${enemyHpPercent}%`;
        }

        function updatePlayerHP() {
            document.getElementById('player-hp').textContent = gameState.player.hp;
            document.getElementById('battle-player-hp').textContent = gameState.player.hp;
            
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            document.getElementById('hp-bar').style.width = `${hpPercent}%`;
            document.getElementById('battle-hp-bar').style.width = `${hpPercent}%`;
        }

        function updatePlayerMP() {
            document.getElementById('player-mp').textContent = gameState.player.mp;
            document.getElementById('battle-player-mp').textContent = gameState.player.mp;
            document.getElementById('spell-select-mp').textContent = gameState.player.mp;
            
            const manaPercent = (gameState.player.mp / gameState.player.maxMp) * 100;
            document.getElementById('mana-bar').style.width = `${manaPercent}%`;
            document.getElementById('battle-mana-bar').style.width = `${manaPercent}%`;
        }

        function updatePlayerSouls() {
            document.getElementById('player-souls').textContent = gameState.player.souls;
            document.getElementById('battle-player-souls').textContent = gameState.player.souls;
            document.getElementById('spell-select-souls').textContent = gameState.player.souls;
            document.getElementById('raise-souls').textContent = gameState.player.souls;
            document.getElementById('enchant-souls').textContent = gameState.player.souls;
            
            const soulsPercent = (gameState.player.souls / gameState.player.maxSouls) * 100;
            document.getElementById('souls-bar').style.width = `${soulsPercent}%`;
        }

        function updateEnemyHP() {
            const enemyHpPercent = (gameState.currentEnemy.hp / gameState.enemyMaxHp) * 100;
            document.getElementById('enemy-hp-bar').style.width = `${enemyHpPercent}%`;
        }

        function addToBattleLog(message) {
            const logElement = document.getElementById('battle-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        function addToGameLog(message) {
            const logElement = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
            audioSystem.playSound('notification');
        }

        function showFloatingText(value, parentElement, className) {
            const floatingText = document.createElement('div');
            floatingText.className = `floating-text ${className}`;
            floatingText.textContent = value;
            floatingText.style.left = `${Math.random() * 50 + 25}%`;
            floatingText.style.top = '50%';
            
            parentElement.appendChild(floatingText);
            
            setTimeout(() => {
                floatingText.remove();
            }, 1000);
        }

        // Enhanced Loot Drops
        function getEnhancedLoot(enemy) {
            const loot = [];
            
            enemy.loot.forEach(lootItem => {
                if (Math.random() < lootItem.chance) {
                    loot.push(lootItem.id);
                }
            });
            
            // Chance for runes
            if (Math.random() < 0.2) {
                const runeKeys = Object.keys(runes);
                const randomRune = runeKeys[Math.floor(Math.random() * runeKeys.length)];
                loot.push(`rune_${randomRune}`);
            }
            
            // Chance for artifacts (very rare)
            if (Math.random() < 0.05) {
                const artifactKeys = Object.keys(artifacts);
                const randomArtifact = artifactKeys[Math.floor(Math.random() * artifactKeys.length)];
                loot.push(`artifact_${randomArtifact}`);
            }
            
            // Chance for set items (rare)
            if (Math.random() < 0.03) {
                const setItems = Object.keys(items).filter(itemId => items[itemId].set);
                if (setItems.length > 0) {
                    const randomSetItem = setItems[Math.floor(Math.random() * setItems.length)];
                    loot.push(randomSetItem);
                }
            }
            
            // Chance for enchanting materials
            if (Math.random() < 0.3) {
                gameState.player.enchantingDust += Math.floor(Math.random() * 3) + 1;
            }
            
            return loot;
        }

        // NEW: Save system using optimized compression
        function saveGame() {
            const success = saveSystem.saveGame();
            if (success) {
                addToGameLog("Your progress has been preserved in the soul ledger.");
            } else {
                addToGameLog("Failed to save your progress.");
            }
            return success;
        }

        // NEW: Load game using optimized decompression
        function loadGame() {
            const success = saveSystem.loadGame();
            if (success) {
                updatePlayerStats();
                showGameScreen();
                addToGameLog("Your dark legacy has been restored...");
                
                // Apply font size from saved preferences
                fontSizeSystem.applyFontSize();
                document.getElementById('font-size-btn').textContent = `Font: ${fontSizeSystem.getCurrentSizeName()}`;
            } else {
                addToGameLog("No saved game found. Starting a new journey...");
                showClassSelection();
            }
            return success;
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);

        // Test function to verify game state
        function testGameInitialization() {
            console.log("=== GAME INITIALIZATION TEST ===");
            console.log("New classes added:", Object.keys(classes).length === 6);
            console.log("New spells added:", Object.keys(spells).length >= 32);
            console.log("New minions added:", Object.keys(minions).length >= 13);
            console.log("Set items defined:", Object.keys(setBonuses).length === 3);
            console.log("Legendary artifacts:", Object.keys(artifacts).length >= 7);
            console.log("=== TEST COMPLETE ===");
        }

        // Run test after initialization
        setTimeout(testGameInitialization, 3000);
    </script>
</body>
</html>
