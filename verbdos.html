<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Castle of the Damned (1985) - Nightfalls Games</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #c00;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #c00;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #c00;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            align-items: center;
        }
        #prompt {
            margin-right: 8px;
            white-space: nowrap;
        }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid #c00;
            color: #c00;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 4px 0;
        }
        #status {
            border-top: 1px solid #c00;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        .command {
            color: #ff6b6b;
        }
        .error {
            color: #ff0000;
        }
        .item {
            color: #00cccc;
        }
        .enemy {
            color: #cc00cc;
        }
        .npc {
            color: #ff9933;
        }
        .success {
            color: #00cc00;
        }
        .quest {
            color: #ffff66;
        }
        .loot {
            color: #ff66b2;
        }
        .system {
            color: #888;
        }
        .damage {
            color: #ff4500;
        }
        .heal {
            color: #32cd32;
        }
        .skill {
            color: #00ffff;
        }
        .puzzle {
            color: #ff66ff;
        }
        .hint {
            color: #aaa;
        }
        .dialogue {
            color: #ffcc66;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        .quick-command {
            display: inline-block;
            background: #222;
            border: 1px solid #c00;
            color: #c00;
            padding: 2px 6px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        #quick-commands {
            margin-top: 8px;
            text-align: center;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        #save-load-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #000;
            border: 1px solid #c00;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        .save-load-btn {
            background: #000;
            border: 1px solid #c00;
            color: #c00;
            padding: 2px 4px;
            margin: 2px;
            cursor: pointer;
            font-size: 8px;
        }
    </style>
</head>
<body>
    <div id="save-load-controls">
        <button class="save-load-btn" onclick="saveGame()">SAVE</button>
        <button class="save-load-btn" onclick="loadGame()">LOAD</button>
        <button class="save-load-btn" onclick="quickSave()">QSAVE</button>
        <button class="save-load-btn" onclick="quickLoad()">QLOAD</button>
    </div>
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    <div id="header">
        <h1>CASTLE OF THE DAMNED</h1>
        <div>1985 â€¢ NIGHTFALLS GAMES</div>
    </div>
    <div id="game-container">
        <div id="output">Welcome to Castle of the Damned! Type 'help' for commands.</div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="quick-commands">
            <span class="quick-command" onclick="quickCommand('n')">N</span>
            <span class="quick-command" onclick="quickCommand('s')">S</span>
            <span class="quick-command" onclick="quickCommand('e')">E</span>
            <span class="quick-command" onclick="quickCommand('w')">W</span>
            <span class="quick-command" onclick="quickCommand('look')">LOOK</span>
            <span class="quick-command" onclick="quickCommand('attack')">ATTACK</span>
            <span class="quick-command" onclick="quickCommand('inventory')">INV</span>
            <span class="quick-command" onclick="quickCommand('skills')">SKILLS</span>
        </div>
        <div id="status"></div>
    </div>

    <script>
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.3; // Lower volume for background music
                    this.sfxGain.gain.value = 0.5; // Higher volume for SFX
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            // ==================== MUSIC GENERATION ====================
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                // Don't restart same music
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                // Stop current background
                this.stopBackground();
                
                this.currentBgName = musicName;
                
                // Generate music based on name
                switch(musicName) {
                    case 'theme':
                        this.playThemeTune(loop);
                        break;
                    case 'castle':
                        this.playCastleMusic(loop);
                        break;
                    case 'gothic':
                        this.playGothicMusic(loop);
                        break;
                    case 'boss':
                        this.playBossMusic(loop);
                        break;
                    case 'victory':
                        this.playVictoryMusic(loop);
                        break;
                    case 'catacombs':
                        this.playCatacombsMusic(loop);
                        break;
                    default:
                        this.playThemeTune(loop);
                }
            }
            
            playThemeTune(loop) {
                // Gothic Dracula theme with longer notes
                const melody = [
                    {note: 220, duration: 0.6},    // A (lower, eerie)
                    {note: 196, duration: 0.3},    // G
                    {note: 174.61, duration: 0.9}, // F (long, haunting)
                    {note: 164.81, duration: 0.6}, // E
                    {note: 146.83, duration: 0.3}, // D
                    {note: 130.81, duration: 1.2}, // C (very long, deep)
                    {note: 164.81, duration: 0.6}, // E
                    {note: 196, duration: 0.9},    // G (long)
                    {note: 220, duration: 1.5},    // A (very long, dramatic)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.2);
            }
            
            playCastleMusic(loop) {
                // Dark, gothic castle music
                const melody = [
                    {note: 130.81, duration: 0.8}, // C low (long)
                    {note: 164.81, duration: 0.8}, // E (long)
                    {note: 196.00, duration: 0.8}, // G (long)
                    {note: 146.83, duration: 0.8}, // D (long)
                    {note: 174.61, duration: 1.6}, // F (very long)
                ];
                
                this.playMelody(melody, 'square', loop, 0.15);
            }
            
            playGothicMusic(loop) {
                // Gothic, atmospheric music
                const melody = [
                    {note: 220, duration: 1.2},   // A (long)
                    {note: 207.65, duration: 0.6}, // G# (medium)
                    {note: 196.00, duration: 1.2}, // G (long)
                    {note: 184.99, duration: 0.6}, // F# (medium)
                    {note: 174.61, duration: 1.8}, // F (very long)
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.1);
            }
            
            playCatacombsMusic(loop) {
                // Creepy catacombs music
                const melody = [
                    {note: 98.00, duration: 1.0},   // G low (long)
                    {note: 116.54, duration: 0.5},  // A# (medium)
                    {note: 130.81, duration: 1.0},  // C (long)
                    {note: 103.83, duration: 0.5},  // G# (medium)
                    {note: 123.47, duration: 1.5},  // B (very long)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.12);
            }
            
            playBossMusic(loop) {
                // Intense vampire battle music with longer notes
                const melody = [
                    {note: 261.63, duration: 0.4}, // C (medium)
                    {note: 329.63, duration: 0.4}, // E (medium)
                    {note: 392.00, duration: 0.4}, // G (medium)
                    {note: 523.25, duration: 0.8}, // C high (long)
                    {note: 392.00, duration: 0.4}, // G (medium)
                    {note: 329.63, duration: 0.4}, // E (medium)
                    {note: 261.63, duration: 1.0}, // C (very long)
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.25);
            }
            
            playVictoryMusic(loop) {
                // Gothic victory fanfare with longer notes
                const melody = [
                    {note: 523.25, duration: 0.4}, // C (medium)
                    {note: 659.25, duration: 0.4}, // E (medium)
                    {note: 783.99, duration: 0.4}, // G (medium)
                    {note: 1046.50, duration: 1.0}, // C high (very long)
                    {note: 783.99, duration: 0.4}, // G (medium)
                    {note: 1046.50, duration: 1.0}, // C high (very long)
                    {note: 1318.51, duration: 1.8}, // E high (very very long)
                ];
                
                this.playMelody(melody, 'sine', loop, 0.3);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                // Schedule notes
                let currentTime = now;
                melody.forEach((note, index) => {
                    // Set frequency
                    source.frequency.setValueAtTime(note.note, currentTime);
                    
                    // Create envelope for each note (longer fade for longer notes)
                    const fadeIn = Math.min(0.1, note.duration * 0.15);
                    const fadeOut = Math.min(0.15, note.duration * 0.2);
                    
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + fadeIn);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - fadeOut);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    
                    currentTime += note.duration;
                });
                
                if (loop) {
                    // Loop the melody
                    source.start(now);
                    source.stop(now + currentTime - now);
                    
                    // Schedule next loop
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try {
                        this.currentBgSource.stop();
                    } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            // ==================== SOUND EFFECTS ====================
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                switch(soundName) {
                    case 'click':
                        this.playClick(volume);
                        break;
                    case 'notification':
                        this.playNotification(volume);
                        break;
                    case 'levelup':
                        this.playLevelUp(volume);
                        break;
                    case 'attack':
                        this.playAttack(volume);
                        break;
                    case 'enemyHit':
                        this.playEnemyHit(volume);
                        break;
                    case 'playerHit':
                        this.playPlayerHit(volume);
                        break;
                    case 'victory':
                        this.playVictory(volume);
                        break;
                    case 'defeat':
                        this.playDefeat(volume);
                        break;
                    case 'pickup':
                        this.playPickup(volume);
                        break;
                    case 'equip':
                        this.playEquip(volume);
                        break;
                    case 'door':
                        this.playDoor(volume);
                        break;
                    case 'step':
                        this.playStep(volume);
                        break;
                    case 'spell':
                        this.playSpell(volume);
                        break;
                    case 'heal':
                        this.playHeal(volume);
                        break;
                    case 'buff':
                        this.playBuff(volume);
                        break;
                    case 'puzzle':
                        this.playPuzzle(volume);
                        break;
                    case 'secret':
                        this.playSecret(volume);
                        break;
                    case 'bat':
                        this.playBat(volume);
                        break;
                    case 'howl':
                        this.playHowl(volume);
                        break;
                    case 'thunder':
                        this.playThunder(volume);
                        break;
                }
            }
            
            playClick(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playNotification(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playLevelUp(volume) {
                const now = this.audioContext.currentTime;
                
                // Play a dramatic ascending arpeggio
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C, E, G, C high
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.2);
                });
            }
            
            playAttack(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playEnemyHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playPlayerHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playVictory(volume) {
                const now = this.audioContext.currentTime;
                
                // Gothic victory fanfare
                const notes = [
                    {freq: 523.25, time: 0.0, duration: 0.4},
                    {freq: 659.25, time: 0.4, duration: 0.4},
                    {freq: 783.99, time: 0.8, duration: 0.4},
                    {freq: 1046.50, time: 1.2, duration: 1.0},
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    gainNode.gain.setValueAtTime(0, now + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + note.time + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + note.time);
                    oscillator.stop(now + note.time + note.duration);
                });
            }
            
            playDefeat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, now);
                oscillator.frequency.exponentialRampToValueAtTime(110, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playPickup(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, now);
                oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playEquip(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playDoor(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStep(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playSpell(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playHeal(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playBuff(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(500, now);
                oscillator.frequency.exponentialRampToValueAtTime(700, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playPuzzle(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playSecret(volume) {
                const now = this.audioContext.currentTime;
                
                // Mysterious secret sound
                const notes = [400, 600, 800, 1000];
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.15);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.15);
                });
            }
            
            playBat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1600, now + 0.2);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.4);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.1, now + 0.2);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playHowl(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 1.0);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.2);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 1.0);
            }
            
            playThunder(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 1.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 1.5);
            }
            
            // ==================== UTILITY METHODS ====================
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            hunter: { 
                hp: 35, mp: 8, str: 8, def: 6, stealth: 4, 
                desc: "A vampire hunter skilled with silver and holy weapons.",
                skills: ['silver_strike', 'ward']
            },
            sorcerer: { 
                hp: 24, mp: 28, str: 4, def: 3, stealth: 5,
                desc: "A master of arcane arts, able to wield light against darkness.",
                skills: ['sunbeam', 'barrier']
            },
            dhampir: { 
                hp: 30, mp: 15, str: 6, def: 4, stealth: 7,
                desc: "Half-vampire, half-human. You walk between both worlds.",
                skills: ['blood_drain', 'shadow_step']
            }
        };

        // ==================== SKILL SYSTEM ====================
        const skills = {
            silver_strike: {
                name: "Silver Strike",
                mpCost: 6,
                description: "A silver-enhanced strike that wounds vampires deeply",
                class: "hunter",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.8) + Math.floor(Math.random() * 10);
                    enemyData.hp -= damage;
                    print(`You strike with SILVER for ${damage} damage!`, 'damage');
                    soundSystem.playSound('attack', 0.7);
                    
                    // Extra damage against vampires
                    if (enemyData.originalType && enemyData.originalType.includes('vampire')) {
                        const bonus = Math.floor(damage * 0.5);
                        enemyData.hp -= bonus;
                        print(`Silver burns the vampire for ${bonus} bonus damage!`, 'damage');
                    }
                    return true;
                }
            },
            ward: {
                name: "Holy Ward",
                mpCost: 4,
                description: "Create a protective ward against dark creatures",
                class: "hunter",
                effect: function(player, enemyData) {
                    player.ward = 4;
                    print("You create a holy ward. Next damage reduced significantly!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            sunbeam: {
                name: "Sunbeam",
                mpCost: 10,
                description: "Channel sunlight to burn undead and vampires",
                class: "sorcerer",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.8) + Math.floor(Math.random() * 20) + 15;
                    enemyData.hp -= damage;
                    print(`You channel SUNLIGHT for ${damage} damage!`, 'damage');
                    soundSystem.playSound('spell', 0.7);
                    
                    // Extra effect against undead
                    if (enemyData.originalType && (enemyData.originalType.includes('vampire') || 
                        enemyData.originalType.includes('skeleton') || 
                        enemyData.originalType.includes('ghost'))) {
                        enemyData.sunburned = 4;
                        print("The undead creature is burning in sunlight!", 'success');
                    }
                    return true;
                }
            },
            barrier: {
                name: "Arcane Barrier",
                mpCost: 8,
                description: "Create a magical barrier that absorbs damage",
                class: "sorcerer",
                effect: function(player, enemyData) {
                    player.barrier = Math.floor(player.maxHp * 0.4);
                    print(`You create an arcane barrier that absorbs ${player.barrier} damage!`, 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            },
            blood_drain: {
                name: "Blood Drain",
                mpCost: 8,
                description: "Drain life from your enemy to heal yourself",
                class: "dhampir",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.2) + Math.floor(Math.random() * 12);
                    enemyData.hp -= damage;
                    const heal = Math.floor(damage * 0.6);
                    player.hp = Math.min(player.maxHp, player.hp + heal);
                    print(`You drain ${damage} life and heal ${heal} HP!`, 'skill');
                    soundSystem.playSound('heal', 0.6);
                    return true;
                }
            },
            shadow_step: {
                name: "Shadow Step",
                mpCost: 12,
                description: "Move through shadows to avoid attacks",
                class: "dhampir",
                effect: function(player, enemyData) {
                    player.shadowed = 3;
                    print("You blend with the shadows. Enemies will likely miss!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false; // Doesn't end turn
                }
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 3, type: 'weapon', value: 0, desc: "Your bare hands." },
            stake: { name: "Wooden Stake", dmg: 12, type: 'weapon', value: 25, desc: "A sharp wooden stake. Effective against vampires.", vs_vampire: 10 },
            silver_sword: { name: "Silver Sword", dmg: 18, type: 'weapon', value: 120, desc: "A sword forged from pure silver. Burns the undead.", vs_undead: 15 },
            crossbow: { name: "Crossbow", dmg: 16, type: 'weapon', value: 80, desc: "A heavy crossbow with silver-tipped bolts.", range: true },
            morning_star: { name: "Morning Star", dmg: 22, type: 'weapon', value: 150, desc: "A spiked flail blessed by a priest.", holy: true },
            arcane_staff: { name: "Arcane Staff", dmg: 14, type: 'weapon', value: 100, desc: "A staff imbued with light magic.", magic: 12, light: true },
            wolfsbane_dagger: { name: "Wolfsbane Dagger", dmg: 10, type: 'weapon', value: 65, desc: "A dagger coated in wolfsbane. Effective against werewolves.", vs_werewolf: 20 },
            holy_water_sprinkler: { name: "Holy Water Sprinkler", dmg: 8, type: 'weapon', value: 45, desc: "A device that sprays holy water.", holy: true, vs_undead: 25 }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather: { name: "Leather Armor", def: 6, type: 'armor', value: 30, desc: "Soft leather armor. Good mobility.", stealth: 3 },
            chainmail: { name: "Chainmail", def: 10, type: 'armor', value: 80, desc: "Heavy chainmail. Good protection.", stealth: -1 },
            hunter_coat: { name: "Hunter's Coat", def: 8, type: 'armor', value: 60, desc: "A long coat with silver threads woven in.", stealth: 4, vs_vampire: 5 },
            plate: { name: "Plate Armor", def: 15, type: 'armor', value: 150, desc: "Full plate armor. Maximum protection.", stealth: -5 },
            robe: { name: "Sorcerer's Robe", def: 5, type: 'armor', value: 40, desc: "A dark robe that enhances magic.", stealth: 4, magic: 8 },
            vampire_cloak: { name: "Vampire Cloak", def: 4, type: 'armor', value: 90, desc: "A dark cloak that blends with shadows.", stealth: 8, darkness: true }
        };

        const items = {
            potion: { type: 'consumable', effect: { hp: 30 }, value: 25, desc: "Heals 30 HP." },
            manapot: { type: 'consumable', effect: { mp: 25 }, value: 30, desc: "Restores 25 MP." },
            elixir: { type: 'consumable', effect: { hp: 60, mp: 40 }, value: 75, desc: "Restores 60 HP and 40 MP." },
            garlic: { type: 'consumable', effect: { ward_vampire: 5 }, value: 15, desc: "Repels vampires for 5 turns." },
            holy_water: { type: 'consumable', effect: { damage_undead: 75 }, value: 50, desc: "Water blessed by a priest. Devastating to undead." },
            wolfsbane: { type: 'consumable', effect: { damage_werewolf: 50 }, value: 35, desc: "A poisonous plant deadly to werewolves." },
            silver_bullet: { type: 'consumable', effect: { damage_vampire: 100 }, value: 80, desc: "A single silver bullet for a firearm." },
            key: { type: 'key', value: 1, desc: "An iron key. It might open something." },
            torch: { type: 'tool', value: 5, desc: "A lit torch. Illuminates dark areas and repels creatures of darkness." },
            gem: { type: 'treasure', value: 125, desc: "A valuable blood-red gemstone." },
            ancient_tome: { type: 'quest', value: 1, desc: "An ancient tome containing vampire lore." },
            vampire_dust: { type: 'quest', value: 1, desc: "Dust from a defeated vampire." },
            werewolf_fang: { type: 'quest', value: 1, desc: "A sharp fang from a werewolf." },
            ghost_essence: { type: 'quest', value: 1, desc: "Ectoplasmic essence from a ghost." },
            crucifix: { type: 'tool', value: 40, desc: "A silver crucifix that wards off evil." },
            mirror: { type: 'tool', value: 25, desc: "A silver-backed hand mirror. Vampires cast no reflection." },
            sun_crystal: { type: 'quest', value: 1, desc: "A crystal that stores sunlight." },
            blood_vial: { type: 'consumable', effect: { hp: 50, mp: -10 }, value: 30, desc: "Vampire blood. Heals but corrupts." }
        };

        const enemies = {
            bat_swarm: { 
                name: "Bat Swarm", 
                hp: 25, dmg: 8, gold: 12, xp: 20, 
                desc: "A swirling mass of sharp-fanged bats.",
                loot: ['garlic'], 
                sounds: { attack: 'bat', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            skeleton: { 
                name: "Skeletal Guard", 
                hp: 40, dmg: 11, gold: 25, xp: 35,
                desc: "An animated skeleton in rusty armor.",
                loot: ['stake', 'potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'castle'
            },
            ghost: { 
                name: "Wailing Ghost", 
                hp: 35, dmg: 9, gold: 20, xp: 30,
                desc: "A translucent spirit that chills the air with its moans.",
                loot: ['ghost_essence', 'manapot'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            werewolf: { 
                name: "Werewolf", 
                hp: 60, dmg: 18, gold: 45, xp: 50,
                desc: "A monstrous hybrid of man and wolf with razor-sharp claws.",
                loot: ['werewolf_fang', 'potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'howl' },
                bgSound: 'castle'
            },
            vampire_spawn: { 
                name: "Vampire Spawn", 
                hp: 55, dmg: 15, gold: 40, xp: 45,
                desc: "A fledgling vampire with pale skin and blood-red eyes.",
                loot: ['vampire_dust', 'blood_vial'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'gothic'
            },
            vampire_knight: { 
                name: "Vampire Knight", 
                hp: 85, dmg: 22, gold: 70, xp: 75,
                desc: "An ancient vampire in black plate armor, wielding a massive sword.",
                loot: ['silver_sword', 'elixir'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'castle'
            },
            vampire_lord: { 
                name: "Vampire Lord", 
                hp: 200, dmg: 35, gold: 300, xp: 200,
                desc: "The master of the castle - an ancient vampire of immense power.",
                loot: ['morning_star', 'hunter_coat', 'elixir', 'gem', 'gem'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss'
            }
        };

        // Create enemy instance function to fix shared HP bug
        function createEnemy(type) {
            const enemyTemplate = enemies[type];
            if (!enemyTemplate) return null;
            
            return {
                ...enemyTemplate,
                hp: enemyTemplate.hp,
                stunned: 0,
                sunburned: 0,
                originalType: type
            };
        }

        const npcs = {
            alchemist: { 
                name: "Alchemist Viktor", 
                desc: "A scholarly man surrounded by bubbling potions and strange instruments.", 
                dialog: "Welcome! I study the creatures of the night. Bring me specimens and I'll reward you.",
                quest: { items: ['vampire_dust', 'werewolf_fang', 'ghost_essence'], reward: { gold: 250, item: 'arcane_staff', xp: 100 }, completed: false },
                hostile: false,
                shopItems: ['stake', 'crossbow', 'garlic', 'holy_water', 'wolfsbane', 'potion', 'manapot', 'crucifix', 'mirror'],
                dialogueTopics: ['vampires', 'werewolves', 'ghosts', 'cures'],
                dialogue: {
                    'default': "The night holds many secrets... and dangers.",
                    'vampires': "A stake through the heart or sunlight will destroy them. Garlic repels them.",
                    'werewolves': "Silver and wolfsbane are their bane. They transform under the full moon.",
                    'ghosts': "They cannot cross salt lines. Holy water damages them severely.",
                    'cures': "I'm researching cures for vampirism and lycanthropy. No success yet..."
                }
            },
            priest: {
                name: "Father Mikhail",
                desc: "An old priest praying in the chapel. He clutches a large silver cross.",
                dialog: "This castle is an abomination! Help me cleanse it of the undead.",
                quest: { item: 'ancient_tome', reward: { gold: 150, item: 'holy_water_sprinkler', xp: 80 }, completed: false },
                hostile: false,
                dialogueTopics: ['vampires', 'holy_water', 'blessings', 'crucifix'],
                dialogue: {
                    'default': "May God protect you in this cursed place.",
                    'vampires': "They cannot enter holy ground without invitation. Use that to your advantage.",
                    'holy_water': "I can bless water to harm undead. Very effective against vampires.",
                    'blessings': "Bring me your weapons, and I shall bless them against the dark.",
                    'crucifix': "A true crucifix will repel vampires. They fear the symbol of our Lord."
                }
            },
            hunter: {
                name: "Vanessa the Hunter",
                desc: "A grim woman covered in scars, polishing a silver sword.",
                dialog: "I've hunted vampires for twenty years. This castle is their nest. We must burn it.",
                quest: { item: 'vampire_dust', count: 5, reward: { gold: 200, item: 'silver_sword', xp: 90 }, completed: false },
                hostile: false,
                dialogueTopics: ['silver', 'stakes', 'vampire_lord', 'hunter_coat'],
                dialogue: {
                    'default': "Stay alert. They can be anywhere.",
                    'silver': "Silver is the vampire's bane. A silver sword is worth its weight in gold here.",
                    'stakes': "A wooden stake through the heart will kill any vampire, young or old.",
                    'vampire_lord': "The master of this castle is ancient and powerful. He must be destroyed at dawn.",
                    'hunter_coat': "My coat has silver threads woven in. It offers some protection against their claws."
                }
            },
            captive_vampire: {
                name: "Lysandra",
                desc: "A pale, beautiful vampire chained with silver. She looks tired and resigned.",
                dialog: "Free me... and I will help you defeat my master. I want this curse ended.",
                quest: { item: 'silver_key', reward: { gold: 0, item: 'vampire_cloak', xp: 60 }, completed: false },
                hostile: false,
                dialogueTopics: ['master', 'curse', 'silver', 'dawn'],
                dialogue: {
                    'default': "These silver chains burn... please...",
                    'master': "He sleeps in the highest tower. Attack at dawn when he is weakest.",
                    'curse': "I was turned against my will centuries ago. I long for peace.",
                    'silver': "Silver weakens us. The key to my chains is in the master's study.",
                    'dawn': "At dawn, vampires are weakest. The master will be in his coffin."
                }
            },
            ghost_maiden: {
                name: "Elenora's Ghost",
                desc: "A translucent young woman in a white dress, floating above the ground.",
                dialog: "The master took my life... my soul cannot rest while he exists...",
                quest: { item: 'sun_crystal', reward: { gold: 0, item: 'mirror', xp: 40 }, completed: false },
                hostile: false,
                dialogueTopics: ['master', 'mirror', 'crystal', 'tragedy'],
                dialogue: {
                    'default': "So cold... so alone...",
                    'master': "He fears the sun above all else. Find the sun crystal in the observatory.",
                    'mirror': "Vampires cast no reflection. A mirror can reveal them in disguise.",
                    'crystal': "The sun crystal stores sunlight. It could destroy the master.",
                    'tragedy': "He turned me on my wedding night... my fiancÃ© died trying to save me..."
                }
            },
          mad_scientist: {
    name: "Dr. Moreau",
    desc: "A wild-eyed man in a stained lab coat, surrounded by bizarre experiments.",
    dialog: "The fusion of man and beast! Perfection! But the master disapproves...",
    quest: null,
    hostile: true,
    dialogueTopics: ['experiments', 'werewolves', 'master', 'perfection'],
    dialogue: {
        'default': "Stay away from my work!",  // FIXED: Changed " to '
        'experiments': "I create life from death! The master's subjects are perfect test subjects.",
        'werewolves': "My finest creation! Man and wolf united!",
        'master': "He thinks my work blasphemous. He doesn't understand true science!",
        'perfection': "The ultimate being would combine vampire, werewolf, and human traits!"
    }
},
            cursed_blacksmith: {
                name: "Boris the Cursed",
                desc: "A massive man with wolf-like features, hammering at an anvil.",
                dialog: "The moon's curse is upon me... but I still know my craft. Silver work calms the beast.",
                quest: null,
                hostile: false,
                dialogueTopics: ['silver', 'werewolf_curse', 'weapons', 'moon'],
                dialogue: {
                    'default': "The beast stirs within...",
                    'silver': "Silver soothes the curse. I work it to keep the wolf at bay.",
                    'werewolf_curse': "The master infected me. Each full moon, I transform...",
                    'weapons': "I can forge silver weapons. Bring me gems and silver.",
                    'moon': "When the moon is full, lock me in the cellar. For your safety."
                }
            },
            // NEW: Librarian Ghost (appears after puzzle)
            librarian_ghost: {
                name: "Ghost of the Librarian",
                desc: "A spectral figure in scholarly robes, tending to phantom books.",
                dialog: "Knowledge must be preserved... even in death...",
                quest: { item: 'ancient_tome', reward: { gold: 50, item: 'crucifix', xp: 35 }, completed: false },
                hostile: false,
                dialogueTopics: ['tome', 'vampire_weaknesses', 'library', 'knowledge'],
                dialogue: {
                    'default': "So many books... so much to protect...",
                    'tome': "The ancient tome contains the master's true name. With it, he can be bound.",
                    'vampire_weaknesses': "Sunlight, silver, holy symbols, garlic, running water...",
                    'library': "The master's private collection is in the west wing. Password protected.",
                    'knowledge': "I died protecting these books. The master wanted them burned..."
                }
            }
        };

        // Enhanced room descriptions with interactive objects - CASTLE THEME
        const roomDescriptions = [
            { 
                desc: "The Castle Gates. Massive iron doors stand before you. Torches flicker in iron sconces.", 
                sound: 'theme',
                objects: {
                    'gates': {
                        desc: "Enormous wrought-iron gates depicting bat-winged demons. They're barred from within.",
                        state: 'locked',
                        states: {
                            'locked': "The gates are firmly locked. You'll need a key or another way in.",
                            'unlocked': "The gates creak open ominously."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: null
                    },
                    'torches': "Iron sconces holding torches that burn with an unnatural blue flame.",
                    'gargoyles': "Stone gargoyles leer down at you. Their eyes seem to follow your movements."
                }
            },
            { 
                desc: "Grand Hall. Tattered banners hang from the ceiling. A massive staircase leads upward.", 
                sound: 'castle',
                objects: {
                    'banners': "Faded banners depicting a bat-winged crest. They flutter in a non-existent breeze.",
                    'staircase': "A grand marble staircase carpeted in red velvet worn thin by centuries.",
                    'chandelier': "A massive crystal chandelier coated in dust and cobwebs."
                }
            },
            { 
                desc: "Portrait Gallery. Paintings of pale aristocrats line the walls. Their eyes follow you.", 
                sound: 'gothic',
                objects: {
                    'portraits': {
                        desc: "Oil paintings of the castle's former inhabitants. All have unnaturally pale skin.",
                        state: 'normal',
                        states: {
                            'normal': "The portraits watch you with hungry eyes.",
                            'examined': "You notice none have reflections in painted mirrors behind them."
                        },
                        requiredItem: 'mirror',
                        action: 'examine',
                        hiddenItem: 'clue'
                    },
                    'frames': "Ornate gold frames tarnished with age. Some hang crookedly."
                }
            },
            { 
                desc: "Dining Hall. A long table set for a feast. The food has turned to dust.", 
                sound: 'castle',
                objects: {
                    'table': "A massive oak table set with tarnished silver and crystal goblets.",
                    'goblets': "Some goblets contain a dark red residue that might be ancient wine... or blood.",
                    'chairs': "High-backed chairs with velvet cushions rotted to threads."
                }
            },
            { 
                desc: "Kitchen. Giant cauldrons hang over cold hearths. Rusty cleavers line the walls.", 
                sound: 'castle',
                objects: {
                    'cauldrons': "Iron pots large enough to cook a man. One still bubbles with a thick red liquid.",
                    'cleavers': "Butcher's tools stained dark brown. The smell of old blood lingers.",
                    'pantry': {
                        desc: "A locked pantry door. Strange scratching comes from within.",
                        state: 'locked',
                        states: {
                            'locked': "The pantry is securely locked.",
                            'unlocked': "The door creaks open, revealing... nothing but dust and rat droppings."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: 'garlic'
                    }
                }
            },
            { 
                desc: "Chapel. Faded frescoes of saints line the walls. The altar is stained dark.", 
                sound: 'theme',
                objects: {
                    'frescoes': "Peeling paintings of saints with their eyes gouged out.",
                    'altar': {
                        desc: "A stone altar defiled with dark symbols. It feels... corrupted.",
                        state: 'defiled',
                        states: {
                            'defiled': "The altar pulses with dark energy.",
                            'cleansed': "Holy water has cleansed the altar. It now glows faintly."
                        },
                        requiredItem: 'holy_water',
                        action: 'cleanse',
                        hiddenItem: 'crucifix'
                    },
                    'pews': "Wooden pews shattered as if by tremendous force."
                }
            },
            { 
                desc: "Library. Books bound in strange leather line the shelves. Some whisper as you pass.", 
                sound: 'gothic',
                objects: {
                    'books': "Volumes bound in what might be human skin. They pulse with dark energy.",
                    'shelves': "Floor-to-ceiling bookshelves filled with forbidden knowledge.",
                    'study': {
                        desc: "A private study area with a massive oak desk.",
                        state: 'locked',
                        states: {
                            'locked': "The desk drawers are locked.",
                            'unlocked': "The drawer contains a silver key and strange notes."
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'ancient_tome'
                    }
                }
            },
            { 
                desc: "Alchemy Lab. Bubbling potions glow with unnatural colors. The air smells of sulfur.", 
                sound: 'gothic',
                objects: {
                    'potions': "Colored liquids bubbling in glass vessels. Some contain floating... things.",
                    'lab': "An alchemical workstation with a scorched grimoire and strange instruments.",
                    'cage': {
                        desc: "A large iron cage containing skeletal remains.",
                        state: 'locked',
                        states: {
                            'locked': "The cage is securely locked.",
                            'unlocked': "Inside, you find notes on vampire anatomy."
                        },
                        requiredItem: 'key',
                        action: 'unlock',
                        hiddenItem: 'vampire_dust'
                    }
                }
            },
            { 
                desc: "Torture Chamber. Rusty implements of pain line the walls. Chains rattle in the draft.", 
                sound: 'gothic',
                objects: {
                    'implements': "Rusted knives, pincers, and other cruel tools. Some are still warm.",
                    'chains': "Heavy iron chains that clink together despite no visible breeze.",
                    'rack': "A stretching rack with leather straps chewed through by something strong."
                }
            },
            { 
                desc: "Barracks. Rotted bunks line the walls. Rat-gnawed bones litter the floor.", 
                sound: 'castle',
                objects: {
                    'bunks': "Moldy bed frames with rotten straw mattresses. Something moves in the shadows.",
                    'bones': "Human bones picked clean. Large teeth marks are visible.",
                    'locker': {
                        desc: "A rusted footlocker at the end of a bunk.",
                        state: 'locked',
                        states: {
                            'locked': "The locker is rusted shut.",
                            'unlocked': "Inside is a rusted but serviceable crossbow."
                        },
                        requiredItem: 'oil',
                        action: 'oil',
                        hiddenItem: 'crossbow'
                    }
                }
            },
            { 
                desc: "Courtyard. Dead vines cling to stone walls. The moon shines blood-red.", 
                sound: 'theme',
                objects: {
                    'vines': "Withered ivy that crumbles at your touch.",
                    'moon': "A blood-red full moon that casts eerie shadows.",
                    'fountain': {
                        desc: "A dry marble fountain with a statue of a bat-winged demon.",
                        state: 'dry',
                        states: {
                            'dry': "The fountain is filled with dead leaves.",
                            'flowing': "Water now flows from the demon's mouth. Something glints within."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'gem'
                    }
                }
            },
            { 
                desc: "Wine Cellar. Racks of dusty bottles. Some contain dark, viscous liquid.", 
                sound: 'gothic',
                objects: {
                    'bottles': "Dusty wine bottles, some centuries old. The labels are faded.",
                    'racks': "Wooden racks sagging under the weight of time.",
                    'cask': {
                        desc: "A massive oak cask bound with iron.",
                        state: 'sealed',
                        states: {
                            'sealed': "The cask is sealed tight.",
                            'opened': "Inside is not wine, but a hibernating bat swarm!"
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: null,
                        spawnEnemy: 'bat_swarm'
                    }
                }
            },
            { 
                desc: "Guard Room. Empty suits of armor stand at attention. One moves.", 
                sound: 'castle',
                objects: {
                    'armor': {
                        desc: "The suits of armor are empty yet move. One raises its sword.",
                        state: 'animated',
                        states: {
                            'animated': "The armor attacks!",
                            'defeated': "The armor collapses into a pile of rusted metal."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'silver_key',
                        spawnEnemy: 'skeleton'
                    },
                    'weapons': "Rusted swords and spears mounted on the walls."
                }
            },
            { 
                desc: "Servant Quarters. Simple cots and worn uniforms. A diary tells of disappearances.", 
                sound: 'castle',
                objects: {
                    'cots': "Rough beds with thin, moth-eaten blankets.",
                    'uniforms': "Black and white servant uniforms hanging on pegs.",
                    'diary': "A maid's diary describing nightly disappearances among the staff."
                }
            },
            { 
                desc: "Throne Room. A black obsidian throne sits empty. Shadows dance on the walls.", 
                sound: 'castle',
                objects: {
                    'throne': {
                        desc: "A massive obsidian throne carved with bat motifs.",
                        state: 'normal',
                        states: {
                            'normal': "The throne emanates cold darkness.",
                            'examined': "Behind the throne, you find a hidden lever."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: null,
                        triggersSecret: true,
                        secretRoom: 50
                    },
                    'tapestries': "Black velvet tapestries depicting scenes of vampiric conquest.",
                    'dais': "A raised platform where the throne sits. The stone is stained dark."
                }
            },
            { 
                desc: "Observatory. A telescope points at the blood-red moon. Star charts cover the walls.", 
                sound: 'theme',
                objects: {
                    'telescope': "A brass telescope pointed at the crimson moon.",
                    'charts': "Astronomical charts showing constellations of bats and wolves.",
                    'crystal': {
                        desc: "A large crystal prism catching moonlight.",
                        state: 'dark',
                        states: {
                            'dark': "The crystal is dark and lifeless.",
                            'charged': "The crystal glows with stored moonlight!",
                            'sunlight': "The crystal now glows with brilliant sunlight!"
                        },
                        requiredItem: null,
                        action: 'charge',
                        hiddenItem: 'sun_crystal',
                        puzzle: true
                    }
                }
            },
            { 
                desc: "Treasure Vault. Piles of gold and jewels glitter in the torchlight.", 
                sound: 'castle',
                objects: {
                    'gold': "Mountains of gold coins from forgotten kingdoms.",
                    'jewels': "Gemstones of every color sparkling in the dim light.",
                    'chest': {
                        desc: "An iron-bound chest with a complex lock.",
                        state: 'locked',
                        states: {
                            'locked': "The chest is securely locked.",
                            'unlocked': "The chest contains legendary weapons!"
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'morning_star'
                    }
                }
            },
            { 
                desc: "Crypt. Stone sarcophagi line the walls. The air smells of decay and old blood.", 
                sound: 'catacombs',
                objects: {
                    'sarcophagi': "Ancient stone coffins. Some lids have been pushed aside from within.",
                    'crypt': "A burial chamber for the castle's unliving inhabitants.",
                    'coffin': {
                        desc: "A newer, polished black coffin in the center of the room.",
                        state: 'closed',
                        states: {
                            'closed': "The coffin lid is firmly shut.",
                            'open': "The coffin is empty except for rich black soil."
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: 'vampire_dust'
                    }
                }
            },
            { 
                desc: "Armory. Weapons of silver and steel line the walls. Most are dusty.", 
                sound: 'castle',
                objects: {
                    'weapons': "Swords, axes, and maces of various sizes and materials.",
                    'racks': "Weapon racks once holding proud arms, now mostly empty.",
                    'display': {
                        desc: "A display case holding a beautiful silver sword.",
                        state: 'locked',
                        states: {
                            'locked': "The case is locked with a silver padlock.",
                            'unlocked': "The silver sword is yours for the taking!"
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'silver_sword'
                    }
                }
            },
            { 
                desc: "Prison Cells. Iron bars enclose small, filthy spaces. Moans echo.", 
                sound: 'catacombs',
                objects: {
                    'bars': "Thick iron bars rusted with age and... other substances.",
                    'cells': "Tiny, dark rooms where prisoners were left to rot or worse.",
                    'chains': {
                        desc: "Silver chains hanging from the wall of one cell.",
                        state: 'empty',
                        states: {
                            'empty': "The chains hang empty. They're stained with blood.",
                            'used': "A vampire was held here recently. The chains are still warm."
                        },
                        requiredItem: null,
                        action: 'examine',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Master Bedchamber. A canopy bed with black silk curtains. The room is freezing.", 
                sound: 'gothic',
                objects: {
                    'bed': "A four-poster bed with black silk curtains. The mattress looks unused.",
                    'curtains': "Heavy black velvet curtains blocking all light from the windows.",
                    'wardrobe': {
                        desc: "An ornate wardrobe of dark wood.",
                        state: 'locked',
                        states: {
                            'locked': "The wardrobe is locked.",
                            'unlocked': "Inside are fine clothes... and a hidden compartment."
                        },
                        requiredItem: 'silver_key',
                        action: 'unlock',
                        hiddenItem: 'gem'
                    }
                }
            },
            { 
                desc: "Study. A desk covered in maps and letters. A single candle burns endlessly.", 
                sound: 'gothic',
                objects: {
                    'desk': {
                        desc: "A mahogany desk covered in correspondence and maps.",
                        state: 'normal',
                        states: {
                            'normal': "The desk has several drawers.",
                            'searched': "A hidden compartment contains the master's journal."
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'ancient_tome'
                    },
                    'maps': "Parchment maps showing the castle and surrounding lands.",
                    'candle': "A black candle that burns without melting, casting an eerie light."
                }
            },
            { 
                desc: "Art Gallery. More portraits, these of beautiful women all with the same pale features.", 
                sound: 'gothic',
                objects: {
                    'portraits': "Paintings of beautiful women, all with jet black hair and blood-red lips.",
                    'frames': "Ornate silver frames tarnished with age.",
                    'mirror': {
                        desc: "A large standing mirror covered by a black cloth.",
                        state: 'covered',
                        states: {
                            'covered': "The mirror is covered.",
                            'uncovered': "The mirror shows no reflections of the portraits!"
                        },
                        requiredItem: null,
                        action: 'uncover',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Music Room. A grand piano plays a haunting nocturne by itself.", 
                sound: 'gothic',
                objects: {
                    'piano': "A dusty grand piano with yellowed keys that depress on their own.",
                    'music': "Sheet music for a melancholic piece called 'Requiem for the Damned'.",
                    'bench': {
                        desc: "The piano bench.",
                        state: 'closed',
                        states: {
                            'closed': "The bench is closed.",
                            'open': "Inside are love letters from centuries past."
                        },
                        requiredItem: null,
                        action: 'open',
                        hiddenItem: 'clue'
                    }
                }
            },
            { 
                desc: "Bathhouse. Tiled pools filled with black water. Steam rises without heat.", 
                sound: 'gothic',
                objects: {
                    'pools': "Marble baths filled with still, black water. Something moves beneath.",
                    'tiles': "Mosaic tile work depicting nymphs and satyrs in compromising positions.",
                    'steam': "Cold mist that rises from the water's surface despite no heat source."
                }
            },
            { 
                desc: "Training Room. Wooden dummies stand ready. One moves when not watched.", 
                sound: 'castle',
                objects: {
                    'dummies': {
                        desc: "Straw-stuffed practice targets. One twitches when you look away.",
                        state: 'normal',
                        states: {
                            'normal': "The dummies show signs of heavy use.",
                            'searched': "Inside one dummy's stuffing, you find a silver key!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'silver_key'
                    },
                    'weapons': "Practice weapons made of wood. Some are stained dark."
                }
            },
            { 
                desc: "Clock Tower. A massive clock frozen at midnight. Bats nest in the gears.", 
                sound: 'theme',
                objects: {
                    'clock': {
                        desc: "A giant clock face with hands forever at midnight.",
                        state: 'frozen',
                        states: {
                            'frozen': "The clock mechanism is jammed with bat guano.",
                            'cleaned': "The clock is clean but still doesn't work.",
                            'working': "The clock chimes! A secret is revealed!"
                        },
                        requiredItem: null,
                        action: 'clean',
                        hiddenItem: 'silver_key',
                        puzzle: true
                    },
                    'gears': "Enormous brass mechanisms clogged with bat nests.",
                    'bats': "Sleeping bats hanging from every available surface."
                }
            },
            { 
                desc: "Aviary. Empty birdcages hang from the ceiling. Feathers float in the air.", 
                sound: 'gothic',
                objects: {
                    'cages': "Gilded birdcages, all empty. Some doors hang open, others are bent outward.",
                    'feathers': "Black feathers that drift on non-existent breezes.",
                    'perches': "Wooden perches scarred by large, sharp talons."
                }
            },
            { 
                desc: "Laboratory. Strange machines hum with dark energy. Glass tanks hold horrors.", 
                sound: 'gothic',
                objects: {
                    'machines': "Brass and copper devices that hum with stored necromantic energy.",
                    'tanks': "Glass cylinders containing horrific hybrids of various creatures.",
                    'notes': "The doctor's notes on 'improving' natural creatures with vampiric traits."
                }
            },
            { 
                desc: "Conservatory. Dead plants in ceramic pots. A single black rose blooms.", 
                sound: 'theme',
                objects: {
                    'plants': "Withered exotic plants from around the world.",
                    'pots': "Ornate ceramic containers filled with dry, cracked earth.",
                    'rose': "A single perfect black rose that seems to absorb light around it."
                }
            },
            { 
                desc: "Archive. Scrolls crumble at your touch. Ancient knowledge lost forever.", 
                sound: 'gothic',
                objects: {
                    'scrolls': "Parchment documents that disintegrate when touched.",
                    'shelves': "Rows of shelves holding the castle's dark history.",
                    'knowledge': "What remains suggests dark rituals and vampiric lore."
                }
            },
            { 
                desc: "Forge. Cold anvils and extinguished fires. A silver sword half-forged on the bench.", 
                sound: 'castle',
                objects: {
                    'anvils': "Massive iron blocks once used for shaping weapons, now cold.",
                    'fires': "Stone hearths filled with gray ash and unburned coal.",
                    'sword': {
                        desc: "A half-completed silver blade still in the tongs.",
                        state: 'incomplete',
                        states: {
                            'incomplete': "The sword needs finishing.",
                            'complete': "The blacksmith has finished the silver sword!"
                        },
                        requiredItem: 'gem',
                        action: 'forge',
                        hiddenItem: 'silver_sword'
                    }
                }
            },
            { 
                desc: "Well Room. A deep well in the center. Something whispers from below.", 
                sound: 'catacombs',
                objects: {
                    'well': "A stone-lined shaft descending into darkness. A rope hangs down.",
                    'whispers': "Faint voices from the depths begging for release.",
                    'bucket': "A wooden bucket on a chain, stained dark red."
                }
            },
            { 
                desc: "Pantry. Rotted food in sacks. Something still moves within.", 
                sound: 'gothic',
                objects: {
                    'food': "Moldy grains and spoiled meat in burlap sacks.",
                    'sacks': "Burst bags spilling their foul contents across the floor.",
                    'something': "There's definitely movement in the darkest corner."
                }
            },
            { 
                desc: "Stable. Empty stalls with rotting hay. A large, wolflike skeleton lies in one.", 
                sound: 'castle',
                objects: {
                    'stalls': "Wooden stalls where horses once stood. The hay is rotten.",
                    'tack': "Leather harnesses and saddles chewed by rats.",
                    'skeleton': "The bones of something much larger than a horse, with wolflike features."
                }
            },
            { 
                desc: "Private Library. Books bound in human skin. They seem to watch you.", 
                sound: 'gothic',
                objects: {
                    'books': "Volumes bound in what looks like human skin. They pulse faintly.",
                    'shelves': "Ebony bookshelves reaching to a shadowed ceiling.",
                    'door': {
                        desc: "A massive oak door carved with protective runes.",
                        state: 'warded',
                        states: {
                            'warded': "The door glows with protective magic.",
                            'unlocked': "The ward dissipates."
                        },
                        requiredItem: 'crucifix',
                        action: 'unward',
                        hiddenItem: null
                    }
                }
            },
            { 
                desc: "Astrology Room. Star charts on the walls. Constellations move on their own.", 
                sound: 'theme',
                objects: {
                    'charts': "Maps of the heavens showing constellations of bats and wolves.",
                    'constellations': "The painted stars shift position when you're not looking.",
                    'orrey': "A mechanical model of the solar system, frozen in time."
                }
            },
            { 
                desc: "Meditation Chamber. Incense burners cold. A mat lies in the center.", 
                sound: 'gothic',
                objects: {
                    'incense': "Brass burners filled with gray ash that smells of funeral flowers.",
                    'mat': "A woven reed mat worn thin by years of use. It feels oddly cold.",
                    'chamber': "A perfectly round room designed for dark contemplation."
                }
            },
            { 
                desc: "Armory Vault. Magical weapons behind glass. All cases are broken open.", 
                sound: 'castle',
                objects: {
                    'weapons': "Glimmering swords and staves behind shattered display cases.",
                    'glass': "Broken protective coverings litter the floor.",
                    'vault': "A secure room that clearly failed to protect its contents."
                }
            },
            { 
                desc: "Guard Tower. Arrow slits look over the misty land. A skeleton holds a rusted crossbow.", 
                sound: 'castle',
                objects: {
                    'slits': "Narrow windows designed for archers.",
                    'skeleton': "A fallen guard still clutching a rusted crossbow.",
                    'crossbow': "A heavy crossbow with a broken string."
                }
            },
            { 
                desc: "Dungeon. Deeper than the prison. The walls sweat blood.", 
                sound: 'catacombs',
                objects: {
                    'walls': "Damp stone that weeps a red liquid. It smells of copper.",
                    'dungeon': "The lowest level where the worst prisoners were kept.",
                    'cells': "Tiny, dark cells with heavy iron doors."
                }
            },
            { 
                desc: "Catacombs. Bones arranged in patterns. They rearrange when you look away.", 
                sound: 'catacombs',
                objects: {
                    'bones': {
                        desc: "Human remains laid out in intricate patterns.",
                        state: 'normal',
                        states: {
                            'normal': "The bones form occult patterns on the floor.",
                            'disturbed': "You've moved some bones. One wall looks different...",
                            'searched': "Behind the moved stones, you find a hidden crucifix!"
                        },
                        requiredItem: null,
                        action: 'search',
                        hiddenItem: 'crucifix'
                    },
                    'patterns': "Geometric designs that shift into new configurations constantly.",
                    'catacombs': "Tunnels lined with skulls that watch your passage."
                }
            },
            { 
                desc: "Shrine. A statue of a bat-winged demon. Offerings of gold and gems at its feet.", 
                sound: 'theme',
                objects: {
                    'statue': "A marble figure of a demon with bat wings and fangs.",
                    'offerings': "Piles of treasure left by desperate worshippers.",
                    'altar': "A black stone altar stained with centuries of blood sacrifice."
                }
            },
            { 
                desc: "Clockwork Room. Mechanical bats frozen in mid-flight. One eye follows you.", 
                sound: 'gothic',
                objects: {
                    'bats': "Brass automaton bats frozen in various poses. One twitches.",
                    'clockwork': "Intricate gears and springs that should move but don't.",
                    'eye': "A glass lens in one bat's head that tracks your movements."
                }
            },
            { 
                desc: "Mirror Hall. Reflections show different versions of yourself. Some are vampires.", 
                sound: 'gothic',
                objects: {
                    'mirrors': {
                        desc: "Tall looking glasses that show alternate versions of you.",
                        state: 'hostile',
                        states: {
                            'hostile': "The reflections show you as a vampire!",
                            'calm': "The reflections show your true self."
                        },
                        requiredItem: 'crucifix',
                        action: 'use',
                        hiddenItem: 'mirror',
                        puzzle: true
                    },
                    'reflections': "Some mirror-you's bare fangs, others recoil in horror.",
                    'hall': "A corridor lined with mirrors that seem to go on forever."
                }
            },
            { 
                desc: "Laboratory Depth. Flesh and machine fused in tanks. Things move within.", 
                sound: 'gothic',
                objects: {
                    'tanks': "Glass cylinders containing horrific hybrids.",
                    'flesh': "Pulsating tissue connected to wires and pipes.",
                    'things': "Shapes that press against the glass from inside the tanks."
                }
            },
            { 
                desc: "Necromancer's Sanctum. Black candles burn with green flame. Skulls line shelves.", 
                sound: 'gothic',
                objects: {
                    'candles': "Tapered black wax burning with unnatural green fire.",
                    'skulls': "Polished craniums arranged by size and species.",
                    'shelves': "Bookshelves holding forbidden texts and preserved organs."
                }
            },
            { 
                desc: "Sorcerer's Tower. Floating books and glowing orbs. Magic crackles in the air.", 
                sound: 'theme',
                objects: {
                    'books': "Tomes that drift through the air, pages turning on their own.",
                    'orbs': "Crystal spheres containing captured starlight.",
                    'magic': "Raw arcane energy that makes the hair on your arms stand up."
                }
            },
            { 
                desc: "Royal Treasury. Mountains of gold and jewels. A dragon skeleton guards it.", 
                sound: 'castle',
                objects: {
                    'gold': "Piles of coins, ingots, and jewelry worth a kingdom's ransom.",
                    'jewels': "Gemstones of every color glittering in the dim light.",
                    'dragon': {
                        desc: "The massive bones of a wyrm arranged as if still alive.",
                        state: 'alert',
                        states: {
                            'alert': "The dragon bones rattle threateningly.",
                            'calm': "Wearing the vampire cloak, the dragon ignores you."
                        },
                        requiredItem: 'vampire_cloak',
                        action: 'sneak',
                        hiddenItem: 'gem'
                    },
                    'skeleton': "A complete dragon skeleton that seems to watch you."
                }
            },
            { 
                desc: "Summit Chamber. The very top of the castle. Wind howls through broken windows. The master awaits.", 
                sound: 'boss',
                objects: {
                    'windows': "Shattered stained glass letting in cold wind and moonlight.",
                    'wind': "A howling gale that carries whispers of the dead.",
                    'coffin': "A massive black coffin on a raised dais. This is it.",
                    'chamber': "The highest point of Castle of the Damned. There's no going back now."
                }
            },
            // Secret Room 50: Hidden Vault (accessed from Throne Room)
            { 
                desc: "Hidden Vault. A secret chamber behind the throne. Ancient artifacts glow on pedestals.", 
                sound: 'theme',
                objects: {
                    'artifacts': "Magical items of great power rest here.",
                    'pedestals': "Stone columns holding treasures beyond imagination.",
                    'vault': "This room was meant to be found only by the worthy."
                }
            }
        ];

        // Generate 51 rooms (50 + secret room)
        function generateRooms() {
            const rooms = [];
            for (let i = 0; i < 51; i++) {
                const roomDesc = roomDescriptions[i] || { desc: "A mysterious room.", sound: 'gothic', objects: {} };
                rooms.push({
                    id: i,
                    desc: roomDesc.desc,
                    sound: roomDesc.sound,
                    objects: roomDesc.objects || {},
                    exits: i < 50 ? { 
                        n: i < 40 ? i + 10 : null, 
                        s: i >= 10 ? i - 10 : null, 
                        e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                        w: i % 10 !== 0 ? i - 1 : null 
                    } : { n: null, s: 15, e: null, w: null }, // Secret room connected to Throne Room
                    items: [],
                    enemy: null,
                    npc: null,
                    explored: false,
                    dark: i > 25 && i < 40,
                    locked: i === 36, // Private Library locked
                    secret: i === 50
                });
            }

            // Place items, enemies, and NPCs with enemy instances
            rooms[1].items = ['stake'];
            rooms[3].enemy = createEnemy('bat_swarm');
            rooms[5].items = ['potion'];
            rooms[7].enemy = createEnemy('skeleton');
            rooms[10].npc = 'alchemist';
            rooms[12].enemy = createEnemy('ghost');
            rooms[15].npc = 'priest';
            rooms[17].items = ['garlic'];
            rooms[20].enemy = createEnemy('vampire_spawn');
            rooms[22].npc = 'hunter';
            rooms[25].items = ['holy_water'];
            rooms[28].enemy = createEnemy('werewolf');
            rooms[30].npc = 'captive_vampire';
            rooms[32].items = ['leather'];
            rooms[35].enemy = createEnemy('vampire_knight');
            rooms[37].npc = 'ghost_maiden';
            rooms[39].items = ['crossbow'];
            rooms[40].npc = 'mad_scientist';
            rooms[42].enemy = createEnemy('skeleton');
            rooms[43].npc = 'cursed_blacksmith';
            rooms[45].enemy = createEnemy('vampire_knight');
            rooms[46].npc = 'librarian_ghost';
            rooms[47].items = ['gem', 'werewolf_fang'];
            rooms[49].enemy = createEnemy('vampire_lord');
            rooms[50].items = ['gem', 'gem', 'elixir', 'morning_star']; // Secret room treasure
            
            return rooms;
        }

        // Initialize rooms
        let rooms = generateRooms();

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            stealth: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: false,
            moves: 0,
            poisoned: false,
            ward: 0,
            barrier: 0,
            shadowed: 0,
            knownPasswords: [],
            discoveredSecrets: [],
            time: 'midnight' // Track time for vampire weaknesses
        };

        // ==================== ENHANCED VERB PARSER ====================
        
        // Expanded verb synonyms mapping
        const verbSynonyms = {
            // Movement
            'go': ['move', 'walk', 'run', 'head', 'travel', 'proceed', 'advance', 'enter'],
            'n': ['north', 'up', 'forward'],
            's': ['south', 'down', 'back', 'backward'],
            'e': ['east', 'right'],
            'w': ['west', 'left'],
            'look': ['l', 'view', 'survey', 'scan', 'observe', 'see', 'gaze', 'peer', 'watch'],
            
            // Object Interaction
            'take': ['get', 'grab', 'pick up', 'acquire', 'collect', 'snatch', 'seize', 'pluck', 'take the', 'pick the'],
            'examine': ['ex', 'x', 'look at', 'inspect', 'study', 'check', 'read', 'search', 'scan', 'peer at', 'gaze at', 'stare at', 'investigate'],
            'use': ['apply', 'employ', 'activate', 'operate', 'utilize', 'wield', 'activate the', 'use the'],
            'open': ['unlock', 'unbar', 'unseal', 'pull', 'push', 'force open', 'pry open'],
            'close': ['shut', 'seal', 'lock'],
            'search': ['look through', 'rummage through', 'go through', 'sift through', 'examine closely'],
            'push': ['press', 'shove', 'move'],
            'pull': ['tug', 'yank', 'draw'],
            'turn': ['rotate', 'twist', 'spin'],
            
            // Combat
            'attack': ['fight', 'hit', 'strike', 'kill', 'smite', 'assault', 'battle', 'engage', 'fight the', 'attack the', 'hit the', 'kill the', 'strike the'],
            'skill': ['cast', 'use skill', 'use ability', 'activate skill', 'special attack'],
            
            // NPC Interaction
            'talk': ['speak', 'converse', 'chat', 'ask', 'question', 'address', 'speak to', 'talk to', 'converse with', 'ask the'],
            'give': ['hand', 'offer', 'present', 'donate', 'hand over', 'give the', 'offer the'],
            
            // Equipment
            'equip': ['wear', 'put on', 'don', 'arm yourself with', 'wield'],
            'unequip': ['remove', 'take off', 'doff', 'store'],
            
            // Inventory
            'inventory': ['i', 'inv', 'items', 'belongings', 'possessions', 'what i have', 'my stuff'],
            
            // Status
            'status': ['stats', 'health', 'hp', 'mana', 'mp', 'condition', 'how am i'],
            
            // System
            'help': ['?', 'h', 'commands', 'what can i do', 'instructions', 'manual'],
            'save': ['save game', 'store game'],
            'load': ['load game', 'restore game', 'continue'],
            'quit': ['exit', 'leave game', 'end', 'stop'],
            
            // Special Actions
            'rest': ['sleep', 'nap', 'wait', 'pause', 'take a break'],
            'map': ['show map', 'display map', 'where am i'],
            'drop': ['discard', 'leave', 'throw away', 'toss'],
            'eat': ['consume', 'drink', 'ingest'],
            'listen': ['hear', 'eavesdrop', 'pay attention'],
            'smell': ['sniff', 'scent'],
            'wait': ['pause', 'stand still', 'do nothing'],
            
            // Puzzle-specific
            'charge': ['activate', 'power up', 'energize'],
            'clean': ['wipe', 'dust', 'clear'],
            'read': ['peruse', 'scan', 'look through'],
            'break': ['smash', 'shatter', 'destroy'],
            'light': ['ignite', 'burn', 'set fire to'],
            'extinguish': ['put out', 'douse', 'snuff'],
            'wear': ['put on', 'don'],
            'remove': ['take off', 'doff'],
        };

        // Direct object mappings (for items with multiple names)
        const objectSynonyms = {
            'torch': ['light', 'lantern', 'fire'],
            'stake': ['wooden stake', 'sharp stick', 'pointed wood'],
            'silver_sword': ['silver sword', 'silver blade', 'silvered sword'],
            'holy_water': ['holy water', 'blessed water', 'consecrated water'],
            'garlic': ['garlic clove', 'garlic bulb', 'clove of garlic'],
            'potion': ['health potion', 'healing potion', 'red potion'],
            'manapot': ['mana potion', 'blue potion', 'magic potion'],
            'gem': ['jewel', 'precious stone', 'crystal'],
            'key': ['iron key', 'metal key', 'old key'],
            'silver_key': ['silver key', 'shiny key', 'special key'],
            'crucifix': ['cross', 'holy symbol', 'religious symbol'],
            'mirror': ['looking glass', 'hand mirror', 'glass'],
            'book': ['tome', 'volume', 'grimoire', 'ancient tome'],
            'letter': ['note', 'message', 'paper', 'scroll'],
            'coffin': ['casket', 'sarcophagus', 'box'],
            'door': ['gate', 'portal', 'entry', 'entrance'],
            'window': ['opening', 'pane', 'portal'],
            'chest': ['box', 'trunk', 'strongbox'],
            'skeleton': ['bones', 'remains', 'corpse'],
            'ghost': ['spirit', 'specter', 'phantom', 'apparition'],
            'vampire': ['bloodsucker', 'undead', 'nosferatu'],
            'werewolf': ['lycanthrope', 'wolf-man', 'beast'],
        };

        // Prepositions to ignore
        const ignoreWords = ['the', 'a', 'an', 'to', 'at', 'in', 'on', 'with', 'from', 'of', 'and', 'then'];

        // Main parser function
        function parseNaturalCommand(input) {
            const originalInput = input.toLowerCase().trim();
            
            // Remove punctuation
            let cleanedInput = originalInput.replace(/[.,!?;]/g, '');
            
            // Split into words
            let words = cleanedInput.split(/\s+/);
            
            // Filter out ignore words
            words = words.filter(word => !ignoreWords.includes(word));
            
            if (words.length === 0) {
                return { command: '', args: [], original: originalInput };
            }
            
            // Try to match multi-word verbs first (like "pick up")
            let verb = '';
            let args = [];
            
            // Check for multi-word verbs (2-3 words)
            for (let i = Math.min(3, words.length); i >= 1; i--) {
                const possibleVerb = words.slice(0, i).join(' ');
                
                // Check direct match first
                if (verbSynonyms.hasOwnProperty(possibleVerb)) {
                    verb = possibleVerb;
                    args = words.slice(i);
                    break;
                }
                
                // Check synonym match
                for (const [baseVerb, synonyms] of Object.entries(verbSynonyms)) {
                    if (synonyms.includes(possibleVerb)) {
                        verb = baseVerb;
                        args = words.slice(i);
                        break;
                    }
                }
                
                if (verb) break;
            }
            
            // If no multi-word verb found, try single word
            if (!verb && words.length > 0) {
                const firstWord = words[0];
                
                // Direct match
                if (verbSynonyms.hasOwnProperty(firstWord)) {
                    verb = firstWord;
                    args = words.slice(1);
                } else {
                    // Synonym match
                    for (const [baseVerb, synonyms] of Object.entries(verbSynonyms)) {
                        if (synonyms.includes(firstWord)) {
                            verb = baseVerb;
                            args = words.slice(1);
                            break;
                        }
                    }
                }
            }
            
            // Handle special case: "look at" -> "examine"
            if (verb === 'look' && args.length > 0 && args[0] === 'at') {
                verb = 'examine';
                args = args.slice(1);
            }
            
            // Handle "pick up" -> "take"
            if (verb === 'pick up') {
                verb = 'take';
            }
            
            // Handle "speak to" -> "talk"
            if (verb === 'speak to') {
                verb = 'talk';
                // "speak to npc" -> args already contains 'npc'
            }
            
            // Normalize object names in args
            args = args.map(arg => {
                // Check for multi-word object names
                for (const [objectId, synonyms] of Object.entries(objectSynonyms)) {
                    for (const synonym of synonyms) {
                        if (arg === synonym || args.join(' ') === synonym) {
                            return objectId;
                        }
                    }
                }
                return arg;
            });
            
            // Special handling for common patterns
            if (!verb) {
                // Maybe it's a direction
                const directions = {
                    'north': 'n', 'south': 's', 'east': 'e', 'west': 'w',
                    'up': 'n', 'down': 's', 'forward': 'n', 'back': 's',
                    'right': 'e', 'left': 'w'
                };
                
                if (directions.hasOwnProperty(cleanedInput)) {
                    verb = directions[cleanedInput];
                    args = [];
                }
                
                // Maybe it's "look" without arguments
                if (cleanedInput === 'l' || cleanedInput === 'look') {
                    verb = 'look';
                    args = [];
                }
                
                // Maybe it's "inventory"
                if (cleanedInput === 'i' || cleanedInput === 'inv' || cleanedInput === 'inventory') {
                    verb = 'inventory';
                    args = [];
                }
            }
            
            // If still no verb, treat first word as verb
            if (!verb && words.length > 0) {
                verb = words[0];
                args = words.slice(1);
            }
            
            return { command: verb, args: args, original: originalInput };
        }

        // Enhanced command processor
        function processEnhancedCommand(input) {
            const parsed = parseNaturalCommand(input);
            
            if (!parsed.command) {
                print("I don't understand that.", 'error');
                soundSystem.playSound('click', 0.2);
                return;
            }
            
            // Build the command string for your existing system
            let commandString = parsed.command;
            if (parsed.args.length > 0) {
                commandString += ' ' + parsed.args.join(' ');
            }
            
            // Show what was understood
            if (parsed.original !== commandString && parsed.original !== parsed.command) {
                print(`> ${parsed.original}`, 'command');
                print(`(understood as: ${commandString})`, 'hint');
            } else {
                print(`> ${parsed.original}`, 'command');
            }
            
            // Split into parts for your existing switch statement
            const parts = commandString.split(' ');
            const verb = parts[0];
            const arg = parts[1];
            const arg2 = parts[2];
            const arg3 = parts[3];
            const arg4 = parts[4];
            
            // Play sound
            soundSystem.playSound('click', 0.3);
            
            // Class selection (keep your existing logic)
            if (!player.class && ['hunter', 'sorcerer', 'dhampir'].includes(verb)) {
                startGame(verb);
                return;
            }
            if (!player.class) {
                print("Choose a class first: hunter, sorcerer, dhampir.", 'error');
                return;
            }
            
            // Route to game command handler
            handleGameCommand(verb, arg, arg2, arg3, arg4);
        }

        // Modified input handler to use the new parser
        function setupEnhancedInputHandler() {
            const input = document.getElementById('input');
            
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    const cmd = input.value.trim();
                    input.value = '';
                    if (!cmd) return;
                    
                    // Use the enhanced parser
                    processEnhancedCommand(cmd);
                }
            });
        }

        // Add help text that shows synonyms
        function showEnhancedHelp() {
            print("=== ENHANCED COMMANDS ===", 'command');
            print("The parser understands natural language! Try:", 'system');
            print("", 'system');
            
            const examples = [
                "GET the silver sword",
                "GRAB the torch",
                "PICK UP the gem",
                "LOOK AT the portrait",
                "INSPECT the altar",
                "USE the holy water ON the vampire",
                "SPEAK TO the alchemist",
                "ASK the priest ABOUT vampires",
                "FIGHT the skeleton",
                "KILL the werewolf",
                "CAST sunbeam",
                "READ the ancient tome",
                "OPEN the chest",
                "UNLOCK the door",
                "SEARCH the desk",
                "PUSH the button",
                "TURN the wheel",
                "WEAR the leather armor",
                "EQUIP the silver sword",
                "DRINK the potion",
                "EAT the garlic",
                "LISTEN to the whispers",
                "SMELL the air",
                "WAIT for dawn",
                "REST for a while",
                "SHOW MAP",
                "WHERE AM I",
                "WHAT CAN I DO",
                "SAVE GAME",
                "LOAD GAME"
            ];
            
            examples.forEach(example => {
                print(`  ${example}`, 'hint');
            });
            
            print("", 'system');
            print("Type 'commands' for basic commands or 'synonyms' to see all recognized words.", 'system');
        }

        // Add to your existing help function
        function enhancedHelp() {
            print("=== CASTLE OF THE DAMNED - ENHANCED PARSER ===", 'command');
            print("You can use natural language commands!", 'system');
            print("Examples:", 'system');
            print("  'get sword' or 'pick up the silver sword'", 'hint');
            print("  'look at portrait' or 'examine the painting'", 'hint');
            print("  'speak to alchemist' or 'ask the priest about vampires'", 'hint');
            print("  'use holy water on vampire' or 'attack the werewolf'", 'hint');
            print("", 'system');
            print("Common verbs: get, take, grab, pick up, examine, look at, inspect,", 'system');
            print("              use, open, close, push, pull, turn, talk, speak, ask,", 'system');
            print("              attack, fight, kill, cast, equip, wear, eat, drink,", 'system');
            print("              rest, wait, search, listen, smell, read, break", 'system');
            print("", 'system');
            print("Type 'commands' for basic command list.", 'system');
            print("Type 'synonyms' to see all recognized words.", 'system');
        }

        // Command to show all synonyms
        function showSynonyms() {
            print("=== RECOGNIZED WORDS ===", 'command');
            
            Object.entries(verbSynonyms).forEach(([baseVerb, synonyms]) => {
                print(`${baseVerb.toUpperCase()}:`, 'system');
                print(`  ${synonyms.join(', ')}`, 'hint');
            });
            
            print("", 'system');
            print("Objects can also be referred to by different names:", 'system');
            print("  'torch' = light, lantern, fire", 'hint');
            print("  'stake' = wooden stake, sharp stick", 'hint');
            print("  etc.", 'hint');
        }

        // ==================== SAVE SYSTEM ====================
        const SAVE_SLOTS = {
            QUICK: 'castle_damned_quick',
            SLOT1: 'castle_damned_slot1',
            SLOT2: 'castle_damned_slot2',
            SLOT3: 'castle_damned_slot3'
        };

        function saveGame(slot = SAVE_SLOTS.SLOT1) {
            if (!gameStarted || !player.class) {
                print("No game in progress to save.", 'error');
                return;
            }
            
            const saveData = {
                player: JSON.parse(JSON.stringify(player)),
                rooms: JSON.parse(JSON.stringify(rooms)),
                gameStarted: gameStarted,
                currentBackground: currentBackground,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem(slot, JSON.stringify(saveData));
                print(`Game saved to slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                soundSystem.playSound('notification', 0.5);
            } catch (e) {
                print("Failed to save game: " + e.message, 'error');
            }
        }

        function quickSave() {
            saveGame(SAVE_SLOTS.QUICK);
        }

        function loadGame(slot = SAVE_SLOTS.SLOT1) {
            try {
                const saveData = localStorage.getItem(slot);
                if (!saveData) {
                    print(`No save found in slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}`, 'error');
                    return false;
                }
                
                const data = JSON.parse(saveData);
                
                // Restore player state
                player = data.player;
                
                // Restore rooms (need to recreate enemy instances)
                rooms = data.rooms;
                rooms.forEach(room => {
                    if (room.enemy && room.enemy.originalType) {
                        // Recreate enemy instance from template
                        const enemyInstance = createEnemy(room.enemy.originalType);
                        if (enemyInstance) {
                            // Keep current HP if enemy wasn't defeated
                            enemyInstance.hp = room.enemy.hp;
                            enemyInstance.stunned = room.enemy.stunned || 0;
                            enemyInstance.sunburned = room.enemy.sunburned || 0;
                            room.enemy = enemyInstance;
                        }
                    }
                });
                
                gameStarted = data.gameStarted;
                currentBackground = data.currentBackground;
                
                print(`Game loaded from slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                print(`Loaded save from ${new Date(data.timestamp).toLocaleString()}`, 'system');
                soundSystem.playSound('notification', 0.5);
                
                look();
                updateStatus();
                return true;
            } catch (e) {
                print("Failed to load game: " + e.message, 'error');
                return false;
            }
        }

        function quickLoad() {
            loadGame(SAVE_SLOTS.QUICK);
        }

        // ==================== GAME SYSTEMS ====================
        const lootTable = ['potion', 'manapot', 'stake', 'torch', 'gem', 'garlic', 'wolfsbane', 'blood_vial'];
        let gameStarted = false;
        let currentBackground = 'theme';
        const soundSystem = new SoundSystem();

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            // Play notification sound for important messages
            if (className === 'success' || className === 'loot' || className === 'quest') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            } else if (className === 'puzzle') {
                soundSystem.playSound('puzzle', 0.5);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            let statusText = `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} STE:${player.stealth} ` +
                `LVL:${player.level} GOLD:${player.gold} TIME:${player.time}${combat}`;
                
            // Add status effects
            const effects = [];
            if (player.poisoned) effects.push('POISON');
            if (player.ward > 0) effects.push(`WARD(${player.ward})`);
            if (player.barrier > 0) effects.push(`BARRIER(${player.barrier})`);
            if (player.shadowed > 0) effects.push(`SHADOW(${player.shadowed})`);
            
            if (effects.length > 0) {
                statusText += `\nEFFECTS: ${effects.join(' ')}`;
            }
            
            status.textContent = statusText;
        }

        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            let baseStealth = classes[player.class].stealth;
            if (weapon.stealth) baseStealth += weapon.stealth;
            if (armor.stealth) baseStealth += armor.stealth;
            player.stealth = Math.max(0, baseStealth);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 120;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 18;
                player.hp = player.maxHp;
                player.maxMp += 10;
                player.mp = player.maxMp;
                player.str += 2;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        // ==================== ENHANCED OBJECT INTERACTION ====================
        function interactWithObject(objectName, action = null, param = null) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see anything!", 'error');
                return;
            }
            
            // Find the object
            let matchedObject = null;
            let objectKey = null;
            
            for (const key in room.objects) {
                if (key.toLowerCase().includes(objectName.toLowerCase()) || 
                    objectName.toLowerCase().includes(key.toLowerCase())) {
                    matchedObject = room.objects[key];
                    objectKey = key;
                    break;
                }
            }
            
            if (!matchedObject) {
                print(`You don't see a ${objectName} here.`, 'error');
                return;
            }
            
            // Simple object (string description)
            if (typeof matchedObject === 'string') {
                print(`You examine the ${objectKey}:`, 'system');
                print(matchedObject, 'system');
                soundSystem.playSound('notification', 0.3);
                return;
            }
            
            // Complex object (object with states)
            const obj = matchedObject;
            
            if (!action) {
                // Just examine
                print(`You examine the ${objectKey}:`, 'system');
                print(obj.desc, 'system');
                print(`Current state: ${obj.states[obj.state]}`, 'hint');
                
                if (obj.state === 'normal' && obj.action === 'examine') {
                    // Auto-examine if that's the action
                    performObjectAction(obj, objectKey, 'examine', param);
                }
                return;
            }
            
            // Perform specific action
            performObjectAction(obj, objectKey, action, param);
        }
        
        function performObjectAction(obj, objectKey, action, param) {
            const room = rooms[player.location];
            
            // Check if this action is valid for this object
            if (obj.action && obj.action !== action) {
                print(`You can't ${action} the ${objectKey}.`, 'error');
                return;
            }
            
            // Check if required item is needed
            if (obj.requiredItem && !player.inventory.includes(obj.requiredItem)) {
                print(`${obj.states[obj.state]}`, 'hint');
                if (obj.requiredItem === 'oil') {
                    print("Perhaps you need something to lubricate it...", 'hint');
                } else if (obj.requiredItem === 'torch') {
                    print("Maybe fire could help...", 'hint');
                } else if (obj.requiredItem === 'key') {
                    print("You need a key to unlock this.", 'hint');
                } else if (obj.requiredItem === 'silver_key') {
                    print("You need a silver key.", 'hint');
                } else if (obj.requiredItem === 'crucifix') {
                    print("This needs a holy symbol...", 'hint');
                } else if (obj.requiredItem === 'vampire_cloak') {
                    print("This requires a vampire's stealth...", 'hint');
                } else if (obj.requiredItem === 'holy_water') {
                    print("This place needs purification.", 'hint');
                } else if (obj.requiredItem === 'gem') {
                    print("This needs a valuable gem...", 'hint');
                }
                return;
            }
            
            // Handle puzzle objects
            if (obj.puzzle) {
                handlePuzzle(obj, objectKey, action, param);
                return;
            }
            
            // Handle enemy-spawning objects
            if (obj.spawnEnemy && obj.state === 'sealed') {
                obj.state = 'opened';
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'puzzle');
                soundSystem.playSound('bat');
                
                // Spawn enemy
                rooms[player.location].enemy = createEnemy(obj.spawnEnemy);
                player.inCombat = obj.spawnEnemy;
                print(`A ${obj.spawnEnemy.replace('_', ' ')} emerges!`, 'enemy');
                return;
            }
            
            // Handle secret-triggering objects
            if (obj.triggersSecret && obj.state === 'normal') {
                obj.state = 'examined';
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'puzzle');
                soundSystem.playSound('puzzle');
                
                // Open secret passage
                if (obj.secretRoom !== undefined) {
                    rooms[player.location].exits.secret = obj.secretRoom;
                    print("A hidden passage opens!", 'success');
                    soundSystem.playSound('secret');
                    player.discoveredSecrets.push(`Secret passage in room ${player.location}`);
                }
                return;
            }
            
            // Standard state transition
            if (obj.requiredItem && player.inventory.includes(obj.requiredItem)) {
                // Use the item
                const index = player.inventory.indexOf(obj.requiredItem);
                if (index !== -1 && items[obj.requiredItem] && 
                    (items[obj.requiredItem].type === 'tool' || items[obj.requiredItem].type === 'consumable')) {
                    player.inventory.splice(index, 1);
                    print(`(You use the ${obj.requiredItem})`, 'system');
                }
                
                // Change state
                const oldState = obj.state;
                
                if (obj.state === 'sealed') obj.state = 'opened';
                else if (obj.state === 'rusted') obj.state = 'oiled';
                else if (obj.state === 'locked') obj.state = 'unlocked';
                else if (obj.state === 'warded') obj.state = 'unlocked';
                else if (obj.state === 'defiled') obj.state = 'cleansed';
                else if (obj.state === 'closed') obj.state = 'open';
                else if (obj.state === 'normal' && obj.action === 'search') obj.state = 'searched';
                else if (obj.state === 'normal' && obj.action === 'examine') obj.state = 'examined';
                else if (obj.state === 'alert') obj.state = 'calm';
                else if (obj.state === 'hostile') obj.state = 'calm';
                else if (obj.state === 'frozen') obj.state = 'cleaned';
                else if (obj.state === 'cleaned') obj.state = 'working';
                else if (obj.state === 'incomplete') obj.state = 'complete';
                else if (obj.state === 'covered') obj.state = 'uncovered';
                else if (obj.state === 'dry') obj.state = 'flowing';
                else if (obj.state === 'empty') obj.state = 'used';
                else if (obj.state === 'dark') obj.state = 'charged';
                else if (obj.state === 'charged') obj.state = 'sunlight';
                
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'success');
                soundSystem.playSound('notification', 0.5);
                
                // Check for hidden item
                if (obj.hiddenItem && (obj.state === 'open' || obj.state === 'unlocked' || 
                    obj.state === 'searched' || obj.state === 'examined' || obj.state === 'cleansed' ||
                    obj.state === 'calm' || obj.state === 'flowing' || obj.state === 'working' ||
                    obj.state === 'complete' || obj.state === 'sunlight')) {
                    
                    if (!room.items.includes(obj.hiddenItem)) {
                        room.items.push(obj.hiddenItem);
                        print(`You find: ${obj.hiddenItem}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                // Special cases
                if (objectKey === 'sword' && obj.state === 'complete') {
                    // Sword forged by blacksmith
                    print("The blacksmith presents you with a finished silver sword!", 'success');
                }
                
                if (objectKey === 'crystal' && obj.state === 'sunlight') {
                    // Sun crystal charged
                    print("The crystal now glows with the light of dawn! It could destroy the master!", 'puzzle');
                    player.time = 'dawn';
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 0) {
                    // Castle gates unlock
                    print("The castle gates creak open!", 'success');
                    soundSystem.playSound('door');
                }
                
                if (objectKey === 'door' && obj.state === 'unlocked' && player.location === 36) {
                    // Private library door unwarded
                    print("The magical ward dissipates! The door is now accessible.", 'success');
                    soundSystem.playSound('secret');
                    rooms[36].locked = false;
                }
                
                // Update player XP for solving puzzles
                player.xp += 15;
            } else {
                print(`You ${action} the ${objectKey}. ${obj.states[obj.state]}`, 'system');
            }
        }
        
        function handlePuzzle(obj, objectKey, action, param) {
            if (objectKey === 'clock') {
                if (obj.state === 'frozen') {
                    print("The clock is frozen at midnight, jammed with bat guano.", 'puzzle');
                    print("You need to clean it first.", 'hint');
                } else if (obj.state === 'cleaned') {
                    print("The clock is clean but still doesn't work. It needs to be wound.", 'puzzle');
                } else if (obj.state === 'working') {
                    print("The clock chimes! A hidden compartment opens in the mechanism!", 'success');
                    soundSystem.playSound('secret');
                    
                    // Add silver key to room items
                    if (!rooms[player.location].items.includes('silver_key')) {
                        rooms[player.location].items.push('silver_key');
                        print("You find: silver_key!", 'loot');
                        soundSystem.playSound('pickup');
                    }
                    
                    player.xp += 30;
                    player.discoveredSecrets.push("Solved the Clock Tower puzzle");
                }
            } else if (objectKey === 'mirrors') {
                if (obj.state === 'hostile') {
                    print("The reflections show you as a vampire! They reach out from the mirrors!", 'enemy');
                    if (!player.inCombat) {
                        rooms[player.location].enemy = createEnemy('vampire_spawn');
                        player.inCombat = 'vampire_spawn';
                        print("A vampire emerges from the mirror!", 'enemy');
                    }
                } else if (obj.state === 'calm') {
                    print("Holding the crucifix, the reflections show your true self.", 'success');
                    print("One mirror shatters, revealing a hidden compartment!", 'puzzle');
                    
                    if (!rooms[player.location].items.includes('mirror')) {
                        rooms[player.location].items.push('mirror');
                        print("You find: mirror!", 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
            } else if (objectKey === 'crystal') {
                if (obj.state === 'dark') {
                    print("The crystal is dark. It needs to be charged with moonlight.", 'puzzle');
                    if (player.time === 'midnight') {
                        print("It's midnight - perfect time to charge it!", 'hint');
                    }
                } else if (obj.state === 'charged') {
                    print("The crystal glows with moonlight. Now it needs sunlight...", 'puzzle');
                    print("Maybe at dawn...", 'hint');
                }
            }
        }
        
        function chargeCrystal() {
            const room = rooms[player.location];
            if (room.id !== 16) {
                print("There's no crystal here to charge.", 'error');
                return;
            }
            
            const obj = room.objects['crystal'];
            if (!obj || !obj.puzzle) {
                print("You can't charge this.", 'error');
                return;
            }
            
            interactWithObject('crystal', 'charge');
        }

        // ==================== DEEPENED NPC INTERACTION ====================
        function talkTo(npcName, topic = null) {
            const room = rooms[player.location];
            
            if (!room.npc) {
                print("There's no one here to talk to.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            
            if (npc.hostile) {
                print(`${npc.name}: "Stay away from my work!"`, 'npc');
                return;
            }
            
            soundSystem.playSound('notification', 0.5);
            
            if (topic && npc.dialogueTopics && npc.dialogueTopics.includes(topic)) {
                // Specific topic
                print(`${npc.name}: "${npc.dialogue[topic]}"`, 'dialogue');
                
                // Special topic responses
                if (room.npc === 'cursed_blacksmith' && topic === 'silver') {
                    if (player.inventory.includes('gem')) {
                        print(`${npc.name}: "I see you have a gem. I can forge you something special for it and 50 gold."`, 'npc');
                    }
                }
                
                if (room.npc === 'alchemist' && topic === 'cures') {
                    print(`${npc.name}: "If you find vampire blood, bring it to me. I might be able to synthesize a cure."`, 'npc');
                }
                
                // Add topic to known topics
                if (!player.knownPasswords.includes(topic)) {
                    player.knownPasswords.push(topic);
                }
            } else if (topic) {
                // Unknown topic
                print(`${npc.name}: "I don't know anything about that."`, 'npc');
            } else {
                // General talk
                print(`${npc.name}: "${npc.dialog}"`, 'npc');
                
                // Show available topics
                if (npc.dialogueTopics) {
                    print(`You can ask about: ${npc.dialogueTopics.join(', ')}`, 'hint');
                    print("Use 'talk [npc] [topic]' to discuss specific topics.", 'system');
                }
            }
            
            // Quest information
            if (npc.quest) {
                if (npc.quest.completed) {
                    print(`${npc.name}: "Thank you again for your help."`, 'npc');
                } else if (npc.quest.items) {
                    // Multiple items quest (alchemist)
                    const counts = {};
                    npc.quest.items.forEach(item => {
                        counts[item] = player.inventory.filter(i => i === item).length;
                    });
                    
                    print(`${npc.name}: "I need: ${npc.quest.items.map(item => `${item} (${counts[item]})`).join(', ')}."`, 'quest');
                    
                    const hasAll = npc.quest.items.every(item => counts[item] > 0);
                    if (hasAll) {
                        print(`You have all the items! Type 'give ${room.npc}' to complete the quest.`, 'quest');
                    }
                } else if (npc.quest.item) {
                    if (npc.quest.count) {
                        const count = player.inventory.filter(item => item === npc.quest.item).length;
                        print(`${npc.name}: "I need ${npc.quest.count} ${npc.quest.item}s. You have ${count}."`, 'quest');
                    } else {
                        const hasItem = player.inventory.includes(npc.quest.item);
                        print(`${npc.name}: "Bring me the ${npc.quest.item}."`, 'quest');
                        if (hasItem) {
                            print(`You have the ${npc.quest.item}. Type 'give ${room.npc}' to complete the quest.`, 'quest');
                        }
                    }
                }
            }
            
            // Special NPC offers
            if (room.npc === 'cursed_blacksmith') {
                print(`${npc.name}: "I can forge silver weapons. Bring me a gem and gold."`, 'npc');
            } else if (room.npc === 'priest') {
                print(`${npc.name}: "I can bless your weapons against the undead. Bring them to me."`, 'npc');
            } else if (room.npc === 'alchemist') {
                print(`${npc.name}: "I sell potions and tools for hunting the creatures of the night."`, 'npc');
            }
        }

        // ==================== SKILL FUNCTIONS ====================
        function showSkills() {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            print(`=== ${player.class.toUpperCase()} SKILLS ===`, 'skill');
            
            classSkills.forEach(skillName => {
                const skill = skills[skillName];
                if (skill) {
                    print(`${skill.name} (${skill.mpCost} MP): ${skill.description}`, 'skill');
                }
            });
            
            print("Use 'skill [name]' in combat to use a skill.", 'system');
        }

        function useSkill(skillName) {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const room = rooms[player.location];
            if (!room.enemy || !player.inCombat) {
                print("You can only use skills in combat!", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            if (!classSkills.includes(skillName)) {
                print(`You don't have the ${skillName} skill!`, 'error');
                return;
            }
            
            const skill = skills[skillName];
            if (!skill) {
                print("Unknown skill.", 'error');
                return;
            }
            
            if (player.mp < skill.mpCost) {
                print(`Not enough MP! Need ${skill.mpCost}, have ${player.mp}.`, 'error');
                return;
            }
            
            player.mp -= skill.mpCost;
            print(`You use ${skill.name}! (-${skill.mpCost} MP)`, 'skill');
            
            const endsTurn = skill.effect(player, room.enemy);
            
            // Apply sunburn damage if enemy is sunburned
            if (room.enemy.sunburned && room.enemy.sunburned > 0) {
                const sunDamage = Math.floor(room.enemy.dmg * 0.4);
                room.enemy.hp -= sunDamage;
                room.enemy.sunburned--;
                print(`Sunlight burns the enemy for ${sunDamage} damage!`, 'damage');
                soundSystem.playSound('attack', 0.3);
            }
            
            // Check if enemy is defeated
            if (room.enemy.hp <= 0) {
                const enemyType = room.enemy.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 25) + 10;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 15) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'vampire_lord') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Vampire Lord!", 'success');
                    print("Castle of the Damned is cleansed!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
                updateStatus();
                return;
            }
            
            // If skill doesn't end turn, enemy doesn't attack
            if (endsTurn) {
                // Enemy turn if not stunned
                if (room.enemy.stunned && room.enemy.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    room.enemy.stunned--;
                } else {
                    enemyTurn(room.enemy);
                }
            }
            
            updateStatus();
        }

        function enemyTurn(enemyData) {
            // Apply damage reduction if warded
            let damageMultiplier = 1;
            if (player.ward > 0) {
                damageMultiplier = 0.3; // Strong reduction for holy ward
                player.ward--;
                if (player.ward <= 0) {
                    print("Your holy ward fades.", 'system');
                }
            }
            
            // Apply miss chance if shadowed
            let hitChance = 1.0;
            if (player.shadowed > 0) {
                hitChance = 0.5; // 50% miss chance
                player.shadowed--;
                if (player.shadowed <= 0) {
                    print("You step out of the shadows.", 'system');
                }
            }
            
            // Check if attack misses
            if (Math.random() > hitChance) {
                print("The enemy's attack misses!", 'success');
                return;
            }
            
            // Apply barrier if exists
            let enemyDmg = Math.max(enemyData.dmg - player.def + Math.floor(Math.random() * 6), 1);
            enemyDmg = Math.floor(enemyDmg * damageMultiplier);
            
            if (player.barrier > 0) {
                const absorbed = Math.min(player.barrier, enemyDmg);
                enemyDmg -= absorbed;
                player.barrier -= absorbed;
                print(`Your barrier absorbs ${absorbed} damage.`, 'heal');
                
                if (player.barrier <= 0) {
                    print("Your arcane barrier shatters!", 'system');
                }
            }
            
            if (enemyDmg > 0) {
                player.hp -= enemyDmg;
                print(`The enemy hits you for ${enemyDmg} damage.`, 'damage');
                soundSystem.playSound('playerHit', 0.5);
                
                // Apply werewolf curse if werewolf
                if (enemyData.originalType === 'werewolf' && Math.random() > 0.8) {
                    print("The werewolf's bite infects you! You feel the curse spreading!", 'error');
                    // Could implement curse mechanics here
                }
                
                if (player.hp <= 0) {
                    print("You have been slain... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                }
            }
        }

        // ==================== GAME LOGIC ====================
        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.stealth = c.stealth;
            player.gold = 60;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['potion', 'torch', 'garlic'];
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.ward = 0;
            player.barrier = 0;
            player.shadowed = 0;
            player.knownPasswords = [];
            player.discoveredSecrets = [];
            player.time = 'midnight';
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 60 gold, a potion, a torch, and garlic.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateStatus();
        }

        function look() {
            const room = rooms[player.location];
            
            // Update background music based on room
            if (room.enemy && room.enemy.bgSound) {
                currentBackground = room.enemy.bgSound;
            } else {
                currentBackground = room.sound;
            }
            soundSystem.playBackground(currentBackground);
            
            // Check if room is dark
            if (room.dark && !player.torch) {
                print("The room is pitch black. You can't see anything!", 'error');
                print("You need a light source.", 'error');
                return;
            }
            
            if (!room.explored) {
                room.explored = true;
                player.xp += 8;
                print(`+8 XP for exploring!`, 'system');
                soundSystem.playSound('notification', 0.5);
            }
            
            print(room.desc);
            
            // List interactive objects
            const objectKeys = Object.keys(room.objects);
            if (objectKeys.length > 0) {
                print(`You see: ${objectKeys.join(', ')}`, 'item');
                print("Use 'examine [object]' to look at something, or 'use [item] on [object]' to interact.", 'hint');
            }
            
            if (room.items.length > 0) {
                print(`Items here: ${room.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
            
            if (room.enemy) {
                const enemy = room.enemy;
                print(`${enemy.desc}`, 'enemy');
                const healthPercent = (enemy.hp / enemies[enemy.originalType].hp) * 100;
                if (healthPercent <= 25) {
                    print(`It looks critically wounded.`, 'enemy');
                } else if (healthPercent <= 50) {
                    print(`It looks badly wounded.`, 'enemy');
                } else if (healthPercent <= 75) {
                    print(`It looks wounded.`, 'enemy');
                } else {
                    print(`It looks healthy.`, 'enemy');
                }
            }
            
            if (room.npc) {
                const npc = npcs[room.npc];
                print(`${npc.name} is here. ${npc.desc}`, 'npc');
                print(`Use 'talk ${room.npc}' to speak with them.`, 'hint');
            }
            
            if (room.locked) {
                print("The door to this room is locked!", 'error');
            }
            
            let exits = [];
            for (let dir in room.exits) if (room.exits[dir] !== null) exits.push(dir);
            if (room.exits.secret) exits.push('secret');
            print(`Exits: ${exits.join(' ')}`);
            
            updateStatus();
        }

        function move(direction) {
            const room = rooms[player.location];
            const target = room.exits[direction];
            
            if (target === null) {
                print("You can't go that way.", 'error');
                soundSystem.playSound('click');
                return;
            }
            
            // Check for locked door
            const targetRoom = rooms[target];
            if (targetRoom.locked) {
                if (player.inventory.includes('silver_key')) {
                    targetRoom.locked = false;
                    print("You use the silver key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else if (player.inventory.includes('key')) {
                    targetRoom.locked = false;
                    print("You use the key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else {
                    print("The door is locked! You need a key.", 'error');
                    return;
                }
            }
            
            soundSystem.playSound('step', 0.3);
            
            // Check for random encounter
            player.moves++;
            if (player.moves % 3 === 0) {
                const encounterChance = Math.max(35 - player.stealth, 8);
                if (Math.random() * 100 < encounterChance) {
                    const randomEnemies = ['bat_swarm', 'skeleton', 'ghost', 'vampire_spawn'];
                    const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
                    rooms[player.location].enemy = createEnemy(enemyType);
                    print(`A ${enemyType.replace('_', ' ')} ambushes you!`, 'enemy');
                    player.inCombat = enemyType;
                    soundSystem.playSound('attack', 0.5);
                    updateStatus();
                    return;
                }
            }
            
            player.location = target;
            print(`You go ${direction}.`, 'command');
            
            // Auto-save on movement
            quickSave();
            
            // Advance time
            if (player.moves % 10 === 0) {
                if (player.time === 'midnight') player.time = 'early morning';
                else if (player.time === 'early morning') player.time = 'dawn';
                else if (player.time === 'dawn') player.time = 'morning';
                else if (player.time === 'morning') player.time = 'midday';
                else if (player.time === 'midday') player.time = 'afternoon';
                else if (player.time === 'afternoon') player.time = 'dusk';
                else if (player.time === 'dusk') player.time = 'evening';
                else if (player.time === 'evening') player.time = 'night';
                else if (player.time === 'night') player.time = 'midnight';
                
                print(`Time passes... It is now ${player.time}.`, 'system');
                
                // Play thunder at night
                if (player.time === 'night' || player.time === 'midnight') {
                    soundSystem.playSound('thunder', 0.3);
                }
            }
            
            // Check for dark room
            const newRoom = rooms[player.location];
            if (newRoom.dark && !player.torch) {
                print("You enter complete darkness. You can't see!", 'error');
            } else {
                look();
            }
            
            updateStatus();
        }

        function take(itemName) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            const index = room.items.indexOf(itemName);
            if (index === -1) {
                // Check if it's a special item from an object
                for (const key in room.objects) {
                    const obj = room.objects[key];
                    if (typeof obj === 'object' && obj.hiddenItem === itemName && 
                        (obj.state === 'open' || obj.state === 'unlocked' || obj.state === 'searched' || 
                         obj.state === 'examined' || obj.state === 'cleansed' || obj.state === 'calm' ||
                         obj.state === 'flowing' || obj.state === 'working' || obj.state === 'complete' ||
                         obj.state === 'sunlight')) {
                        room.items.push(itemName);
                        print(`You take the ${itemName} from the ${key}.`, 'success');
                        soundSystem.playSound('pickup');
                        updateStatus();
                        return;
                    }
                }
                print("That item isn't here.", 'error');
                return;
            }
            
            room.items.splice(index, 1);
            player.inventory.push(itemName);
            print(`You take the ${itemName}.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function give(npcName) {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== npcName) {
                print("That NPC isn't here.", 'error');
                return;
            }
            
            const npc = npcs[npcName];
            
            if (!npc.quest || npc.quest.completed) {
                print(`${npc.name} doesn't want anything from you.`, 'npc');
                return;
            }
            
            if (npc.quest.items) {
                // Multiple items quest (alchemist)
                const hasAll = npc.quest.items.every(item => 
                    player.inventory.includes(item)
                );
                
                if (!hasAll) {
                    print(`You don't have all the required items.`, 'error');
                    return;
                }
                
                // Remove items
                npc.quest.items.forEach(item => {
                    const index = player.inventory.indexOf(item);
                    if (index !== -1) {
                        player.inventory.splice(index, 1);
                    }
                });
                
                npc.quest.completed = true;
                player.gold += npc.quest.reward.gold;
                player.xp += npc.quest.reward.xp;
                if (npc.quest.reward.item) {
                    player.inventory.push(npc.quest.reward.item);
                }
                
                print(`${npc.name}: "Excellent! Here is your reward."`, 'success');
                print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                if (npc.quest.reward.item) {
                    print(`You receive: ${npc.quest.reward.item}`, 'loot');
                }
                
                soundSystem.playSound('victory');
                checkLevelUp();
            } else if (npc.quest.count) {
                const items = player.inventory.filter(item => item === npc.quest.item);
                if (items.length >= npc.quest.count) {
                    for (let i = 0; i < npc.quest.count; i++) {
                        const index = player.inventory.indexOf(npc.quest.item);
                        player.inventory.splice(index, 1);
                    }
                    
                    npc.quest.completed = true;
                    player.gold += npc.quest.reward.gold;
                    player.xp += npc.quest.reward.xp;
                    if (npc.quest.reward.item) {
                        player.inventory.push(npc.quest.reward.item);
                    }
                    
                    print(`${npc.name}: "Excellent! Here is your reward."`, 'success');
                    print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                    if (npc.quest.reward.item) {
                        print(`You receive: ${npc.quest.reward.item}`, 'loot');
                    }
                    
                    soundSystem.playSound('victory');
                    checkLevelUp();
                } else {
                    print(`You need ${npc.quest.count} ${npc.quest.item}s. You only have ${items.length}.`, 'error');
                }
            } else {
                const index = player.inventory.indexOf(npc.quest.item);
                if (index === -1) {
                    print(`You don't have the ${npc.quest.item}.`, 'error');
                    return;
                }
                
                player.inventory.splice(index, 1);
                npc.quest.completed = true;
                player.gold += npc.quest.reward.gold;
                player.xp += npc.quest.reward.xp;
                if (npc.quest.reward.item) {
                    player.inventory.push(npc.quest.reward.item);
                }
                
                print(`${npc.name}: "Thank you! Here is your reward."`, 'success');
                print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
                if (npc.quest.reward.item) {
                    print(`You receive: ${npc.quest.reward.item}`, 'loot');
                }
                
                soundSystem.playSound('victory');
                checkLevelUp();
            }
            
            updateStatus();
        }

        function forgeWeapon() {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== 'cursed_blacksmith') {
                print("The blacksmith isn't here.", 'error');
                return;
            }
            
            // Check for gem and gold
            if (player.inventory.includes('gem') && player.gold >= 50) {
                const gemIndex = player.inventory.indexOf('gem');
                player.inventory.splice(gemIndex, 1);
                player.gold -= 50;
                
                const forgedWeapons = ['silver_sword', 'crossbow', 'wolfsbane_dagger'];
                const weapon = forgedWeapons[Math.floor(Math.random() * forgedWeapons.length)];
                player.inventory.push(weapon);
                
                print("Boris hammers away at his anvil, silver glowing in the forge...", 'system');
                setTimeout(() => {
                    print(`Boris hands you a freshly forged ${weapon}!`, 'success');
                    print("The blacksmith growls approvingly.", 'npc');
                    soundSystem.playSound('equip');
                }, 1000);
            } else {
                print("You need a gem and 50 gold for forging.", 'error');
                return;
            }
            
            updateStatus();
        }

        function listShop() {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            print(`${npc.name}'s Shop:`, 'npc');
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (item) {
                    const price = item.value;
                    print(`${item.name || itemName} - ${price} gold: ${item.desc}`, 'item');
                }
            });
            print("Sell items for 70% of value.", 'npc');
        }

        function buy(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            if (!npc.shopItems.includes(itemName)) {
                print("The alchemist doesn't sell that.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                print("That item doesn't exist.", 'error');
                return;
            }
            
            if (player.gold < item.value) {
                print(`You need ${item.value} gold, but only have ${player.gold}.`, 'error');
                return;
            }
            
            player.gold -= item.value;
            player.inventory.push(itemName);
            print(`You buy ${item.name || itemName} for ${item.value} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function sell(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'alchemist') {
                print("There's no shop here.", 'error');
                return;
            }
            
            const index = player.inventory.indexOf(itemName);
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item || item.type === 'quest') {
                print("You can't sell that.", 'error');
                return;
            }
            
            const sellPrice = Math.floor(item.value * 0.7);
            player.gold += sellPrice;
            player.inventory.splice(index, 1);
            print(`You sell ${item.name || itemName} for ${sellPrice} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

        function attack(target) {
            const room = rooms[player.location];
            
            if (target) {
                if (room.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        room.enemy = createEnemy('werewolf');
                        room.npc = null;
                        player.inCombat = 'werewolf';
                        player.stealth = Math.max(0, player.stealth - 5);
                        print("Your reputation suffers! Stealth -5.", 'error');
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        room.npc = null;
                        player.stealth = Math.max(0, player.stealth - 10);
                        print("Your dark deed stains your soul! Stealth -10.", 'error');
                        player.xp += 25;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    return;
                }
            }
            
            if (!room.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyData = room.enemy;
            player.inCombat = enemyData.originalType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemyData.originalType}!`, 'command');
            
            // Player attack
            const playerDmg = player.dmg + Math.floor(Math.random() * 6);
            
            // Apply weapon bonuses
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            let bonusDamage = 0;
            
            if (enemyData.originalType.includes('vampire') && weapon.vs_vampire) {
                bonusDamage += weapon.vs_vampire;
            }
            if (enemyData.originalType.includes('werewolf') && weapon.vs_werewolf) {
                bonusDamage += weapon.vs_werewolf;
            }
            if ((enemyData.originalType.includes('vampire') || enemyData.originalType.includes('skeleton') || 
                 enemyData.originalType.includes('ghost')) && weapon.vs_undead) {
                bonusDamage += weapon.vs_undead;
            }
            if (weapon.holy && (enemyData.originalType.includes('vampire') || enemyData.originalType.includes('skeleton') || 
                enemyData.originalType.includes('ghost'))) {
                bonusDamage += 10;
            }
            
            const totalDamage = playerDmg + bonusDamage;
            enemyData.hp -= totalDamage;
            print(`You hit for ${totalDamage} damage${bonusDamage > 0 ? ` (+${bonusDamage} bonus)` : ''}.`, 'damage');
            soundSystem.playSound(enemyData.sounds.hit, 0.5);
            
            // Apply sunburn damage if enemy is sunburned
            if (enemyData.sunburned && enemyData.sunburned > 0) {
                const sunDamage = Math.floor(enemyData.dmg * 0.4);
                enemyData.hp -= sunDamage;
                enemyData.sunburned--;
                print(`Sunlight burns the enemy for ${sunDamage} damage!`, 'damage');
                soundSystem.playSound('attack', 0.3);
            }
            
            // Use special items
            if (enemyData.originalType.includes('vampire') && player.inventory.includes('holy_water')) {
                const holyDamage = 75;
                enemyData.hp -= holyDamage;
                print(`The holy water burns the vampire for ${holyDamage} damage!`, 'damage');
                const waterIndex = player.inventory.indexOf('holy_water');
                player.inventory.splice(waterIndex, 1);
            }
            
            if (enemyData.originalType.includes('werewolf') && player.inventory.includes('wolfsbane')) {
                const wolfsbaneDamage = 50;
                enemyData.hp -= wolfsbaneDamage;
                print(`Wolfsbane poisons the werewolf for ${wolfsbaneDamage} damage!`, 'damage');
                const wolfsbaneIndex = player.inventory.indexOf('wolfsbane');
                player.inventory.splice(wolfsbaneIndex, 1);
            }
            
            if (enemyData.originalType.includes('vampire') && player.inventory.includes('garlic')) {
                print("The garlic repels the vampire! It seems weakened.", 'success');
                enemyData.dmg = Math.floor(enemyData.dmg * 0.7);
            }
            
            if (enemyData.hp <= 0) {
                const enemyType = enemyData.originalType;
                const enemy = enemies[enemyType];
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                // Loot drop
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 30) + 15;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.7) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 10;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'vampire_lord') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Vampire Lord!", 'success');
                    print("Castle of the Damned is cleansed!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('theme'), 10000);
                }
                
                room.enemy = null;
                player.inCombat = null;
                
                checkLevelUp();
            } else {
                print(`The ${enemyData.name} has ${enemyData.hp} HP left.`);
                
                // Check if enemy is stunned
                if (enemyData.stunned && enemyData.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    enemyData.stunned--;
                } else {
                    enemyTurn(enemyData);
                }
            }
            
            updateStatus();
        }

        function use(itemName) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(`You heal ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(`You restore ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.ward_vampire) {
                    player.ward = item.effect.ward_vampire;
                    print(`Garlic repels vampires for ${player.ward} turns.`, 'success');
                    soundSystem.playSound('buff', 0.5);
                }
                if (item.effect.damage_undead) {
                    print("Holy water must be used in combat against undead!", 'error');
                    return;
                }
                if (item.effect.damage_werewolf) {
                    print("Wolfsbane must be used in combat against werewolves!", 'error');
                    return;
                }
                if (item.effect.damage_vampire) {
                    print("Silver bullets must be used in combat against vampires!", 'error');
                    return;
                }
                if (item.effect.hp && item.effect.mp === -10) {
                    // Blood vial (heals but corrupts)
                    print("You drink the vampire blood. You feel stronger but corrupted...", 'system');
                }
                player.inventory.splice(index, 1);
                updateStatus();
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(player.torch ? "You light the torch." : "You extinguish the torch.", 'system');
                soundSystem.playSound('click');
            } else if (itemName === 'crucifix') {
                print("You hold up the crucifix. It glows with holy light.", 'system');
                soundSystem.playSound('buff', 0.5);
                // Could implement area effect against undead
            } else if (itemName === 'mirror') {
                print("You look in the mirror. Your reflection looks back.", 'system');
                // Could implement vampire detection
            } else {
                print("You can't use that now.");
            }
        }

        function showInventory() {
            if (player.inventory.length === 0) {
                print("Your inventory is empty.");
            } else {
                print("Inventory:");
                const counts = {};
                player.inventory.forEach(item => {
                    counts[item] = (counts[item] || 0) + 1;
                });
                
                Object.keys(counts).forEach(itemName => {
                    const item = weapons[itemName] || armors[itemName] || items[itemName];
                    const count = counts[itemName];
                    const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
                    print(`${itemName} x${count}: ${itemDesc}`, 'item');
                });
            }
            const weapon = weapons[player.equipped.weapon];
            const armor = armors[player.equipped.armor];
            print(`Equipped: ${weapon.name} (${weapon.dmg + player.str} DMG), ${armor.name} (${armor.def} DEF)`);
            print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.stealth} STEALTH`);
            
            // Show discovered secrets
            if (player.discoveredSecrets.length > 0) {
                print(`\nDiscovered Secrets:`, 'puzzle');
                player.discoveredSecrets.forEach(secret => {
                    print(`  ${secret}`, 'hint');
                });
            }
        }

        function examine(itemName) {
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                // Try to interact with object
                interactWithObject(itemName);
                return;
            }
            
            print(`${item.name || itemName}:`, 'item');
            print(`  ${item.desc}`);
            
            if (weapons[itemName]) {
                print(`  Damage: ${item.dmg}`);
                if (item.vs_vampire) print(`  vs Vampires: +${item.vs_vampire}`);
                if (item.vs_werewolf) print(`  vs Werewolves: +${item.vs_werewolf}`);
                if (item.vs_undead) print(`  vs Undead: +${item.vs_undead}`);
                if (item.holy) print(`  Holy: Effective against undead`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
                if (item.light) print(`  Light: Glows with magical light`);
            } else if (armors[itemName]) {
                print(`  Defense: ${item.def}`);
                if (item.stealth) print(`  Stealth: ${item.stealth > 0 ? '+' : ''}${item.stealth}`);
                if (item.vs_vampire) print(`  vs Vampires: +${item.vs_vampire}`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
                if (item.darkness) print(`  Darkness: Blends with shadows`);
            } else if (items[itemName]) {
                print(`  Value: ${item.value} gold`);
            }
        }

        // Original help function
        function originalHelp() {
            print("=== CASTLE OF THE DAMNED COMMANDS ===", 'command');
            print("MOVEMENT: n, s, e, w, look", 'system');
            print("OBJECT INTERACTION: examine [object], use [item] on [object], search [object]", 'system');
            print("PUZZLES: charge crystal (in Observatory)", 'system');
            print("COMBAT: attack [target], skill [name], use [item]", 'system');
            print("SKILLS: skills (to see available skills)", 'system');
            print("NPCS: talk [npc], talk [npc] [topic], give [npc], forge", 'system');
            print("SHOP: list, buy [item], sell [item] (with Alchemist)", 'system');
            print("ITEMS: take [item], equip [item], use [item], examine [item]", 'system');
            print("INVENTORY: inventory, status", 'system');
            print("SAVE/LOAD: save, load, qsave, qload", 'system');
            print("OTHER: help, quit", 'system');
            print("=== VAMPIRE HUNTING TIPS ===", 'command');
            print("- Vampires are weak to: silver, sunlight, holy symbols, garlic, stakes", 'system');
            print("- Werewolves are weak to: silver, wolfsbane", 'system');
            print("- Ghosts are weak to: holy water, salt", 'system');
            print("- Use garlic to repel vampires, holy water in combat", 'system');
            print("- The time of day affects vampire strength (weakest at dawn)", 'system');
            print("- Find the sun crystal and charge it at dawn", 'system');
            print("- Silver keys open many doors in the castle", 'system');
        }

        // Enhanced help function
        function help() {
            enhancedHelp();
            // Also show basic commands
            setTimeout(() => {
                print("\n=== BASIC COMMANDS (for reference) ===", 'command');
                originalHelp();
            }, 100);
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            rooms = generateRooms();
            soundSystem.playBackground('theme');
            print("GAME OVER", 'error');
            print("Choose a class: hunter, sorcerer, dhampir.");
            updateStatus();
        }

        function quickCommand(cmd) {
            document.getElementById('input').value = cmd;
            const event = new KeyboardEvent('keydown', { key: 'Enter' });
            document.getElementById('input').dispatchEvent(event);
        }

        // ==================== GAME COMMAND HANDLER ====================
        function handleGameCommand(verb, arg, arg2, arg3, arg4) {
            // Game commands
            switch (verb) {
                case 'n': case 'north': move('n'); break;
                case 's': case 'south': move('s'); break;
                case 'e': case 'east': move('e'); break;
                case 'w': case 'west': move('w'); break;
                case 'secret': move('secret'); break;
                case 'go': if (arg) move(arg); else print("Go where?"); break;
                case 'l': case 'look': 
                    if (arg === 'at' && arg2) {
                        interactWithObject(arg2);
                    } else if (arg) {
                        interactWithObject(arg);
                    } else {
                        look();
                    }
                    break;
                case 'examine': 
                    if (arg) examine(arg); 
                    else print("Examine what?"); 
                    break;
                case 'search': 
                    if (arg) interactWithObject(arg, 'search'); 
                    else print("Search what?"); 
                    break;
                case 'use': 
                    if (arg && arg2 === 'on' && arg3) {
                        // use item on object
                        if (player.inventory.includes(arg)) {
                            interactWithObject(arg3, 'use', arg);
                        } else {
                            print(`You don't have ${arg}.`, 'error');
                        }
                    } else if (arg) {
                        use(arg);
                    } else {
                        print("Use what?"); 
                    }
                    break;
                case 'charge':
                    if (arg === 'crystal') {
                        chargeCrystal();
                    } else {
                        print("Charge what?"); 
                    }
                    break;
                case 'take': if (arg) take(arg); else print("Take what?"); break;
                case 'talk': 
                    if (arg && arg2) {
                        talkTo(arg, arg2);
                    } else if (arg) {
                        talkTo(arg);
                    } else {
                        print("Talk to who?"); 
                    }
                    break;
                case 'give': if (arg) give(arg); else print("Give to who?"); break;
                case 'forge': forgeWeapon(); break;
                case 'list': listShop(); break;
                case 'buy': if (arg) buy(arg); else print("Buy what?"); break;
                case 'sell': if (arg) sell(arg); else print("Sell what?"); break;
                case 'skill': if (arg) useSkill(arg); else print("Use which skill?"); break;
                case 'skills': showSkills(); break;
                case 'attack': if (arg) attack(arg); else attack(); break;
                case 'equip': if (arg) equip(arg); else print("Equip what?"); break;
                case 'i': case 'inventory': case 'inv': showInventory(); break;
                case 'status': updateStatus(); break;
                case 'save': saveGame(); break;
                case 'load': loadGame(); break;
                case 'qsave': quickSave(); break;
                case 'qload': quickLoad(); break;
                case 'help': case '?': help(); break;
                case 'commands': originalHelp(); break;
                case 'synonyms': showSynonyms(); break;
                case 'quit': resetGame(); break;
                default: print("Unknown command. Type 'help'.", 'error');
            }
        }

        // ==================== INITIALIZATION ====================
        
        // Sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundSystem.toggle();
        });

        // Initialize audio on first user interaction
        document.addEventListener('click', function initAudio() {
            soundSystem.resumeAudioContext();
            if (!gameStarted) {
                soundSystem.playBackground('theme');
            }
            document.removeEventListener('click', initAudio);
        }, { once: true });

        // Set up the enhanced input handler
        setupEnhancedInputHandler();

        // ==================== INIT ====================
        print("CASTLE OF THE DAMNED (1985) - GOTHIC EDITION", 'success');
        print("NIGHTFALLS GAMES PRESENTS", 'system');
        print("", 'system');
        print("A GOTHIC HORROR ADVENTURE in a vampire's castle!", 'system');
        print("Hunt vampires, werewolves, and ghosts in this Dracula-inspired sequel!", 'system');
        print("", 'system');
        print("KEY FEATURES:", 'puzzle');
        print("- Vampire hunting with silver, stakes, and holy water", 'system');
        print("- Time system: vampires weaken at dawn", 'system');
        print("- Gothic castle with 50+ rooms to explore", 'system');
        print("- Three unique classes: Hunter, Sorcerer, Dhampir", 'system');
        print("- Interactive objects and environmental puzzles", 'system');
        print("- Day/night cycle affecting gameplay", 'system');
        print("", 'system');
        print("NEW: Enhanced natural language parser! Type naturally like:", 'success');
        print("  'pick up the silver sword' or 'attack the vampire'", 'hint');
        print("  'talk to the priest' or 'use holy water on skeleton'", 'hint');
        print("", 'system');
        print("Touch sound button to toggle audio", 'system');
        print("Use quick buttons for mobile play", 'system');
        print("SAVE/LOAD buttons in top-left corner", 'system');
        print("", 'system');
        print("Choose your class: hunter, sorcerer, dhampir.", 'system');
        updateStatus();
        input.focus();
    </script>
</body>
</html>
