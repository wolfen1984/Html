<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elemental Chess Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            font-family: 'Courier New', monospace;
            background-color: #000;
            color: #0f0;
            line-height: 1.2;
            overflow-x: hidden;
            width: 100%;
            height: 100vh;
            height: 100dvh;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .screen {
            display: none;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        #main-menu {
            display: flex;
        }

        .active {
            display: flex !important;
        }

        .header {
            text-align: center;
            padding: 8px;
            border-bottom: 1px solid #0f0;
            margin-bottom: 0;
            flex-shrink: 0;
            flex-grow: 0;
        }

        .content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            min-height: 0;
            margin: 0;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .footer {
            padding: 8px;
            border-top: 1px solid #0f0;
            margin-top: 0;
            flex-shrink: 0;
            flex-grow: 0;
        }

        button {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 12px 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 2px 0;
            cursor: pointer;
            width: 100%;
            min-height: 50px;
            flex-shrink: 0;
            transition: all 0.1s ease;
        }

        button:active {
            background-color: #0a0;
            color: #000;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Chess Board Styles */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vmin;
            height: 90vmin;
            max-width: 500px;
            max-height: 500px;
            border: 2px solid #0f0;
            margin: 10px auto;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
        }

        .light-square {
            background-color: #c0c0c0;
            color: #000;
        }

        .dark-square {
            background-color: #808080;
            color: #fff;
        }

        .selected {
            background-color: #0a0 !important;
        }

        .valid-move {
            position: relative;
        }

        .valid-move::after {
            content: "";
            position: absolute;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background-color: rgba(0, 255, 0, 0.5);
        }

        .capture-move::after {
            content: "";
            position: absolute;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            border: 2px solid rgba(255, 0, 0, 0.7);
            background-color: transparent;
        }

        .piece {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
        }

        .white-piece {
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        .black-piece {
            color: #000;
            text-shadow: 1px 1px 2px #fff;
        }

        .fire-piece { border: 1px solid #f00; }
        .water-piece { border: 1px solid #00f; }
        .earth-piece { border: 1px solid #8b4513; }
        .air-piece { border: 1px solid #87ceeb; }

        .piece-info {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #0f0;
            width: 90%;
            max-width: 500px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 500px;
            margin: 10px 0;
        }

        .player-info {
            border: 1px solid #0f0;
            padding: 5px 10px;
            text-align: center;
        }

        .active-player {
            background-color: rgba(0, 255, 0, 0.2);
        }

        .mana-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            margin: 5px 0;
        }

        .mana-fill {
            height: 100%;
            background-color: #00f;
        }

        .elemental-bonus {
            color: #ff0;
            font-weight: bold;
        }

        .spell-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            width: 90%;
            max-width: 500px;
            margin: 10px 0;
        }

        .spell {
            width: 48%;
            margin-bottom: 5px;
            min-width: 120px;
        }

        .log {
            height: 100px;
            overflow-y: auto;
            border: 1px solid #0f0;
            padding: 5px;
            margin-top: 10px;
            font-size: 12px;
            flex-shrink: 0;
            width: 90%;
            max-width: 500px;
        }

        .victory-screen, .defeat-screen {
            text-align: center;
            padding: 10px;
        }

        .victory-message, .defeat-message {
            font-size: 16px;
            margin: 10px 0;
            color: #ff0;
        }

        .defeat-message {
            color: #f00;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .pulsing {
            animation: pulse 1s infinite;
        }

        @media (max-height: 700px) {
            .header {
                padding: 5px;
            }
            
            .header pre {
                font-size: 10px;
                line-height: 1;
            }
            
            .header h2 {
                font-size: 16px;
            }
            
            .content {
                padding: 5px;
            }
            
            button {
                padding: 10px 6px;
                min-height: 40px;
                font-size: 13px;
            }
            
            .footer {
                padding: 5px;
            }
            
            .chess-board {
                width: 85vmin;
                height: 85vmin;
            }
        }

        @media (max-height: 500px) {
            .header pre {
                display: none;
            }
            
            .header {
                padding: 3px;
            }
            
            .content {
                padding: 3px;
            }
            
            button {
                padding: 8px 4px;
                min-height: 36px;
                font-size: 12px;
            }
            
            .chess-board {
                width: 80vmin;
                height: 80vmin;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Main Menu Screen -->
        <div id="main-menu" class="screen active">
            <div class="header">
                <pre>
   _____ _     _ _     _ _____ ______ _______ ______ 
  | ____| |   | | |   | | ____|  ____|__   __|  ____|
  | |__ | |   | | |   | | |__ | |__     | |  | |__   
  |  __|| |   | | |   | |  __||  __|    | |  |  __|  
  | |___| |___| | |___| | |___| |____   | |  | |____ 
  |_____|_____|_|_____|_|_____|______|  |_|  |______|
                </pre>
                <h2>ELEMENTAL CHESS BATTLE</h2>
            </div>
            <div class="content">
                <div style="display: flex; flex-direction: column; width: 90%; max-width: 400px;">
                    <button id="new-chess-game">NEW GAME</button>
                    <button id="chess-tutorial">HOW TO PLAY</button>
                    <button id="chess-ai-settings">AI DIFFICULTY</button>
                </div>
            </div>
            <div class="footer">
                <p>Combine chess strategy with elemental magic!</p>
            </div>
        </div>

        <!-- Chess Game Screen -->
        <div id="chess-game-screen" class="screen">
            <div class="header">
                <h2>ELEMENTAL CHESS BATTLE</h2>
                <div id="turn-indicator">White's Turn</div>
            </div>
            <div class="content">
                <div class="game-info">
                    <div class="player-info" id="white-player">
                        <div>WHITE</div>
                        <div>Mana: <span id="white-mana">10</span>/10</div>
                        <div class="mana-bar">
                            <div class="mana-fill" id="white-mana-fill" style="width: 100%;"></div>
                        </div>
                    </div>
                    <div class="player-info" id="black-player">
                        <div>BLACK</div>
                        <div>Mana: <span id="black-mana">10</span>/10</div>
                        <div class="mana-bar">
                            <div class="mana-fill" id="black-mana-fill" style="width: 100%;"></div>
                        </div>
                    </div>
                </div>
                
                <div class="chess-board" id="chess-board">
                    <!-- Chess board will be generated by JavaScript -->
                </div>
                
                <div class="piece-info" id="piece-info">
                    Select a piece to see its abilities
                </div>
                
                <div class="spell-list" id="spell-list">
                    <!-- Spells will be dynamically added here -->
                </div>
                
                <div class="log" id="chess-log">
                    <div>Elemental Chess Battle begins!</div>
                </div>
            </div>
            <div class="footer">
                <button id="resign-chess">RESIGN</button>
                <button id="main-menu-from-chess">MAIN MENU</button>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="chess-victory-screen" class="screen">
            <div class="header">
                <h2>VICTORY!</h2>
            </div>
            <div class="content">
                <div class="victory-screen">
                    <pre>
   __   _____  _  _  ____  __    ____ 
  /__\ (  _  )( \( )( ___)(  )  ( ___)
 /(__)\ )(_)(  )  (  )__)  )(__  )__) 
(__)(__)(_____)(_)\_)(____)(____)(____)
                    </pre>
                    <div class="victory-message" id="chess-victory-message">
                        You have checkmated your opponent!
                    </div>
                </div>
            </div>
            <div class="footer">
                <button id="play-again">PLAY AGAIN</button>
                <button id="main-menu-after-victory">MAIN MENU</button>
            </div>
        </div>

        <!-- Tutorial Screen -->
        <div id="tutorial-screen" class="screen">
            <div class="header">
                <h2>HOW TO PLAY</h2>
            </div>
            <div class="content">
                <div style="width: 90%; max-width: 600px; overflow-y: auto;">
                    <h3>Elemental Chess Battle</h3>
                    <p>This game combines traditional chess with elemental magic:</p>
                    
                    <h4>Basic Rules:</h4>
                    <ul>
                        <li>Standard chess rules apply for piece movement</li>
                        <li>Each piece has an elemental affinity (Fire, Water, Earth, Air)</li>
                        <li>Elements have strengths and weaknesses against each other</li>
                        <li>Gain mana each turn to cast powerful spells</li>
                    </ul>
                    
                    <h4>Elemental System:</h4>
                    <ul>
                        <li><strong>Fire</strong> beats Air, weak to Water</li>
                        <li><strong>Water</strong> beats Fire, weak to Earth</li>
                        <li><strong>Earth</strong> beats Water, weak to Air</li>
                        <li><strong>Air</strong> beats Earth, weak to Fire</li>
                    </ul>
                    <p>When attacking with elemental advantage, deal +2 damage. With disadvantage, deal -1 damage.</p>
                    
                    <h4>Spell System:</h4>
                    <p>Each turn, you gain 1 mana (up to 10 maximum). Spend mana to cast spells:</p>
                    <ul>
                        <li><strong>Fireball (3 mana)</strong>: Deal 3 damage to any enemy piece</li>
                        <li><strong>Healing Wave (4 mana)</strong>: Restore 3 health to any friendly piece</li>
                        <li><strong>Earth Shield (2 mana)</strong>: Give a piece +2 defense for 2 turns</li>
                        <li><strong>Wind Dash (3 mana)</strong>: Move a piece again this turn</li>
                    </ul>
                    
                    <h4>Piece Health:</h4>
                    <p>Pieces have health instead of being instantly captured:</p>
                    <ul>
                        <li>Pawn: 2 HP</li>
                        <li>Knight/Bishop: 3 HP</li>
                        <li>Rook: 4 HP</li>
                        <li>Queen: 5 HP</li>
                        <li>King: 6 HP</li>
                    </ul>
                    <p>When a piece's health reaches 0, it is captured.</p>
                </div>
            </div>
            <div class="footer">
                <button id="back-from-tutorial">BACK</button>
            </div>
        </div>
    </div>

    <script>
    // Game state
    const gameState = {
        board: [],
        currentPlayer: 'white',
        selectedPiece: null,
        validMoves: [],
        whiteMana: 10,
        blackMana: 10,
        gameOver: false,
        aiDifficulty: 'medium', // easy, medium, hard
        pieces: {
            white: [],
            black: []
        },
        log: ["Elemental Chess Battle begins!"]
    };

    // Elemental strengths and weaknesses
    const elementalAdvantages = {
        fire: { strongVs: 'air', weakVs: 'water' },
        water: { strongVs: 'fire', weakVs: 'earth' },
        earth: { strongVs: 'water', weakVs: 'air' },
        air: { strongVs: 'earth', weakVs: 'fire' }
    };

    // Piece definitions with health and elements
    const pieceDefinitions = {
        pawn: { health: 2, element: 'earth', symbol: '♟', value: 1 },
        knight: { health: 3, element: 'air', symbol: '♞', value: 3 },
        bishop: { health: 3, element: 'water', symbol: '♝', value: 3 },
        rook: { health: 4, element: 'fire', symbol: '♜', value: 5 },
        queen: { health: 5, element: null, symbol: '♛', value: 9 },
        king: { health: 6, element: null, symbol: '♚', value: 100 }
    };

    // Spells available
    const spells = [
        { name: "Fireball", cost: 3, description: "Deal 3 damage to any enemy piece" },
        { name: "Healing Wave", cost: 4, description: "Restore 3 health to any friendly piece" },
        { name: "Earth Shield", cost: 2, description: "Give a piece +2 defense for 2 turns" },
        { name: "Wind Dash", cost: 3, description: "Move a piece again this turn" }
    ];

    // Initialize the chess board
    function initializeBoard() {
        gameState.board = [];
        gameState.pieces.white = [];
        gameState.pieces.black = [];
        
        // Create empty board
        for (let row = 0; row < 8; row++) {
            gameState.board[row] = [];
            for (let col = 0; col < 8; col++) {
                gameState.board[row][col] = null;
            }
        }
        
        // Place pawns
        for (let col = 0; col < 8; col++) {
            placePiece(1, col, 'pawn', 'black');
            placePiece(6, col, 'pawn', 'white');
        }
        
        // Place other pieces
        const backRowPieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for (let col = 0; col < 8; col++) {
            placePiece(0, col, backRowPieces[col], 'black');
            placePiece(7, col, backRowPieces[col], 'white');
        }
        
        // Set initial mana
        gameState.whiteMana = 10;
        gameState.blackMana = 10;
        
        // Reset game state
        gameState.currentPlayer = 'white';
        gameState.selectedPiece = null;
        gameState.validMoves = [];
        gameState.gameOver = false;
        gameState.log = ["Elemental Chess Battle begins!"];
        
        updateUI();
    }

    // Place a piece on the board
    function placePiece(row, col, type, color) {
        const piece = {
            type: type,
            color: color,
            health: pieceDefinitions[type].health,
            maxHealth: pieceDefinitions[type].health,
            element: pieceDefinitions[type].element,
            symbol: pieceDefinitions[type].symbol,
            value: pieceDefinitions[type].value,
            hasMoved: false,
            statusEffects: []
        };
        
        gameState.board[row][col] = piece;
        
        if (color === 'white') {
            gameState.pieces.white.push(piece);
        } else {
            gameState.pieces.black.push(piece);
        }
    }

    // Render the chess board
    function renderBoard() {
        const boardElement = document.getElementById('chess-board');
        boardElement.innerHTML = '';
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `chess-square ${(row + col) % 2 === 0 ? 'light-square' : 'dark-square'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                
                // Check if this square is a valid move
                const isSelected = gameState.selectedPiece && 
                                  gameState.selectedPiece.row === row && 
                                  gameState.selectedPiece.col === col;
                
                const isValidMove = gameState.validMoves.some(move => 
                    move.row === row && move.col === col
                );
                
                const isCaptureMove = gameState.validMoves.some(move => 
                    move.row === row && move.col === col && move.capture
                );
                
                if (isSelected) {
                    square.classList.add('selected');
                }
                
                if (isValidMove && !isSelected) {
                    square.classList.add('valid-move');
                }
                
                if (isCaptureMove) {
                    square.classList.add('capture-move');
                }
                
                // Add piece if present
                const piece = gameState.board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `piece ${piece.color}-piece ${piece.element ? piece.element + '-piece' : ''}`;
                    pieceElement.textContent = piece.symbol;
                    
                    // Show health for damaged pieces
                    if (piece.health < piece.maxHealth) {
                        pieceElement.title = `${piece.type} (${piece.health}/${piece.maxHealth} HP)`;
                    }
                    
                    square.appendChild(pieceElement);
                }
                
                square.addEventListener('click', () => handleSquareClick(row, col));
                boardElement.appendChild(square);
            }
        }
    }

    // Handle square click
    function handleSquareClick(row, col) {
        if (gameState.gameOver) return;
        
        const piece = gameState.board[row][col];
        
        // If we have a selected piece, try to move it
        if (gameState.selectedPiece) {
            const isValidMove = gameState.validMoves.some(move => 
                move.row === row && move.col === col
            );
            
            if (isValidMove) {
                movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                
                // Check for game over
                if (!gameState.gameOver) {
                    // Switch player and add mana
                    gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    if (gameState.currentPlayer === 'white') {
                        gameState.whiteMana = Math.min(10, gameState.whiteMana + 1);
                    } else {
                        gameState.blackMana = Math.min(10, gameState.blackMana + 1);
                    }
                    
                    // AI move if it's black's turn
                    if (gameState.currentPlayer === 'black' && !gameState.gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                }
                
                updateUI();
                return;
            }
        }
        
        // If clicking on a piece of the current player, select it
        if (piece && piece.color === gameState.currentPlayer) {
            gameState.selectedPiece = { row, col, piece };
            gameState.validMoves = calculateValidMoves(row, col);
            updateUI();
        } else {
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            updateUI();
        }
    }

    // Calculate valid moves for a piece
    function calculateValidMoves(row, col) {
        const piece = gameState.board[row][col];
        if (!piece) return [];
        
        const moves = [];
        
        switch (piece.type) {
            case 'pawn':
                calculatePawnMoves(row, col, piece, moves);
                break;
            case 'knight':
                calculateKnightMoves(row, col, piece, moves);
                break;
            case 'bishop':
                calculateBishopMoves(row, col, piece, moves);
                break;
            case 'rook':
                calculateRookMoves(row, col, piece, moves);
                break;
            case 'queen':
                calculateQueenMoves(row, col, piece, moves);
                break;
            case 'king':
                calculateKingMoves(row, col, piece, moves);
                break;
        }
        
        return moves;
    }

    // Calculate pawn moves
    function calculatePawnMoves(row, col, piece, moves) {
        const direction = piece.color === 'white' ? -1 : 1;
        
        // Forward move
        if (isInBoard(row + direction, col) && !gameState.board[row + direction][col]) {
            moves.push({ row: row + direction, col });
            
            // Double move from starting position
            if ((piece.color === 'white' && row === 6) || (piece.color === 'black' && row === 1)) {
                if (!gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
        }
        
        // Captures
        for (let dcol of [-1, 1]) {
            const newRow = row + direction;
            const newCol = col + dcol;
            
            if (isInBoard(newRow, newCol)) {
                const target = gameState.board[newRow][newCol];
                if (target && target.color !== piece.color) {
                    moves.push({ row: newRow, col: newCol, capture: true });
                }
            }
        }
    }

    // Calculate knight moves
    function calculateKnightMoves(row, col, piece, moves) {
        const knightMoves = [
            [2, 1], [2, -1], [-2, 1], [-2, -1],
            [1, 2], [1, -2], [-1, 2], [-1, -2]
        ];
        
        for (let [dr, dc] of knightMoves) {
            const newRow = row + dr;
            const newCol = col + dc;
            
            if (isInBoard(newRow, newCol)) {
                const target = gameState.board[newRow][newCol];
                if (!target || target.color !== piece.color) {
                    moves.push({ 
                        row: newRow, 
                        col: newCol, 
                        capture: !!target 
                    });
                }
            }
        }
    }

    // Calculate bishop moves
    function calculateBishopMoves(row, col, piece, moves) {
        const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        calculateSlidingMoves(row, col, piece, moves, directions);
    }

    // Calculate rook moves
    function calculateRookMoves(row, col, piece, moves) {
        const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
        calculateSlidingMoves(row, col, piece, moves, directions);
    }

    // Calculate queen moves
    function calculateQueenMoves(row, col, piece, moves) {
        const directions = [
            [1, 0], [-1, 0], [0, 1], [0, -1],
            [1, 1], [1, -1], [-1, 1], [-1, -1]
        ];
        calculateSlidingMoves(row, col, piece, moves, directions);
    }

    // Calculate king moves
    function calculateKingMoves(row, col, piece, moves) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isInBoard(newRow, newCol)) {
                    const target = gameState.board[newRow][newCol];
                    if (!target || target.color !== piece.color) {
                        moves.push({ 
                            row: newRow, 
                            col: newCol, 
                            capture: !!target 
                        });
                    }
                }
            }
        }
    }

    // Helper function for sliding pieces (bishop, rook, queen)
    function calculateSlidingMoves(row, col, piece, moves, directions) {
        for (let [dr, dc] of directions) {
            let newRow = row + dr;
            let newCol = col + dc;
            
            while (isInBoard(newRow, newCol)) {
                const target = gameState.board[newRow][newCol];
                
                if (!target) {
                    moves.push({ row: newRow, col: newCol });
                } else {
                    if (target.color !== piece.color) {
                        moves.push({ row: newRow, col: newCol, capture: true });
                    }
                    break;
                }
                
                newRow += dr;
                newCol += dc;
            }
        }
    }

    // Move a piece
    function movePiece(fromRow, fromCol, toRow, toCol) {
        const piece = gameState.board[fromRow][fromCol];
        const target = gameState.board[toRow][toCol];
        
        // Move the piece
        gameState.board[toRow][toCol] = piece;
        gameState.board[fromRow][fromCol] = null;
        piece.hasMoved = true;
        
        // Handle capture
        if (target) {
            // Calculate damage with elemental bonuses
            let damage = 1;
            if (piece.element && target.element) {
                if (elementalAdvantages[piece.element].strongVs === target.element) {
                    damage = 2; // Elemental advantage
                    addToLog(`${piece.color} ${piece.type} deals +1 damage with elemental advantage!`);
                } else if (elementalAdvantages[piece.element].weakVs === target.element) {
                    damage = 0; // Elemental disadvantage
                    addToLog(`${piece.color} ${piece.type} deals -1 damage with elemental disadvantage!`);
                }
            }
            
            // Apply damage
            target.health -= damage;
            
            // Check if target is destroyed
            if (target.health <= 0) {
                addToLog(`${piece.color} ${piece.type} captures ${target.color} ${target.type}!`);
                
                // Remove from pieces array
                const pieceArray = target.color === 'white' ? gameState.pieces.white : gameState.pieces.black;
                const index = pieceArray.indexOf(target);
                if (index > -1) {
                    pieceArray.splice(index, 1);
                }
                
                // Check if king was captured
                if (target.type === 'king') {
                    gameState.gameOver = true;
                    showVictoryScreen(piece.color);
                    return;
                }
            } else {
                addToLog(`${piece.color} ${piece.type} attacks ${target.color} ${target.type} (${target.health}/${target.maxHealth} HP)`);
            }
        } else {
            addToLog(`${piece.color} ${piece.type} moves to ${String.fromCharCode(97 + toCol)}${8 - toRow}`);
        }
        
        // Check for pawn promotion
        if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
            promotePawn(toRow, toCol);
        }
    }

    // Promote a pawn that reached the back rank
    function promotePawn(row, col) {
        const piece = gameState.board[row][col];
        piece.type = 'queen';
        piece.health = 5;
        piece.maxHealth = 5;
        piece.symbol = '♛';
        piece.value = 9;
        addToLog(`${piece.color} pawn promotes to Queen!`);
    }

    // Check if coordinates are within the board
    function isInBoard(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
    }

    // Update the UI
    function updateUI() {
        renderBoard();
        
        // Update turn indicator
        document.getElementById('turn-indicator').textContent = 
            `${gameState.currentPlayer.charAt(0).toUpperCase() + gameState.currentPlayer.slice(1)}'s Turn`;
        
        // Update mana displays
        document.getElementById('white-mana').textContent = gameState.whiteMana;
        document.getElementById('black-mana').textContent = gameState.blackMana;
        document.getElementById('white-mana-fill').style.width = `${gameState.whiteMana * 10}%`;
        document.getElementById('black-mana-fill').style.width = `${gameState.blackMana * 10}%`;
        
        // Update player info highlights
        document.getElementById('white-player').classList.toggle('active', gameState.currentPlayer === 'white');
        document.getElementById('black-player').classList.toggle('active', gameState.currentPlayer === 'black');
        
        // Update piece info
        const pieceInfo = document.getElementById('piece-info');
        if (gameState.selectedPiece) {
            const piece = gameState.selectedPiece.piece;
            let info = `${piece.color} ${piece.type}`;
            
            if (piece.element) {
                info += ` (${piece.element})`;
            }
            
            info += ` - ${piece.health}/${piece.maxHealth} HP`;
            
            if (piece.element) {
                const advantage = elementalAdvantages[piece.element];
                info += `<br>Strong vs: ${advantage.strongVs}, Weak vs: ${advantage.weakVs}`;
            }
            
            pieceInfo.innerHTML = info;
        } else {
            pieceInfo.textContent = "Select a piece to see its abilities";
        }
        
        // Update spell list
        const spellList = document.getElementById('spell-list');
        spellList.innerHTML = '';
        
        const currentMana = gameState.currentPlayer === 'white' ? gameState.whiteMana : gameState.blackMana;
        
        spells.forEach(spell => {
            const button = document.createElement('button');
            button.className = 'spell';
            button.textContent = `${spell.name} (${spell.cost} mana)`;
            button.disabled = currentMana < spell.cost || !gameState.selectedPiece;
            
            button.addEventListener('click', () => {
                castSpell(spell);
            });
            
            spellList.appendChild(button);
        });
        
        // Update log
        const logElement = document.getElementById('chess-log');
        logElement.innerHTML = '';
        gameState.log.forEach(entry => {
            const div = document.createElement('div');
            div.innerHTML = entry;
            logElement.appendChild(div);
        });
        logElement.scrollTop = logElement.scrollHeight;
    }

    // Cast a spell
    function castSpell(spell) {
        if (!gameState.selectedPiece) return;
        
        const currentMana = gameState.currentPlayer === 'white' ? gameState.whiteMana : gameState.blackMana;
        if (currentMana < spell.cost) return;
        
        // Deduct mana
        if (gameState.currentPlayer === 'white') {
            gameState.whiteMana -= spell.cost;
        } else {
            gameState.blackMana -= spell.cost;
        }
        
        // Apply spell effect
        switch (spell.name) {
            case "Fireball":
                // In a full implementation, this would allow selecting an enemy piece
                addToLog(`${gameState.currentPlayer} casts ${spell.name}! (Not fully implemented)`);
                break;
            case "Healing Wave":
                const piece = gameState.selectedPiece.piece;
                piece.health = Math.min(piece.maxHealth, piece.health + 3);
                addToLog(`${gameState.currentPlayer} casts ${spell.name} on ${piece.type}!`);
                break;
            case "Earth Shield":
                addToLog(`${gameState.currentPlayer} casts ${spell.name}! (Not fully implemented)`);
                break;
            case "Wind Dash":
                addToLog(`${gameState.currentPlayer} casts ${spell.name}! (Not fully implemented)`);
                break;
        }
        
        updateUI();
    }

    // Add message to game log
    function addToLog(message) {
        gameState.log.push(message);
        if (gameState.log.length > 10) {
            gameState.log.shift();
        }
    }

    // Show victory screen
    function showVictoryScreen(winner) {
        document.getElementById('chess-victory-message').textContent = 
            `${winner.charAt(0).toUpperCase() + winner.slice(1)} wins by checkmate!`;
        showScreen('chess-victory-screen');
    }

    // AI move logic
    function makeAIMove() {
        if (gameState.gameOver) return;
        
        // Simple AI: evaluate all possible moves and pick the best one
        let bestMove = null;
        let bestScore = -Infinity;
        
        // Get all black pieces
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const piece = gameState.board[row][col];
                if (piece && piece.color === 'black') {
                    const moves = calculateValidMoves(row, col);
                    
                    for (let move of moves) {
                        // Evaluate this move
                        const score = evaluateMove(row, col, move.row, move.col);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = {
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col
                            };
                        }
                    }
                }
            }
        }
        
        // Make the best move
        if (bestMove) {
            movePiece(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
            
            // Switch back to white player
            gameState.currentPlayer = 'white';
            gameState.whiteMana = Math.min(10, gameState.whiteMana + 1);
            
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            
            updateUI();
        }
    }

    // Evaluate a move for the AI
    function evaluateMove(fromRow, fromCol, toRow, toCol) {
        let score = 0;
        const piece = gameState.board[fromRow][fromCol];
        const target = gameState.board[toRow][toCol];
        
        // Prefer captures
        if (target) {
            score += target.value;
            
            // Elemental advantage bonus
            if (piece.element && target.element) {
                if (elementalAdvantages[piece.element].strongVs === target.element) {
                    score += 2;
                } else if (elementalAdvantages[piece.element].weakVs === target.element) {
                    score -= 1;
                }
            }
        }
        
        // Prefer moving toward the center
        const centerBonus = (3.5 - Math.abs(toRow - 3.5)) + (3.5 - Math.abs(toCol - 3.5));
        score += centerBonus * 0.1;
        
        // Prefer developing pieces (moving them from starting position)
        if (!piece.hasMoved) {
            score += 0.5;
        }
        
        // Avoid putting pieces in danger
        // This is a simplified version - a full implementation would simulate the move
        // and evaluate the resulting position
        
        return score;
    }

    // Screen navigation
    function showScreen(name) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(name).classList.add('active');
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
        // Main menu buttons
        document.getElementById('new-chess-game').addEventListener('click', () => {
            initializeBoard();
            showScreen('chess-game-screen');
        });
        
        document.getElementById('chess-tutorial').addEventListener('click', () => {
            showScreen('tutorial-screen');
        });
        
        document.getElementById('chess-ai-settings').addEventListener('click', () => {
            // Cycle through AI difficulties
            const difficulties = ['easy', 'medium', 'hard'];
            const currentIndex = difficulties.indexOf(gameState.aiDifficulty);
            gameState.aiDifficulty = difficulties[(currentIndex + 1) % difficulties.length];
            addToLog(`AI difficulty set to: ${gameState.aiDifficulty}`);
        });
        
        // Chess game buttons
        document.getElementById('resign-chess').addEventListener('click', () => {
            const winner = gameState.currentPlayer === 'white' ? 'black' : 'white';
            showVictoryScreen(winner);
        });
        
        document.getElementById('main-menu-from-chess').addEventListener('click', () => {
            showScreen('main-menu');
        });
        
        // Tutorial screen button
        document.getElementById('back-from-tutorial').addEventListener('click', () => {
            showScreen('main-menu');
        });
        
        // Victory screen buttons
        document.getElementById('play-again').addEventListener('click', () => {
            initializeBoard();
            showScreen('chess-game-screen');
        });
        
        document.getElementById('main-menu-after-victory').addEventListener('click', () => {
            showScreen('main-menu');
        });
        
        // Initialize the game
        initializeBoard();
    });
    </script>
</body>
</html>
