<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tower of Terror (1984) - Nightfalls Games</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #0f0;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #0f0;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            align-items: center;
        }
        #prompt {
            margin-right: 8px;
            white-space: nowrap;
        }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid #0f0;
            color: #0f0;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 4px 0;
        }
        #status {
            border-top: 1px solid #0f0;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        .command {
            color: #ff0;
        }
        .error {
            color: #f00;
        }
        .item {
            color: #0ff;
        }
        .enemy {
            color: #f0f;
        }
        .npc {
            color: #ffa500;
        }
        .success {
            color: #0f0;
        }
        .quest {
            color: #ffff00;
        }
        .loot {
            color: #ff69b4;
        }
        .system {
            color: #888;
        }
        .damage {
            color: #ff4500;
        }
        .heal {
            color: #32cd32;
        }
        .skill {
            color: #00ffff;
        }
        .puzzle {
            color: #ff8c00;
        }
        .examine {
            color: #add8e6;
        }
        .dialogue {
            color: #ffb6c1;
        }
        .interact {
            color: #90ee90;
        }
        .response {
            color: #dda0dd;
            cursor: pointer;
            margin-left: 10px;
        }
        .response:hover {
            text-decoration: underline;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        .quick-command {
            display: inline-block;
            background: #222;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 6px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        #quick-commands {
            margin-top: 8px;
            text-align: center;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        #save-load-controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: #000;
            border: 1px solid #0f0;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        .save-load-btn {
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 4px;
            margin: 2px;
            cursor: pointer;
            font-size: 8px;
        }
        .dialogue-window {
            border: 2px solid #ffa500;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.8);
        }
        .response-option {
            margin: 5px 0;
            padding: 5px;
            border-left: 2px solid #ffa500;
            cursor: pointer;
        }
        .response-option:hover {
            background: rgba(255, 165, 0, 0.1);
        }
        .examine-level {
            margin-left: 10px;
            color: #add8e6;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="save-load-controls">
        <button class="save-load-btn" onclick="saveGame()">SAVE</button>
        <button class="save-load-btn" onclick="loadGame()">LOAD</button>
        <button class="save-load-btn" onclick="quickSave()">QSAVE</button>
        <button class="save-load-btn" onclick="quickLoad()">QLOAD</button>
    </div>
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    <div id="header">
        <h1>TOWER OF TERROR</h1>
        <div>1984 â€¢ NIGHTFALLS GAMES</div>
    </div>
    <div id="game-container">
        <div id="output">Welcome to the Tower of Terror! Type 'help' for commands.</div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="quick-commands">
            <span class="quick-command" onclick="quickCommand('n')">N</span>
            <span class="quick-command" onclick="quickCommand('s')">S</span>
            <span class="quick-command" onclick="quickCommand('e')">E</span>
            <span class="quick-command" onclick="quickCommand('w')">W</span>
            <span class="quick-command" onclick="quickCommand('look')">LOOK</span>
            <span class="quick-command" onclick="quickCommand('attack')">ATTACK</span>
            <span class="quick-command" onclick="quickCommand('inventory')">INV</span>
            <span class="quick-command" onclick="quickCommand('skills')">SKILLS</span>
        </div>
        <div id="status"></div>
    </div>

    <script>
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.3;
                    this.sfxGain.gain.value = 0.5;
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                this.stopBackground();
                this.currentBgName = musicName;
                
                switch(musicName) {
                    case 'theme': this.playThemeTune(loop); break;
                    case 'dungeon': this.playDungeonMusic(loop); break;
                    case 'eerie': this.playEerieMusic(loop); break;
                    case 'boss': this.playBossMusic(loop); break;
                    case 'victory': this.playVictoryMusic(loop); break;
                    default: this.playThemeTune(loop);
                }
            }
            
            playThemeTune(loop) {
                const melody = [
                    {note: 440, duration: 0.3}, {note: 493.88, duration: 0.3},
                    {note: 523.25, duration: 0.3}, {note: 587.33, duration: 0.3},
                    {note: 659.25, duration: 0.6}, {note: 587.33, duration: 0.3},
                    {note: 523.25, duration: 0.3}, {note: 493.88, duration: 0.3},
                    {note: 440, duration: 0.6}
                ];
                this.playMelody(melody, 'sawtooth', loop, 0.2);
            }
            
            playDungeonMusic(loop) {
                const melody = [
                    {note: 130.81, duration: 0.5}, {note: 164.81, duration: 0.5},
                    {note: 196.00, duration: 0.5}, {note: 146.83, duration: 0.5},
                    {note: 174.61, duration: 1.0}
                ];
                this.playMelody(melody, 'square', loop, 0.15);
            }
            
            playEerieMusic(loop) {
                const melody = [
                    {note: 220, duration: 1.0}, {note: 207.65, duration: 0.5},
                    {note: 196.00, duration: 1.0}, {note: 184.99, duration: 0.5},
                    {note: 174.61, duration: 1.0}
                ];
                this.playMelody(melody, 'triangle', loop, 0.1);
            }
            
            playBossMusic(loop) {
                const melody = [
                    {note: 261.63, duration: 0.2}, {note: 329.63, duration: 0.2},
                    {note: 392.00, duration: 0.2}, {note: 523.25, duration: 0.4},
                    {note: 392.00, duration: 0.2}, {note: 329.63, duration: 0.2},
                    {note: 261.63, duration: 0.4}
                ];
                this.playMelody(melody, 'sawtooth', loop, 0.25);
            }
            
            playVictoryMusic(loop) {
                const melody = [
                    {note: 523.25, duration: 0.2}, {note: 659.25, duration: 0.2},
                    {note: 783.99, duration: 0.2}, {note: 1046.50, duration: 0.5},
                    {note: 783.99, duration: 0.2}, {note: 1046.50, duration: 0.5},
                    {note: 1318.51, duration: 1.0}
                ];
                this.playMelody(melody, 'sine', loop, 0.3);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                let currentTime = now;
                melody.forEach((note) => {
                    source.frequency.setValueAtTime(note.note, currentTime);
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    currentTime += note.duration;
                });
                
                if (loop) {
                    source.start(now);
                    source.stop(now + currentTime - now);
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try { this.currentBgSource.stop(); } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                const sounds = {
                    'click': { freq: 800, type: 'sine', duration: 0.1 },
                    'notification': { freq: 400, type: 'sine', duration: 0.3 },
                    'levelup': { freq: 523.25, type: 'sine', duration: 0.2 },
                    'attack': { freq: 300, type: 'sawtooth', duration: 0.2 },
                    'enemyHit': { freq: 150, type: 'square', duration: 0.3 },
                    'playerHit': { freq: 200, type: 'square', duration: 0.2 },
                    'victory': { freq: 523.25, type: 'sine', duration: 0.5 },
                    'defeat': { freq: 220, type: 'sine', duration: 0.5 },
                    'pickup': { freq: 1000, type: 'sine', duration: 0.1 },
                    'equip': { freq: 600, type: 'sawtooth', duration: 0.2 },
                    'door': { freq: 200, type: 'sine', duration: 0.5 },
                    'step': { freq: 400, type: 'sine', duration: 0.1 },
                    'spell': { freq: 800, type: 'sine', duration: 0.3 },
                    'heal': { freq: 600, type: 'sine', duration: 0.3 },
                    'buff': { freq: 500, type: 'triangle', duration: 0.2 },
                    'puzzle': { freq: 600, type: 'sine', duration: 0.4 },
                    'examine': { freq: 700, type: 'triangle', duration: 0.2 }
                };
                
                const sound = sounds[soundName];
                if (!sound) return;
                
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = sound.type;
                oscillator.frequency.setValueAtTime(sound.freq, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + sound.duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + sound.duration);
            }
            
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== SIMPLIFIED OBJECT SYSTEM ====================
        class SimpleObject {
            constructor(name, baseDescription) {
                this.name = name;
                this.baseDescription = baseDescription;
                this.examinationLevels = [];
                this.examinedCount = 0;
                this.hiddenItem = null; // Item that can be found by searching
                this.useEffect = null; // Function to call when "use" is called on this object
                
                // Add basic examination level
                this.addExaminationLevel(0, baseDescription);
            }
            
            addExaminationLevel(level, description) {
                this.examinationLevels[level] = description;
            }
            
            setHiddenItem(itemName) {
                this.hiddenItem = itemName;
            }
            
            setUseEffect(effectFunction) {
                this.useEffect = effectFunction;
            }
            
            examine() {
                this.examinedCount++;
                const level = Math.min(this.examinationLevels.length - 1, this.examinedCount - 1);
                
                let result = `You examine the ${this.name}:\n`;
                result += this.examinationLevels[level];
                
                // Add hints about hidden items
                if (this.hiddenItem && this.examinedCount >= 2) {
                    const item = items[this.hiddenItem];
                    if (item) {
                        result += `\nYou notice something that might be ${item.desc.toLowerCase()}`;
                    }
                }
                
                return result;
            }
            
            search(room) {
    if (!this.hiddenItem) {
        return `You search the ${this.name} but find nothing special.`;
    }
    
    // Check if item is already in room OR player has it
    const itemAlreadyInRoom = room.items.includes(this.hiddenItem);
    const playerAlreadyHas = player.inventory.includes(this.hiddenItem);
    
    if (itemAlreadyInRoom || playerAlreadyHas) {
        return `You already found everything in the ${this.name}.`;
    }
    
    room.items.push(this.hiddenItem);
    const displayName = displayNames[this.hiddenItem] || this.hiddenItem;
    return `You search the ${this.name} and find ${displayName}!`;
}
            
            
            use(room, player) {
                if (this.useEffect) {
                    return this.useEffect(room, player);
                }
                return `You're not sure how to use the ${this.name}.`;
            }
            
            reset() {
                this.examinedCount = 0;
            }
            
            toJSON() {
                return {
                    name: this.name,
                    baseDescription: this.baseDescription,
                    examinationLevels: this.examinationLevels,
                    examinedCount: this.examinedCount,
                    hiddenItem: this.hiddenItem
                };
            }
            
            static fromJSON(data) {
                const obj = new SimpleObject(data.name, data.baseDescription);
                obj.examinationLevels = data.examinationLevels || [];
                obj.examinedCount = data.examinedCount || 0;
                obj.hiddenItem = data.hiddenItem || null;
                return obj;
            }
        }

        // ==================== DIALOGUE TREE SYSTEM ====================
        class DialogueTree {
            constructor(npcId, name) {
                this.npcId = npcId;
                this.npcName = name;
                this.currentNode = 'initial';
                this.nodes = {};
                this.initializeDialogue();
            }
            
            initializeDialogue() {
                const templates = {
                    wizard: {
                        initial: {
                            text: "Ah, another brave soul enters the tower. I am Archmage Valerius. What brings you here?",
                            responses: [
                                { text: "I seek the Ancient Tome you mentioned.", action: 'start_quest', next: 'tome_quest' },
                                { text: "Tell me about this tower.", next: 'tower_info' },
                                { text: "Can you teach me magic?", next: 'magic_lessons' },
                                { text: "Goodbye.", action: 'end_conversation' }
                            ]
                        },
                        tome_quest: {
                            text: "The Ancient Tome contains forbidden knowledge. It lies in the Royal Library. Bring it to me and I'll reward you.",
                            responses: [
                                { text: "I accept your quest.", action: 'accept_quest', next: 'quest_accepted' },
                                { text: "What's in it for me?", next: 'rewards' },
                                { text: "Never mind.", next: 'initial' }
                            ]
                        },
                        quest_accepted: {
                            text: "Excellent! Return when you have the tome.",
                            responses: [
                                { text: "I have the tome!", action: 'check_quest_item', item: 'tome', next: 'quest_complete' },
                                { text: "I'm still looking.", next: 'initial' }
                            ]
                        },
                        quest_complete: {
                            text: "Marvelous! Here is your reward - the Fire Staff. Use it wisely.",
                            action: 'complete_quest',
                            reward: { gold: 100, item: 'fire_staff', xp: 50 },
                            next: 'initial'
                        },
                        tower_info: {
                            text: "This tower was built by ancient sorcerers. Now it's filled with monsters and dark magic. Be careful.",
                            responses: [
                                { text: "Tell me about the Lich King.", next: 'lich_info' },
                                { text: "Back to other questions.", next: 'initial' }
                            ]
                        }
                    },
                    merchant: {
                        initial: {
                            text: "Welcome! Looking to buy or sell? Or perhaps you have questions?",
                            responses: [
                                { text: "Show me your wares.", action: 'open_shop' },
                                { text: "I have items to sell.", action: 'open_sell' },
                                { text: "What rumors have you heard?", next: 'rumors' },
                                { text: "Just browsing.", action: 'end_conversation' }
                            ]
                        },
                        rumors: {
                            text: "They say the prisoner knows where treasure is hidden. But he's guarded...",
                            responses: [
                                { text: "Tell me more.", next: 'prisoner_info' },
                                { text: "Back to business.", next: 'initial' }
                            ]
                        }
                    },
                    prisoner: {
                        initial: {
                            text: "*muffled cries* Please... free me... the key... guard captain...",
                            responses: [
                                { text: "I'll free you if you tell me about treasure.", action: 'make_deal', next: 'deal' },
                                { text: "Who put you here?", next: 'story' },
                                { text: "I can't help.", action: 'end_conversation' }
                            ]
                        },
                        deal: {
                            text: "Yes! Free me! I know where the royal jewels are hidden... in the throne room... under the third stone...",
                            responses: [
                                { text: "I'll find the key.", action: 'accept_quest', next: 'waiting' },
                                { text: "You're lying.", next: 'initial' }
                            ]
                        },
                        waiting: {
                            text: "*chains rattle* I'm waiting...",
                            responses: [
                                { text: "I have the key!", action: 'free_prisoner', item: 'key', next: 'freedom' },
                                { text: "I'm still looking.", next: 'initial' }
                            ]
                        },
                        freedom: {
                            text: "Thank you! The treasure is yours! *runs away*",
                            action: 'complete_quest',
                            reward: { gold: 200, item: 'cloak', xp: 60 },
                            next: 'escaped'
                        },
                        escaped: {
                            text: "The prisoner has escaped. Only empty chains remain.",
                            responses: []
                        }
                    }
                };
                
                this.nodes = templates[this.npcId] || templates.merchant;
            }
            
            getCurrentNode() {
                return this.nodes[this.currentNode] || this.nodes.initial;
            }
            
            selectResponse(responseIndex) {
                const currentNode = this.getCurrentNode();
                if (!currentNode.responses || responseIndex >= currentNode.responses.length) {
                    return null;
                }
                
                const response = currentNode.responses[responseIndex];
                if (response.next) {
                    this.currentNode = response.next;
                }
                
                return response;
            }
            
            reset() {
                this.currentNode = 'initial';
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            warrior: { 
                hp: 35, mp: 5, str: 8, def: 6, stealth: 3, 
                desc: "A hardy fighter with heavy armor training.",
                skills: ['bash', 'block']
            },
            wizard: { 
                hp: 22, mp: 25, str: 3, def: 2, stealth: 6,
                desc: "A master of arcane arts, quick and silent.",
                skills: ['fireball', 'shield']
            },
            necromancer: { 
                hp: 28, mp: 18, str: 4, def: 3, stealth: 5,
                desc: "A dark summoner who moves in shadows.",
                skills: ['life_drain', 'summon']
            }
        };

        // ==================== SKILL SYSTEM ====================
        const skills = {
            bash: {
                name: "Bash",
                mpCost: 5,
                description: "A powerful strike that stuns the enemy",
                class: "warrior",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 1.5) + Math.floor(Math.random() * 8);
                    enemyData.hp -= damage;
                    print(`You BASH the enemy for ${damage} damage!`, 'damage');
                    soundSystem.playSound('attack', 0.7);
                    
                    if (Math.random() > 0.5) {
                        enemyData.stunned = 2;
                        print("The enemy is stunned!", 'success');
                    }
                    return true;
                }
            },
            block: {
                name: "Block",
                mpCost: 3,
                description: "Raise your guard, reducing next damage",
                class: "warrior",
                effect: function(player, enemyData) {
                    player.blocking = 3;
                    print("You assume a defensive stance. Next damage reduced!", 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false;
                }
            },
            fireball: {
                name: "Fireball",
                mpCost: 8,
                description: "Launch a magical fireball at your enemy",
                class: "wizard",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.5) + Math.floor(Math.random() * 15) + 10;
                    enemyData.hp -= damage;
                    print(`You cast FIREBALL for ${damage} damage!`, 'damage');
                    soundSystem.playSound('spell', 0.7);
                    
                    if (Math.random() > 0.7) {
                        enemyData.burning = 3;
                        print("The enemy is burning!", 'success');
                    }
                    return true;
                }
            },
            shield: {
                name: "Magic Shield",
                mpCost: 6,
                description: "Create a magical barrier that absorbs damage",
                class: "wizard",
                effect: function(player, enemyData) {
                    player.shield = Math.floor(player.maxHp * 0.3);
                    print(`You create a magical shield that absorbs ${player.shield} damage!`, 'success');
                    soundSystem.playSound('buff', 0.5);
                    return false;
                }
            },
            life_drain: {
                name: "Life Drain",
                mpCost: 7,
                description: "Steal life from your enemy to heal yourself",
                class: "necromancer",
                effect: function(player, enemyData) {
                    const damage = Math.floor(player.dmg * 0.8) + Math.floor(Math.random() * 10);
                    enemyData.hp -= damage;
                    const heal = Math.floor(damage * 0.5);
                    player.hp = Math.min(player.maxHp, player.hp + heal);
                    print(`You drain ${damage} life from the enemy and heal ${heal} HP!`, 'skill');
                    soundSystem.playSound('heal', 0.6);
                    return true;
                }
            },
            summon: {
                name: "Summon Skeleton",
                mpCost: 10,
                description: "Summon a skeletal minion to fight for you",
                class: "necromancer",
                effect: function(player, enemyData) {
                    if (player.skeleton) {
                        print("You already have a skeleton minion!", 'error');
                        return false;
                    }
                    player.skeleton = { hp: 20, dmg: 8 };
                    print("You summon a skeletal minion to fight by your side!", 'success');
                    soundSystem.playSound('spell', 0.6);
                    return false;
                }
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 3, type: 'weapon', value: 0, desc: "Your bare hands." },
            dagger: { name: "Dagger", dmg: 8, type: 'weapon', value: 15, desc: "A small, sharp dagger.", stealth: 2 },
            sword: { name: "Iron Sword", dmg: 14, type: 'weapon', value: 50, desc: "A sturdy iron longsword." },
            staff: { name: "Oak Staff", dmg: 10, type: 'weapon', value: 40, desc: "An oak staff with magical carvings.", magic: 5 },
            greatsword: { name: "Greatsword", dmg: 20, type: 'weapon', value: 120, desc: "A massive two-handed sword.", stealth: -3 },
            bow: { name: "Short Bow", dmg: 12, type: 'weapon', value: 35, desc: "A basic wooden bow with arrows.", range: true },
            mace: { name: "Iron Mace", dmg: 16, type: 'weapon', value: 65, desc: "A heavy mace for crushing armor." },
            fire_staff: { name: "Fire Staff", dmg: 18, type: 'weapon', value: 150, desc: "A staff imbued with fire magic.", magic: 10, element: 'fire' }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather: { name: "Leather Armor", def: 6, type: 'armor', value: 30, desc: "Soft leather armor.", stealth: 2 },
            chainmail: { name: "Chainmail", def: 10, type: 'armor', value: 80, desc: "Heavy chainmail.", stealth: -2 },
            robe: { name: "Mage Robe", def: 4, type: 'armor', value: 25, desc: "A dark mage's robe.", stealth: 3, magic: 5 },
            plate: { name: "Plate Armor", def: 15, type: 'armor', value: 150, desc: "Full plate armor.", stealth: -5 },
            scale: { name: "Scale Armor", def: 8, type: 'armor', value: 60, desc: "Scale armor.", stealth: 0 },
            cloak: { name: "Shadow Cloak", def: 2, type: 'armor', value: 45, desc: "A cloak that blends with shadows.", stealth: 5 }
        };

        const items = {
            potion: { type: 'consumable', effect: { hp: 25 }, value: 20, desc: "Heals 25 HP." },
            manapot: { type: 'consumable', effect: { mp: 20 }, value: 25, desc: "Restores 20 MP." },
            elixir: { type: 'consumable', effect: { hp: 50, mp: 30 }, value: 60, desc: "Restores 50 HP and 30 MP." },
            antidote: { type: 'consumable', effect: { cure: 'poison' }, value: 15, desc: "Cures poison." },
            skull: { type: 'quest', value: 1, desc: "A polished human skull." },
            tome: { type: 'quest', value: 1, desc: "An ancient spell tome." },
            amulet: { type: 'quest', value: 1, desc: "A glowing amulet." },
            key: { type: 'key', value: 1, desc: "An iron key." },
            torch: { type: 'tool', value: 5, desc: "A lit torch." },
            gem: { type: 'treasure', value: 100, desc: "A valuable gemstone." },
            scroll_fireball: { type: 'scroll', effect: 'fireball', value: 50, desc: "Scroll of Fireball." },
            water_flask: { type: 'tool', value: 5, desc: "A flask filled with water." },
            red_book: { type: 'tool', value: 10, desc: "A strange red book that might be a lever." },
            journal: { type: 'quest', value: 1, desc: "A guard's journal with blood stains." }
        };

// Add this near other game data (after items/weapons/armors definitions)
const itemNameMapping = {
    // Weapons
    'sword': 'sword',
    'iron sword': 'sword',
    'dagger': 'dagger',
    'staff': 'staff',
    'oak staff': 'staff',
    'fire staff': 'fire_staff',
    'greatsword': 'greatsword',
    'bow': 'bow',
    'short bow': 'bow',
    'mace': 'mace',
    'iron mace': 'mace',
    
    // Armors
    'leather': 'leather',
    'leather armor': 'leather',
    'chainmail': 'chainmail',
    'chain mail': 'chainmail',
    'robe': 'robe',
    'mage robe': 'robe',
    'plate': 'plate',
    'plate armor': 'plate',
    'scale': 'scale',
    'scale armor': 'scale',
    'cloak': 'cloak',
    'shadow cloak': 'cloak',
    
    // Items
    'potion': 'potion',
    'health potion': 'potion',
    'manapot': 'manapot',
    'mana potion': 'manapot',
    'elixir': 'elixir',
    'antidote': 'antidote',
    'skull': 'skull',
    'tome': 'tome',
    'ancient tome': 'tome',
    'amulet': 'amulet',
    'key': 'key',
    'iron key': 'key',
    'torch': 'torch',
    'gem': 'gem',
    'gemstone': 'gem',
    'scroll': 'scroll_fireball',
    'fireball scroll': 'scroll_fireball',
    'scroll of fireball': 'scroll_fireball',
    'flask': 'water_flask',
    'water flask': 'water_flask',
    'book': 'red_book',
    'red book': 'red_book',
    'journal': 'journal'
};

// Reverse mapping for display
const displayNames = {
    'scroll_fireball': 'scroll of fireball',
    'water_flask': 'water flask',
    'red_book': 'red book',
    'manapot': 'mana potion',
    'fire_staff': 'fire staff',
    'oak_staff': 'oak staff',
    'iron_sword': 'iron sword',
    'iron_mace': 'iron mace',
    'short_bow': 'short bow',
    'leather_armor': 'leather armor',
    'plate_armor': 'plate armor',
    'scale_armor': 'scale armor',
    'shadow_cloak': 'shadow cloak',
    'mage_robe': 'mage robe'
};

        const enemies = {
            rat: { name: "Giant Rat", hp: 20, dmg: 5, gold: 8, xp: 15, desc: "A giant sewer rat.", loot: ['potion'] },
            skeleton: { name: "Skeleton Warrior", hp: 35, dmg: 9, gold: 20, xp: 30, desc: "An animated skeleton.", loot: ['dagger', 'potion'] },
            ghost: { name: "Phantom", hp: 28, dmg: 7, gold: 15, xp: 25, desc: "A translucent phantom.", loot: ['torch', 'manapot'] },
            spider: { name: "Giant Spider", hp: 25, dmg: 8, gold: 12, xp: 22, desc: "A giant spider.", loot: ['potion', 'antidote'] },
            guard: { name: "Tower Guard", hp: 45, dmg: 12, gold: 35, xp: 40, desc: "A well-trained tower guard.", loot: ['chainmail', 'sword'] },
            wraith: { name: "Wraith", hp: 60, dmg: 15, gold: 50, xp: 60, desc: "A powerful spectral being.", loot: ['elixir', 'gem'] },
            boss: { name: "Lich King", hp: 150, dmg: 25, gold: 200, xp: 150, desc: "The Tower's master.", loot: ['greatsword', 'plate', 'elixir', 'gem', 'gem'] }
        };

        // ==================== SIMPLE OBJECT CREATION ====================
        function createSimpleObjects() {
            const objects = {};
            
            // Fountain
            const fountain = new SimpleObject("fountain", "A dry fountain with a stone basin.");
            fountain.addExaminationLevel(1, "The fountain hasn't flowed in years. Moss grows on its edges.");
            fountain.addExaminationLevel(2, "You notice ancient carvings depicting water spirits. There's clear water at the bottom.");
            fountain.setUseEffect(function(room, player) {
                player.hp = Math.min(player.maxHp, player.hp + 10);
                soundSystem.playSound('heal');
                return "You drink from the fountain. The water tastes pure and refreshing. You heal 10 HP!";
            });
            objects['fountain'] = fountain;
            
            // Bookshelf
            const bookshelf = new SimpleObject("bookshelf", "A large bookshelf filled with dusty tomes.");
            bookshelf.addExaminationLevel(1, "The books are arranged in a strange pattern. One book is red while all others are brown.");
            bookshelf.addExaminationLevel(2, "The red book seems to be a lever in disguise! It's slightly protruding.");
            bookshelf.setHiddenItem('red_book');
            objects['bookshelf'] = bookshelf;
            
            // Desk
            const desk = new SimpleObject("desk", "A wooden desk covered in papers.");
            desk.addExaminationLevel(1, "The desk has several drawers. One is slightly open.");
            desk.addExaminationLevel(2, "Inside the open drawer, you can see something that looks like a journal.");
            desk.setHiddenItem('journal');
            objects['desk'] = desk;
            
            // Piano
            const piano = new SimpleObject("piano", "A grand piano covered in dust.");
            piano.addExaminationLevel(1, "The keys are dusty but intact. Sheet music rests on the stand.");
            piano.addExaminationLevel(2, "The sheet music shows a sequence: C, E, G.");
            piano.setUseEffect(function(room, player) {
                if (!room.items.includes('gem')) {
                    room.items.push('gem');
                    soundSystem.playSound('puzzle', 0.8);
                    return "You play the piano. A hidden drawer opens with a gem inside!";
                } else {
                    return "The piano's secret compartment is already open.";
                }
            });
            objects['piano'] = piano;
            
            // Throne
            const throne = new SimpleObject("throne", "A stone throne worn smooth by time.");
            throne.addExaminationLevel(1, "A skeletal figure sits on the throne, crown askew.");
            throne.addExaminationLevel(2, "The crown is tarnished but might be valuable. The skeleton's bony fingers point downward.");
            throne.setHiddenItem('gem');
            throne.setUseEffect(function(room, player) {
                if (Math.random() > 0.7) {
                    player.gold += 50;
                    soundSystem.playSound('pickup');
                    return "You search beneath the throne and find 50 gold coins!";
                } else {
                    return "You search beneath the throne but find nothing.";
                }
            });
            objects['throne'] = throne;
            
            // Well
            const well = new SimpleObject("well", "A deep well with a rope hanging down.");
            well.addExaminationLevel(1, "Something whispers from below. The rope seems sturdy.");
            well.addExaminationLevel(2, "You peer down but see only darkness. The whispers grow louder.");
            well.setUseEffect(function(room, player) {
                if (!room.items.includes('potion')) {
                    room.items.push('potion');
                    soundSystem.playSound('notification');
                    return "You lower the bucket into the well and pull up healing water.";
                } else {
                    return "You already got water from the well.";
                }
            });
            objects['well'] = well;
            
            return objects;
        }

        // ==================== NPC DEFINITIONS ====================
        const npcs = {
            wizard: { 
                name: "Archmage Valerius", 
                desc: "An old wizard with a long white beard and glowing eyes.", 
                dialog: "I seek the Ancient Tome. Bring it to me for a reward.",
                quest: { item: 'tome', reward: { gold: 100, item: 'fire_staff', xp: 50 }, completed: false },
                hostile: false
            },
            merchant: { 
                name: "Merchant Garvin", 
                desc: "A shady trader with a heavy cloak.", 
                dialog: "Welcome! I buy and sell goods.",
                quest: null,
                hostile: false,
                shopItems: ['dagger', 'sword', 'staff', 'potion', 'manapot']
            },
            prisoner: {
                name: "Chained Prisoner",
                desc: "A poor soul chained to the wall.",
                dialog: "Please... free me... the key is with the guard captain...",
                quest: { item: 'key', reward: { gold: 200, item: 'cloak', xp: 60 }, completed: false },
                hostile: false
            }
        };

        // ==================== ROOM DESCRIPTIONS ====================
        const roomDescriptions = [
            { desc: "The Entrance Hall. A massive iron door lies behind you. Torches flicker on stone walls.", sound: 'theme' },
            { desc: "Guard Room. Two empty suits of armor stand watch. One seems to be moving...", sound: 'dungeon' },
            { desc: "Stone Corridor. Cobwebs hang from the ceiling. The air is cold and damp.", sound: 'dungeon' },
            { desc: "Storage Room. Broken crates and barrels litter the floor. Something scurries in the dark.", sound: 'eerie' },
            { desc: "Armory. Rusty weapons line the walls. Most are beyond use.", sound: 'dungeon' },
            { desc: "Chapel. Faded frescoes depict forgotten gods. Candles burn on a stone altar.", sound: 'theme' },
            { desc: "Library. Books lie scattered, pages torn. A large bookshelf stands against the wall.", sound: 'eerie' },
            { desc: "Alchemy Lab. Broken vials ooze colorful liquids. A strange scent lingers.", sound: 'eerie' },
            { desc: "Torture Chamber. Rusty implements hang from walls. Chains rattle in the draft.", sound: 'eerie' },
            { desc: "Barracks. Rotted bunks line the walls. Rats nest in the straw.", sound: 'dungeon' },
            { desc: "Courtyard. Dead vines cling to stone walls. A fountain stands in the center.", sound: 'theme' },
            { desc: "Wine Cellar. Broken casks leak foul liquid. Shadows move between barrels.", sound: 'eerie' },
            { desc: "Kitchen. A giant cauldron hangs over cold ashes. Knives gleam on a block.", sound: 'dungeon' },
            { desc: "Dining Hall. A long table set for a feast that never came. Plates are covered in dust.", sound: 'eerie' },
            { desc: "Throne Room. A skeletal figure sits on a stone throne, crown askew.", sound: 'dungeon' },
            { desc: "Observatory. A cracked telescope points at the sky through a broken dome.", sound: 'theme' },
            { desc: "Treasure Vault. Empty chests lie open. Something valuable might remain...", sound: 'dungeon' },
            { desc: "Crypt. Stone sarcophagi line the walls. The air smells of decay.", sound: 'eerie' },
            { desc: "Guard Post. A journal lies open on a desk. The last entry is smeared with blood.", sound: 'dungeon' },
            { desc: "Prison Cells. Iron bars enclose small spaces. Moaning echoes from within.", sound: 'eerie' },
            { desc: "Royal Bedchamber. A canopy bed with moth-eaten curtains. Jewels glitter in a box.", sound: 'dungeon' },
            { desc: "Study. A desk covered in yellowed maps. A single candle burns endlessly.", sound: 'eerie' },
            { desc: "Art Gallery. Portraits with eyes that follow you. One frame is empty.", sound: 'eerie' },
            { desc: "Music Room. A grand piano plays a haunting tune by itself.", sound: 'eerie' },
            { desc: "Bathhouse. Tiled pools filled with black water. Steam rises without heat.", sound: 'eerie' },
            { desc: "Training Room. Wooden dummies stand ready. One moves when not watched.", sound: 'dungeon' },
            { desc: "Clock Tower. Gears turn silently. The hands are stuck at midnight.", sound: 'theme' },
            { desc: "Aviary. Empty birdcages hang from the ceiling. Feathers float in the air.", sound: 'eerie' },
            { desc: "Laboratory. Strange machines hum with residual energy. Glass tubes glow faintly.", sound: 'eerie' },
            { desc: "Garden. Dead plants in stone planters. A single black rose blooms.", sound: 'theme' },
            { desc: "Archives. Scrolls crumble at your touch. Ancient knowledge lost forever.", sound: 'eerie' },
            { desc: "Forge. Cold anvils and extinguished fires. A sword half-forged on the bench.", sound: 'dungeon' },
            { desc: "Well Room. A deep well in the center. Something whispers from below.", sound: 'eerie' },
            { desc: "Pantry. Rotted food in sacks. Something still moves within.", sound: 'eerie' },
            { desc: "Servant Quarters. Simple cots and worn clothing. A diary tells of escape.", sound: 'dungeon' },
            { desc: "Royal Library. Books bound in strange leather. They seem to watch you.", sound: 'eerie' },
            { desc: "Astronomy Room. Star charts on the walls. Constellations move on their own.", sound: 'theme' },
            { desc: "Meditation Chamber. Incense burners cold. A mat lies in the center.", sound: 'eerie' },
            { desc: "Armory Vault. Magical weapons behind glass. All cases are broken open.", sound: 'dungeon' },
            { desc: "Guard Tower. Arrow slits look over the land. A skeleton holds a bow.", sound: 'dungeon' },
            { desc: "Dungeon. Deeper than the prison. The walls sweat and moan.", sound: 'eerie' },
            { desc: "Catacombs. Bones arranged in patterns. They rearrange when you look away.", sound: 'eerie' },
            { desc: "Shrine. A statue of a forgotten deity. Offerings of gold and gems at its feet.", sound: 'theme' },
            { desc: "Clockwork Room. Mechanical creatures frozen in mid-action. One eye follows you.", sound: 'eerie' },
            { desc: "Mirror Hall. Reflections show different versions of yourself. Some attack.", sound: 'eerie' },
            { desc: "Laboratory Depth. Flesh and metal fused in tanks. Things move within.", sound: 'eerie' },
            { desc: "Necromancer's Sanctum. Black candles burn with green flame. Skulls line shelves.", sound: 'eerie' },
            { desc: "Wizard's Tower. Floating books and glowing orbs. Magic crackles in the air.", sound: 'theme' },
            { desc: "Royal Treasury. Mountains of gold and jewels. A dragon skeleton guards it.", sound: 'dungeon' },
            { desc: "Summit Chamber. The very top of the tower. Wind howls through broken windows. A final challenge awaits.", sound: 'boss' }
        ];

        // Room object assignments
        const roomObjects = {
            6: ['bookshelf'],   // Library
            10: ['fountain'],   // Courtyard
            14: ['throne'],     // Throne Room
            18: ['desk'],       // Guard Post
            21: ['desk'],       // Study
            23: ['piano'],      // Music Room
            32: ['well']        // Well Room
        };

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            stealth: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: false,
            moves: 0,
            poisoned: false,
            effects: [],
            blocking: 0,
            shield: 0,
            skeleton: null,
            activeDialogue: null
        };

        let rooms = [];
        let gameStarted = false;
        let currentBackground = 'theme';
        const soundSystem = new SoundSystem();
        const npcDialogues = {};
        const simpleObjects = createSimpleObjects();

        // ==================== GAME FUNCTIONS ====================
        function generateRooms() {
            const rooms = [];
            for (let i = 0; i < 50; i++) {
                const room = {
                    id: i,
                    desc: roomDescriptions[i].desc,
                    sound: roomDescriptions[i].sound,
                    exits: { 
                        n: i < 40 ? i + 10 : null, 
                        s: i >= 10 ? i - 10 : null, 
                        e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                        w: i % 10 !== 0 ? i - 1 : null 
                    },
                    items: [],
                    enemy: null,
                    npc: null,
                    explored: false,
                    dark: i > 25 && i < 40,
                    locked: i === 41 || i === 25 || i === 35
                };

                // Add simple objects to rooms
                if (roomObjects[i]) {
                    roomObjects[i].forEach(objName => {
                        const template = simpleObjects[objName];
                        if (template) {
                            const obj = SimpleObject.fromJSON(template.toJSON());
                            if (!room.simpleObjects) room.simpleObjects = {};
                            room.simpleObjects[objName] = obj;
                        }
                    });
                }

                rooms.push(room);
            }

            // Place items, enemies, and NPCs
            rooms[1].items = ['dagger'];
            rooms[3].enemy = createEnemy('rat');
            rooms[5].items = ['potion'];
            rooms[7].enemy = createEnemy('spider');
            rooms[10].npc = 'merchant';
            rooms[12].enemy = createEnemy('skeleton');
            rooms[15].npc = 'wizard';
            rooms[17].items = ['skull'];
            rooms[20].enemy = createEnemy('ghost');
            rooms[25].items = ['tome'];
            rooms[28].enemy = createEnemy('spider');
            rooms[32].items = ['leather'];
            rooms[35].enemy = createEnemy('wraith');
            rooms[39].items = ['sword'];
            rooms[40].npc = 'prisoner';
            rooms[40].items = ['key'];
            rooms[42].enemy = createEnemy('guard');
            rooms[45].enemy = createEnemy('wraith');
            rooms[47].items = ['gem'];
            rooms[49].enemy = createEnemy('boss');
            
            return rooms;
        }

        // Create enemy instance function
        function createEnemy(type) {
            const enemyTemplate = enemies[type];
            if (!enemyTemplate) return null;
            
            return {
                name: enemyTemplate.name,
                hp: enemyTemplate.hp,
                maxHp: enemyTemplate.hp,
                dmg: enemyTemplate.dmg,
                gold: enemyTemplate.gold,
                xp: enemyTemplate.xp,
                desc: enemyTemplate.desc,
                loot: enemyTemplate.loot,
                stunned: 0,
                burning: 0,
                originalType: type
            };
        }

        // Initialize rooms
        rooms = generateRooms();

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            if (className === 'success' || className === 'loot' || className === 'quest' || 
                className === 'puzzle' || className === 'examine') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            let statusText = `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} STE:${player.stealth} ` +
                `LVL:${player.level} GOLD:${player.gold}${combat}`;
                
            const effects = [];
            if (player.poisoned) effects.push('POISON');
            if (player.blocking > 0) effects.push(`BLOCK(${player.blocking})`);
            if (player.shield > 0) effects.push(`SHIELD(${player.shield})`);
            if (player.skeleton) effects.push('SKELETON');
            
            if (effects.length > 0) {
                statusText += `\nEFFECTS: ${effects.join(' ')}`;
            }
            
            status.textContent = statusText;
        }

        // ==================== OBJECT INTERACTION FUNCTIONS ====================

        // Enhanced examine function
        function examineObject(objectName) {
            const room = rooms[player.location];
            
            // Check for room object
            if (room.simpleObjects && room.simpleObjects[objectName]) {
                const obj = room.simpleObjects[objectName];
                const result = obj.examine();
                print(result, 'examine');
                soundSystem.playSound('examine');
                
                // Add XP for examining
                player.xp += 5;
                return;
            }
            
            // Check for item in inventory
            const item = weapons[objectName] || armors[objectName] || items[objectName];
            if (item) {
                print(`${item.name || objectName}: ${item.desc}`, 'examine');
                soundSystem.playSound('examine');
                return;
            }
            
            // Check for room objects mentioned in description
            const roomDesc = room.desc.toLowerCase();
            if (roomDesc.includes(objectName.toLowerCase())) {
                print(`You examine the ${objectName}. It looks ordinary.`, 'system');
                return;
            }
            
            print(`You don't see a ${objectName} here.`, 'error');
        }

        // Search function
        function searchObject(objectName) {
    const room = rooms[player.location];
    
    if (!room.simpleObjects || !room.simpleObjects[objectName]) {
        print(`There's no ${objectName} here to search.`, 'error');
        return;
    }
    
    const obj = room.simpleObjects[objectName];
    
    // Check if the hidden item is already in room OR player already has it
    if (obj.hiddenItem) {
        const itemAlreadyInRoom = room.items.includes(obj.hiddenItem);
        const playerAlreadyHas = player.inventory.includes(obj.hiddenItem);
        
        if (itemAlreadyInRoom || playerAlreadyHas) {
            return `You already found everything in the ${objectName}.`;
        }
    }
    
    const result = obj.search(room);
    print(result, 'interact');
    
    if (result.includes("find")) {
        soundSystem.playSound('pickup');
    }
}

        // Use function
       function useObject(objectInput) {
    const room = rooms[player.location];
    const args = Array.from(arguments);
    
    // Handle multi-word inputs
    let objectName = objectInput;
    if (args.length > 1) {
        objectName = args.join(' ');
    }
    
    // Convert to internal name using mapping
    let internalName = objectName.toLowerCase();
    if (itemNameMapping[internalName]) {
        internalName = itemNameMapping[internalName];
    }
    
    // Check if player has the item
    if (!player.inventory.includes(internalName)) {
        // Player doesn't have item, maybe they want to use a room object
        if (room.simpleObjects && room.simpleObjects[internalName]) {
            const obj = room.simpleObjects[internalName];
            const result = obj.use(room, player);
            print(result, 'interact');
            
            if (result.includes("heal") || result.includes("find") || result.includes("open")) {
                soundSystem.playSound('notification');
            }
            return;
        }
        
        print(`You don't have a ${objectName} and there's nothing here to use.`, 'error');
        return;
    }
    
    // Player HAS the item - check for special uses first
    const specialUse = handleSpecialUse(internalName, room);
    if (specialUse) {
        if (specialUse.success) {
            print(specialUse.message, 'success');
            if (specialUse.sound) {
                soundSystem.playSound(specialUse.sound);
            }
        } else {
            print(specialUse.message, specialUse.success ? 'success' : 'error');
        }
        return;
    }
    
    // Not a special use, try to use as inventory item
    useInventoryItem(internalName);
}

        function useInventoryItem(itemName) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(`You heal ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(`You restore ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                }
                if (item.effect.cure === 'poison') {
                    player.poisoned = false;
                    print("The poison is cured!", 'success');
                    soundSystem.playSound('notification', 0.3);
                }
                player.inventory.splice(index, 1);
                updateStatus();
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(player.torch ? "You light the torch." : "You extinguish the torch.", 'system');
                soundSystem.playSound('click');
            } else if (item.type === 'scroll') {
                print(`You use the ${itemName}...`, 'system');
                if (item.effect === 'fireball') {
                    const room = rooms[player.location];
                    if (room.enemy) {
                        const fireDmg = 30 + Math.floor(Math.random() * 20);
                        room.enemy.hp -= fireDmg;
                        print(`A massive fireball hits the ${room.enemy.name} for ${fireDmg} damage!`, 'damage');
                        soundSystem.playSound('attack');
                        if (room.enemy.hp <= 0) {
                            defeatEnemy(room.enemy);
                            room.enemy = null;
                            player.inCombat = null;
                        }
                    } else {
                        print("The fireball fizzles with no target.", 'error');
                    }
                    player.inventory.splice(index, 1);
                }
                updateStatus();
            } else {
                print(`You're not sure how to use the ${itemName}.`, 'system');
            }
        }

        // In the readObject function, add red book handling:
function readObject(objectName) {
    if (objectName === 'journal' || objectName === 'red_book' || objectName === 'red book') {
        const itemName = objectName === 'red_book' ? 'red_book' : objectName === 'red book' ? 'red_book' : 'journal';
        if (player.inventory.includes(itemName)) {
            if (itemName === 'journal') {
                print("You read the journal...", 'examine');
                print("'The guard captain has gone mad. He's locking doors and keeping the keys.", 'examine');
                print("I fear he plans to trap us all in this cursed tower.'", 'examine');
            } else {
                print("You read the red book...", 'examine');
                print("The pages are filled with strange symbols. One page shows a diagram", 'examine');
                print("of a bookshelf with a red book marked as a lever.", 'examine');
            }
        } else {
            print(`You don't have a ${objectName} to read.`, 'error');
        }
    } else if (objectName === 'desk') {
        const room = rooms[player.location];
        if (room.simpleObjects && room.simpleObjects.desk) {
            print("You read the papers on the desk. They're mostly mundane reports about tower maintenance.", 'examine');
        } else {
            print("There's no desk here to read.", 'error');
        }
    } else {
        print(`You can't read the ${objectName}.`, 'error');
    }
}

        // ==================== DIALOGUE SYSTEM ====================
        function startDialogue(npcId) {
            if (!npcDialogues[npcId]) {
                npcDialogues[npcId] = new DialogueTree(npcId, npcs[npcId]?.name || npcId);
            }
            
            player.activeDialogue = npcId;
            const dialogue = npcDialogues[npcId];
            const node = dialogue.getCurrentNode();
            
            print(`${npcId.toUpperCase()} DIALOGUE:`, 'dialogue');
            print(node.text, 'npc');
            
            if (node.action) {
                handleDialogueAction(node.action, node);
            }
            
            if (node.responses && node.responses.length > 0) {
                print("Responses:", 'dialogue');
                node.responses.forEach((response, index) => {
                    print(`${index + 1}. ${response.text}`, 'response');
                });
                print("Type 'respond [number]' to choose a response.", 'system');
            } else if (node.next) {
                dialogue.currentNode = node.next;
                startDialogue(npcId);
            }
        }

        function handleDialogueResponse(responseNumber) {
            if (!player.activeDialogue) {
                print("You're not in a conversation.", 'error');
                return;
            }
            
            const dialogue = npcDialogues[player.activeDialogue];
            const response = dialogue.selectResponse(responseNumber - 1);
            
            if (!response) {
                print("Invalid response.", 'error');
                return;
            }
            
            if (response.action) {
                handleDialogueAction(response.action, response);
            }
            
            if (response.next) {
                dialogue.currentNode = response.next;
                startDialogue(player.activeDialogue);
            } else if (response.action === 'end_conversation') {
                player.activeDialogue = null;
                print("Conversation ended.", 'system');
            } else {
                dialogue.currentNode = 'initial';
                startDialogue(player.activeDialogue);
            }
        }

        function handleDialogueAction(action, data) {
            const room = rooms[player.location];
            const npc = npcs[player.activeDialogue];
            
            switch(action) {
                case 'open_shop':
                    print("The merchant shows you his wares...", 'system');
                    print("Available: dagger (15g), sword (50g), staff (40g), potion (20g), manapot (25g)", 'item');
                    break;
                case 'accept_quest':
                    print("Quest accepted!", 'quest');
                    if (npc.quest) {
                        player.quests.push({
                            npc: player.activeDialogue,
                            item: npc.quest.item,
                            completed: false
                        });
                    }
                    break;
                case 'check_quest_item':
                    if (player.inventory.includes(data.item)) {
                        const dialogue = npcDialogues[player.activeDialogue];
                        dialogue.currentNode = data.next;
                        startDialogue(player.activeDialogue);
                    } else {
                        print(`You don't have the ${data.item}.`, 'error');
                    }
                    break;
                case 'complete_quest':
                    if (data.reward) {
                        player.gold += data.reward.gold;
                        player.xp += data.reward.xp;
                        if (data.reward.item) {
                            player.inventory.push(data.reward.item);
                        }
                        print(`Reward: ${data.reward.gold} gold, ${data.reward.xp} XP${data.reward.item ? `, ${data.reward.item}` : ''}`, 'success');
                        
                        if (npc.quest) {
                            npc.quest.completed = true;
                        }
                    }
                    break;
                case 'free_prisoner':
                    if (player.inventory.includes('key')) {
                        const index = player.inventory.indexOf('key');
                        player.inventory.splice(index, 1);
                        room.npc = null;
                        print("You free the prisoner!", 'success');
                    } else {
                        print("You need the key to free the prisoner.", 'error');
                    }
                    break;
                case 'end_conversation':
                    player.activeDialogue = null;
                    print("You end the conversation.", 'system');
                    break;
            }
        }

        // ==================== COMBAT FUNCTIONS ====================
        function showSkills() {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            print(`=== ${player.class.toUpperCase()} SKILLS ===`, 'skill');
            
            classSkills.forEach(skillName => {
                const skill = skills[skillName];
                if (skill) {
                    print(`${skill.name} (${skill.mpCost} MP): ${skill.description}`, 'skill');
                }
            });
            
            print("Use 'skill [name]' in combat to use a skill.", 'system');
        }

        function useSkill(skillName) {
            if (!player.class) {
                print("You haven't chosen a class yet.", 'error');
                return;
            }
            
            const room = rooms[player.location];
            if (!room.enemy || !player.inCombat) {
                print("You can only use skills in combat!", 'error');
                return;
            }
            
            const classSkills = classes[player.class].skills;
            if (!classSkills.includes(skillName)) {
                print(`You don't have the ${skillName} skill!`, 'error');
                return;
            }
            
            const skill = skills[skillName];
            if (!skill) {
                print("Unknown skill.", 'error');
                return;
            }
            
            if (player.mp < skill.mpCost) {
                print(`Not enough MP! Need ${skill.mpCost}, have ${player.mp}.`, 'error');
                return;
            }
            
            player.mp -= skill.mpCost;
            print(`You use ${skill.name}! (-${skill.mpCost} MP)`, 'skill');
            
            const endsTurn = skill.effect(player, room.enemy);
            
            if (room.enemy.hp <= 0) {
                defeatEnemy(room.enemy);
                room.enemy = null;
                player.inCombat = null;
                checkLevelUp();
                updateStatus();
                return;
            }
            
            if (endsTurn) {
                if (room.enemy.stunned && room.enemy.stunned > 0) {
                    print("The enemy is stunned and cannot attack!", 'success');
                    room.enemy.stunned--;
                } else {
                    enemyTurn(room.enemy);
                }
            }
            
            updateStatus();
        }

        function enemyTurn(enemyData) {
            let damageMultiplier = 1;
            if (player.blocking > 0) {
                damageMultiplier = 0.5;
                player.blocking--;
                if (player.blocking <= 0) {
                    print("Your defensive stance ends.", 'system');
                }
            }
            
            let enemyDmg = Math.max(enemyData.dmg - player.def + Math.floor(Math.random() * 5), 1);
            enemyDmg = Math.floor(enemyDmg * damageMultiplier);
            
            if (player.shield > 0) {
                const absorbed = Math.min(player.shield, enemyDmg);
                enemyDmg -= absorbed;
                player.shield -= absorbed;
                print(`Your shield absorbs ${absorbed} damage.`, 'heal');
                
                if (player.shield <= 0) {
                    print("Your magical shield shatters!", 'system');
                }
            }
            
            if (enemyDmg > 0) {
                player.hp -= enemyDmg;
                print(`The enemy hits you for ${enemyDmg} damage.`, 'damage');
                soundSystem.playSound('playerHit', 0.5);
                
                if (player.hp <= 0) {
                    print("You have been slain... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                }
            }
        }

        function defeatEnemy(enemyData) {
            const enemyType = enemyData.originalType;
            const enemy = enemies[enemyType];
            print(`You defeated the ${enemy.name}!`, 'success');
            player.gold += enemy.gold;
            player.xp += enemy.xp;
            print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
            soundSystem.playSound('victory');
            
            if (enemy.loot && Math.random() > 0.3) {
                const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                if (loot === 'gold') {
                    const extraGold = Math.floor(Math.random() * 20) + 5;
                    player.gold += extraGold;
                    print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                } else {
                    player.inventory.push(loot);
                    print(`The enemy drops: ${loot}!`, 'loot');
                    soundSystem.playSound('pickup');
                }
            }
            
            if (enemyType === 'boss') {
                print("*** CONGRATULATIONS! ***", 'success');
                print("You have conquered the Tower of Terror!", 'success');
                print("You are now the master of the tower!", 'success');
                soundSystem.playBackground('victory');
                setTimeout(() => soundSystem.playBackground('theme'), 10000);
            }
        }

        // ==================== CORE GAME FUNCTIONS ====================
        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            let baseStealth = classes[player.class].stealth;
            if (weapon.stealth) baseStealth += weapon.stealth;
            if (armor.stealth) baseStealth += armor.stealth;
            player.stealth = Math.max(0, baseStealth);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 100;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 15;
                player.hp = player.maxHp;
                player.maxMp += 8;
                player.mp = player.maxMp;
                player.str += 2;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.stealth = c.stealth;
            player.gold = 50;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['potion', 'torch'];
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.blocking = 0;
            player.shield = 0;
            player.skeleton = null;
            player.activeDialogue = null;
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 50 gold, a potion, and a torch.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateStatus();
        }

        function look() {
    const room = rooms[player.location];
    
    if (room.enemy && room.enemy.bgSound) {
        currentBackground = 'boss';
    } else {
        currentBackground = room.sound;
    }
    soundSystem.playBackground(currentBackground);
    
    if (room.dark && !player.torch) {
        print("The room is pitch black. You can't see anything!", 'error');
        print("You need a light source.", 'error');
        return;
    }
    
    if (!room.explored) {
        room.explored = true;
        player.xp += 5;
        print(`+5 XP for exploring!`, 'system');
        soundSystem.playSound('notification', 0.5);
    }
    
    print(room.desc);
    
    // List room objects
    if (room.simpleObjects && Object.keys(room.simpleObjects).length > 0) {
        print(`You see: ${Object.keys(room.simpleObjects).join(', ')}`, 'item');
    }
    
    if (room.items.length > 0) {
        print(`Items here: ${room.items.map(item => {
            const displayName = displayNames[item] || item;
            return displayName;
        }).join(', ')}`, 'item');
    }
    
    if (room.enemy) {
        const enemy = room.enemy;
        print(`${enemy.desc}`, 'enemy');
        print(`It has ${enemy.hp}/${enemy.maxHp} HP.`, 'enemy');
    }
    
    if (room.npc) {
        const npcName = room.npc;
        const npc = npcs[npcName];
        print(`${npc.name} is here. ${npc.desc}`, 'npc');
    }
    
    // Show locked status for CURRENT room (if player is inside a locked room)
    if (room.locked) {
        print("The door to this room is locked from the outside!", 'error');
        print("You're trapped unless you have another way out.", 'system');
    }
    
    // Check exits and show which ones might be locked
    let exits = [];
    for (let dir in room.exits) {
        if (room.exits[dir] !== null) {
            const exitRoom = rooms[room.exits[dir]];
            if (exitRoom && exitRoom.locked) {
                exits.push(`${dir}(locked)`);
            } else {
                exits.push(dir);
            }
        }
    }
    
    print(`Exits: ${exits.join(' ')}`);
    
    updateStatus();
}

        function move(direction) {
    const room = rooms[player.location];
    const target = room.exits[direction];
    
    if (target === null) {
        print("You can't go that way.", 'error');
        soundSystem.playSound('click');
        return;
    }
    
    const targetRoom = rooms[target];
    
    // Check if target room is locked
    if (targetRoom && targetRoom.locked) {
        print("The door is locked! You need a key.", 'error');
        soundSystem.playSound('door');
        return;
    }
    
    soundSystem.playSound('step', 0.3);
    
    // Random encounter check
    player.moves++;
    if (player.moves % 3 === 0) {
        const encounterChance = Math.max(30 - player.stealth, 5);
        if (Math.random() * 100 < encounterChance) {
            const randomEnemies = ['rat', 'spider', 'skeleton', 'ghost'];
            const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
            rooms[player.location].enemy = createEnemy(enemyType);
            print(`A ${enemyType} ambushes you!`, 'enemy');
            player.inCombat = enemyType;
            soundSystem.playSound('attack', 0.5);
            updateStatus();
            return;
        }
    }
    
    player.location = target;
    print(`You go ${direction}.`, 'command');
    
    // End any active dialogue
    player.activeDialogue = null;
    
    // Apply poison damage if poisoned
    if (player.poisoned) {
        const poisonDmg = Math.floor(player.maxHp * 0.05);
        player.hp -= poisonDmg;
        print(`Poison damages you for ${poisonDmg} HP!`, 'damage');
        soundSystem.playSound('playerHit', 0.3);
        if (player.hp <= 0) {
            print("You succumb to poison... GAME OVER.", 'error');
            soundSystem.playSound('defeat');
            resetGame();
            return;
        }
    }
    
    // Check for dark room
    const newRoom = rooms[player.location];
    if (newRoom.dark && !player.torch) {
        print("You enter complete darkness. You can't see!", 'error');
    } else {
        look();
    }
    
    updateStatus();
}

        function take(itemInput) {
    const room = rooms[player.location];
    
    if (room.dark && !player.torch) {
        print("It's too dark to see items!", 'error');
        return;
    }
    
    // Convert player input to internal item name
    let itemName = itemInput.toLowerCase();
    
    // Check if input matches a mapped name
    if (itemNameMapping[itemName]) {
        itemName = itemNameMapping[itemName];
    }
    // Handle multi-word inputs like "red book"
    else if (itemInput.includes(' ')) {
        // Try the exact phrase first
        if (itemNameMapping[itemInput]) {
            itemName = itemNameMapping[itemInput];
        }
    }
    
    // Check if item exists in room
    const index = room.items.indexOf(itemName);
    if (index === -1) {
        // Try to find similar items
        const availableItems = room.items.map(item => {
            const displayName = displayNames[item] || item;
            return displayName;
        });
        
        print(`That item isn't here. Available items: ${availableItems.join(', ') || 'none'}`, 'error');
        return;
    }
    
    // Remove from room and add to inventory
    room.items.splice(index, 1);
    player.inventory.push(itemName);
    
    // Get display name for message
    const displayName = displayNames[itemName] || itemName;
    print(`You take the ${displayName}.`, 'success');
    soundSystem.playSound('pickup');
    updateStatus();
}

        function attack(target) {
            const room = rooms[player.location];
            
            if (target) {
                if (room.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        room.enemy = createEnemy('guard');
                        room.npc = null;
                        player.inCombat = 'guard';
                        player.stealth = Math.max(0, player.stealth - 5);
                        print("Your reputation suffers! Stealth -5.", 'error');
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        room.npc = null;
                        player.stealth = Math.max(0, player.stealth - 10);
                        print("Your dark deed stains your soul! Stealth -10.", 'error');
                        player.xp += 20;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    return;
                }
            }
            
            if (!room.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyData = room.enemy;
            player.inCombat = enemyData.originalType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemyData.name}!`, 'command');
            
            const playerDmg = player.dmg + Math.floor(Math.random() * 5);
            enemyData.hp -= playerDmg;
            print(`You hit for ${playerDmg} damage.`, 'damage');
            soundSystem.playSound('enemyHit', 0.5);
            
            if (enemyData.hp <= 0) {
                defeatEnemy(enemyData);
                room.enemy = null;
                player.inCombat = null;
                checkLevelUp();
            } else {
                print(`The ${enemyData.name} has ${enemyData.hp} HP left.`);
                
                enemyTurn(enemyData);
            }
            
            updateStatus();
        }

        function showInventory() {
    if (player.inventory.length === 0) {
        print("Your inventory is empty.");
    } else {
        print("Inventory:");
        const counts = {};
        player.inventory.forEach(item => {
            counts[item] = (counts[item] || 0) + 1;
        });
        
        Object.keys(counts).forEach(internalName => {
            const item = weapons[internalName] || armors[internalName] || items[internalName];
            const count = counts[internalName];
            
            // Use display name if available, otherwise use internal name
            const displayName = displayNames[internalName] || internalName;
            const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
            print(`${displayName} x${count}: ${itemDesc}`, 'item');
        });
    }
    
    // Show equipped items with display names
    const weapon = weapons[player.equipped.weapon];
    const armor = armors[player.equipped.armor];
    const weaponDisplay = displayNames[player.equipped.weapon] || player.equipped.weapon;
    const armorDisplay = displayNames[player.equipped.armor] || player.equipped.armor;
    
    print(`Equipped: ${weaponDisplay} (${weapon.dmg + player.str} DMG), ${armorDisplay} (${armor.def} DEF)`);
    print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.stealth} STEALTH`);
}

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

function handleSpecialUse(itemName, room) {
    switch(itemName) {
        case 'red_book':
            if (room.simpleObjects && room.simpleObjects.bookshelf) {
                if (!room.items.includes('scroll_fireball')) {
                    room.items.push('scroll_fireball');
                    return {
                        success: true,
                        message: "You use the red book on the bookshelf. It clicks and slides aside, revealing a hidden scroll!",
                        sound: 'puzzle'
                    };
                } else {
                    return {
                        success: false,
                        message: "The mechanism is already activated."
                    };
                }
            } else {
                return {
                    success: false, 
                    message: "There's no bookshelf here to use the red book on."
                };
            }
            
        case 'water_flask':
        case 'flask':
            if (room.simpleObjects && room.simpleObjects.fountain) {
                if (!player.inventory.includes('water_flask')) {
                    player.inventory.push('water_flask');
                    return {
                        success: true,
                        message: "You fill your flask with water from the fountain.",
                        sound: 'pickup'
                    };
                } else {
                    return {
                        success: false,
                        message: "Your flask is already full."
                    };
                }
            } else {
                return {
                    success: false,
                    message: "There's nothing to fill your flask with here."
                };
            }
            
        case 'key':
            if (room.locked) {
                room.locked = false;
                // Remove key from inventory
                const keyIndex = player.inventory.indexOf('key');
                if (keyIndex > -1) {
                    player.inventory.splice(keyIndex, 1);
                }
                return {
                    success: true,
                    message: "You use the key to unlock the door.",
                    sound: 'door'
                };
            } else {
                return {
                    success: false,
                    message: "There's nothing to unlock here."
                };
            }
            
        default:
            return null; // Not a special use case
    }
}

        function help() {
            print("=== TOWER OF TERROR - SIMPLIFIED COMMANDS ===", 'command');
            print("MOVEMENT: n, s, e, w, look", 'system');
            print("EXAMINATION: examine [object/item]", 'examine');
            print("INTERACTION: search [object], use [object], read [object]", 'system');
            print("DIALOGUE: talk [npc], respond [number]", 'dialogue');
            print("COMBAT: attack, skill [name]", 'system');
            print("SKILLS: skills (to see available skills)", 'skill');
            print("ITEMS: take [item], equip [item], use [item]", 'system');
            print("INVENTORY: inventory, status", 'system');
            print("SAVE/LOAD: save, load, qsave, qload", 'system');
            print("OTHER: help, quit", 'system');
            print("=== OBJECT INTERACTIONS ===", 'command');
            print("search bookshelf/desk/throne - Find hidden items", 'system');
            print("use fountain - Drink for healing", 'system');
            print("use piano - Play to find treasure", 'system');
            print("use well - Get healing water", 'system');
            print("use red book - Use on bookshelf to find scroll", 'system');
            print("use flask - Fill at fountain", 'system');
        }

        // ==================== SAVE/LOAD SYSTEM ====================
        const SAVE_SLOTS = {
            QUICK: 'tower_terror_quick',
            SLOT1: 'tower_terror_slot1',
            SLOT2: 'tower_terror_slot2',
            SLOT3: 'tower_terror_slot3'
        };

        function saveGame(slot = SAVE_SLOTS.SLOT1) {
            if (!gameStarted || !player.class) {
                print("No game in progress to save.", 'error');
                return;
            }
            
            const saveData = {
                player: JSON.parse(JSON.stringify(player)),
                rooms: rooms.map(room => {
                    const roomCopy = { ...room };
                    if (roomCopy.simpleObjects) {
                        Object.keys(roomCopy.simpleObjects).forEach(key => {
                            if (roomCopy.simpleObjects[key] instanceof SimpleObject) {
                                roomCopy.simpleObjects[key] = roomCopy.simpleObjects[key].toJSON();
                            }
                        });
                    }
                    return roomCopy;
                }),
                gameStarted: gameStarted,
                currentBackground: currentBackground,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem(slot, JSON.stringify(saveData));
                print(`Game saved to slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                soundSystem.playSound('notification', 0.5);
            } catch (e) {
                print("Failed to save game: " + e.message, 'error');
            }
        }

        function quickSave() {
            saveGame(SAVE_SLOTS.QUICK);
        }

        function loadGame(slot = SAVE_SLOTS.SLOT1) {
            try {
                const saveData = localStorage.getItem(slot);
                if (!saveData) {
                    print(`No save found in slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}`, 'error');
                    return false;
                }
                
                const data = JSON.parse(saveData);
                
                player = data.player;
                
                rooms = data.rooms;
                rooms.forEach(room => {
                    if (room.enemy && room.enemy.originalType) {
                        const enemyInstance = createEnemy(room.enemy.originalType);
                        if (enemyInstance) {
                            enemyInstance.hp = room.enemy.hp;
                            enemyInstance.stunned = room.enemy.stunned || 0;
                            enemyInstance.burning = room.enemy.burning || 0;
                            room.enemy = enemyInstance;
                        }
                    }
                    
                    if (room.simpleObjects) {
                        Object.keys(room.simpleObjects).forEach(key => {
                            const objData = room.simpleObjects[key];
                            if (objData && !(objData instanceof SimpleObject)) {
                                room.simpleObjects[key] = SimpleObject.fromJSON(objData);
                            }
                        });
                    }
                });
                
                gameStarted = data.gameStarted;
                currentBackground = data.currentBackground;
                
                print(`Game loaded from slot ${slot === SAVE_SLOTS.QUICK ? 'QUICK' : slot.slice(-1)}!`, 'success');
                print(`Loaded save from ${new Date(data.timestamp).toLocaleString()}`, 'system');
                soundSystem.playSound('notification', 0.5);
                
                look();
                updateStatus();
                return true;
            } catch (e) {
                print("Failed to load game: " + e.message, 'error');
                return false;
            }
        }

        function quickLoad() {
            loadGame(SAVE_SLOTS.QUICK);
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            rooms = generateRooms();
            soundSystem.playBackground('theme');
            print("GAME OVER", 'error');
            print("Choose a class: warrior, wizard, necromancer.");
            updateStatus();
        }

        // ==================== QUICK COMMANDS ====================
        function quickCommand(cmd) {
            const inputField = document.getElementById('input');
            inputField.value = cmd;
            
            const event = new KeyboardEvent('keydown', {
                key: 'Enter',
                code: 'Enter',
                keyCode: 13,
                which: 13,
                bubbles: true
            });
            
            inputField.dispatchEvent(event);
        }

        // ==================== COMMAND PARSER ====================
input.addEventListener('keydown', function (e) {
    if (e.key === 'Enter') {
        const rawCmd = input.value.trim(); // Keep original case
        const cmd = rawCmd.toLowerCase(); // Lowercase for comparison
        input.value = '';
        if (!cmd) return;

        soundSystem.playSound('click', 0.3);
        print(`> ${rawCmd}`, 'command');
        const parts = rawCmd.split(' '); // Use rawCmd to preserve case for display
        const verb = parts[0].toLowerCase();
        const arg = parts[1];
        const arg2 = parts[2];
        const arg3 = parts[3];
        
        // Reconstruct multi-word arguments
        let fullArg = '';
        if (arg) {
            fullArg = parts.slice(1).join(' ');
        }

        // Class selection
        if (!player.class && ['warrior', 'wizard', 'necromancer'].includes(verb)) {
            startGame(verb);
            return;
        }
        if (!player.class) {
            print("Choose a class first: warrior, wizard, necromancer.", 'error');
            return;
        }

        // Game commands - ONLY ONE SWITCH STATEMENT!
        switch (verb) {
            case 'n': case 'north': move('n'); break;
            case 's': case 'south': move('s'); break;
            case 'e': case 'east': move('e'); break;
            case 'w': case 'west': move('w'); break;
            case 'go': if (fullArg) move(fullArg); else if (arg) move(arg); else print("Go where?"); break;
            case 'l': case 'look': look(); break;
            
            // Object interaction
            case 'examine': case 'x': 
                if (fullArg) examineObject(fullArg); 
                else if (arg) examineObject(arg);
                else print("Examine what?", 'error');
                break;
                
            case 'search': 
                if (fullArg) searchObject(fullArg);
                else if (arg) searchObject(arg);
                else print("Search what?", 'error');
                break;
                
            case 'use': 
                if (fullArg) useObject(fullArg);
                else if (arg) useObject(arg);
                else print("Use what?", 'error');
                break;
                
            case 'read':
                if (fullArg) readObject(fullArg);
                else if (arg) readObject(arg);
                else print("Read what?", 'error');
                break;
                
            // Dialogue system
            case 'talk': 
                if (arg) {
                    const room = rooms[player.location];
                    if (room.npc === arg) {
                        startDialogue(arg);
                    } else {
                        print("That NPC isn't here.", 'error');
                    }
                } else print("Talk to who?", 'error');
                break;
            case 'respond': case 'r':
                if (arg) handleDialogueResponse(parseInt(arg));
                else print("Respond with what number?", 'error');
                break;
                
            // Original game commands
            case 'take': 
                if (fullArg) take(fullArg);
                else if (arg) take(arg);
                else print("Take what?", 'error');
                break;
                
            case 'attack': 
                if (fullArg) attack(fullArg);
                else attack(); 
                break;
                
            case 'equip': 
                if (fullArg) equip(fullArg);
                else if (arg) equip(arg);
                else print("Equip what?", 'error');
                break;
                
            case 'skill': if (arg) useSkill(arg); else print("Use which skill?"); break;
            case 'skills': showSkills(); break;
            case 'i': case 'inventory': case 'inv': showInventory(); break;
            case 'status': updateStatus(); break;
            case 'save': saveGame(); break;
            case 'load': loadGame(); break;
            case 'qsave': quickSave(); break;
            case 'qload': quickLoad(); break;
            case 'help': case '?': help(); break;
            case 'quit': resetGame(); break;
            default: print("Unknown command. Type 'help'.", 'error');
        }
    }
});

// Sound toggle button - THIS COMES AFTER THE COMMAND PARSER, NOT ANOTHER SWITCH!
document.getElementById('sound-toggle').addEventListener('click', () => {
    soundSystem.toggle();
});

// Initialize audio on first user interaction
document.addEventListener('click', function initAudio() {
    soundSystem.resumeAudioContext();
    if (!gameStarted) {
        soundSystem.playBackground('theme');
    }
    document.removeEventListener('click', initAudio);
}, { once: true });

// ==================== INIT ====================
print("TOWER OF TERROR - SIMPLIFIED ADVENTURE", 'success');
print("NIGHTFALLS GAMES PRESENTS", 'system');
print("", 'system');
print("Now with intuitive adventure game commands:", 'system');
print("- Simple verb system: use, search, examine, read, take", 'system');
print("- No complex 'interact' command needed", 'system');
print("- Objects work like classic text adventures", 'system');
print("", 'system');
print("Touch sound button to toggle audio", 'system');
print("Use quick buttons for mobile play", 'system');
print("SAVE/LOAD buttons in top-left corner", 'system');
print("", 'system');
print("Choose your class: warrior, wizard, necromancer.", 'system');
updateStatus();
input.focus();
    </script>
</body>
</html>
