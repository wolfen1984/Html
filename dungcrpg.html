<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Might & Magic: Dungeon Delver</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            background-color: #000;
            color: #fff;
            line-height: 1.4;
            padding: 10px;
            max-width: 1200px;
            margin: 0 auto;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(40, 0, 0, 0.9) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(0, 20, 40, 0.9) 0%, transparent 20%);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .game-container {
            border: 4px double #fff;
            padding: 15px;
            margin-bottom: 20px;
            background-color: rgba(0, 0, 0, 0.85);
            box-shadow: 0 0 0 1px #333, 0 0 20px rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* Scanline effect */
        .game-container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            z-index: 2;
            pointer-events: none;
        }
        
        h1 {
            color: #ff3355;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #000;
            font-size: 2rem;
            border-bottom: 2px dotted #666;
            padding-bottom: 15px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        h2 {
            color: #ff3355;
            margin: 15px 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px dashed #666;
            font-size: 1.2rem;
            text-shadow: 2px 2px 0 #000;
        }
        
        h3 {
            color: #ffaa00;
            margin: 10px 0;
            font-size: 1rem;
        }
        
        .screen {
            display: none;
            min-height: 400px;
        }
        
        .active-screen {
            display: block;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            background-color: #222;
            padding: 10px;
            border: 2px solid #fff;
            margin-bottom: 20px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .status-item {
            margin: 5px 10px;
            color: #ff3355;
            text-shadow: 1px 1px 0 #000;
        }
        
        .status-value {
            color: #fff;
            font-weight: bold;
            display: block;
            margin-top: 5px;
            font-size: 1.2rem;
        }
        
        /* First-Person Dungeon View */
        .dungeon-view-container {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .dungeon-view {
            background-color: #111;
            border: 2px solid #fff;
            padding: 20px;
            height: 400px;
            position: relative;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            line-height: 1.3;
            white-space: pre;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
        }
        
        .first-person-view {
            font-size: 24px;
            text-align: center;
            line-height: 1.5;
        }
        
        .wall {
            color: #666;
            background-color: #333;
            padding: 2px 4px;
            margin: 1px;
        }
        
        .door {
            color: #ffaa00;
            background-color: #442200;
            padding: 2px 4px;
            margin: 1px;
        }
        
        .floor {
            color: #aaa;
            background-color: #222;
            padding: 2px 4px;
            margin: 1px;
        }
        
        .monster-tile {
            color: #ff3355;
            background-color: #330000;
            padding: 2px 4px;
            margin: 1px;
            animation: pulse 1.5s infinite;
        }
        
        .treasure-tile {
            color: #ffaa00;
            background-color: #332200;
            padding: 2px 4px;
            margin: 1px;
            animation: glow 2s infinite alternate;
        }
        
        .exit-tile {
            color: #44ff88;
            background-color: #003300;
            padding: 2px 4px;
            margin: 1px;
        }
        
        .player-tile {
            color: #44aaff;
            background-color: #002233;
            padding: 2px 4px;
            margin: 1px;
        }
        
        .dungeon-sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .dungeon-info {
            background-color: #222;
            border: 2px solid #fff;
            padding: 15px;
            color: #ffaa00;
        }
        
        .dungeon-info p {
            margin: 8px 0;
            font-size: 12px;
        }
        
        .dungeon-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .dungeon-btn {
            background-color: #333;
            color: #ffaa00;
            border: 2px solid #fff;
            padding: 12px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            text-align: center;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 #000;
        }
        
        .dungeon-btn:hover {
            background-color: #444;
            border-color: #ffaa00;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #000;
            color: #fff;
        }
        
        .dungeon-btn:active {
            transform: translateY(0);
            box-shadow: 0 0 0 #000;
        }
        
        .dungeon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Auto-Map */
        .automap-container {
            background-color: #111;
            border: 2px solid #fff;
            padding: 15px;
            margin-top: 20px;
            min-height: 200px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
        }
        
        .automap-grid {
            display: inline-grid;
            grid-template-columns: repeat(9, 20px);
            gap: 2px;
            margin: 10px auto;
            border: 1px solid #444;
            padding: 5px;
            background-color: #000;
        }
        
        .map-cell {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }
        
        .map-wall {
            background-color: #444;
        }
        
        .map-floor {
            background-color: #222;
        }
        
        .map-explored {
            background-color: #1a2a1a;
        }
        
        .map-player {
            background-color: #44aaff;
            color: #000;
            font-weight: bold;
        }
        
        .map-monster {
            background-color: #ff3355;
            color: #000;
        }
        
        .map-treasure {
            background-color: #ffaa00;
            color: #000;
        }
        
        .map-exit {
            background-color: #44ff88;
            color: #000;
        }
        
        .map-door {
            background-color: #664400;
            color: #ffaa00;
        }
        
        /* Party Status */
        .party-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .party-member {
            background-color: #222;
            border: 2px solid #fff;
            padding: 15px;
            position: relative;
        }
        
        .party-member.active {
            border-color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }
        
        .member-name {
            color: #ff3355;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .member-class {
            color: #44aaff;
            font-size: 11px;
            margin-bottom: 10px;
        }
        
        .member-health {
            height: 8px;
            background-color: #333;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .member-health-fill {
            height: 100%;
            background-color: #ff3355;
            transition: width 0.3s;
        }
        
        .member-mana {
            height: 8px;
            background-color: #333;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .member-mana-fill {
            height: 100%;
            background-color: #44aaff;
            transition: width 0.3s;
        }
        
        .member-status {
            margin-top: 10px;
            font-size: 10px;
            color: #aaa;
        }
        
        .menu {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 8px;
            margin: 20px 0;
        }
        
        .menu-option {
            background-color: #333;
            border: 2px solid #fff;
            padding: 12px 8px;
            cursor: pointer;
            transition: all 0.1s;
            text-align: center;
            color: #ff3355;
            text-shadow: 1px 1px 0 #000;
            font-size: 12px;
        }
        
        .menu-option:hover {
            background-color: #444;
            border-color: #ffaa00;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #000;
            color: #fff;
        }
        
        .menu-option:active {
            transform: translateY(0);
            box-shadow: 0 0 0 #000;
        }
        
        .menu-option:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .combat-log {
            background-color: #111;
            border: 2px solid #fff;
            padding: 15px;
            height: 220px;
            overflow-y: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            color: #fff;
            font-size: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
            line-height: 1.6;
        }
        
        button {
            background-color: #333;
            color: #ffaa00;
            border: 2px solid #fff;
            padding: 12px 24px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            margin: 8px;
            transition: all 0.1s;
            text-shadow: 1px 1px 0 #000;
        }
        
        button:hover {
            background-color: #444;
            border-color: #ffaa00;
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #000;
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 0 0 #000;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            border-color: #666;
        }
        
        /* Town Interface */
        .town-interface {
            background-color: #222;
            border: 2px solid #fff;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .town-locations {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .town-location {
            background-color: #333;
            border: 2px solid #666;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .town-location:hover {
            border-color: #ffaa00;
            transform: translateY(-2px);
            box-shadow: 0 4px 0 #000;
        }
        
        .location-name {
            color: #ffaa00;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .location-desc {
            color: #aaa;
            font-size: 10px;
        }
        
        /* Shop Interface */
        .shop-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .shop-item {
            background-color: #222;
            border: 2px solid #666;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .shop-item:hover {
            border-color: #ffaa00;
            background-color: #333;
        }
        
        .item-price {
            color: #ffaa00;
            float: right;
            font-size: 12px;
        }
        
        /* Pixel art dividers */
        .divider {
            height: 2px;
            background-color: #fff;
            margin: 20px 0;
            position: relative;
        }
        
        .divider::before, .divider::after {
            content: "‚óÜ";
            position: absolute;
            top: -10px;
            color: #ffaa00;
            font-size: 20px;
            background-color: #000;
            padding: 0 10px;
        }
        
        .divider::before {
            left: 20px;
        }
        
        .divider::after {
            right: 20px;
        }
        
        /* Trap System */
        .trap-warning {
            background-color: #662222;
            border: 2px solid #ff3355;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            animation: pulse 1s infinite;
        }
        
        /* Puzzle Interface */
        .puzzle-container {
            background-color: #1a1a2a;
            border: 2px solid #44aaff;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .puzzle-element {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin: 5px;
            border: 2px solid #44aaff;
            cursor: pointer;
            font-size: 20px;
            line-height: 36px;
            vertical-align: middle;
        }
        
        .puzzle-element:hover {
            background-color: #2a2a4a;
        }
        
        .puzzle-element.fire {
            color: #ff3355;
            border-color: #ff3355;
        }
        
        .puzzle-element.water {
            color: #44aaff;
            border-color: #44aaff;
        }
        
        .puzzle-element.earth {
            color: #aa9955;
            border-color: #aa9955;
        }
        
        .puzzle-element.air {
            color: #44ff88;
            border-color: #44ff88;
        }
        
        /* Game Over Screen */
        .game-over {
            color: #ff3355;
            text-align: center;
            font-size: 2.5rem;
            margin: 30px 0;
            text-shadow: 4px 4px 0 #000;
            animation: pulse 1.5s infinite;
        }
        
        .victory {
            color: #ffaa00;
            text-align: center;
            font-size: 2.5rem;
            margin: 30px 0;
            text-shadow: 4px 4px 0 #000;
            animation: glow 2s infinite alternate;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 10px;
            border-top: 1px dashed #444;
            padding-top: 15px;
            font-family: 'Courier New', monospace;
        }
        
        /* CRT monitor curvature effect */
        .crt-curve {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
            background: radial-gradient(
                ellipse at center,
                rgba(0,0,0,0) 0%,
                rgba(0,0,0,0) 60%,
                rgba(0,0,0,0.3) 100%
            );
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes glow {
            from { text-shadow: 4px 4px 0 #000, 0 0 10px #ffaa00; }
            to { text-shadow: 4px 4px 0 #000, 0 0 20px #ffaa00, 0 0 30px #ffaa00; }
        }
        
        @media (max-width: 768px) {
            .dungeon-view-container {
                grid-template-columns: 1fr;
            }
            
            .menu {
                grid-template-columns: 1fr;
            }
            
            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            body {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="crt-curve"></div>
    
    <div class="game-container">
        <h1>MIGHT & MAGIC: DUNGEON DELVER</h1>
        <div class="divider"></div>
        
        <div class="status-bar">
            <div class="status-item">DUNGEON: <span class="status-value" id="currentDungeon">-</span></div>
            <div class="status-item">FLOOR: <span class="status-value" id="currentFloor">1</span></div>
            <div class="status-item">PARTY HP: <span class="status-value" id="partyHealth">100</span>/<span class="status-value" id="partyMaxHealth">100</span></div>
            <div class="status-item">GOLD: <span class="status-value" id="gold">500</span></div>
            <div class="status-item">TORCHES: <span class="status-value" id="torches">10</span></div>
            <div class="status-item">MAP: <span class="status-value" id="mapProgress">0</span>%</div>
        </div>
        
        <!-- Character Creation Screen -->
        <div id="creationScreen" class="screen active-screen">
            <h2>PARTY CREATION</h2>
            <p>FORM YOUR PARTY OF FOUR ADVENTURERS. CHOOSE THEIR CLASSES AND DISTRIBUTE ATTRIBUTES.</p>
            
            <div id="partyCreation" style="margin: 20px 0;">
                <!-- Party members will be dynamically added here -->
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="completePartyCreation()">BEGIN ADVENTURE</button>
            </div>
        </div>
        
        <!-- Town Screen -->
        <div id="townScreen" class="screen">
            <h2>TOWN OF RIVERWOOD</h2>
            <p>YOUR PARTY STANDS IN THE CENTER OF RIVERWOOD. REST, RESUPPLY, AND PREPARE FOR YOUR NEXT DUNGEON DELVE.</p>
            
            <div class="town-interface">
                <div class="town-locations">
                    <div class="town-location" onclick="goToInn()">
                        <div class="location-name">THE DRUNKEN DRAGON INN</div>
                        <div class="location-desc">REST AND HEAL YOUR PARTY</div>
                    </div>
                    <div class="town-location" onclick="goToShop()">
                        <div class="location-name">BLACKSMITH'S SHOP</div>
                        <div class="location-desc">BUY WEAPONS AND ARMOR</div>
                    </div>
                    <div class="town-location" onclick="goToMagicShop()">
                        <div class="location-name">MAGIC EMPORIUM</div>
                        <div class="location-desc">PURCHASE SPELLS AND POTIONS</div>
                    </div>
                    <div class="town-location" onclick="goToGuild()">
                        <div class="location-name">ADVENTURER'S GUILD</div>
                        <div class="location-desc">ACCEPT QUESTS AND CONTRACTS</div>
                    </div>
                    <div class="town-location" onclick="goToTemple()">
                        <div class="location-name">TEMPLE OF LIGHT</div>
                        <div class="location-desc">REMOVE CURSES AND BLESSINGS</div>
                    </div>
                    <div class="town-location" onclick="goToDungeonSelect()">
                        <div class="location-name">DUNGEON GATE</div>
                        <div class="location-desc">ENTER A DUNGEON TO EXPLORE</div>
                    </div>
                </div>
            </div>
            
            <div id="townMessage" style="margin-top: 20px; padding: 15px; background-color: #222; border: 1px dashed #666;"></div>
        </div>
        
        <!-- Dungeon Selection Screen -->
        <div id="dungeonSelectScreen" class="screen">
            <h2>SELECT A DUNGEON</h2>
            <p>CHOOSE A DUNGEON TO EXPLORE. EACH HAS DIFFERENT CHALLENGES AND REWARDS.</p>
            
            <div class="menu">
                <div class="menu-option" onclick="enterDungeon('catacombs')">
                    <strong>CATACOMBS OF RIVERWOOD</strong>
                    <div style="color: #aaa; font-size: 10px; margin-top: 5px;">LEVEL 1-3 | UNDEAD AND GOBLINS</div>
                </div>
                <div class="menu-option" onclick="enterDungeon('crystal')" id="crystalDungeon">
                    <strong>CRYSTAL CAVERNS</strong>
                    <div style="color: #aaa; font-size: 10px; margin-top: 5px;">LEVEL 2-4 | ELEMENTALS AND CRYSTAL BEASTS</div>
                </div>
                <div class="menu-option" onclick="enterDungeon('fortress')" id="fortressDungeon">
                    <strong>FORGOTTEN FORTRESS</strong>
                    <div style="color: #aaa; font-size: 10px; margin-top: 5px;">LEVEL 3-5 | ORCS AND WAR MACHINES</div>
                </div>
                <div class="menu-option" onclick="enterDungeon('labyrinth')" id="labyrinthDungeon">
                    <strong>MINOTAUR'S LABYRINTH</strong>
                    <div style="color: #aaa; font-size: 10px; margin-top: 5px;">LEVEL 4-6 | MINOTAURS AND TRAPS</div>
                </div>
                <div class="menu-option" onclick="enterDungeon('void')" id="voidDungeon">
                    <strong>VOID TEMPLE</strong>
                    <div style="color: #aaa; font-size: 10px; margin-top: 5px;">LEVEL 5+ | DEMONS AND VOID CREATURES</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="goToTown()">RETURN TO TOWN</button>
            </div>
        </div>
        
        <!-- First-Person Dungeon Screen -->
        <div id="dungeonScreen" class="screen">
            <h2 id="dungeonTitle">CATACOMBS OF RIVERWOOD - FLOOR 1</h2>
            
            <div class="dungeon-view-container">
                <div class="dungeon-view">
                    <div id="firstPersonView" class="first-person-view">
                        <!-- First-person view will be rendered here -->
                    </div>
                </div>
                
                <div class="dungeon-sidebar">
                    <div class="dungeon-info">
                        <h3>DUNGEON INFO</h3>
                        <p>FLOOR: <span id="infoFloor">1</span></p>
                        <p>POSITION: (<span id="infoX">5</span>, <span id="infoY">5</span>)</p>
                        <p>DIRECTION: <span id="infoDirection">NORTH</span></p>
                        <p>TURNS: <span id="infoTurns">0</span></p>
                        <p>MONSTERS NEARBY: <span id="infoMonsters">0</span></p>
                        <p>TRAPS DETECTED: <span id="infoTraps">0</span></p>
                    </div>
                    
                    <div class="dungeon-controls">
                        <div class="dungeon-btn" onclick="moveForward()">‚Üë MOVE FORWARD</div>
                        <div class="dungeon-btn" onclick="turnLeft()">‚Ü∞ TURN LEFT</div>
                        <div class="dungeon-btn" onclick="turnRight()">‚Ü± TURN RIGHT</div>
                        <div class="dungeon-btn" onclick="moveBackward()">‚Üì MOVE BACK</div>
                        <div class="dungeon-btn" onclick="searchArea()">üîç SEARCH</div>
                        <div class="dungeon-btn" onclick="restInDungeon()">üí§ REST</div>
                        <div class="dungeon-btn" onclick="useSkill('detect_traps')">‚ö†Ô∏è DETECT TRAPS</div>
                        <div class="dungeon-btn" onclick="useSkill('detect_secret')">üîì FIND SECRETS</div>
                    </div>
                </div>
            </div>
            
            <!-- Party Status -->
            <div class="party-container" id="partyContainer">
                <!-- Party members will be dynamically added here -->
            </div>
            
            <!-- Auto-Map -->
            <div class="automap-container">
                <h3>AUTO-MAP</h3>
                <div id="automapGrid" class="automap-grid">
                    <!-- Auto-map will be dynamically generated here -->
                </div>
                <p style="text-align: center; margin-top: 10px; font-size: 10px; color: #aaa;">
                    LEGEND: ‚ñà=WALL ‚ñë=FLOOR P=YOU M=MONSTER T=TREASURE E=EXIT D=DOOR
                </p>
            </div>
            
            <!-- Combat Log -->
            <div id="combatLog" class="combat-log"></div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="fleeToTown()">FLEE TO TOWN</button>
                <button onclick="useTorch()" id="torchButton">LIGHT TORCH (10)</button>
                <button onclick="viewInventory()">INVENTORY</button>
            </div>
        </div>
        
        <!-- Combat Screen -->
        <div id="combatScreen" class="screen">
            <h2>ENCOUNTER!</h2>
            
            <div id="combatView" style="text-align: center; margin: 20px 0;">
                <!-- Combat visualization will be here -->
            </div>
            
            <div class="combat-log" id="battleLog"></div>
            
            <div style="text-align: center; margin: 20px 0;">
                <button onclick="attackEnemy()">ATTACK</button>
                <button onclick="castSpell()" id="spellButton">CAST SPELL</button>
                <button onclick="useItem()">USE ITEM</button>
                <button onclick="fleeCombat()">FLEE</button>
                <button onclick="defend()">DEFEND</button>
            </div>
            
            <div class="party-container" id="combatParty">
                <!-- Party members in combat will be dynamically added here -->
            </div>
        </div>
        
        <!-- Shop Screen -->
        <div id="shopScreen" class="screen">
            <h2>BLACKSMITH'S SHOP</h2>
            <p>"WHAT CAN I GET FOR YOU TODAY, ADVENTURERS?"</p>
            
            <div class="shop-items">
                <div class="shop-item" onclick="buyItem('torch', 5)">
                    <strong>TORCH</strong> <span class="item-price">5 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">ILLUMINATES DARK AREAS FOR 30 TURNS</div>
                </div>
                <div class="shop-item" onclick="buyItem('healing_potion', 25)">
                    <strong>HEALING POTION</strong> <span class="item-price">25 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">RESTORES 50 HP TO ONE PARTY MEMBER</div>
                </div>
                <div class="shop-item" onclick="buyItem('antidote', 20)">
                    <strong>ANTIDOTE</strong> <span class="item-price">20 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">CURES POISON AND VENOM</div>
                </div>
                <div class="shop-item" onclick="buyItem('iron_key', 50)">
                    <strong>IRON KEY</strong> <span class="item-price">50 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">OPENS IRON DOORS</div>
                </div>
                <div class="shop-item" onclick="buyItem('trap_kit', 75)">
                    <strong>TRAP DISARMING KIT</strong> <span class="item-price">75 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">+25% TO TRAP DISARMING</div>
                </div>
                <div class="shop-item" onclick="buyItem('map_scroll', 100)">
                    <strong>MAPPING SCROLL</strong> <span class="item-price">100 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">REVEALS PART OF CURRENT FLOOR MAP</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="goToTown()">LEAVE SHOP</button>
            </div>
            
            <div id="shopMessage" style="margin-top: 20px; padding: 15px; background-color: #222; border: 1px dashed #666;"></div>
        </div>
        
        <!-- Magic Shop Screen -->
        <div id="magicShopScreen" class="screen">
            <h2>MAGIC EMPORIUM</h2>
            <p>"THE ARCANE ARTS AWAIT THOSE WITH GOLD AND WIT."</p>
            
            <div class="shop-items">
                <div class="shop-item" onclick="buySpell('light')">
                    <strong>SPELL: LIGHT</strong> <span class="item-price">100 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">CREATES MAGICAL LIGHT (50 TURNS)</div>
                </div>
                <div class="shop-item" onclick="buySpell('detect_traps')">
                    <strong>SPELL: DETECT TRAPS</strong> <span class="item-price">150 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">REVEALS TRAPS IN CURRENT AREA</div>
                </div>
                <div class="shop-item" onclick="buySpell('detect_secret')">
                    <strong>SPELL: DETECT SECRET</strong> <span class="item-price">200 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">REVEALS HIDDEN DOORS AND PASSAGES</div>
                </div>
                <div class="shop-item" onclick="buySpell('heal')">
                    <strong>SPELL: HEAL</strong> <span class="item-price">250 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">RESTORES HP TO PARTY MEMBERS</div>
                </div>
                <div class="shop-item" onclick="buySpell('fireball')">
                    <strong>SPELL: FIREBALL</strong> <span class="item-price">300 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">DAMAGES ALL ENEMIES IN FRONT</div>
                </div>
                <div class="shop-item" onclick="buySpell('identify')">
                    <strong>SPELL: IDENTIFY</strong> <span class="item-price">350 GOLD</span>
                    <div style="color: #aaa; font-size: 11px; margin-top: 5px;">REVEALS PROPERTIES OF MYSTERY ITEMS</div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button onclick="goToTown()">LEAVE SHOP</button>
            </div>
            
            <div id="magicShopMessage" style="margin-top: 20px; padding: 15px; background-color: #222; border: 1px dashed #666;"></div>
        </div>
        
        <!-- Puzzle Screen -->
        <div id="puzzleScreen" class="screen">
            <h2>ANCIENT PUZZLE</h2>
            <p id="puzzleDescription">AN ANCIENT MECHANISM BLOCKS YOUR PATH. REARRANGE THE ELEMENTS TO MATCH THE PATTERN.</p>
            
            <div class="puzzle-container">
                <div id="puzzleElements">
                    <!-- Puzzle elements will be dynamically added here -->
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="checkPuzzle()">ACTIVATE</button>
                    <button onclick="skipPuzzle()">ATTEMPT TO FORCE (RISKY)</button>
                </div>
            </div>
            
            <div id="puzzleResult" style="margin-top: 20px; padding: 15px; background-color: #222; border: 1px dashed #666;"></div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="screen">
            <h2 class="game-over">PARTY DEFEATED</h2>
            <div class="divider"></div>
            <p>YOUR ADVENTURERS HAVE FALLEN IN THE DEPTHS OF THE DUNGEON.</p>
            <p>FLOORS EXPLORED: <span class="status-value" id="finalFloors">0</span></p>
            <p>MONSTERS SLAIN: <span class="status-value" id="finalMonsters">0</span></p>
            <p>TREASURE FOUND: <span class="status-value" id="finalTreasure">0</span> GOLD</p>
            <p>MAY THEIR SACRIFICE BE REMEMBERED.</p>
            <div style="text-align: center; margin-top: 40px;">
                <button onclick="restartGame()">START NEW GAME</button>
            </div>
        </div>
        
        <!-- Victory Screen -->
        <div id="victoryScreen" class="screen">
            <h2 class="victory">DUNGEON CONQUERED!</h2>
            <div class="divider"></div>
            <p>YOUR PARTY HAS EMERGED VICTORIOUS FROM THE DUNGEON!</p>
            <p>FLOORS CLEARED: <span class="status-value" id="victoryFloors">0</span></p>
            <p>MONSTERS SLAIN: <span class="status-value" id="victoryMonsters">0</span></p>
            <p>TREASURE ACQUIRED: <span class="status-value" id="victoryTreasure">0</span> GOLD</p>
            <p>LEGENDARY STATUS ACHIEVED!</p>
            <div style="text-align: center; margin-top: 40px;">
                <button onclick="goToTown()">RETURN TO TOWN</button>
                <button onclick="restartGame()">NEW ADVENTURE</button>
            </div>
        </div>
    </div>
    
    <div class="footer">
        MIGHT & MAGIC: DUNGEON DELVER ‚Ä¢ FIRST-PERSON GRID-BASED CRPG ‚Ä¢ INSPIRED BY WORLD XEEN
    </div>

    <script>
        // Game state
        const gameState = {
            // Party information
            party: [],
            gold: 500,
            torches: 10,
            currentDungeon: null,
            currentFloor: 1,
            
            // Dungeon state
            dungeonGrid: [],
            playerX: 5,
            playerY: 5,
            playerDirection: 0, // 0=North, 1=East, 2=South, 3=West
            exploredTiles: new Set(),
            discoveredSecrets: new Set(),
            discoveredTraps: new Set(),
            
            // Game stats
            monstersSlain: 0,
            treasureFound: 0,
            totalTurns: 0,
            mapRevealed: 0,
            
            // Combat state
            inCombat: false,
            currentEnemy: null,
            combatTurn: 0,
            
            // Puzzle state
            inPuzzle: false,
            currentPuzzle: null,
            
            // Inventory
            inventory: {
                keys: { iron: 0, silver: 0, gold: 0 },
                potions: { healing: 3, mana: 1, antidote: 1 },
                scrolls: { identify: 1, mapping: 0 },
                special: []
            },
            
            // Spells known
            spells: ['light'], // Start with basic light spell
            
            // Dungeon completion
            dungeonsCompleted: []
        };

        // Direction vectors
        const directions = [
            { x: 0, y: -1, name: "NORTH" },
            { x: 1, y: 0, name: "EAST" },
            { x: 0, y: 1, name: "SOUTH" },
            { x: -1, y: 0, name: "WEST" }
        ];

        // Tile types
        const TILE = {
            WALL: '#',
            FLOOR: '.',
            DOOR: 'D',
            SECRET_DOOR: 'S',
            STAIRS_UP: 'U',
            STAIRS_DOWN: 'V',
            TREASURE: 'T',
            MONSTER: 'M',
            TRAP: 'X',
            PUZZLE: 'P',
            EXIT: 'E'
        };

        // Character classes
        const classes = {
            warrior: {
                name: "WARRIOR",
                hpPerLevel: 12,
                mpPerLevel: 2,
                skills: ["SWORD", "SHIELD", "HEAVY_ARMOR"],
                startingEquipment: ["LONG_SWORD", "CHAIN_MAIL"]
            },
            rogue: {
                name: "ROGUE",
                hpPerLevel: 8,
                mpPerLevel: 4,
                skills: ["DAGGER", "LOCKPICK", "TRAP_DISARM", "STEALTH"],
                startingEquipment: ["DAGGER", "LEATHER_ARMOR"]
            },
            mage: {
                name: "MAGE",
                hpPerLevel: 6,
                mpPerLevel: 10,
                skills: ["STAFF", "SPELLCAST", "IDENTIFY", "ENCHANT"],
                startingEquipment: ["STAFF", "ROBE"]
            },
            cleric: {
                name: "CLERIC",
                hpPerLevel: 10,
                mpPerLevel: 6,
                skills: ["MACE", "HEAL", "TURN_UNDEAD", "PROTECTION"],
                startingEquipment: ["MACE", "CHAIN_MAIL"]
            }
        };

        // Dungeon templates
        const dungeons = {
            catacombs: {
                name: "CATACOMBS OF RIVERWOOD",
                floors: 3,
                levelRange: "1-3",
                description: "ANCIENT BURIAL GROUNDS INFESTED WITH UNDEAD AND GOBLINS",
                monsters: ["SKELETON", "ZOMBIE", "GHOUL", "GOBLIN"],
                treasures: [50, 200],
                puzzles: ["ELEMENTAL", "COMBINATION"],
                special: "UNDEAD TAKE EXTRA DAMAGE FROM HOLY WEAPONS"
            },
            crystal: {
                name: "CRYSTAL CAVERNS",
                floors: 4,
                levelRange: "2-4",
                description: "GLOWING CAVES WITH PRECIOUS GEMS AND ELEMENTAL CREATURES",
                monsters: ["CRYSTAL_GOLEM", "EARTH_ELEMENTAL", "CAVE_TROLL", "BAT_SWARM"],
                treasures: [100, 300],
                puzzles: ["CRYSTAL", "REFLECTION"],
                special: "CRYSTAL MONSTERS ARE RESISTANT TO PHYSICAL ATTACKS"
            },
            fortress: {
                name: "FORGOTTEN FORTRESS",
                floors: 5,
                levelRange: "3-5",
                description: "RUINED STRONGHOLD GUARDED BY ORCS AND WAR MACHINES",
                monsters: ["ORC", "ORC_WARLORD", "WAR_GOLEM", "SPEAR_TRAP"],
                treasures: [150, 400],
                puzzles: ["LEVER", "PRESSURE_PLATE"],
                special: "MANY TRAPS AND SECRET PASSAGES"
            },
            labyrinth: {
                name: "MINOTAUR'S LABYRINTH",
                floors: 6,
                levelRange: "4-6",
                description: "MAZE-LIKE DUNGEON RULED BY MINOTAURS",
                monsters: ["MINOTAUR", "HARPIE", "CYCLOPS", "LIVING_Maze"],
                treasures: [200, 500],
                puzzles: ["MAZE", "RIDDLE"],
                special: "EASY TO GET LOST - MAPPING IS ESSENTIAL"
            },
            void: {
                name: "VOID TEMPLE",
                floors: 7,
                levelRange: "5+",
                description: "OTHERWORLLY TEMPLE INFESTED WITH DEMONS AND VOID CREATURES",
                monsters: ["DEMON", "VOID_WALKER", "SHADOW", "MIND_FLAYER"],
                treasures: [300, 750],
                puzzles: ["VOID", "SACRIFICE"],
                special: "DARKNESS DRAINS HEALTH AND MANA"
            }
        };

        // Monsters
        const monsters = {
            SKELETON: { name: "SKELETON", health: 30, damage: [3, 8], xp: 25, gold: [5, 15], level: 1, resistance: [] },
            ZOMBIE: { name: "ZOMBIE", health: 40, damage: [4, 10], xp: 30, gold: [8, 20], level: 1, resistance: ["PIERCE"] },
            GOBLIN: { name: "GOBLIN", health: 25, damage: [2, 6], xp: 20, gold: [3, 12], level: 1, resistance: [] },
            CRYSTAL_GOLEM: { name: "CRYSTAL GOLEM", health: 60, damage: [6, 14], xp: 50, gold: [20, 40], level: 2, resistance: ["SLASH", "PIERCE"] },
            EARTH_ELEMENTAL: { name: "EARTH ELEMENTAL", health: 80, damage: [8, 16], xp: 70, gold: [25, 50], level: 3, resistance: ["BLUNT", "FIRE"] },
            ORC: { name: "ORC", health: 45, damage: [5, 12], xp: 35, gold: [10, 25], level: 2, resistance: [] },
            ORC_WARLORD: { name: "ORC WARLORD", health: 100, damage: [10, 20], xp: 100, gold: [50, 100], level: 4, resistance: ["SLASH"] },
            MINOTAUR: { name: "MINOTAUR", health: 120, damage: [12, 24], xp: 150, gold: [75, 150], level: 5, resistance: ["PIERCE"] },
            DEMON: { name: "DEMON", health: 150, damage: [15, 30], xp: 200, gold: [100, 200], level: 6, resistance: ["FIRE", "ICE"] },
            VOID_WALKER: { name: "VOID WALKER", health: 100, damage: [10, 25], xp: 180, gold: [80, 180], level: 6, resistance: ["PHYSICAL"] }
        };

        // Initialize the game
        function initGame() {
            // Initialize party creation UI
            initPartyCreation();
            
            // Show creation screen
            showScreen('creationScreen');
            
            // Check for saved game
            const savedGame = localStorage.getItem('dungeonDelverSave');
            if (savedGame) {
                if (confirm("A SAVED GAME WAS FOUND. LOAD IT?")) {
                    const loadedState = JSON.parse(savedGame);
                    Object.assign(gameState, loadedState);
                    updateStatusBar();
                    showScreen('townScreen');
                    updatePartyDisplay();
                }
            }
        }

        // Initialize party creation
        function initPartyCreation() {
            const partyCreation = document.getElementById('partyCreation');
            partyCreation.innerHTML = '';
            
            // Create 4 party members
            for (let i = 0; i < 4; i++) {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'party-member';
                memberDiv.innerHTML = `
                    <h3>PARTY MEMBER ${i + 1}</h3>
                    <div style="margin: 10px 0;">
                        <label for="memberName${i}" style="display: block; margin-bottom: 5px; color: #ffaa00;">NAME:</label>
                        <input type="text" id="memberName${i}" placeholder="ADVENTURER NAME" value="ADVENTURER ${i + 1}" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #666; font-family: 'Press Start 2P'; font-size: 10px;">
                    </div>
                    <div style="margin: 10px 0;">
                        <label for="memberClass${i}" style="display: block; margin-bottom: 5px; color: #ffaa00;">CLASS:</label>
                        <select id="memberClass${i}" style="width: 100%; padding: 8px; background: #111; color: #fff; border: 1px solid #666; font-family: 'Press Start 2P'; font-size: 10px;">
                            <option value="warrior">WARRIOR</option>
                            <option value="rogue">ROGUE</option>
                            <option value="mage">MAGE</option>
                            <option value="cleric">CLERIC</option>
                        </select>
                    </div>
                    <div style="margin: 10px 0;">
                        <div style="color: #ffaa00; margin-bottom: 5px;">ATTRIBUTES (20 POINTS):</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 10px;">
                            <div>STRENGTH: <span id="str${i}" class="stat-value">10</span></div>
                            <div><button onclick="adjustStat(${i}, 'str', 1)" style="padding: 3px 6px; font-size: 8px;">+</button> <button onclick="adjustStat(${i}, 'str', -1)" style="padding: 3px 6px; font-size: 8px;">-</button></div>
                            <div>DEXTERITY: <span id="dex${i}" class="stat-value">10</span></div>
                            <div><button onclick="adjustStat(${i}, 'dex', 1)" style="padding: 3px 6px; font-size: 8px;">+</button> <button onclick="adjustStat(${i}, 'dex', -1)" style="padding: 3px 6px; font-size: 8px;">-</button></div>
                            <div>INTELLIGENCE: <span id="int${i}" class="stat-value">10</span></div>
                            <div><button onclick="adjustStat(${i}, 'int', 1)" style="padding: 3px 6px; font-size: 8px;">+</button> <button onclick="adjustStat(${i}, 'int', -1)" style="padding: 3px 6px; font-size: 8px;">-</button></div>
                            <div>VITALITY: <span id="vit${i}" class="stat-value">10</span></div>
                            <div><button onclick="adjustStat(${i}, 'vit', 1)" style="padding: 3px 6px; font-size: 8px;">+</button> <button onclick="adjustStat(${i}, 'vit', -1)" style="padding: 3px 6px; font-size: 8px;">-</button></div>
                        </div>
                        <div style="color: #ffaa00; margin-top: 5px;">POINTS LEFT: <span id="points${i}" class="stat-value">0</span></div>
                    </div>
                `;
                partyCreation.appendChild(memberDiv);
                
                // Initialize stats for this member
                updateMemberStats(i);
            }
        }

        // Update member stats display
        function updateMemberStats(memberIndex) {
            // This would track stat points in a real implementation
            // For now, just show the current values
            document.getElementById(`str${memberIndex}`).textContent = 10;
            document.getElementById(`dex${memberIndex}`).textContent = 10;
            document.getElementById(`int${memberIndex}`).textContent = 10;
            document.getElementById(`vit${memberIndex}`).textContent = 10;
            document.getElementById(`points${memberIndex}`).textContent = 0;
        }

        // Adjust stat (placeholder)
        function adjustStat(memberIndex, stat, amount) {
            // In a full implementation, this would adjust stats with point limits
            const current = parseInt(document.getElementById(`${stat}${memberIndex}`).textContent);
            const newValue = Math.max(5, Math.min(18, current + amount));
            document.getElementById(`${stat}${memberIndex}`).textContent = newValue;
            
            // Update points
            const pointsElement = document.getElementById(`points${memberIndex}`);
            // This would calculate remaining points
        }

        // Complete party creation
        function completePartyCreation() {
            // Create party members
            gameState.party = [];
            
            for (let i = 0; i < 4; i++) {
                const name = document.getElementById(`memberName${i}`).value || `ADVENTURER ${i + 1}`;
                const className = document.getElementById(`memberClass${i}`).value;
                const charClass = classes[className];
                
                const member = {
                    id: i,
                    name: name.toUpperCase(),
                    class: className,
                    className: charClass.name,
                    level: 1,
                    xp: 0,
                    nextLevelXP: 100,
                    health: 20 + (parseInt(document.getElementById(`vit${i}`).textContent) * 2),
                    maxHealth: 20 + (parseInt(document.getElementById(`vit${i}`).textContent) * 2),
                    mana: className === 'mage' ? 30 : className === 'cleric' ? 20 : 10,
                    maxMana: className === 'mage' ? 30 : className === 'cleric' ? 20 : 10,
                    strength: parseInt(document.getElementById(`str${i}`).textContent),
                    dexterity: parseInt(document.getElementById(`dex${i}`).textContent),
                    intelligence: parseInt(document.getElementById(`int${i}`).textContent),
                    vitality: parseInt(document.getElementById(`vit${i}`).textContent),
                    skills: [...charClass.skills],
                    equipment: [...charClass.startingEquipment],
                    status: [],
                    active: true
                };
                
                gameState.party.push(member);
            }
            
            // Update status bar
            updateStatusBar();
            updatePartyDisplay();
            
            // Go to town
            showScreen('townScreen');
            
            // Show welcome message
            document.getElementById('townMessage').innerHTML = 
                `<p class="heal">WELCOME TO RIVERWOOD, ADVENTURERS!</p>
                 <p>YOUR PARTY OF FOUR HAS ARRIVED. VISIT THE SHOPS TO PREPARE, THEN HEAD TO THE DUNGEON GATE.</p>`;
        }

        // Show a specific screen
        function showScreen(screenId) {
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => screen.classList.remove('active-screen'));
            document.getElementById(screenId).classList.add('active-screen');
            
            // Update specific screens
            if (screenId === 'townScreen') {
                updatePartyDisplay();
            } else if (screenId === 'dungeonScreen') {
                updateDungeonView();
                updatePartyDisplay();
                updateAutoMap();
            }
        }

        // Update status bar
        function updateStatusBar() {
            // Calculate total party health
            let totalHealth = 0;
            let totalMaxHealth = 0;
            
            gameState.party.forEach(member => {
                if (member.active) {
                    totalHealth += member.health;
                    totalMaxHealth += member.maxHealth;
                }
            });
            
            document.getElementById('partyHealth').textContent = totalHealth;
            document.getElementById('partyMaxHealth').textContent = totalMaxHealth;
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('torches').textContent = gameState.torches;
            
            if (gameState.currentDungeon) {
                document.getElementById('currentDungeon').textContent = dungeons[gameState.currentDungeon].name;
                document.getElementById('currentFloor').textContent = gameState.currentFloor;
                
                // Calculate map progress
                const totalTiles = gameState.dungeonGrid.length * (gameState.dungeonGrid[0]?.length || 0);
                const exploredPercent = totalTiles > 0 ? Math.round((gameState.exploredTiles.size / totalTiles) * 100) : 0;
                document.getElementById('mapProgress').textContent = exploredPercent;
            }
        }

        // Update party display
        function updatePartyDisplay() {
            const partyContainer = document.getElementById('partyContainer');
            if (!partyContainer) return;
            
            partyContainer.innerHTML = '';
            
            gameState.party.forEach((member, index) => {
                const memberDiv = document.createElement('div');
                memberDiv.className = `party-member ${member.active ? 'active' : ''}`;
                
                const healthPercent = (member.health / member.maxHealth) * 100;
                const manaPercent = (member.mana / member.maxMana) * 100;
                
                memberDiv.innerHTML = `
                    <div class="member-name">${member.name}</div>
                    <div class="member-class">${member.className} LVL ${member.level}</div>
                    <div>HP: ${member.health}/${member.maxHealth}</div>
                    <div class="member-health">
                        <div class="member-health-fill" style="width: ${healthPercent}%"></div>
                    </div>
                    <div>MP: ${member.mana}/${member.maxMana}</div>
                    <div class="member-mana">
                        <div class="member-mana-fill" style="width: ${manaPercent}%"></div>
                    </div>
                    <div class="member-status">${member.status.length > 0 ? member.status.join(', ') : 'HEALTHY'}</div>
                `;
                
                partyContainer.appendChild(memberDiv);
            });
        }

        // Town functions
        function goToTown() {
            gameState.currentDungeon = null;
            gameState.inCombat = false;
            gameState.inPuzzle = false;
            showScreen('townScreen');
        }

        function goToDungeonSelect() {
            showScreen('dungeonSelectScreen');
        }

        function goToShop() {
            showScreen('shopScreen');
        }

        function goToMagicShop() {
            showScreen('magicShopScreen');
        }

        function goToInn() {
            // Heal party
            gameState.party.forEach(member => {
                member.health = member.maxHealth;
                member.mana = member.maxMana;
                member.status = member.status.filter(s => !s.includes('POISON') && !s.includes('CURSED'));
            });
            
            // Cost: 10 gold per party member
            const cost = gameState.party.length * 10;
            
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                document.getElementById('townMessage').innerHTML = 
                    `<p class="heal">YOUR PARTY RESTS AT THE INN. ALL HP AND MP RESTORED. COST: ${cost} GOLD.</p>`;
            } else {
                // Free rest if can't afford
                document.getElementById('townMessage').innerHTML = 
                    `<p class="heal">THE INNKEEPER TAKES PITY ON YOU. YOUR PARTY RESTS FOR FREE.</p>`;
            }
            
            updateStatusBar();
            updatePartyDisplay();
        }

        function goToGuild() {
            // Simple quest system placeholder
            const quests = [
                "CLEAR THE CATACOMBS OF UNDEAD (200 GOLD REWARD)",
                "RETRIEVE THE CRYSTAL OF POWER FROM THE CAVERNS (500 GOLD)",
                "DEFEAT THE ORC WARLORD IN THE FORTRESS (1000 GOLD)",
                "SLAY THE MINOTAUR IN THE LABYRINTH (1500 GOLD)",
                "CLOSE THE VOID PORTAL IN THE TEMPLE (2500 GOLD)"
            ];
            
            const randomQuest = quests[Math.floor(Math.random() * quests.length)];
            document.getElementById('townMessage').innerHTML = 
                `<p class="quest">ADVENTURER'S GUILD</p>
                 <p>GUILDMASTER: "WE HAVE A CONTRACT FOR YOU."</p>
                 <p>${randomQuest}</p>
                 <p>RETURN WHEN THE TASK IS COMPLETE FOR YOUR REWARD.</p>`;
        }

        function goToTemple() {
            // Remove curses and blessings
            let cured = 0;
            gameState.party.forEach(member => {
                const hadCurses = member.status.filter(s => s.includes('CURSED')).length;
                member.status = member.status.filter(s => !s.includes('CURSED'));
                cured += hadCurses;
            });
            
            if (cured > 0) {
                const cost = cured * 50;
                if (gameState.gold >= cost) {
                    gameState.gold -= cost;
                    document.getElementById('townMessage').innerHTML = 
                        `<p class="heal">THE PRIESTS REMOVE ${cured} CURSE(S) FROM YOUR PARTY. COST: ${cost} GOLD.</p>`;
                } else {
                    document.getElementById('townMessage').innerHTML = 
                        `<p class="damage">YOU NEED ${cost} GOLD TO REMOVE THE CURSES.</p>`;
                }
            } else {
                document.getElementById('townMessage').innerHTML = 
                    `<p>HIGH PRIEST: "MAY THE LIGHT PROTECT YOU ON YOUR JOURNEY."</p>`;
            }
            
            updateStatusBar();
        }

        // Shop functions
        function buyItem(item, cost) {
            const shopMessage = document.getElementById('shopMessage');
            
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                
                switch(item) {
                    case 'torch':
                        gameState.torches += 1;
                        shopMessage.innerHTML = `<p class="heal">PURCHASED TORCH. YOU NOW HAVE ${gameState.torches} TORCHES.</p>`;
                        break;
                    case 'healing_potion':
                        gameState.inventory.potions.healing += 1;
                        shopMessage.innerHTML = `<p class="heal">PURCHASED HEALING POTION. TOTAL: ${gameState.inventory.potions.healing}</p>`;
                        break;
                    case 'antidote':
                        gameState.inventory.potions.antidote += 1;
                        shopMessage.innerHTML = `<p class="heal">PURCHASED ANTIDOTE. TOTAL: ${gameState.inventory.potions.antidote}</p>`;
                        break;
                    case 'iron_key':
                        gameState.inventory.keys.iron += 1;
                        shopMessage.innerHTML = `<p class="heal">PURCHASED IRON KEY. TOTAL: ${gameState.inventory.keys.iron}</p>`;
                        break;
                    case 'trap_kit':
                        // This would modify trap disarm chance
                        shopMessage.innerHTML = `<p class="heal">PURCHASED TRAP DISARMING KIT. +25% TO TRAP DISARMING.</p>`;
                        break;
                    case 'map_scroll':
                        gameState.inventory.scrolls.mapping += 1;
                        shopMessage.innerHTML = `<p class="heal">PURCHASED MAPPING SCROLL. TOTAL: ${gameState.inventory.scrolls.mapping}</p>`;
                        break;
                }
                
                updateStatusBar();
            } else {
                shopMessage.innerHTML = `<p class="damage">NOT ENOUGH GOLD. YOU NEED ${cost} GOLD.</p>`;
            }
        }

        function buySpell(spell) {
            const magicShopMessage = document.getElementById('magicShopMessage');
            const spellCosts = {
                light: 100,
                detect_traps: 150,
                detect_secret: 200,
                heal: 250,
                fireball: 300,
                identify: 350
            };
            
            const cost = spellCosts[spell] || 100;
            
            if (gameState.gold >= cost) {
                if (!gameState.spells.includes(spell)) {
                    gameState.gold -= cost;
                    gameState.spells.push(spell);
                    magicShopMessage.innerHTML = `<p class="heal">LEARNED SPELL: ${spell.toUpperCase()}. COST: ${cost} GOLD.</p>`;
                    updateStatusBar();
                } else {
                    magicShopMessage.innerHTML = `<p class="damage">YOU ALREADY KNOW THIS SPELL.</p>`;
                }
            } else {
                magicShopMessage.innerHTML = `<p class="damage">NOT ENOUGH GOLD. YOU NEED ${cost} GOLD.</p>`;
            }
        }

        // Dungeon functions
        function enterDungeon(dungeonId) {
            gameState.currentDungeon = dungeonId;
            gameState.currentFloor = 1;
            gameState.playerX = 5;
            gameState.playerY = 5;
            gameState.playerDirection = 0;
            gameState.exploredTiles.clear();
            gameState.discoveredSecrets.clear();
            gameState.discoveredTraps.clear();
            gameState.totalTurns = 0;
            
            // Generate dungeon floor
            generateDungeonFloor();
            
            // Update UI
            document.getElementById('dungeonTitle').textContent = `${dungeons[dungeonId].name} - FLOOR ${gameState.currentFloor}`;
            
            // Show dungeon screen
            showScreen('dungeonScreen');
            updateDungeonView();
            updateAutoMap();
            
            // Log entry
            document.getElementById('combatLog').innerHTML = 
                `<p>YOU ENTER THE ${dungeons[dungeonId].name}...</p>
                 <p>${dungeons[dungeonId].description}</p>`;
        }

        function generateDungeonFloor() {
            // Create a 11x11 grid dungeon
            const size = 11;
            gameState.dungeonGrid = [];
            
            // Initialize with walls
            for (let y = 0; y < size; y++) {
                gameState.dungeonGrid[y] = [];
                for (let x = 0; x < size; x++) {
                    // Border walls
                    if (x === 0 || y === 0 || x === size - 1 || y === size - 1) {
                        gameState.dungeonGrid[y][x] = TILE.WALL;
                    } else {
                        // Random floor or wall
                        gameState.dungeonGrid[y][x] = Math.random() > 0.3 ? TILE.FLOOR : TILE.WALL;
                    }
                }
            }
            
            // Ensure start position is floor
            gameState.dungeonGrid[gameState.playerY][gameState.playerX] = TILE.FLOOR;
            
            // Add some doors
            for (let i = 0; i < 3; i++) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                if (gameState.dungeonGrid[y][x] === TILE.FLOOR) {
                    gameState.dungeonGrid[y][x] = TILE.DOOR;
                }
            }
            
            // Add stairs down (except on last floor)
            if (gameState.currentFloor < dungeons[gameState.currentDungeon].floors) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    if (gameState.dungeonGrid[y][x] === TILE.FLOOR && 
                        (Math.abs(x - gameState.playerX) > 3 || Math.abs(y - gameState.playerY) > 3)) {
                        gameState.dungeonGrid[y][x] = TILE.STAIRS_DOWN;
                        placed = true;
                    }
                }
            } else {
                // Last floor has exit instead
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    if (gameState.dungeonGrid[y][x] === TILE.FLOOR && 
                        (Math.abs(x - gameState.playerX) > 3 || Math.abs(y - gameState.playerY) > 3)) {
                        gameState.dungeonGrid[y][x] = TILE.EXIT;
                        placed = true;
                    }
                }
            }
            
            // Add monsters
            const dungeon = dungeons[gameState.currentDungeon];
            const monsterCount = 5 + gameState.currentFloor;
            
            for (let i = 0; i < monsterCount; i++) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    if (gameState.dungeonGrid[y][x] === TILE.FLOOR && 
                        (Math.abs(x - gameState.playerX) > 2 || Math.abs(y - gameState.playerY) > 2)) {
                        gameState.dungeonGrid[y][x] = TILE.MONSTER;
                        placed = true;
                    }
                }
            }
            
            // Add treasures
            const treasureCount = 3 + Math.floor(gameState.currentFloor / 2);
            
            for (let i = 0; i < treasureCount; i++) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    if (gameState.dungeonGrid[y][x] === TILE.FLOOR) {
                        gameState.dungeonGrid[y][x] = TILE.TREASURE;
                        placed = true;
                    }
                }
            }
            
            // Add traps (hidden initially)
            const trapCount = 2 + gameState.currentFloor;
            
            for (let i = 0; i < trapCount; i++) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * (size - 2)) + 1;
                    const y = Math.floor(Math.random() * (size - 2)) + 1;
                    if (gameState.dungeonGrid[y][x] === TILE.FLOOR) {
                        gameState.dungeonGrid[y][x] = TILE.TRAP;
                        placed = true;
                    }
                }
            }
            
            // Add one puzzle per floor
            let placed = false;
            while (!placed) {
                const x = Math.floor(Math.random() * (size - 2)) + 1;
                const y = Math.floor(Math.random() * (size - 2)) + 1;
                if (gameState.dungeonGrid[y][x] === TILE.FLOOR && 
                    (Math.abs(x - gameState.playerX) > 2 || Math.abs(y - gameState.playerY) > 2)) {
                    gameState.dungeonGrid[y][x] = TILE.PUZZLE;
                    placed = true;
                }
            }
            
            // Mark starting position as explored
            gameState.exploredTiles.add(`${gameState.playerX},${gameState.playerY}`);
        }

        function updateDungeonView() {
            const firstPersonView = document.getElementById('firstPersonView');
            const direction = directions[gameState.playerDirection];
            
            // Get tiles in front, left, and right
            const frontTile = getTileInDirection(0);
            const leftTile = getTileInDirection(-1);
            const rightTile = getTileInDirection(1);
            
            // Create first-person view
            let viewHTML = '';
            
            // Ceiling
            viewHTML += `<div style="color: #444; margin-bottom: 10px;">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</div>`;
            
            // Walls and floor
            for (let row = 0; row < 5; row++) {
                let rowHTML = '';
                
                if (row === 0) {
                    // Far wall
                    if (frontTile.type === TILE.WALL) {
                        rowHTML = `<span class="wall">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span>`;
                    } else if (frontTile.type === TILE.DOOR) {
                        rowHTML = `<span class="door">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê DOOR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</span>`;
                    } else if (frontTile.type === TILE.MONSTER) {
                        rowHTML = `<span class="monster-tile">!!!!! MONSTER AHEAD !!!!!!!!!!!</span>`;
                    } else if (frontTile.type === TILE.TREASURE) {
                        rowHTML = `<span class="treasure-tile">$$$$$ TREASURE AHEAD $$$$$$$$$$</span>`;
                    } else if (frontTile.type === TILE.EXIT) {
                        rowHTML = `<span class="exit-tile">>>>> EXIT AHEAD <<<<<<<<<<<<<</span>`;
                    } else {
                        rowHTML = `<span class="floor">................................</span>`;
                    }
                } else if (row === 2) {
                    // Middle row (player level)
                    const leftChar = leftTile.type === TILE.WALL ? '‚ñà' : ' ';
                    const rightChar = rightTile.type === TILE.WALL ? '‚ñà' : ' ';
                    rowHTML = `<span class="wall">${leftChar}</span>`;
                    rowHTML += `<span class="player-tile"> YOU face ${direction.name} </span>`;
                    rowHTML += `<span class="wall">${rightChar}</span>`;
                } else {
                    // Other rows
                    rowHTML = `<span class="floor">................................</span>`;
                }
                
                viewHTML += `<div style="margin-bottom: 5px;">${rowHTML}</div>`;
            }
            
            // Floor
            viewHTML += `<div style="color: #aaa; margin-top: 10px;">................................</div>`;
            
            firstPersonView.innerHTML = viewHTML;
            
            // Update dungeon info
            document.getElementById('infoFloor').textContent = gameState.currentFloor;
            document.getElementById('infoX').textContent = gameState.playerX;
            document.getElementById('infoY').textContent = gameState.playerY;
            document.getElementById('infoDirection').textContent = direction.name;
            document.getElementById('infoTurns').textContent = gameState.totalTurns;
            
            // Count monsters nearby
            const monsterCount = countNearbyMonsters();
            document.getElementById('infoMonsters').textContent = monsterCount;
            
            // Count detected traps
            const trapCount = gameState.discoveredTraps.size;
            document.getElementById('infoTraps').textContent = trapCount;
        }

        function getTileInDirection(offset) {
            const directionIndex = (gameState.playerDirection + offset + 4) % 4;
            const direction = directions[directionIndex];
            const x = gameState.playerX + direction.x;
            const y = gameState.playerY + direction.y;
            
            // Check bounds
            if (x < 0 || y < 0 || y >= gameState.dungeonGrid.length || x >= gameState.dungeonGrid[0].length) {
                return { type: TILE.WALL, x, y };
            }
            
            return { type: gameState.dungeonGrid[y][x], x, y };
        }

        function countNearbyMonsters() {
            let count = 0;
            const range = 3;
            
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    const x = gameState.playerX + dx;
                    const y = gameState.playerY + dy;
                    
                    if (x >= 0 && y >= 0 && y < gameState.dungeonGrid.length && x < gameState.dungeonGrid[0].length) {
                        if (gameState.dungeonGrid[y][x] === TILE.MONSTER) {
                            count++;
                        }
                    }
                }
            }
            
            return count;
        }

        // Movement functions
        function moveForward() {
            const direction = directions[gameState.playerDirection];
            const newX = gameState.playerX + direction.x;
            const newY = gameState.playerY + direction.y;
            
            // Check bounds
            if (newX < 0 || newY < 0 || 
                newY >= gameState.dungeonGrid.length || 
                newX >= gameState.dungeonGrid[0].length) {
                logMessage("CANNOT MOVE - SOLID WALL");
                return;
            }
            
            const targetTile = gameState.dungeonGrid[newY][newX];
            
            // Check what's in front
            switch(targetTile) {
                case TILE.WALL:
                    logMessage("SOLID WALL - CANNOT PASS");
                    break;
                    
                case TILE.DOOR:
                    // Check if we have a key or can open it
                    if (gameState.inventory.keys.iron > 0) {
                        gameState.inventory.keys.iron--;
                        gameState.dungeonGrid[newY][newX] = TILE.FLOOR;
                        moveTo(newX, newY);
                        logMessage("UNLOCKED DOOR WITH IRON KEY");
                    } else {
                        logMessage("DOOR IS LOCKED. NEED IRON KEY.");
                    }
                    break;
                    
                case TILE.MONSTER:
                    // Start combat
                    startCombat(newX, newY);
                    break;
                    
                case TILE.TREASURE:
                    collectTreasure(newX, newY);
                    moveTo(newX, newY);
                    break;
                    
                case TILE.TRAP:
                    triggerTrap(newX, newY);
                    break;
                    
                case TILE.STAIRS_DOWN:
                    descendFloor();
                    break;
                    
                case TILE.EXIT:
                    completeDungeon();
                    break;
                    
                case TILE.PUZZLE:
                    startPuzzle(newX, newY);
                    break;
                    
                default:
                    // Normal floor tile
                    moveTo(newX, newY);
                    break;
            }
            
            gameState.totalTurns++;
            updateDungeonView();
            updateAutoMap();
            updateStatusBar();
        }

        function moveBackward() {
            // Turn around 180 degrees
            gameState.playerDirection = (gameState.playerDirection + 2) % 4;
            updateDungeonView();
            gameState.totalTurns++;
        }

        function turnLeft() {
            gameState.playerDirection = (gameState.playerDirection + 3) % 4;
            updateDungeonView();
            gameState.totalTurns++;
        }

        function turnRight() {
            gameState.playerDirection = (gameState.playerDirection + 1) % 4;
            updateDungeonView();
            gameState.totalTurns++;
        }

        function moveTo(x, y) {
            gameState.playerX = x;
            gameState.playerY = y;
            
            // Mark as explored
            gameState.exploredTiles.add(`${x},${y}`);
            
            // Check for hidden traps (if not already discovered)
            const tileKey = `${x},${y}`;
            if (gameState.dungeonGrid[y][x] === TILE.TRAP && !gameState.discoveredTraps.has(tileKey)) {
                triggerTrap(x, y);
            }
        }

        function searchArea() {
            logMessage("SEARCHING THE AREA...");
            
            // Chance to find secrets or traps
            const searchRoll = Math.random();
            
            if (searchRoll < 0.3) {
                // Find something
                const findRoll = Math.random();
                
                if (findRoll < 0.4) {
                    // Find gold
                    const goldFound = Math.floor(Math.random() * 50) + 10;
                    gameState.gold += goldFound;
                    logMessage(`FOUND ${goldFound} GOLD SCATTERED ON THE FLOOR!`);
                } else if (findRoll < 0.7) {
                    // Find hidden door
                    logMessage("FOUND A HIDDEN DOOR!");
                    // This would reveal a secret door in the grid
                } else {
                    // Find trap
                    discoverTraps();
                }
            } else {
                logMessage("FOUND NOTHING OF INTEREST.");
            }
            
            gameState.totalTurns++;
            updateStatusBar();
        }

        function discoverTraps() {
            // Reveal traps in adjacent tiles
            let trapsFound = 0;
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const x = gameState.playerX + dx;
                    const y = gameState.playerY + dy;
                    
                    if (x >= 0 && y >= 0 && y < gameState.dungeonGrid.length && x < gameState.dungeonGrid[0].length) {
                        if (gameState.dungeonGrid[y][x] === TILE.TRAP) {
                            const tileKey = `${x},${y}`;
                            if (!gameState.discoveredTraps.has(tileKey)) {
                                gameState.discoveredTraps.add(tileKey);
                                trapsFound++;
                            }
                        }
                    }
                }
            }
            
            if (trapsFound > 0) {
                logMessage(`DISCOVERED ${trapsFound} TRAP(S) NEARBY!`);
            } else {
                logMessage("NO TRAPS FOUND IN THIS AREA.");
            }
        }

        function restInDungeon() {
            // Rest heals party but may attract monsters
            logMessage("PARTY TAKES A SHORT REST...");
            
            // Heal each party member slightly
            gameState.party.forEach(member => {
                if (member.active) {
                    const healAmount = Math.floor(member.maxHealth * 0.1);
                    member.health = Math.min(member.maxHealth, member.health + healAmount);
                    
                    const manaRestore = Math.floor(member.maxMana * 0.2);
                    member.mana = Math.min(member.maxMana, member.mana + manaRestore);
                }
            });
            
            // Chance for random encounter
            if (Math.random() < 0.3) {
                logMessage("MONSTERS HEARD YOU RESTING!");
                // Start combat with a random monster
                startRandomCombat();
            }
            
            gameState.totalTurns += 3; // Resting takes time
            updatePartyDisplay();
            updateStatusBar();
        }

        function useSkill(skill) {
            const combatLog = document.getElementById('combatLog');
            
            if (!gameState.spells.includes(skill)) {
                logMessage(`YOU DON'T KNOW THE ${skill.toUpperCase()} SPELL.`);
                return;
            }
            
            // Find a mage or cleric with enough mana
            const caster = gameState.party.find(member => 
                member.active && 
                (member.class === 'mage' || member.class === 'cleric') && 
                member.mana >= 10
            );
            
            if (!caster) {
                logMessage("NO CASTER WITH ENOUGH MANA AVAILABLE.");
                return;
            }
            
            caster.mana -= 10;
            
            switch(skill) {
                case 'detect_traps':
                    discoverTraps();
                    logMessage(`${caster.name} CASTS DETECT TRAPS!`);
                    break;
                    
                case 'detect_secret':
                    // Reveal secret doors
                    logMessage(`${caster.name} CASTS DETECT SECRET! SECRET DOORS REVEALED.`);
                    // This would reveal secret doors in the auto-map
                    break;
                    
                case 'light':
                    logMessage(`${caster.name} CASTS LIGHT! AREA ILLUMINATED.`);
                    // This would reveal more of the map
                    revealArea();
                    break;
                    
                case 'heal':
                    // Heal party
                    gameState.party.forEach(member => {
                        if (member.active) {
                            member.health = Math.min(member.maxHealth, member.health + 20);
                        }
                    });
                    logMessage(`${caster.name} CASTS HEAL! PARTY RESTORED.`);
                    updatePartyDisplay();
                    break;
            }
            
            gameState.totalTurns++;
            updateStatusBar();
        }

        function revealArea() {
            // Reveal tiles in a 3x3 area around player
            for (let dy = -2; dy <= 2; dy++) {
                for (let dx = -2; dx <= 2; dx++) {
                    const x = gameState.playerX + dx;
                    const y = gameState.playerY + dy;
                    
                    if (x >= 0 && y >= 0 && y < gameState.dungeonGrid.length && x < gameState.dungeonGrid[0].length) {
                        gameState.exploredTiles.add(`${x},${y}`);
                    }
                }
            }
            
            updateAutoMap();
        }

        function useTorch() {
            if (gameState.torches > 0) {
                gameState.torches--;
                revealArea();
                logMessage("LIT A TORCH. AREA ILLUMINATED.");
                updateStatusBar();
            } else {
                logMessage("NO TORCHES LEFT!");
            }
        }

        function fleeToTown() {
            if (confirm("FLEE THE DUNGEON AND RETURN TO TOWN?")) {
                const goldLost = Math.floor(gameState.gold * 0.1);
                gameState.gold -= goldLost;
                
                logMessage(`FLED THE DUNGEON! LOST ${goldLost} GOLD IN THE ESCAPE.`);
                
                setTimeout(() => {
                    goToTown();
                    document.getElementById('townMessage').innerHTML = 
                        `<p class="damage">YOUR PARTY RETREATS TO TOWN. LOST ${goldLost} GOLD DURING THE ESCAPE.</p>`;
                }, 1000);
            }
        }

        // Auto-map functions
        function updateAutoMap() {
            const automapGrid = document.getElementById('automapGrid');
            if (!automapGrid) return;
            
            automapGrid.innerHTML = '';
            const size = gameState.dungeonGrid.length;
            const center = Math.floor(size / 2);
            const viewRadius = 4;
            
            // Create 9x9 map centered on player
            for (let y = -viewRadius; y <= viewRadius; y++) {
                for (let x = -viewRadius; x <= viewRadius; x++) {
                    const mapX = gameState.playerX + x;
                    const mapY = gameState.playerY + y;
                    const cell = document.createElement('div');
                    cell.className = 'map-cell';
                    
                    // Check if position is valid
                    if (mapX >= 0 && mapY >= 0 && mapY < size && mapX < size) {
                        const isExplored = gameState.exploredTiles.has(`${mapX},${mapY}`);
                        const tile = gameState.dungeonGrid[mapY][mapX];
                        
                        if (mapX === gameState.playerX && mapY === gameState.playerY) {
                            // Player position
                            cell.className += ' map-player';
                            cell.textContent = 'P';
                        } else if (!isExplored) {
                            // Unexplored
                            cell.className += ' map-wall';
                        } else {
                            // Explored tile
                            switch(tile) {
                                case TILE.WALL:
                                    cell.className += ' map-wall';
                                    cell.textContent = '‚ñà';
                                    break;
                                case TILE.DOOR:
                                    cell.className += ' map-door';
                                    cell.textContent = 'D';
                                    break;
                                case TILE.MONSTER:
                                    cell.className += ' map-monster';
                                    cell.textContent = 'M';
                                    break;
                                case TILE.TREASURE:
                                    cell.className += ' map-treasure';
                                    cell.textContent = 'T';
                                    break;
                                case TILE.EXIT:
                                case TILE.STAIRS_DOWN:
                                    cell.className += ' map-exit';
                                    cell.textContent = 'E';
                                    break;
                                case TILE.TRAP:
                                    if (gameState.discoveredTraps.has(`${mapX},${mapY}`)) {
                                        cell.className += ' map-treasure'; // Different color for traps
                                        cell.textContent = 'X';
                                    } else {
                                        cell.className += ' map-floor';
                                        cell.textContent = '.';
                                    }
                                    break;
                                default:
                                    cell.className += ' map-floor';
                                    cell.textContent = '.';
                            }
                        }
                    } else {
                        // Out of bounds
                        cell.className += ' map-wall';
                    }
                    
                    automapGrid.appendChild(cell);
                }
            }
            
            // Set grid columns
            automapGrid.style.gridTemplateColumns = `repeat(${viewRadius * 2 + 1}, 20px)`;
        }

        // Combat functions
        function startCombat(x, y) {
            // Get random monster for this dungeon
            const dungeon = dungeons[gameState.currentDungeon];
            const monsterType = dungeon.monsters[Math.floor(Math.random() * dungeon.monsters.length)];
            gameState.currentEnemy = { ...monsters[monsterType], x, y };
            gameState.inCombat = true;
            
            // Remove monster from grid
            gameState.dungeonGrid[y][x] = TILE.FLOOR;
            
            // Update combat display
            document.getElementById('combatView').innerHTML = `
                <div style="font-size: 24px; color: #ff3355; margin: 20px 0;">
                    ${gameState.currentEnemy.name} APPEARS!
                </div>
                <div style="background-color: #330000; border: 2px solid #ff3355; padding: 15px; display: inline-block;">
                    <h3>${gameState.currentEnemy.name}</h3>
                    <p>HEALTH: ${gameState.currentEnemy.health}</p>
                    <p>DAMAGE: ${gameState.currentEnemy.damage[0]}-${gameState.currentEnemy.damage[1]}</p>
                    <p>LEVEL: ${gameState.currentEnemy.level}</p>
                </div>
            `;
            
            // Update combat party display
            updateCombatParty();
            
            // Show combat screen
            showScreen('combatScreen');
            
            // Initial log message
            const battleLog = document.getElementById('battleLog');
            battleLog.innerHTML = `<p>COMBAT STARTED! ${gameState.currentEnemy.name} ATTACKS!</p>`;
        }

        function startRandomCombat() {
            // Start combat with a random monster from current dungeon
            const dungeon = dungeons[gameState.currentDungeon];
            const monsterType = dungeon.monsters[Math.floor(Math.random() * dungeon.monsters.length)];
            gameState.currentEnemy = { ...monsters[monsterType], x: gameState.playerX, y: gameState.playerY };
            gameState.inCombat = true;
            
            // Show combat screen
            showScreen('combatScreen');
            
            // Update displays
            document.getElementById('combatView').innerHTML = `
                <div style="font-size: 24px; color: #ff3355; margin: 20px 0;">
                    ${gameState.currentEnemy.name} AMBUSHES YOU!
                </div>
                <div style="background-color: #330000; border: 2px solid #ff3355; padding: 15px; display: inline-block;">
                    <h3>${gameState.currentEnemy.name}</h3>
                    <p>HEALTH: ${gameState.currentEnemy.health}</p>
                </div>
            `;
            
            updateCombatParty();
            
            const battleLog = document.getElementById('battleLog');
            battleLog.innerHTML = `<p>AMBUSH! ${gameState.currentEnemy.name} ATTACKS!</p>`;
        }

        function updateCombatParty() {
            const combatParty = document.getElementById('combatParty');
            if (!combatParty) return;
            
            combatParty.innerHTML = '';
            
            gameState.party.forEach((member, index) => {
                const memberDiv = document.createElement('div');
                memberDiv.className = `party-member ${member.active ? 'active' : ''}`;
                
                const healthPercent = (member.health / member.maxHealth) * 100;
                const manaPercent = (member.mana / member.maxMana) * 100;
                
                memberDiv.innerHTML = `
                    <div class="member-name">${member.name}</div>
                    <div class="member-class">${member.className}</div>
                    <div>HP: ${member.health}/${member.maxHealth}</div>
                    <div class="member-health">
                        <div class="member-health-fill" style="width: ${healthPercent}%"></div>
                    </div>
                    <div>MP: ${member.mana}/${member.maxMana}</div>
                    <div class="member-mana">
                        <div class="member-mana-fill" style="width: ${manaPercent}%"></div>
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="partyMemberAction(${index}, 'attack')" style="padding: 5px 10px; font-size: 10px;">ATTACK</button>
                        <button onclick="partyMemberAction(${index}, 'defend')" style="padding: 5px 10px; font-size: 10px;">DEFEND</button>
                    </div>
                `;
                
                combatParty.appendChild(memberDiv);
            });
        }

        function attackEnemy() {
            if (!gameState.inCombat || !gameState.currentEnemy) return;
            
            const battleLog = document.getElementById('battleLog');
            
            // Each party member attacks
            gameState.party.forEach((member, index) => {
                if (member.active && member.health > 0) {
                    // Calculate damage based on class and stats
                    let damage = 0;
                    if (member.class === 'warrior') {
                        damage = Math.floor(Math.random() * 8) + 4 + Math.floor(member.strength / 3);
                    } else if (member.class === 'rogue') {
                        damage = Math.floor(Math.random() * 6) + 3 + Math.floor(member.dexterity / 3);
                    } else {
                        damage = Math.floor(Math.random() * 4) + 2;
                    }
                    
                    gameState.currentEnemy.health -= damage;
                    battleLog.innerHTML += `<p>${member.name} HITS FOR <span class="damage">${damage}</span> DAMAGE.</p>`;
                }
            });
            
            // Check if enemy is defeated
            if (gameState.currentEnemy.health <= 0) {
                enemyDefeated();
                return;
            }
            
            // Enemy attacks back
            enemyAttack();
            
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        function partyMemberAction(index, action) {
            if (!gameState.inCombat || !gameState.currentEnemy) return;
            
            const member = gameState.party[index];
            if (!member.active || member.health <= 0) return;
            
            const battleLog = document.getElementById('battleLog');
            
            switch(action) {
                case 'attack':
                    let damage = 0;
                    if (member.class === 'warrior') {
                        damage = Math.floor(Math.random() * 10) + 5 + Math.floor(member.strength / 2);
                    } else if (member.class === 'rogue') {
                        damage = Math.floor(Math.random() * 8) + 4 + Math.floor(member.dexterity / 2);
                    } else if (member.class === 'mage') {
                        if (member.mana >= 5) {
                            member.mana -= 5;
                            damage = Math.floor(Math.random() * 12) + 8 + Math.floor(member.intelligence / 2);
                            battleLog.innerHTML += `<p>${member.name} CASTS A SPELL!</p>`;
                        } else {
                            damage = Math.floor(Math.random() * 3) + 1;
                        }
                    } else if (member.class === 'cleric') {
                        damage = Math.floor(Math.random() * 6) + 3 + Math.floor(member.intelligence / 3);
                    }
                    
                    gameState.currentEnemy.health -= damage;
                    battleLog.innerHTML += `<p>${member.name} HITS FOR <span class="damage">${damage}</span> DAMAGE.</p>`;
                    break;
                    
                case 'defend':
                    member.status.push('DEFENDING');
                    battleLog.innerHTML += `<p>${member.name} TAKES A DEFENSIVE STANCE.</p>`;
                    break;
            }
            
            // Check if enemy is defeated
            if (gameState.currentEnemy.health <= 0) {
                enemyDefeated();
                return;
            }
            
            // Enemy attacks after all party actions
            setTimeout(() => {
                enemyAttack();
            }, 100);
            
            battleLog.scrollTop = battleLog.scrollHeight;
            updateCombatParty();
        }

        function enemyAttack() {
            if (!gameState.currentEnemy) return;
            
            const battleLog = document.getElementById('battleLog');
            const damageRange = gameState.currentEnemy.damage;
            const damage = Math.floor(Math.random() * (damageRange[1] - damageRange[0] + 1)) + damageRange[0];
            
            // Attack random party member
            const activeMembers = gameState.party.filter(m => m.active && m.health > 0);
            if (activeMembers.length === 0) return;
            
            const target = activeMembers[Math.floor(Math.random() * activeMembers.length)];
            const targetIndex = gameState.party.findIndex(m => m.id === target.id);
            
            // Check if defending
            const isDefending = target.status.includes('DEFENDING');
            const actualDamage = isDefending ? Math.floor(damage / 2) : damage;
            
            target.health -= actualDamage;
            battleLog.innerHTML += `<p>${gameState.currentEnemy.name} HITS ${target.name} FOR <span class="damage">${actualDamage}</span> DAMAGE${isDefending ? ' (DEFENDED!)' : ''}.</p>`;
            
            // Remove defend status
            const memberIndex = gameState.party.findIndex(m => m.id === target.id);
            if (memberIndex !== -1) {
                gameState.party[memberIndex].status = gameState.party[memberIndex].status.filter(s => s !== 'DEFENDING');
            }
            
            // Check if party member is down
            if (target.health <= 0) {
                target.health = 0;
                battleLog.innerHTML += `<p>${target.name} HAS BEEN KNOCKED OUT!</p>`;
                
                // Check if all party members are down
                const aliveMembers = gameState.party.filter(m => m.active && m.health > 0);
                if (aliveMembers.length === 0) {
                    gameOver();
                    return;
                }
            }
            
            updateCombatParty();
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        function enemyDefeated() {
            const battleLog = document.getElementById('battleLog');
            const xp = gameState.currentEnemy.xp;
            const gold = Math.floor(Math.random() * (gameState.currentEnemy.gold[1] - gameState.currentEnemy.gold[0] + 1)) + gameState.currentEnemy.gold[0];
            
            gameState.monstersSlain++;
            gameState.gold += gold;
            
            // Distribute XP to party
            gameState.party.forEach(member => {
                if (member.active && member.health > 0) {
                    member.xp += Math.floor(xp / 4);
                    // Check level up
                    if (member.xp >= member.nextLevelXP) {
                        levelUp(member);
                    }
                }
            });
            
            battleLog.innerHTML += `<p class="heal">${gameState.currentEnemy.name} DEFEATED!</p>`;
            battleLog.innerHTML += `<p>GAINED ${xp} XP AND ${gold} GOLD.</p>`;
            
            // End combat
            setTimeout(() => {
                gameState.inCombat = false;
                gameState.currentEnemy = null;
                showScreen('dungeonScreen');
                updateStatusBar();
                updatePartyDisplay();
            }, 2000);
        }

        function levelUp(member) {
            member.level++;
            member.xp -= member.nextLevelXP;
            member.nextLevelXP = Math.floor(member.nextLevelXP * 1.5);
            
            // Increase stats
            member.maxHealth += classes[member.class].hpPerLevel;
            member.health = member.maxHealth;
            member.maxMana += classes[member.class].mpPerLevel;
            member.mana = member.maxMana;
            
            // Log message
            const combatLog = document.getElementById('combatLog');
            if (combatLog) {
                combatLog.innerHTML += `<p class="heal">${member.name} REACHED LEVEL ${member.level}!</p>`;
            }
        }

        function fleeCombat() {
            const battleLog = document.getElementById('battleLog');
            const fleeChance = 0.5; // 50% base chance
            
            if (Math.random() < fleeChance) {
                battleLog.innerHTML += `<p class="heal">SUCCESSFULLY FLED FROM COMBAT!</p>`;
                
                setTimeout(() => {
                    gameState.inCombat = false;
                    gameState.currentEnemy = null;
                    showScreen('dungeonScreen');
                }, 1500);
            } else {
                battleLog.innerHTML += `<p class="damage">FAILED TO FLEE!</p>`;
                enemyAttack();
            }
        }

        // Treasure functions
        function collectTreasure(x, y) {
            const dungeon = dungeons[gameState.currentDungeon];
            const gold = Math.floor(Math.random() * (dungeon.treasures[1] - dungeon.treasures[0] + 1)) + dungeon.treasures[0];
            
            gameState.gold += gold;
            gameState.treasureFound += gold;
            gameState.dungeonGrid[y][x] = TILE.FLOOR;
            
            logMessage(`FOUND TREASURE! GAINED ${gold} GOLD.`);
            updateStatusBar();
        }

        function triggerTrap(x, y) {
            const tileKey = `${x},${y}`;
            
            // If trap already discovered, can attempt to disarm
            if (gameState.discoveredTraps.has(tileKey)) {
                logMessage("DISARMED TRAP BEFORE TRIGGERING.");
                gameState.dungeonGrid[y][x] = TILE.FLOOR;
                return;
            }
            
            // Discover trap
            gameState.discoveredTraps.add(tileKey);
            
            // Trigger trap effect
            const trapTypes = ['DART', 'PIT', 'POISON_GAS', 'FIRE_JET'];
            const trapType = trapTypes[Math.floor(Math.random() * trapTypes.length)];
            
            let damage = 0;
            let statusEffect = '';
            
            switch(trapType) {
                case 'DART':
                    damage = Math.floor(Math.random() * 15) + 5;
                    logMessage(`DART TRAP! PARTY TAKES ${damage} DAMAGE.`);
                    break;
                case 'PIT':
                    damage = Math.floor(Math.random() * 20) + 10;
                    logMessage(`PIT TRAP! PARTY FALLS AND TAKES ${damage} DAMAGE.`);
                    break;
                case 'POISON_GAS':
                    damage = Math.floor(Math.random() * 10) + 5;
                    statusEffect = 'POISONED';
                    logMessage(`POISON GAS TRAP! PARTY TAKES ${damage} DAMAGE AND IS POISONED.`);
                    break;
                case 'FIRE_JET':
                    damage = Math.floor(Math.random() * 25) + 15;
                    logMessage(`FIRE JET TRAP! PARTY TAKES ${damage} DAMAGE.`);
                    break;
            }
            
            // Apply damage to party
            gameState.party.forEach(member => {
                if (member.active) {
                    member.health -= damage;
                    if (statusEffect && member.health > 0) {
                        member.status.push(statusEffect);
                    }
                }
            });
            
            // Remove trap
            gameState.dungeonGrid[y][x] = TILE.FLOOR;
            
            // Check for party wipe
            const aliveMembers = gameState.party.filter(m => m.active && m.health > 0);
            if (aliveMembers.length === 0) {
                gameOver();
                return;
            }
            
            updatePartyDisplay();
            updateStatusBar();
        }

        // Puzzle functions
        function startPuzzle(x, y) {
            gameState.inPuzzle = true;
            gameState.currentPuzzle = {
                x: x,
                y: y,
                type: 'ELEMENTAL',
                solution: [0, 1, 2, 3] // Simple pattern
            };
            
            document.getElementById('puzzleDescription').textContent = 
                "AN ANCIENT MECHANISM WITH FOUR CRYSTALS BLOCKS YOUR PATH. ARRANGE THE ELEMENTS IN THE CORRECT ORDER: FIRE, WATER, EARTH, AIR.";
            
            // Create puzzle interface
            const puzzleElements = document.getElementById('puzzleElements');
            puzzleElements.innerHTML = '';
            
            const elements = ['FIRE', 'WATER', 'EARTH', 'AIR'];
            const shuffled = [...elements].sort(() => Math.random() - 0.5);
            
            shuffled.forEach((element, index) => {
                const elementDiv = document.createElement('div');
                elementDiv.className = `puzzle-element ${element.toLowerCase()}`;
                elementDiv.textContent = element.charAt(0);
                elementDiv.dataset.element = element;
                elementDiv.onclick = () => cycleElement(elementDiv);
                puzzleElements.appendChild(elementDiv);
            });
            
            showScreen('puzzleScreen');
        }

        function cycleElement(elementDiv) {
            const elements = ['FIRE', 'WATER', 'EARTH', 'AIR'];
            const current = elementDiv.dataset.element;
            const currentIndex = elements.indexOf(current);
            const nextIndex = (currentIndex + 1) % elements.length;
            const nextElement = elements[nextIndex];
            
            elementDiv.dataset.element = nextElement;
            elementDiv.textContent = nextElement.charAt(0);
            elementDiv.className = `puzzle-element ${nextElement.toLowerCase()}`;
        }

        function checkPuzzle() {
            const puzzleElements = document.getElementById('puzzleElements');
            const elements = Array.from(puzzleElements.children).map(child => child.dataset.element);
            const correctOrder = ['FIRE', 'WATER', 'EARTH', 'AIR'];
            
            let correct = true;
            for (let i = 0; i < elements.length; i++) {
                if (elements[i] !== correctOrder[i]) {
                    correct = false;
                    break;
                }
            }
            
            const puzzleResult = document.getElementById('puzzleResult');
            
            if (correct) {
                puzzleResult.innerHTML = `<p class="heal">PUZZLE SOLVED! THE PATH IS CLEAR.</p>`;
                // Remove puzzle from dungeon
                gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x] = TILE.FLOOR;
                
                // Reward
                const reward = 100 * gameState.currentFloor;
                gameState.gold += reward;
                puzzleResult.innerHTML += `<p>FOUND ${reward} GOLD HIDDEN IN THE MECHANISM.</p>`;
                
                setTimeout(() => {
                    gameState.inPuzzle = false;
                    gameState.currentPuzzle = null;
                    showScreen('dungeonScreen');
                    updateStatusBar();
                }, 3000);
            } else {
                puzzleResult.innerHTML = `<p class="damage">INCORRECT PATTERN. TRY AGAIN.</p>`;
                // Small penalty for wrong guess
                gameState.party.forEach(member => {
                    member.health = Math.max(1, member.health - 5);
                });
                updatePartyDisplay();
            }
        }

        function skipPuzzle() {
            if (confirm("ATTEMPT TO FORCE THE MECHANISM? THIS MAY CAUSE DAMAGE.")) {
                // 50% chance of success
                if (Math.random() < 0.5) {
                    // Success
                    document.getElementById('puzzleResult').innerHTML = 
                        `<p class="heal">THE MECHANISM JAMS OPEN! PATH CLEARED.</p>`;
                    gameState.dungeonGrid[gameState.currentPuzzle.y][gameState.currentPuzzle.x] = TILE.FLOOR;
                } else {
                    // Failure - trap triggers
                    document.getElementById('puzzleResult').innerHTML = 
                        `<p class="damage">TRAP TRIGGERED! PARTY TAKES 20 DAMAGE.</p>`;
                    gameState.party.forEach(member => {
                        member.health = Math.max(1, member.health - 20);
                    });
                    updatePartyDisplay();
                }
                
                setTimeout(() => {
                    gameState.inPuzzle = false;
                    gameState.currentPuzzle = null;
                    showScreen('dungeonScreen');
                }, 3000);
            }
        }

        // Dungeon progression
        function descendFloor() {
            if (gameState.currentFloor < dungeons[gameState.currentDungeon].floors) {
                gameState.currentFloor++;
                gameState.playerX = 5;
                gameState.playerY = 5;
                gameState.playerDirection = 0;
                gameState.exploredTiles.clear();
                gameState.discoveredSecrets.clear();
                gameState.discoveredTraps.clear();
                
                generateDungeonFloor();
                
                document.getElementById('dungeonTitle').textContent = 
                    `${dungeons[gameState.currentDungeon].name} - FLOOR ${gameState.currentFloor}`;
                
                logMessage(`DESCENDED TO FLOOR ${gameState.currentFloor}.`);
                updateDungeonView();
                updateAutoMap();
                updateStatusBar();
            }
        }

        function completeDungeon() {
            const dungeon = dungeons[gameState.currentDungeon];
            const completionBonus = 1000 * gameState.currentFloor;
            
            gameState.gold += completionBonus;
            gameState.dungeonsCompleted.push(gameState.currentDungeon);
            
            // Show victory screen
            document.getElementById('victoryFloors').textContent = gameState.currentFloor;
            document.getElementById('victoryMonsters').textContent = gameState.monstersSlain;
            document.getElementById('victoryTreasure').textContent = gameState.gold;
            
            showScreen('victoryScreen');
            
            // Save game
            localStorage.setItem('dungeonDelverSave', JSON.stringify(gameState));
        }

        // Game over
        function gameOver() {
            document.getElementById('finalFloors').textContent = gameState.currentFloor;
            document.getElementById('finalMonsters').textContent = gameState.monstersSlain;
            document.getElementById('finalTreasure').textContent = gameState.gold;
            
            showScreen('gameOverScreen');
            
            // Clear save
            localStorage.removeItem('dungeonDelverSave');
        }

        function restartGame() {
            // Reset game state
            Object.assign(gameState, {
                party: [],
                gold: 500,
                torches: 10,
                currentDungeon: null,
                currentFloor: 1,
                dungeonGrid: [],
                playerX: 5,
                playerY: 5,
                playerDirection: 0,
                exploredTiles: new Set(),
                discoveredSecrets: new Set(),
                discoveredTraps: new Set(),
                monstersSlain: 0,
                treasureFound: 0,
                totalTurns: 0,
                mapRevealed: 0,
                inCombat: false,
                currentEnemy: null,
                combatTurn: 0,
                inPuzzle: false,
                currentPuzzle: null,
                inventory: {
                    keys: { iron: 0, silver: 0, gold: 0 },
                    potions: { healing: 3, mana: 1, antidote: 1 },
                    scrolls: { identify: 1, mapping: 0 },
                    special: []
                },
                spells: ['light'],
                dungeonsCompleted: []
            });
            
            // Return to character creation
            showScreen('creationScreen');
            initPartyCreation();
        }

        // Utility functions
        function logMessage(message) {
            const combatLog = document.getElementById('combatLog');
            if (combatLog) {
                combatLog.innerHTML += `<p>${message}</p>`;
                combatLog.scrollTop = combatLog.scrollHeight;
            }
        }

        // Initialize the game when page loads
        window.onload = initGame;
    </script>
</body>
</html>
