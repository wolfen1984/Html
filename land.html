<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Land of the Undead - RPG Strategy Game</title>
<style>
  :root {
    --primary-bg: #1a1a2e;
    --secondary-bg: #1e1e2e;
    --accent-color: #ffcc00;
    --danger-color: #8a0303;
    --hero-color: #e33;
    --enemy-color: #37f;
    --text-color: #e6e6e6;
    --border-color: #444;
    --cell-size: 60px;
    --gap-size: 4px;
  }
  
  * {
    box-sizing: border-box;
  }
  
  body {
    font-family: Arial, Helvetica, sans-serif;
    background: var(--primary-bg);
    margin: 0;
    padding: 10px;
    color: var(--text-color);
    font-size: 16px;
    line-height: 1.4;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    overflow-x: hidden;
  }
  
  h1 {
    color: var(--accent-color);
    margin: 0 0 10px 0;
    text-align: center;
    font-size: 1.8rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
  }
  
  #game-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  /* Board styling */
  #board-container {
    width: 100%;
    overflow-x: auto;
    margin-bottom: 10px;
    -webkit-overflow-scrolling: touch;
  }
  
  #game-board {
    display: flex;
    flex-direction: column;
    gap: var(--gap-size);
    padding: 10px;
    background: #162447;
    border: 3px solid var(--danger-color);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,.6);
  }
  
  .board-row {
    display: flex;
    gap: var(--gap-size);
  }
  
  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    border-radius: 6px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 4px;
    position: relative;
    font-size: 10px;
    font-weight: 600;
    overflow: hidden;
    border: 1px solid rgba(0,0,0,0.3);
  }
  
  .cell-name {
    font-size: 8px;
    line-height: 1.1;
    margin-bottom: 2px;
  }
  
  .cell-price {
    font-size: 7px;
    background: rgba(0,0,0,0.3);
    padding: 1px 3px;
    border-radius: 3px;
  }
  
  /* Cell types */
  .corner { background: #5d0e0e; color: var(--accent-color); }
  .village { background: #295d7a; }
  .forest { background: #2d5d29; }
  .mountain { background: #5d5d5d; }
  .castle { background: #7a2929; }
  .stronghold { background: #5d295d; }
  .artifact { background: #5d5d29; }
  .tribute { background: #5d2929; }
  .quest { background: #29295d; }
  
  .ownerTag {
    position: absolute;
    top: 2px;
    left: 2px;
    font-size: 8px;
    padding: 1px 3px;
    border-radius: 3px;
    background: rgba(0,0,0,.6);
    color: #fff;
  }
  
  .garrisons {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 9px;
    font-weight: bold;
  }
  
  .player-token {
    position: absolute;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    z-index: 20;
    box-shadow: 0 1px 4px rgba(0,0,0,.5);
    transition: all 0.3s ease;
  }
  
  .token-hero { background: var(--hero-color); }
  .token-enemy { background: var(--enemy-color); }
  
  /* Controls */
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
    margin: 10px 0;
  }
  
  button {
    padding: 12px 15px;
    font-size: 16px;
    background: var(--danger-color);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    min-width: 120px;
    flex: 1;
    max-width: 180px;
  }
  
  button:hover { opacity: 0.9; }
  button:disabled { background: #444; color: #888; cursor: not-allowed; }
  
  #diceDisplay {
    padding: 12px;
    background: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    text-align: center;
    font-weight: bold;
    color: var(--accent-color);
    min-width: 120px;
    flex: 1;
    max-width: 180px;
  }
  
  /* Stats */
  #stats-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  #stats {
    display: flex;
    gap: 15px;
  }
  
  .box {
    background: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    flex: 1;
  }
  
  .box h3 {
    margin: 0 0 10px 0;
    font-size: 16px;
    color: var(--accent-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
  }
  
  #log {
    height: 120px;
    overflow: auto;
    background: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    font-size: 14px;
  }
  
  /* NEW STYLES */
  #notification-area {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: var(--accent-color);
    padding: 12px 18px;
    border-radius: 8px;
    z-index: 100;
    display: none;
    max-width: 90%;
    text-align: center;
    border: 1px solid var(--accent-color);
    font-size: 16px;
  }
  
  #card-display, #territory-conquest, #dungeon-management, #class-selection {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--secondary-bg);
    border: 2px solid var(--accent-color);
    border-radius: 10px;
    padding: 20px;
    z-index: 90;
    display: none;
    box-shadow: 0 6px 20px rgba(0,0,0,0.5);
    width: 90%;
    max-width: 400px;
    text-align: center;
  }
  
  #card-display h3, #territory-conquest h3, #dungeon-management h3, #class-selection h3 {
    margin: 0 0 15px 0;
    color: var(--accent-color);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
    font-size: 18px;
  }
  
  #card-display p, #territory-conquest p, #dungeon-management p {
    margin: 15px 0;
    font-size: 16px;
    line-height: 1.4;
  }
  
  #card-display button, #territory-conquest button, #dungeon-management button, .class-option {
    margin-top: 15px;
    background: #295d29;
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    width: 100%;
  }
  
  .turn-indicator {
    position: sticky;
    top: 0;
    background: var(--danger-color);
    color: var(--accent-color);
    padding: 10px;
    border-radius: 0 0 8px 8px;
    font-weight: bold;
    z-index: 10;
    text-align: center;
    margin-bottom: 10px;
    font-size: 16px;
  }
  
  .hero-turn #rollBtn {
    background: #295d29;
  }
  
  .enemy-turn #rollBtn {
    background: #333;
    color: #666;
    cursor: not-allowed;
  }
  
  .game-over {
    pointer-events: none;
    opacity: 0.7;
  }
  
  .class-option {
    margin: 10px 0;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    background: #2d2d3e;
    text-align: left;
  }
  
  .class-option:hover {
    background: #3d3d4e;
  }
  
  .class-option.selected {
    background: var(--danger-color);
    border-color: var(--accent-color);
  }
  
  .highlight {
    animation: highlight 1s ease-in-out;
  }
  
  @keyframes highlight {
    0% { box-shadow: 0 0 0 0 rgba(255,215,0,0.7); }
    70% { box-shadow: 0 0 0 10px rgba(255,215,0,0); }
    100% { box-shadow: 0 0 0 0 rgba(255,215,0,0); }
  }
  
  /* Responsive adjustments */
  @media (max-width: 480px) {
    :root {
      --cell-size: 50px;
    }
    
    h1 {
      font-size: 1.5rem;
    }
    
    .cell-name {
      font-size: 7px;
    }
    
    button {
      min-width: 100px;
      padding: 10px 12px;
      font-size: 14px;
    }
    
    #diceDisplay {
      padding: 10px;
      font-size: 14px;
    }
    
    .box {
      padding: 10px;
    }
    
    .box h3 {
      font-size: 14px;
    }
  }
  
  @media (max-width: 360px) {
    :root {
      --cell-size: 45px;
    }
    
    .cell-name {
      font-size: 6px;
    }
  }
</style>
</head>
<body>
  <h1>Land of the Undead</h1>
  
  <div class="turn-indicator" id="turnIndicator">Hero's Turn</div>
  
  <div id="game-container">
    <div id="board-container">
      <div id="game-board"></div>
    </div>

    <div id="controls">
      <button id="rollBtn">Roll Initiative</button>
      <button id="endTurnBtn" disabled>End Turn</button>
      <div id="diceDisplay">Initiative: -</div>
    </div>
    
    <div id="controls">
      <button id="reinforceBtn">Reinforce</button>
      <button id="fortifyBtn">Fortify</button>
    </div>

    <div id="stats-container">
      <div id="stats">
        <div class="box" id="heroStats">
          <h3 id="heroClass">Hero</h3>
          <div id="heroArmy">Army: 1500 soldiers</div>
          <div id="heroTerritories">Territories: None</div>
          <div id="heroDungeon"></div>
        </div>
        <div class="box" id="enemyStats">
          <h3 id="enemyClass">Enemy</h3>
          <div id="enemyArmy">Army: 1500 soldiers</div>
          <div id="enemyTerritories">Territories: None</div>
          <div id="enemyDungeon"></div>
        </div>
      </div>
      
      <div class="box">
        <h3>Battle Log</h3>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- NEW ELEMENTS -->
  <div id="notification-area"></div>
  
  <div id="card-display">
    <h3 id="card-pile-name"></h3>
    <p id="card-text"></p>
    <button id="card-close">Continue</button>
  </div>
  
  <div id="territory-conquest">
    <h3>Territory Available</h3>
    <p id="territory-name"></p>
    <p id="territory-cost"></p>
    <div>
      <button id="territory-conquest-buy">Conquer</button>
      <button id="territory-conquest-pass">Ignore</button>
    </div>
  </div>
  
  <div id="dungeon-management">
    <h3>You're Captured!</h3>
    <p id="dungeon-message"></p>
    <div>
      <button id="dungeon-pay">Sacrifice 50 Soldiers</button>
      <button id="dungeon-roll">Roll for Escape</button>
    </div>
  </div>

  <div id="class-selection">
    <h3>Choose Your Hero Class</h3>
    <div class="class-option" data-class="Paladin">Paladin - Strong against undead</div>
    <div class="class-option" data-class="Ranger">Ranger - Expert scout</div>
    <div class="class-option" data-class="Wizard">Wizard - Arcane powers</div>
    <div class="class-option" data-class="Warrior">Warrior - Combat master</div>
    <button id="start-game" disabled>Begin Battle</button>
  </div>

<script>
/* -------------------------
   Board data & init
   ------------------------- */
const board = [
  { name:"Recruitment", type:"corner" },
  { name:"Haunted Hamlet", type:"village", price:60, rent:2, color:"brown" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Ghostly Grove", type:"forest", price:60, rent:4, color:"brown" },
  { name:"Plunder", type:"tribute", price:200 },
  { name:"Northern Stronghold", type:"stronghold", price:200 },
  { name:"Whispering Woods", type:"forest", price:100, rent:6, color:"lightblue" },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Mystic Marsh", type:"forest", price:100, rent:6, color:"lightblue" },
  { name:"Enchanted Glen", type:"forest", price:120, rent:8, color:"lightblue" },
  { name:"Dungeon", type:"corner" },
  { name:"Dragon's Peak", type:"mountain", price:140, rent:10, color:"pink" },
  { name:"Holy Relic", type:"artifact", price:150 },
  { name:"Griffin's Nest", type:"mountain", price:140, rent:10, color:"pink" },
  { name:"Troll's Cave", type:"mountain", price:160, rent:12, color:"pink" },
  { name:"Eastern Stronghold", type:"stronghold", price:200 },
  { name:"Shadow Keep", type:"castle", price:180, rent:14, color:"orange" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Dread Fortress", type:"castle", price:180, rent:14, color:"orange" },
  { name:"Black Tower", type:"castle", price:200, rent:16, color:"orange" },
  { name:"Reinforcements", type:"corner" },
  { name:"Necropolis", type:"castle", price:220, rent:18, color:"red" },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Plague City", type:"castle", price:220, rent:18, color:"red" },
  { name:"Crypt", type:"castle", price:240, rent:20, color:"red" },
  { name:"Southern Stronghold", type:"stronghold", price:200 },
  { name:"Holy Temple", type:"castle", price:260, rent:22, color:"yellow" },
  { name:"Divine Shrine", type:"castle", price:260, rent:22, color:"yellow" },
  { name:"Cursed Idol", type:"artifact", price:150 },
  { name:"Sacred Grove", type:"forest", price:280, rent:24, color:"yellow" },
  { name:"Captured", type:"corner", action:"gotodungeon" },
  { name:"Arcane Spire", type:"castle", price:300, rent:26, color:"green" },
  { name:"Wizard's Tower", type:"castle", price:300, rent:26, color:"green" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Sorcerer's Citadel", type:"castle", price:320, rent:28, color:"green" },
  { name:"Western Stronghold", type:"stronghold", price:200 },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Dragon's Lair", type:"castle", price:350, rent:35, color:"darkblue" },
  { name:"Tithe", type:"tribute", price:100 },
  { name:"Phoenix Roost", type:"castle", price:400, rent:50, color:"darkblue" }
];
// add tracking fields for territories
board.forEach((s,i)=>{
  if (["village","forest","mountain","castle","stronghold","artifact"].includes(s.type)) {
    s.owner = null; // 'hero' or 'enemy'
    s.garrisons = 0;   // 0-4, 5 -> fortress (we'll treat 5 as fortress)
    s.fortified = false;
  }
});

/* -------------------------
   Players & game state
   ------------------------- */
let hero = { name:"Hero", pos:0, army:1500, territories:[], inDungeon:false, dungeonTurns:0, class: "Paladin" };
let enemy = { name:"Enemy", pos:0, army:1500, territories:[], inDungeon:false, dungeonTurns:0, class: "Necromancer" };
let currentPlayer = 'hero';
let doublesCount = 0;
let gameOver = false;
let isMoving = false; // Track if a player is currently moving
let hasRolled = false; // Track if player has rolled this turn

/* -------------------------
   Cards
   ------------------------- */
const eventCards = [
  { text:"Advance to Recruitment", exec:pl=>{pl.pos=0; give(pl,200);} },
  { text:"Your army receives reinforcements of 50 soldiers", exec:pl=>give(pl,50) },
  { text:"You've been captured! Go to the Dungeon", exec:pl=>sendToDungeon(pl) },
  { text:"Sacrifice 15 soldiers to local lords", exec:pl=>pay(pl,15) },
  { text:"Advance to Phoenix Roost", exec:pl=>{pl.pos=39; } },
  { text:"March to the Northern Stronghold", exec:pl=>pl.pos=5 },
  { text:"Your investments pay off - collect 150 soldiers", exec:pl=>give(pl,150) },
  { text:"Sacrifice 50 soldiers for equipment repairs", exec:pl=>pay(pl,50) }
];
const questCards = [
  { text:"From successful campaigns you get 50 soldiers", exec:pl=>give(pl,50) },
  { text:"Sacrifice 100 soldiers for healing fees", exec:pl=>pay(pl,100) },
  { text:"Royal favor - collect 200 soldiers", exec:pl=>give(pl,200) },
  { text:"Collect 25 soldiers reward for completed quest", exec:pl=>give(pl,25) },
  { text:"You inherit 100 soldiers from fallen comrade", exec:pl=>give(pl,100) },
  { text:"Betrayed! Go to the Dungeon", exec:pl=>sendToDungeon(pl) },
  { text:"Sacrifice 50 soldiers for supplies", exec:pl=>pay(pl,50) },
  { text:"Successful trade - collect 100 soldiers", exec:pl=>give(pl,100) }
];
function drawCard(pile){
  const arr = pile==='event'?eventCards:questCards;
  const card = arr[Math.floor(Math.random()*arr.length)];
  return card;
}

/* -------------------------
   UI elements & helpers
   ------------------------- */
const boardEl = document.getElementById('game-board');
const rollBtn = document.getElementById('rollBtn');
const endTurnBtn = document.getElementById('endTurnBtn');
const reinforceBtn = document.getElementById('reinforceBtn');
const fortifyBtn = document.getElementById('fortifyBtn');
const diceDisplay = document.getElementById('diceDisplay');
const logEl = document.getElementById('log');
const heroArmyEl = document.getElementById('heroArmy');
const enemyArmyEl = document.getElementById('enemyArmy');
const heroTerritoriesEl = document.getElementById('heroTerritories');
const enemyTerritoriesEl = document.getElementById('enemyTerritories');
const heroDungeonEl = document.getElementById('heroDungeon');
const enemyDungeonEl = document.getElementById('enemyDungeon');
const turnIndicator = document.getElementById('turnIndicator');
const heroClassEl = document.getElementById('heroClass');
const enemyClassEl = document.getElementById('enemyClass');
const classSelection = document.getElementById('class-selection');
const classOptions = document.querySelectorAll('.class-option');
const startGameBtn = document.getElementById('start-game');

// NEW ELEMENTS
const notificationArea = document.getElementById('notification-area');
const cardDisplay = document.getElementById('card-display');
const cardPileName = document.getElementById('card-pile-name');
const cardText = document.getElementById('card-text');
const cardClose = document.getElementById('card-close');
const territoryConquest = document.getElementById('territory-conquest');
const territoryName = document.getElementById('territory-name');
const territoryCost = document.getElementById('territory-cost');
const territoryConquestBuy = document.getElementById('territory-conquest-buy');
const territoryConquestPass = document.getElementById('territory-conquest-pass');
const dungeonManagement = document.getElementById('dungeon-management');
const dungeonMessage = document.getElementById('dungeon-message');
const dungeonPay = document.getElementById('dungeon-pay');
const dungeonRoll = document.getElementById('dungeon-roll');

function log(...txt){
  logEl.innerHTML += `<div>${txt.join(' ')}</div>`;
  logEl.scrollTop = logEl.scrollHeight;
}
function fmtArmy(n){return `${n} soldiers`;}
function give(player, amt){
  player.army += amt;
  log(`${player.name} receives ${fmtArmy(amt)}.`);
  updateStats();
}
function pay(player, amt){
  player.army -= amt;
  log(`${player.name} sacrifices ${fmtArmy(amt)}.`);
  updateStats();
  checkDefeat(player);
}
function getPlayerObj(id){ return id==='hero'?hero:enemy; }
function checkDefeat(player){
  if (player.army < 0){
    gameOver = true;
    const other = player===hero?enemy:hero;
    showNotification(`${player.name} has been defeated! ${other.name} wins the war!`);
    log(`${player.name} has been defeated. ${ (player===hero)?'Enemy':'Hero' } wins!`);
    rollBtn.disabled = true;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = true;
    fortifyBtn.disabled = true;
    document.body.classList.add('game-over');
  }
}

// NEW FUNCTIONS FOR UI
function showNotification(message, duration = 3000) {
  notificationArea.textContent = message;
  notificationArea.style.display = 'block';
  
  setTimeout(() => {
    notificationArea.style.display = 'none';
  }, duration);
}

function showCard(card, pile) {
  cardPileName.textContent = `${pile.toUpperCase()} Card`;
  cardText.textContent = card.text;
  cardDisplay.style.display = 'block';
  
  // Disable controls while card is displayed
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

function showTerritoryConquest(sq) {
  territoryName.textContent = sq.name;
  territoryCost.textContent = `Conquest Cost: ${fmtArmy(sq.price)}`;
  territoryConquest.style.display = 'block';
  
  // Disable controls while conquest decision is pending
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

function showDungeonManagement() {
  dungeonMessage.textContent = `You have been captured for ${hero.dungeonTurns} turn(s).`;
  dungeonManagement.style.display = 'block';
  
  // Disable controls while dungeon decision is pending
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

/* -------------------------
   Build visual board
   ------------------------- */
function createBoardUI(){
  // Create a grid layout with 4 rows of 10 cells each
  for(let row = 0; row < 4; row++) {
    const rowEl = document.createElement('div');
    rowEl.className = 'board-row';
    
    for(let col = 0; col < 10; col++) {
      const idx = row * 10 + col;
      if (idx >= 40) break;
      
      const sq = document.createElement('div');
      const base = board[idx];
      sq.className = `cell ${base.type}`;
      sq.dataset.idx = idx;
      
      // Add name and price
      const nameEl = document.createElement('div');
      nameEl.className = 'cell-name';
      nameEl.textContent = base.name;
      sq.appendChild(nameEl);
      
      if (base.price) {
        const priceEl = document.createElement('div');
        priceEl.className = 'cell-price';
        priceEl.textContent = fmtArmy(base.price);
        sq.appendChild(priceEl);
      }
      
      // owner tag & garrisons
      const ownerTag = document.createElement('div');
      ownerTag.className='ownerTag';
      ownerTag.style.display='none';
      sq.appendChild(ownerTag);
      
      const garrisons = document.createElement('div');
      garrisons.className='garrisons';
      garrisons.style.display='none';
      sq.appendChild(garrisons);
      
      rowEl.appendChild(sq);
    }
    
    boardEl.appendChild(rowEl);
  }
  
  // Create tokens
  const heroToken = document.createElement('div');
  heroToken.id = 'heroToken';
  heroToken.className = 'player-token token-hero';
  document.body.appendChild(heroToken);
  
  const enemyToken = document.createElement('div');
  enemyToken.id = 'enemyToken';
  enemyToken.className = 'player-token token-enemy';
  document.body.appendChild(enemyToken);
}

/* -------------------------
   Update tokens visually
   ------------------------- */
function updateTokenPosition(player){
  const cell = boardEl.querySelector(`[data-idx="${player.pos}"]`);
  if (!cell) return;
  
  const cellRect = cell.getBoundingClientRect();
  const boardRect = boardEl.getBoundingClientRect();
  
  // Position token relative to viewport
  const x = cellRect.left + cellRect.width/2 - 7;
  const y = cellRect.top + cellRect.height/2 - 7;
  
  if (player===hero){
    heroToken.style.left = `${x}px`;
    heroToken.style.top = `${y}px`;
  } else {
    enemyToken.style.left = `${x+10}px`;
    enemyToken.style.top = `${y}px`;
  }
  
  // Highlight the current cell
  cell.classList.add('highlight');
  setTimeout(() => {
    cell.classList.remove('highlight');
  }, 1000);
}

/* -------------------------
   Movement animation
   ------------------------- */
function movePlayerAnimated(playerObj, steps, cb){
  isMoving = true; // Set moving flag
  let step = 0;
  let plObj = playerObj;
  const pg = setInterval(()=>{
    step++;
    const prev = plObj.pos;
    plObj.pos = (plObj.pos + 1) % 40;
    updateTokenPosition(plObj);
    // passing Recruitment
    if (plObj.pos === 0) {
      give(plObj,200);
      log(`${plObj.name} passed Recruitment and collected 200 soldiers`);
      showNotification(`${plObj.name} passed Recruitment and collected 200 soldiers!`);
    }
    if (step >= steps){ 
      clearInterval(pg); 
      isMoving = false; // Clear moving flag
      cb && cb(); 
    }
  }, 260);
}

/* -------------------------
   Landing & square handling
   ------------------------- */
function handleLanding(playerObj, diceTotal){
  const sq = board[playerObj.pos];
  log(`${playerObj.name} entered ${sq.name} (${playerObj.pos})`);
  showNotification(`${playerObj.name} entered ${sq.name}`);
  
  if (sq.type==='tribute'){
    pay(playerObj, sq.price);
    showNotification(`${playerObj.name} sacrificed ${fmtArmy(sq.price)} in tribute`);
    return;
  }
  if (sq.type==='corner' && sq.action==='gotodungeon'){
    sendToDungeon(playerObj);
    return;
  }
  if (sq.type==='corner' && sq.name==='Reinforcements'){
    // Loot drop - random amount of soldiers
    const loot = Math.floor(Math.random() * 100) + 50;
    give(playerObj, loot);
    showNotification(`${playerObj.name} found ${fmtArmy(loot)} in reinforcements!`);
    return;
  }
  if (sq.type==='quest'){
    const card = drawCard(sq.pile);
    showCard(card, sq.pile);
    return;
  }
  if (['village','forest','mountain','castle','stronghold','artifact'].includes(sq.type)){
    if (sq.owner===null){
      // offer to conquer if hero, otherwise enemy auto-decide
      if (playerObj===hero){
        // prompt conquest interface
        showTerritoryConquest(sq);
      } else {
        // Enemy decision
        const willConquer = enemyShouldConquer(playerObj, sq);
        if (willConquer) { conquerTerritory(playerObj, 'enemy', sq); }
        else log(`Enemy passed on ${sq.name}.`);
      }
    } else if (sq.owner !== (playerObj===hero?'hero':'enemy')){
      // pay tribute if not fortified
      if (sq.fortified){
        log(`Territory ${sq.name} is fortified; no tribute due.`);
        showNotification(`Territory ${sq.name} is fortified; no tribute due.`);
        return;
      }
      const owner = getPlayerObj(sq.owner);
      const tribute = calculateTribute(sq, diceTotal, owner);
      pay(playerObj, tribute);
      give(owner, tribute);
      log(`${playerObj.name} paid ${fmtArmy(tribute)} tribute to ${owner.name} for ${sq.name}.`);
      showNotification(`${playerObj.name} paid ${fmtArmy(tribute)} tribute to ${owner.name}`);
    } else {
      log(`${playerObj.name} entered own territory.`);
    }
  }
  updateBoardOwners();
}

/* -------------------------
   Conquer, reinforce, fortify
   ------------------------- */
function conquerTerritory(playerObj, ownerId, sq){
  if (playerObj.army < sq.price){
    log(`${playerObj.name} cannot afford to conquer ${sq.name}.`);
    showNotification(`${playerObj.name} cannot afford to conquer ${sq.name}.`);
    return;
  }
  playerObj.army -= sq.price;
  sq.owner = ownerId;
  playerObj.territories.push(sqIndex(sq));
  log(`${playerObj.name} conquered ${sq.name} for ${fmtArmy(sq.price)}.`);
  showNotification(`${playerObj.name} conquered ${sq.name}!`);
  updateStats();
  updateBoardOwners();
}

function sqIndex(sq){ return board.indexOf(sq); }

function calculateTribute(sq, diceTotal=0, ownerObj=null){
  if (sq.type==='artifact'){
    // if owner has both artifacts, high multiplier
    let owner = ownerObj || getPlayerObj(sq.owner);
    if (!owner) return 0;
    const artifactCount = owner.territories.filter(i=>board[i].type==='artifact').length;
    const mult = artifactCount>1?10:4;
    return mult * (diceTotal || 1);
  }
  if (sq.type==='stronghold'){
    let owner = ownerObj || getPlayerObj(sq.owner);
    const strongholdCount = owner.territories.filter(i=>board[i].type==='stronghold').length;
    return 25 * strongholdCount; // simplified
  }
  // territory
  if (sq.garrisons >= 5) return sq.rent * 10; // fortress
  if (sq.garrisons > 0) return sq.rent * (sq.garrisons + 1);
  // check control (all same color owned)
  if (sq.color){
    const sameColor = board.reduce((acc,s,i)=>{
      if (s.color===sq.color) acc.push(i);
      return acc;
    },[]);
    const owner = getPlayerObj(sq.owner);
    const ownsAll = sameColor.every(i => owner.territories.includes(i));
    if (ownsAll) return sq.rent * 2; // double tribute for control
  }
  return sq.rent;
}

function updateBoardOwners(){
  // set owner tags and garrisons visually
  board.forEach((s,i)=>{
    const cell = boardEl.querySelector(`[data-idx="${i}"]`);
    if (!cell) return;
    const ownerTag = cell.querySelector('.ownerTag');
    const garrisonsTag = cell.querySelector('.garrisons');
    if (["village","forest","mountain","castle","stronghold","artifact"].includes(s.type) && s.owner){
      ownerTag.style.display='block';
      ownerTag.textContent = s.owner==='hero' ? 'Hero' : 'Enemy';
      ownerTag.className = 'ownerTag ' + (s.owner==='hero'?'owner-hero':'owner-enemy');
      if (s.fortified){ ownerTag.textContent += ' (F)'; }
    } else {
      ownerTag.style.display='none';
      ownerTag.textContent='';
      ownerTag.className='ownerTag';
    }
    if (["village","forest","mountain","castle"].includes(s.type) && (s.garrisons>0 || s.garrisons===5)){
      garrisonsTag.style.display='block';
      if (s.garrisons===5) garrisonsTag.textContent = 'Fortress';
      else garrisonsTag.textContent = 'G:' + s.garrisons;
    } else { garrisonsTag.style.display='none'; garrisonsTag.textContent=''; }
  });
}

/* -------------------------
   Dungeon mechanics
   ------------------------- */
function sendToDungeon(playerObj){
  playerObj.pos = 10;
  playerObj.inDungeon = true;
  playerObj.dungeonTurns = 0;
  updateTokenPosition(playerObj);
  log(`${playerObj.name} was captured and sent to the Dungeon.`);
  showNotification(`${playerObj.name} was captured and sent to the Dungeon!`);
}

/* -------------------------
   Simple Enemy heuristics
   ------------------------- */
function enemyShouldConquer(playerObj, sq){
  // conquers if has more than price + 150 buffer and not near defeat
  if (playerObj.army > sq.price + 150) return true;
  return false;
}

function enemyTurn(d1,d2,total){
  // if in dungeon simple behavior: try to pay to get out if low dungeonTurns or roll dice for doubles handled earlier
  if (enemy.inDungeon){
    enemy.dungeonTurns++;
    if (enemy.dungeonTurns >= 3){
      // pay to get out
      if (enemy.army >= 50){ pay(enemy,50); enemy.inDungeon=false; log("Enemy sacrificed 50 soldiers to escape the Dungeon."); }
      else { log("Enemy cannot sacrifice to escape the dungeon"); }
    } else {
      log("Enemy remains in the Dungeon this turn.");
      return endTurn();
    }
  }
  // roll already performed in controller; landing handled after move
}

/* -------------------------
   Garrisons & Fortifications UI actions
   ------------------------- */
reinforceBtn.addEventListener('click', ()=>{
  // show list of player's reinforceable territories
  const playerObj = currentPlayer==='hero' ? hero : enemy;
  const reinforceable = playerObj.territories
    .map(i=>board[i])
    .filter(s=>["village","forest","mountain","castle"].includes(s.type) && !s.fortified);
  if (reinforceable.length===0){
    showNotification("You have no territories to reinforce.");
    return;
  }
  
  // For simplicity, we'll just reinforce the first available territory
  const s = reinforceable[0];
  
  // check full control
  if (!s.color){ 
    showNotification("You can only reinforce colored territories.");
    return; 
  }
  const sameColorIdxs = board.reduce((acc,s,i)=>{ if (s.color===s.color) acc.push(i); return acc;},[]);
  // check ownership
  if (!sameColorIdxs.every(i=>board[i].owner=== (playerObj===hero? 'hero':'enemy'))){
    showNotification("You must control the full color set to reinforce.");
    return;
  }
  const garrisonCost = Math.round(s.price * 0.5);
  if (playerObj.army < garrisonCost){
    showNotification("You don't have enough soldiers to reinforce.");
    return;
  }
  if (s.garrisons < 4){
    s.garrisons++;
    playerObj.army -= garrisonCost;
    log(`${playerObj.name} reinforced ${s.name} with ${fmtArmy(garrisonCost)}.`);
    showNotification(`${playerObj.name} reinforced ${s.name}`);
  } else if (s.garrisons === 4){
    s.garrisons = 5; // fortress
    playerObj.army -= garrisonCost;
    log(`${playerObj.name} built a fortress on ${s.name} for ${fmtArmy(garrisonCost)}.`);
    showNotification(`${playerObj.name} built a fortress on ${s.name}`);
  } else {
    showNotification("No more reinforcement allowed on this territory.");
    return;
  }
  updateStats();
  updateBoardOwners();
});

/* Fortify / Abandon UI */
fortifyBtn.addEventListener('click', ()=>{
  const playerObj = hero;
  const fortifiable = playerObj.territories
    .map(i=>board[i])
    .filter(s=>["village","forest","mountain","castle","stronghold","artifact"].includes(s.type));
  
  if (fortifiable.length === 0) {
    showNotification("You have no territories to fortify.");
    return;
  }
  
  // For simplicity, we'll just fortify/abandon the first available territory
  const s = fortifiable[0];
  
  if (s.fortified) {
    // Abandon (unfortify)
    const val = Math.round(s.price/2 * 0.9); // Get back 90% of the garrison value
    s.fortified = false;
    playerObj.army += val;
    log(`${playerObj.name} abandoned ${s.name} for ${fmtArmy(val)}.`);
    showNotification(`${playerObj.name} abandoned ${s.name}`);
  } else {
    // Fortify
    const val = Math.round(s.price/2);
    if (playerObj.army < val){ 
      showNotification("Not enough soldiers to fortify.");
      return; 
    }
    s.fortified = true;
    playerObj.army -= val;
    log(`${playerObj.name} fortified ${s.name} for ${fmtArmy(val)}.`);
    showNotification(`${playerObj.name} fortified ${s.name}`);
  }
  updateStats();
  updateBoardOwners();
});

/* -------------------------
   Dice & turn controller
   ------------------------- */
function rollDiceVals(){
  const d1 = Math.floor(Math.random()*6)+1;
  const d2 = Math.floor(Math.random()*6)+1;
  return [d1,d2];
}

function startHeroTurn(){
  if (gameOver) return;
  // Update UI to show it's hero's turn
  document.body.classList.remove('enemy-turn');
  document.body.classList.add('hero-turn');
  turnIndicator.textContent = "Hero's Turn";
  turnIndicator.style.background = "#5d0e0e";
  
  hasRolled = false;
  rollBtn.disabled = false;
  endTurnBtn.disabled = true;
  reinforceBtn.disabled = false;
  fortifyBtn.disabled = false;
  
  if (hero.inDungeon){
    showDungeonManagement();
  }
}

rollBtn.addEventListener('click', ()=>{
  if (currentPlayer !== 'hero' || isMoving || hasRolled) return;
  
  hasRolled = true;
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
  // roll
  const [d1,d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  const total = d1 + d2;
  if (hero.inDungeon){
    // if doubles, escape and move; otherwise increase dungeonTurns
    if (d1 === d2){
      hero.inDungeon=false;
      hero.dungeonTurns=0;
      log("You rolled doubles and escaped the dungeon!");
      showNotification("You rolled doubles and escaped the dungeon!");
      animateAndResolve(hero,total,d1===d2);
    } else {
      hero.dungeonTurns++;
      log("You failed to roll doubles in the Dungeon.");
      showNotification("You failed to roll doubles in the Dungeon.");
      if (hero.dungeonTurns>=3){
        // must pay 50 and escape
        if (hero.army>=50){ pay(hero,50); hero.inDungeon=false; hero.dungeonTurns=0; log("Sacrificed 50 soldiers to escape the Dungeon."); animateAndResolve(hero,total,false); }
        else { log("Can't sacrifice to escape; still in dungeon."); endTurnBtn.disabled = false; }
      } else {
        endTurnBtn.disabled = false;
      }
    }
  } else {
    // normal move
    if (d1===d2) doublesCount++; else doublesCount=0;
    if (doublesCount>=3){
      // three doubles -> dungeon
      sendToDungeon(hero);
      doublesCount=0;
      endTurnBtn.disabled = false;
      return;
    }
    animateAndResolve(hero,total,d1===d2);
  }
});

function animateAndResolve(playerObj, steps, rolledDouble){
  movePlayerAnimated(playerObj, steps, ()=>{
    updateTokenPosition(playerObj);
    handleLanding(playerObj, steps);
    updateStats();
    // decide if player gets extra turn for doubles (hero)
    if (playerObj===hero && rolledDouble && !playerObj.inDungeon && !gameOver){
      showNotification("You rolled doubles! You get another turn.");
      // Enable roll button for another turn
      hasRolled = false;
      rollBtn.disabled = false;
      return;
    } else {
      // after hero moves, enable end turn button
      endTurnBtn.disabled = false;
    }
  });
}

function endTurn(){
  if (gameOver) return;
  
  // toggle turn
  currentPlayer = currentPlayer==='hero'?'enemy':'hero';
  updateControlsForTurn();
  
  if (currentPlayer==='enemy'){
    // Update UI to show it's enemy's turn
    document.body.classList.remove('hero-turn');
    document.body.classList.add('enemy-turn');
    turnIndicator.textContent = "Enemy's Turn";
    turnIndicator.style.background = "#295d7a";
    
    setTimeout(()=>enemyPlay(), 1000);
  } else {
    // hero turn
    startHeroTurn();
  }
}

/* -------------------------
   Enemy play
   ------------------------- */
function enemyPlay(){
  if (gameOver) return;
  
  // Disable all buttons during enemy turn
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
  reinforceBtn.disabled = true;
  fortifyBtn.disabled = true;
  
  // if in dungeon, do dungeon logic
  if (enemy.inDungeon){
    enemy.dungeonTurns++;
    if (enemy.dungeonTurns>=3){
      if (enemy.army>=50){ pay(enemy,50); enemy.inDungeon=false; log("Enemy sacrificed 50 soldiers to escape the dungeon."); }
      else log("Enemy cannot sacrifice to escape the dungeon.");
    } else {
      log("Enemy is in the dungeon and stays this turn.");
      setTimeout(endTurn, 1000);
      return;
    }
  }
  // Enemy rolls
  const [d1,d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  const total = d1+d2;
  let enemyDoubles = (d1===d2);
  // handle double rules for enemy
  if (enemyDoubles) doublesCount++;
  else doublesCount=0;
  if (doublesCount>=3){
    sendToDungeon(enemy);
    doublesCount=0;
    setTimeout(endTurn, 1000);
    return;
  }
  movePlayerAnimated(enemy, total, ()=>{
    updateTokenPosition(enemy);
    handleLanding(enemy,total);
    updateStats();
    // Enemy reinforces with simple logic
    enemyReinforces();
    // if rolled doubles and not in dungeon -> extra enemy turn
    if (enemyDoubles && !enemy.inDungeon){
      setTimeout(()=>{ enemyPlay(); }, 800);
    } else {
      // back to hero
      setTimeout(endTurn, 1000);
    }
  });
}

/* Enemy reinforce heuristics */
function enemyReinforces(){
  // if enemy controls full set, attempt to reinforce on cheapest territory in that set if army > threshold
  const colorGroups = {};
  board.forEach((s,i)=>{ if (s.color) { colorGroups[s.color] = colorGroups[s.color] || []; colorGroups[s.color].push(i); }});
  for (const color in colorGroups){
    const idxs = colorGroups[color];
    if (idxs.every(i=>board[i].owner==='enemy')){
      // affordable?
      const cheapest = idxs.map(i=>board[i]).sort((a,b)=>a.price-b.price)[0];
      const garrisonCost = Math.round(cheapest.price*0.5);
      if (enemy.army > garrisonCost + 200){
        // reinforce first territory with less than 5 garrisons
        const target = idxs.map(i=>board[i]).find(s=>s.garrisons < 5);
        if (target){ target.garrisons++; enemy.army -= garrisonCost; log(`Enemy reinforced ${target.name} for ${fmtArmy(garrisonCost)}.`); updateBoardOwners(); updateStats(); }
      }
    }
  }
}

/* -------------------------
   Controls update & stats
   ------------------------- */
function updateControlsForTurn(){
  if (currentPlayer==='hero'){
    rollBtn.disabled = false;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = false;
    fortifyBtn.disabled = false;
  } else {
    rollBtn.disabled = true;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = true;
    fortifyBtn.disabled = true;
  }
}

endTurnBtn.addEventListener('click', ()=>{
  endTurn();
});

/* -------------------------
   Event listeners for new UI elements
   ------------------------- */
cardClose.addEventListener('click', () => {
  cardDisplay.style.display = 'none';
  // Re-enable controls
  endTurnBtn.disabled = false;
});

territoryConquestBuy.addEventListener('click', () => {
  const sq = board[hero.pos];
  conquerTerritory(hero, 'hero', sq);
  territoryConquest.style.display = 'none';
  // Re-enable controls
  endTurnBtn.disabled = false;
});

territoryConquestPass.addEventListener('click', () => {
  territoryConquest.style.display = 'none';
  log(`You passed on conquering ${board[hero.pos].name}.`);
  // Re-enable controls
  endTurnBtn.disabled = false;
});

dungeonPay.addEventListener('click', () => {
  if (hero.army >= 50) {
    pay(hero, 50);
    hero.inDungeon = false;
    hero.dungeonTurns = 0;
    log("You sacrificed 50 soldiers to escape the Dungeon.");
    showNotification("You sacrificed 50 soldiers to escape the Dungeon.");
    dungeonManagement.style.display = 'none';
    // Re-enable controls
    rollBtn.disabled = false;
    endTurnBtn.disabled = false;
  } else {
    showNotification("You don't have enough soldiers to sacrifice.");
  }
});

dungeonRoll.addEventListener('click', () => {
  dungeonManagement.style.display = 'none';
  // Simulate a roll for dungeon
  const [d1, d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  if (d1 === d2) {
    hero.inDungeon = false;
    hero.dungeonTurns = 0;
    log("You rolled doubles and escaped the dungeon!");
    showNotification("You rolled doubles and escaped the dungeon!");
    animateAndResolve(hero, d1+d2, true);
  } else {
    hero.dungeonTurns++;
    log("You failed to roll doubles in the Dungeon.");
    showNotification("You failed to roll doubles in the Dungeon.");
    if (hero.dungeonTurns >= 3) {
      log("You have been in the dungeon for 3 turns. You must sacrifice 50 soldiers next turn.");
    }
    endTurnBtn.disabled = false;
  }
});

// Class selection
classOptions.forEach(option => {
  option.addEventListener('click', () => {
    classOptions.forEach(opt => opt.classList.remove('selected'));
    option.classList.add('selected');
    hero.class = option.getAttribute('data-class');
    heroClassEl.textContent = hero.class;
    startGameBtn.disabled = false;
  });
});

startGameBtn.addEventListener('click', () => {
  classSelection.style.display = 'none';
  startHeroTurn();
  log("Game ready. Click 'Roll Initiative' to start your turn.");
});

/* -------------------------
   Utility: UI & Stats initial
   ------------------------- */
function updateStats(){
  heroArmyEl.textContent = "Army: " + fmtArmy(hero.army);
  enemyArmyEl.textContent = "Army: " + fmtArmy(enemy.army);
  heroTerritoriesEl.textContent = "Territories: " + (hero.territories.length? hero.territories.map(i=>board[i].name).join(', ') : 'None');
  enemyTerritoriesEl.textContent = "Territories: " + (enemy.territories.length? enemy.territories.map(i=>board[i].name).join(', ') : 'None');
  heroDungeonEl.textContent = hero.inDungeon ? `In Dungeon (${hero.dungeonTurns} turns)` : '';
  enemyDungeonEl.textContent = enemy.inDungeon ? `In Dungeon (${enemy.dungeonTurns} turns)` : '';
  
  // Check for defeat
  if (hero.army <= 0) {
    showNotification("Enemy wins! Your army has been defeated.");
    gameOver = true;
    document.body.classList.add('game-over');
  } else if (enemy.army <= 0) {
    showNotification("You win! The enemy army has been defeated.");
    gameOver = true;
    document.body.classList.add('game-over');
  }
}

/* -------------------------
   Utility: events & init
   ------------------------- */
window.addEventListener('resize', ()=>{ updateTokenPosition(hero); updateTokenPosition(enemy);});
createBoardUI();
updateBoardOwners();
updateTokenPosition(hero);
updateTokenPosition(enemy);
updateStats();

// Show class selection at start
classSelection.style.display = 'block';
heroClassEl.textContent = hero.class;
enemyClassEl.textContent = enemy.class;

/* -------------------------
   End of script
   ------------------------- */
</script>
</body>
</html>
