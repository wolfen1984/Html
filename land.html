<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Land of the Undead - RPG Strategy Game</title>
<style>
  :root{
    --cell: 30px;
    --gap: 1px;
    --board-size: 340px;
  }
  
  body{
    font-family: Arial, Helvetica, sans-serif;
    background: #1a1a2e;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 10px;
    color: #e6e6e6;
    font-size: 14px;
  }
  
  h1{
    color: #ffcc00;
    margin: 0 0 6px 0;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    font-size: 1.8rem;
    text-align: center;
  }
  
  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    max-width: 100%;
  }
  
  #boardWrap{
    position: relative;
    width: var(--board-size);
    height: var(--board-size);
  }
  
  #game-board{
    display: grid;
    grid-template-columns: repeat(11, var(--cell));
    grid-template-rows: repeat(11, var(--cell));
    gap: var(--gap);
    background: #162447;
    border: 4px solid #8a0303;
    box-shadow: 0 4px 12px rgba(0,0,0,.6);
    width: var(--board-size);
    height: var(--board-size);
  }
  
  .cell{
    width: var(--cell);
    height: var(--cell);
    border: 1px solid #333;
    box-sizing: border-box;
    font-size: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 1px;
    position: relative;
    background: #1e1e2e;
    color: #e6e6e6;
    overflow: hidden;
  }
  
  .corner{background:#5d0e0e;font-weight:700;color:#ffcc00}
  .castle{background:#7a2929}
  .village{background:#295d7a}
  .forest{background:#2d5d29}
  .mountain{background:#5d5d5d}
  .stronghold{background:#5d295d}
  .artifact{background:#5d5d29}
  .tribute{background:#5d2929}
  .quest{background:#29295d}
  
  .ownerTag{
    position:absolute;
    left:1px;
    top:1px;
    font-size:7px;
    padding:1px 3px;
    border-radius:3px;
    background:rgba(0,0,0,.6);
    color:#fff;
  }
  
  .garrisons{
    position:absolute;
    right:2px;
    bottom:2px;
    font-size:9px;
  }
  
  .player-token{
    width:12px;
    height:12px;
    border-radius:50%;
    position:absolute;
    transition:all .25s linear;
    z-index:20;
    box-shadow:0 1px 4px rgba(0,0,0,.5);
  }
  
  .token-hero{background:#e33}
  .token-enemy{background:#37f}
  
  #controls{
    display:flex;
    gap:6px;
    align-items:center;
    flex-wrap:wrap;
    justify-content:center;
    margin-top: 5px;
  }
  
  button{
    padding:6px 10px;
    font-size:12px;
    cursor:pointer;
    background:#5d0e0e;
    color:#fff;
    border:1px solid #ffcc00;
    border-radius:3px;
  }
  
  button:hover{background:#7a2929}
  button:disabled{background:#333;color:#666;cursor:not-allowed}
  
  #stats-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    width: 100%;
    max-width: var(--board-size);
  }
  
  #stats{
    display:flex;
    gap:8px;
    justify-content:center;
    flex-wrap:wrap;
  }
  
  .box{
    background:#1e1e2e;
    border:1px solid #444;
    padding:8px;
    width:calc(var(--board-size)/2 - 10px);
    box-sizing:border-box;
    color:#e6e6e6;
    font-size: 12px;
  }
  
  .box h3 {
    margin: 0 0 8px 0;
    font-size: 14px;
    color: #ffcc00;
    border-bottom: 1px solid #444;
    padding-bottom: 5px;
  }
  
  #log{
    height:80px;
    overflow:auto;
    background:#1e1e2e;
    border:1px solid #444;
    padding:6px;
    font-size:12px;
    color:#e6e6e6;
  }
  
  .small{font-size:11px}
  .owner-hero{background:rgba(227,51,51,.95)}
  .owner-enemy{background:rgba(55,103,255,.95)}
  
  /* NEW STYLES */
  #notification-area {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: #ffcc00;
    padding: 10px 16px;
    border-radius: 6px;
    z-index: 100;
    display: none;
    max-width: 80%;
    text-align: center;
    border: 1px solid #ffcc00;
    font-size: 14px;
  }
  
  #card-display, #territory-conquest, #dungeon-management, #class-selection {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #1e1e2e;
    border: 2px solid #ffcc00;
    border-radius: 8px;
    padding: 15px;
    z-index: 90;
    display: none;
    box-shadow: 0 6px 20px rgba(0,0,0,0.5);
    max-width: 80%;
    text-align: center;
    color: #e6e6e6;
    width: 300px;
  }
  
  #card-display h3, #territory-conquest h3, #dungeon-management h3, #class-selection h3 {
    margin: 0 0 12px 0;
    color: #ffcc00;
    border-bottom: 1px solid #444;
    padding-bottom: 8px;
    font-size: 16px;
  }
  
  #card-display p, #territory-conquest p, #dungeon-management p {
    margin: 12px 0;
    font-size: 14px;
  }
  
  #card-display button, #territory-conquest button, #dungeon-management button, .class-option {
    margin-top: 10px;
    background: #295d29;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
  }
  
  .turn-indicator {
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background: #5d0e0e;
    color: #ffcc00;
    padding: 4px 12px;
    border-radius: 15px;
    font-weight: bold;
    z-index: 10;
    border: 1px solid #ffcc00;
    font-size: 12px;
  }
  
  .hero-turn #rollBtn {
    background: #295d29;
    color: white;
  }
  
  .enemy-turn #rollBtn {
    background: #333;
    color: #666;
    cursor: not-allowed;
  }
  
  .game-over {
    pointer-events: none;
    opacity: 0.7;
  }
  
  #diceDisplay {
    font-weight: bold;
    font-size: 13px;
    padding: 6px;
    border: 1px solid #444;
    border-radius: 4px;
    background: #1e1e2e;
    min-width: 100px;
    text-align: center;
    color: #ffcc00;
  }
  
  .class-option {
    margin: 8px 0;
    padding: 8px;
    border: 1px solid #444;
    border-radius: 4px;
    cursor: pointer;
    background: #2d2d3e;
    text-align: left;
    width: auto;
  }
  
  .class-option:hover {
    background: #3d3d4e;
  }
  
  .class-option.selected {
    background: #5d0e0e;
    border-color: #ffcc00;
  }
  
  .highlight {
    animation: highlight 1s ease-in-out;
  }
  
  @keyframes highlight {
    0% { box-shadow: 0 0 0 0 rgba(255,215,0,0.7); }
    70% { box-shadow: 0 0 0 6px rgba(255,215,0,0); }
    100% { box-shadow: 0 0 0 0 rgba(255,215,0,0); }
  }
  
  /* Responsive adjustments */
  @media (max-width: 600px) {
    :root {
      --cell: 25px;
      --board-size: 280px;
    }
    
    h1 {
      font-size: 1.5rem;
    }
    
    .cell {
      font-size: 7px;
    }
    
    #controls {
      flex-direction: column;
    }
    
    #stats {
      flex-direction: column;
    }
    
    .box {
      width: 100%;
    }
  }
</style>
</head>
<body>
  <h1>Land of the Undead - RPG Strategy Game</h1>
  
  <div id="game-container">
    <div id="boardWrap">
      <div id="game-board"></div>
      <div class="turn-indicator" id="turnIndicator">Hero's Turn</div>

      <!-- Tokens placed absolutely relative to viewport and board -->
      <div id="heroToken" class="player-token token-hero" style="left:0;top:0"></div>
      <div id="enemyToken" class="player-token token-enemy" style="left:0;top:0"></div>
    </div>

    <div id="controls">
      <button id="rollBtn">Roll Initiative (Your Turn)</button>
      <button id="endTurnBtn" disabled>End Turn</button>
      <button id="reinforceBtn" disabled>Reinforce Garrison</button>
      <button id="fortifyBtn" disabled>Fortify / Abandon</button>
      <div id="diceDisplay" class="small">Initiative: -</div>
    </div>

    <div id="stats-container">
      <div id="stats">
        <div class="box" id="heroStats">
          <h3 id="heroClass">Hero</h3>
          <div id="heroArmy">Army: 1500 soldiers</div>
          <div id="heroTerritories" class="small">Territories: None</div>
          <div id="heroDungeon" class="small"></div>
        </div>
        <div class="box" id="enemyStats">
          <h3 id="enemyClass">Enemy</h3>
          <div id="enemyArmy">Army: 1500 soldiers</div>
          <div id="enemyTerritories" class="small">Territories: None</div>
          <div id="enemyDungeon" class="small"></div>
        </div>
      </div>
      
      <div class="box">
        <h3>Battle Log</h3>
        <div id="log"></div>
      </div>
    </div>
  </div>

  <!-- NEW ELEMENTS -->
  <div id="notification-area"></div>
  
  <div id="card-display">
    <h3 id="card-pile-name"></h3>
    <p id="card-text"></p>
    <button id="card-close">Continue</button>
  </div>
  
  <div id="territory-conquest">
    <h3>Territory Available</h3>
    <p id="territory-name"></p>
    <p id="territory-cost"></p>
    <div id="territory-conquest-buttons">
      <button id="territory-conquest-buy">Conquer</button>
      <button id="territory-conquest-pass">Ignore</button>
    </div>
  </div>
  
  <div id="dungeon-management">
    <h3>You're Captured!</h3>
    <p id="dungeon-message"></p>
    <div id="dungeon-buttons">
      <button id="dungeon-pay">Sacrifice 50 Soldiers</button>
      <button id="dungeon-roll">Roll for Escape</button>
    </div>
  </div>

  <div id="class-selection">
    <h3>Choose Your Hero Class</h3>
    <div class="class-option" data-class="Paladin">Paladin - Holy warrior strong against undead</div>
    <div class="class-option" data-class="Ranger">Ranger - Expert scout and survivalist</div>
    <div class="class-option" data-class="Wizard">Wizard - Master of arcane powers</div>
    <div class="class-option" data-class="Warrior">Warrior - Master of weapons and combat</div>
    <button id="start-game" disabled>Begin Battle</button>
  </div>

<script>
/* -------------------------
   Board data & init
   ------------------------- */
const board = [
  { name:"Recruitment", type:"corner" },
  { name:"Haunted Hamlet", type:"village", price:60, rent:2, color:"brown" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Ghostly Grove", type:"forest", price:60, rent:4, color:"brown" },
  { name:"Plunder", type:"tribute", price:200 },
  { name:"Northern Stronghold", type:"stronghold", price:200 },
  { name:"Whispering Woods", type:"forest", price:100, rent:6, color:"lightblue" },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Mystic Marsh", type:"forest", price:100, rent:6, color:"lightblue" },
  { name:"Enchanted Glen", type:"forest", price:120, rent:8, color:"lightblue" },
  { name:"Dungeon", type:"corner" },
  { name:"Dragon's Peak", type:"mountain", price:140, rent:10, color:"pink" },
  { name:"Holy Relic", type:"artifact", price:150 },
  { name:"Griffin's Nest", type:"mountain", price:140, rent:10, color:"pink" },
  { name:"Troll's Cave", type:"mountain", price:160, rent:12, color:"pink" },
  { name:"Eastern Stronghold", type:"stronghold", price:200 },
  { name:"Shadow Keep", type:"castle", price:180, rent:14, color:"orange" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Dread Fortress", type:"castle", price:180, rent:14, color:"orange" },
  { name:"Black Tower", type:"castle", price:200, rent:16, color:"orange" },
  { name:"Reinforcements", type:"corner" },
  { name:"Necropolis", type:"castle", price:220, rent:18, color:"red" },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Plague City", type:"castle", price:220, rent:18, color:"red" },
  { name:"Crypt", type:"castle", price:240, rent:20, color:"red" },
  { name:"Southern Stronghold", type:"stronghold", price:200 },
  { name:"Holy Temple", type:"castle", price:260, rent:22, color:"yellow" },
  { name:"Divine Shrine", type:"castle", price:260, rent:22, color:"yellow" },
  { name:"Cursed Idol", type:"artifact", price:150 },
  { name:"Sacred Grove", type:"forest", price:280, rent:24, color:"yellow" },
  { name:"Captured", type:"corner", action:"gotodungeon" },
  { name:"Arcane Spire", type:"castle", price:300, rent:26, color:"green" },
  { name:"Wizard's Tower", type:"castle", price:300, rent:26, color:"green" },
  { name:"Quest", type:"quest", pile:"quest" },
  { name:"Sorcerer's Citadel", type:"castle", price:320, rent:28, color:"green" },
  { name:"Western Stronghold", type:"stronghold", price:200 },
  { name:"Event", type:"quest", pile:"event" },
  { name:"Dragon's Lair", type:"castle", price:350, rent:35, color:"darkblue" },
  { name:"Tithe", type:"tribute", price:100 },
  { name:"Phoenix Roost", type:"castle", price:400, rent:50, color:"darkblue" }
];
// add tracking fields for territories
board.forEach((s,i)=>{
  if (["village","forest","mountain","castle","stronghold","artifact"].includes(s.type)) {
    s.owner = null; // 'hero' or 'enemy'
    s.garrisons = 0;   // 0-4, 5 -> fortress (we'll treat 5 as fortress)
    s.fortified = false;
  }
});

/* -------------------------
   Players & game state
   ------------------------- */
let hero = { name:"Hero", pos:0, army:1500, territories:[], inDungeon:false, dungeonTurns:0, class: "Paladin" };
let enemy = { name:"Enemy", pos:0, army:1500, territories:[], inDungeon:false, dungeonTurns:0, class: "Necromancer" };
let currentPlayer = 'hero';
let doublesCount = 0;
let gameOver = false;
let isMoving = false; // Track if a player is currently moving
let hasRolled = false; // Track if player has rolled this turn

/* -------------------------
   Cards
   ------------------------- */
const eventCards = [
  { text:"Advance to Recruitment", exec:pl=>{pl.pos=0; give(pl,200);} },
  { text:"Your army receives reinforcements of 50 soldiers", exec:pl=>give(pl,50) },
  { text:"You've been captured! Go to the Dungeon", exec:pl=>sendToDungeon(pl) },
  { text:"Sacrifice 15 soldiers to local lords", exec:pl=>pay(pl,15) },
  { text:"Advance to Phoenix Roost", exec:pl=>{pl.pos=39; } },
  { text:"March to the Northern Stronghold", exec:pl=>pl.pos=5 },
  { text:"Your investments pay off - collect 150 soldiers", exec:pl=>give(pl,150) },
  { text:"Sacrifice 50 soldiers for equipment repairs", exec:pl=>pay(pl,50) }
];
const questCards = [
  { text:"From successful campaigns you get 50 soldiers", exec:pl=>give(pl,50) },
  { text:"Sacrifice 100 soldiers for healing fees", exec:pl=>pay(pl,100) },
  { text:"Royal favor - collect 200 soldiers", exec:pl=>give(pl,200) },
  { text:"Collect 25 soldiers reward for completed quest", exec:pl=>give(pl,25) },
  { text:"You inherit 100 soldiers from fallen comrade", exec:pl=>give(pl,100) },
  { text:"Betrayed! Go to the Dungeon", exec:pl=>sendToDungeon(pl) },
  { text:"Sacrifice 50 soldiers for supplies", exec:pl=>pay(pl,50) },
  { text:"Successful trade - collect 100 soldiers", exec:pl=>give(pl,100) }
];
function drawCard(pile){
  const arr = pile==='event'?eventCards:questCards;
  const card = arr[Math.floor(Math.random()*arr.length)];
  return card;
}

/* -------------------------
   UI elements & helpers
   ------------------------- */
const boardEl = document.getElementById('game-board');
const heroToken = document.getElementById('heroToken');
const enemyToken = document.getElementById('enemyToken');
const rollBtn = document.getElementById('rollBtn');
const endTurnBtn = document.getElementById('endTurnBtn');
const reinforceBtn = document.getElementById('reinforceBtn');
const fortifyBtn = document.getElementById('fortifyBtn');
const diceDisplay = document.getElementById('diceDisplay');
const logEl = document.getElementById('log');
const heroArmyEl = document.getElementById('heroArmy');
const enemyArmyEl = document.getElementById('enemyArmy');
const heroTerritoriesEl = document.getElementById('heroTerritories');
const enemyTerritoriesEl = document.getElementById('enemyTerritories');
const heroDungeonEl = document.getElementById('heroDungeon');
const enemyDungeonEl = document.getElementById('enemyDungeon');
const turnIndicator = document.getElementById('turnIndicator');
const heroClassEl = document.getElementById('heroClass');
const enemyClassEl = document.getElementById('enemyClass');
const classSelection = document.getElementById('class-selection');
const classOptions = document.querySelectorAll('.class-option');
const startGameBtn = document.getElementById('start-game');

// NEW ELEMENTS
const notificationArea = document.getElementById('notification-area');
const cardDisplay = document.getElementById('card-display');
const cardPileName = document.getElementById('card-pile-name');
const cardText = document.getElementById('card-text');
const cardClose = document.getElementById('card-close');
const territoryConquest = document.getElementById('territory-conquest');
const territoryName = document.getElementById('territory-name');
const territoryCost = document.getElementById('territory-cost');
const territoryConquestBuy = document.getElementById('territory-conquest-buy');
const territoryConquestPass = document.getElementById('territory-conquest-pass');
const dungeonManagement = document.getElementById('dungeon-management');
const dungeonMessage = document.getElementById('dungeon-message');
const dungeonPay = document.getElementById('dungeon-pay');
const dungeonRoll = document.getElementById('dungeon-roll');

function log(...txt){
  logEl.innerHTML += `<div>${txt.join(' ')}</div>`;
  logEl.scrollTop = logEl.scrollHeight;
}
function fmtArmy(n){return `${n} soldiers`;}
function give(player, amt){
  player.army += amt;
  log(`${player.name} receives ${fmtArmy(amt)}.`);
  updateStats();
}
function pay(player, amt){
  player.army -= amt;
  log(`${player.name} sacrifices ${fmtArmy(amt)}.`);
  updateStats();
  checkDefeat(player);
}
function getPlayerObj(id){ return id==='hero'?hero:enemy; }
function checkDefeat(player){
  if (player.army < 0){
    gameOver = true;
    const other = player===hero?enemy:hero;
    showNotification(`${player.name} has been defeated! ${other.name} wins the war!`);
    log(`${player.name} has been defeated. ${ (player===hero)?'Enemy':'Hero' } wins!`);
    rollBtn.disabled = true;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = true;
    fortifyBtn.disabled = true;
    document.body.classList.add('game-over');
  }
}

// NEW FUNCTIONS FOR UI
function showNotification(message, duration = 3000) {
  notificationArea.textContent = message;
  notificationArea.style.display = 'block';
  
  setTimeout(() => {
    notificationArea.style.display = 'none';
  }, duration);
}

function showCard(card, pile) {
  cardPileName.textContent = `${pile.toUpperCase()} Card`;
  cardText.textContent = card.text;
  cardDisplay.style.display = 'block';
  
  // Disable controls while card is displayed
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

function showTerritoryConquest(sq) {
  territoryName.textContent = sq.name;
  territoryCost.textContent = `Conquest Cost: ${fmtArmy(sq.price)}`;
  territoryConquest.style.display = 'block';
  
  // Disable controls while conquest decision is pending
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

function showDungeonManagement() {
  dungeonMessage.textContent = `You have been captured for ${hero.dungeonTurns} turn(s).`;
  dungeonManagement.style.display = 'block';
  
  // Disable controls while dungeon decision is pending
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
}

/* -------------------------
   Build visual board
   ------------------------- */
function createBoardUI(){
  // create 11x11 grid cells and map positions like classic monopoly
  for(let i=0;i<121;i++){
    const cell = document.createElement('div');
    cell.className='cell';
    boardEl.appendChild(cell);
  }
  // place 40 squares into appropriate grid cells (same mapping as your original)
  for(let i=0;i<40;i++){
    const sq = document.createElement('div');
    const base = board[i];
    sq.className = `cell ${base.type}`;
    if (base.type==='corner') sq.classList.add('corner');
    if (base.type==='village') sq.classList.add('village');
    if (base.type==='forest') sq.classList.add('forest');
    if (base.type==='mountain') sq.classList.add('mountain');
    if (base.type==='castle') sq.classList.add('castle');
    if (base.type==='stronghold') sq.classList.add('stronghold');
    if (base.type==='artifact') sq.classList.add('artifact');
    if (base.type==='tribute') sq.classList.add('tribute');
    if (base.type==='quest') sq.classList.add('quest');
    sq.dataset.idx = i;
    sq.style.display = 'flex';
    sq.style.flexDirection = 'column';
    sq.style.justifyContent = 'center';
    sq.style.alignItems = 'center';
    sq.style.fontSize = '8px';
    sq.innerHTML = `<div style="font-weight:600">${base.name}</div>`;
    if (base.price) sq.innerHTML += `<div style="font-size:7px">${fmtArmy(base.price)}</div>`;
    // owner tag & garrisons
    const ownerTag = document.createElement('div');
    ownerTag.className='ownerTag';
    ownerTag.style.display='none';
    sq.appendChild(ownerTag);
    const garrisons = document.createElement('div');
    garrisons.className='garrisons';
    garrisons.style.display='none';
    sq.appendChild(garrisons);

    // compute insertion index into 11x11 cells
    // mapping like original: indexes 0..10 top row right to left, 11..19 right col top->bottom, 20..30 bottom row left->right, 31..39 left col bottom->top
    let cellIndex;
    if (i < 11) cellIndex = (11 - i - 1); // top row cells 0..10 mapping left->right
    else if (i < 20) cellIndex = (i - 10) * 11 - 1 + 11; // right column (approx). Simpler: compute coordinates then map.
    // To avoid mapping math issues, compute row/col and index:
    const coords = idxToRowCol(i);
    const insertIndex = coords.row * 11 + coords.col;
    boardEl.replaceChild(sq, boardEl.children[insertIndex]);
  }
}

function idxToRowCol(i){
  // returns {row, col} in 0..10 grid
  if (i < 11) {
    // top row: positions 0..10 go from right->left across top
    return {row:0, col:10 - i};
  } else if (i < 20){
    // right column: positions 11..19 go from 1..9 rows at col 10
    return {row:i - 10, col:10};
  } else if (i < 31){
    // bottom row: 20..30 go left->right across row 10
    return {row:10, col:i - 20};
  } else {
    // left column: 31..39 go bottom->top at col 0
    return {row:40 - i, col:0};
  }
}

/* -------------------------
   Update tokens visually
   ------------------------- */
function updateTokenPosition(player){
  // find cell with dataset idx == player.pos and locate its bounding rect
  const cell = boardEl.querySelector(`[data-idx="${player.pos}"]`);
  if (!cell) return;
  const cellRect = cell.getBoundingClientRect();
  const boardRect = boardEl.getBoundingClientRect();
  // position token relative to board container
  const x = (cellRect.left - boardRect.left) + cellRect.width/2 - 6; // subtract half token
  const y = (cellRect.top - boardRect.top) + cellRect.height/2 - 6;
  if (player===hero){
    heroToken.style.transform = `translate(${x}px, ${y}px)`;
  } else {
    enemyToken.style.transform = `translate(${x+10}px, ${y}px)`; // slight offset
  }
  
  // Highlight the current cell
  cell.classList.add('highlight');
  setTimeout(() => {
    cell.classList.remove('highlight');
  }, 1000);
}

/* -------------------------
   Movement animation
   ------------------------- */
function movePlayerAnimated(playerObj, steps, cb){
  isMoving = true; // Set moving flag
  let step = 0;
  let plObj = playerObj;
  const pg = setInterval(()=>{
    step++;
    const prev = plObj.pos;
    plObj.pos = (plObj.pos + 1) % 40;
    updateTokenPosition(plObj);
    // passing Recruitment
    if (plObj.pos === 0) {
      give(plObj,200);
      log(`${plObj.name} passed Recruitment and collected 200 soldiers`);
      showNotification(`${plObj.name} passed Recruitment and collected 200 soldiers!`);
    }
    if (step >= steps){ 
      clearInterval(pg); 
      isMoving = false; // Clear moving flag
      cb && cb(); 
    }
  }, 260);
}

/* -------------------------
   Landing & square handling
   ------------------------- */
function handleLanding(playerObj, diceTotal){
  const sq = board[playerObj.pos];
  log(`${playerObj.name} entered ${sq.name} (${playerObj.pos})`);
  showNotification(`${playerObj.name} entered ${sq.name}`);
  
  if (sq.type==='tribute'){
    pay(playerObj, sq.price);
    showNotification(`${playerObj.name} sacrificed ${fmtArmy(sq.price)} in tribute`);
    return;
  }
  if (sq.type==='corner' && sq.action==='gotodungeon'){
    sendToDungeon(playerObj);
    return;
  }
  if (sq.type==='corner' && sq.name==='Reinforcements'){
    // Loot drop - random amount of soldiers
    const loot = Math.floor(Math.random() * 100) + 50;
    give(playerObj, loot);
    showNotification(`${playerObj.name} found ${fmtArmy(loot)} in reinforcements!`);
    return;
  }
  if (sq.type==='quest'){
    const card = drawCard(sq.pile);
    showCard(card, sq.pile);
    return;
  }
  if (['village','forest','mountain','castle','stronghold','artifact'].includes(sq.type)){
    if (sq.owner===null){
      // offer to conquer if hero, otherwise enemy auto-decide
      if (playerObj===hero){
        // prompt conquest interface
        showTerritoryConquest(sq);
      } else {
        // Enemy decision
        const willConquer = enemyShouldConquer(playerObj, sq);
        if (willConquer) { conquerTerritory(playerObj, 'enemy', sq); }
        else log(`Enemy passed on ${sq.name}.`);
      }
    } else if (sq.owner !== (playerObj===hero?'hero':'enemy')){
      // pay tribute if not fortified
      if (sq.fortified){
        log(`Territory ${sq.name} is fortified; no tribute due.`);
        showNotification(`Territory ${sq.name} is fortified; no tribute due.`);
        return;
      }
      const owner = getPlayerObj(sq.owner);
      const tribute = calculateTribute(sq, diceTotal, owner);
      pay(playerObj, tribute);
      give(owner, tribute);
      log(`${playerObj.name} paid ${fmtArmy(tribute)} tribute to ${owner.name} for ${sq.name}.`);
      showNotification(`${playerObj.name} paid ${fmtArmy(tribute)} tribute to ${owner.name}`);
    } else {
      log(`${playerObj.name} entered own territory.`);
    }
  }
  updateBoardOwners();
}

/* -------------------------
   Conquer, reinforce, fortify
   ------------------------- */
function conquerTerritory(playerObj, ownerId, sq){
  if (playerObj.army < sq.price){
    log(`${playerObj.name} cannot afford to conquer ${sq.name}.`);
    showNotification(`${playerObj.name} cannot afford to conquer ${sq.name}.`);
    return;
  }
  playerObj.army -= sq.price;
  sq.owner = ownerId;
  playerObj.territories.push(sqIndex(sq));
  log(`${playerObj.name} conquered ${sq.name} for ${fmtArmy(sq.price)}.`);
  showNotification(`${playerObj.name} conquered ${sq.name}!`);
  updateStats();
  updateBoardOwners();
}

function sqIndex(sq){ return board.indexOf(sq); }

function calculateTribute(sq, diceTotal=0, ownerObj=null){
  if (sq.type==='artifact'){
    // if owner has both artifacts, high multiplier
    let owner = ownerObj || getPlayerObj(sq.owner);
    if (!owner) return 0;
    const artifactCount = owner.territories.filter(i=>board[i].type==='artifact').length;
    const mult = artifactCount>1?10:4;
    return mult * (diceTotal || 1);
  }
  if (sq.type==='stronghold'){
    let owner = ownerObj || getPlayerObj(sq.owner);
    const strongholdCount = owner.territories.filter(i=>board[i].type==='stronghold').length;
    return 25 * strongholdCount; // simplified
  }
  // territory
  if (sq.garrisons >= 5) return sq.rent * 10; // fortress
  if (sq.garrisons > 0) return sq.rent * (sq.garrisons + 1);
  // check control (all same color owned)
  if (sq.color){
    const sameColor = board.reduce((acc,s,i)=>{
      if (s.color===sq.color) acc.push(i);
      return acc;
    },[]);
    const owner = getPlayerObj(sq.owner);
    const ownsAll = sameColor.every(i => owner.territories.includes(i));
    if (ownsAll) return sq.rent * 2; // double tribute for control
  }
  return sq.rent;
}

function updateBoardOwners(){
  // set owner tags and garrisons visually
  board.forEach((s,i)=>{
    const cell = boardEl.querySelector(`[data-idx="${i}"]`);
    if (!cell) return;
    const ownerTag = cell.querySelector('.ownerTag');
    const garrisonsTag = cell.querySelector('.garrisons');
    if (["village","forest","mountain","castle","stronghold","artifact"].includes(s.type) && s.owner){
      ownerTag.style.display='block';
      ownerTag.textContent = s.owner==='hero' ? 'Hero' : 'Enemy';
      ownerTag.className = 'ownerTag ' + (s.owner==='hero'?'owner-hero':'owner-enemy');
      if (s.fortified){ ownerTag.textContent += ' (F)'; }
    } else {
      ownerTag.style.display='none';
      ownerTag.textContent='';
      ownerTag.className='ownerTag';
    }
    if (["village","forest","mountain","castle"].includes(s.type) && (s.garrisons>0 || s.garrisons===5)){
      garrisonsTag.style.display='block';
      if (s.garrisons===5) garrisonsTag.textContent = 'Fortress';
      else garrisonsTag.textContent = 'G:' + s.garrisons;
    } else { garrisonsTag.style.display='none'; garrisonsTag.textContent=''; }
  });
}

/* -------------------------
   Dungeon mechanics
   ------------------------- */
function sendToDungeon(playerObj){
  playerObj.pos = 10;
  playerObj.inDungeon = true;
  playerObj.dungeonTurns = 0;
  updateTokenPosition(playerObj);
  log(`${playerObj.name} was captured and sent to the Dungeon.`);
  showNotification(`${playerObj.name} was captured and sent to the Dungeon!`);
}

/* -------------------------
   Simple Enemy heuristics
   ------------------------- */
function enemyShouldConquer(playerObj, sq){
  // conquers if has more than price + 150 buffer and not near defeat
  if (playerObj.army > sq.price + 150) return true;
  return false;
}

function enemyTurn(d1,d2,total){
  // if in dungeon simple behavior: try to pay to get out if low dungeonTurns or roll dice for doubles handled earlier
  if (enemy.inDungeon){
    enemy.dungeonTurns++;
    if (enemy.dungeonTurns >= 3){
      // pay to get out
      if (enemy.army >= 50){ pay(enemy,50); enemy.inDungeon=false; log("Enemy sacrificed 50 soldiers to escape the Dungeon."); }
      else { log("Enemy cannot sacrifice to escape the dungeon"); }
    } else {
      log("Enemy remains in the Dungeon this turn.");
      return endTurn();
    }
  }
  // roll already performed in controller; landing handled after move
}

/* -------------------------
   Garrisons & Fortifications UI actions
   ------------------------- */
reinforceBtn.addEventListener('click', ()=>{
  // show list of player's reinforceable territories
  const playerObj = currentPlayer==='hero' ? hero : enemy;
  const reinforceable = playerObj.territories
    .map(i=>board[i])
    .filter(s=>["village","forest","mountain","castle"].includes(s.type) && !s.fortified);
  if (reinforceable.length===0){
    showNotification("You have no territories to reinforce.");
    return;
  }
  
  // For simplicity, we'll just reinforce the first available territory
  const s = reinforceable[0];
  
  // check full control
  if (!s.color){ 
    showNotification("You can only reinforce colored territories.");
    return; 
  }
  const sameColorIdxs = board.reduce((acc,s,i)=>{ if (s.color===s.color) acc.push(i); return acc;},[]);
  // check ownership
  if (!sameColorIdxs.every(i=>board[i].owner=== (playerObj===hero? 'hero':'enemy'))){
    showNotification("You must control the full color set to reinforce.");
    return;
  }
  const garrisonCost = Math.round(s.price * 0.5);
  if (playerObj.army < garrisonCost){
    showNotification("You don't have enough soldiers to reinforce.");
    return;
  }
  if (s.garrisons < 4){
    s.garrisons++;
    playerObj.army -= garrisonCost;
    log(`${playerObj.name} reinforced ${s.name} with ${fmtArmy(garrisonCost)}.`);
    showNotification(`${playerObj.name} reinforced ${s.name}`);
  } else if (s.garrisons === 4){
    s.garrisons = 5; // fortress
    playerObj.army -= garrisonCost;
    log(`${playerObj.name} built a fortress on ${s.name} for ${fmtArmy(garrisonCost)}.`);
    showNotification(`${playerObj.name} built a fortress on ${s.name}`);
  } else {
    showNotification("No more reinforcement allowed on this territory.");
    return;
  }
  updateStats();
  updateBoardOwners();
});

/* Fortify / Abandon UI */
fortifyBtn.addEventListener('click', ()=>{
  const playerObj = hero;
  const fortifiable = playerObj.territories
    .map(i=>board[i])
    .filter(s=>["village","forest","mountain","castle","stronghold","artifact"].includes(s.type));
  
  if (fortifiable.length === 0) {
    showNotification("You have no territories to fortify.");
    return;
  }
  
  // For simplicity, we'll just fortify/abandon the first available territory
  const s = fortifiable[0];
  
  if (s.fortified) {
    // Abandon (unfortify)
    const val = Math.round(s.price/2 * 0.9); // Get back 90% of the garrison value
    s.fortified = false;
    playerObj.army += val;
    log(`${playerObj.name} abandoned ${s.name} for ${fmtArmy(val)}.`);
    showNotification(`${playerObj.name} abandoned ${s.name}`);
  } else {
    // Fortify
    const val = Math.round(s.price/2);
    if (playerObj.army < val){ 
      showNotification("Not enough soldiers to fortify.");
      return; 
    }
    s.fortified = true;
    playerObj.army -= val;
    log(`${playerObj.name} fortified ${s.name} for ${fmtArmy(val)}.`);
    showNotification(`${playerObj.name} fortified ${s.name}`);
  }
  updateStats();
  updateBoardOwners();
});

/* -------------------------
   Dice & turn controller
   ------------------------- */
function rollDiceVals(){
  const d1 = Math.floor(Math.random()*6)+1;
  const d2 = Math.floor(Math.random()*6)+1;
  return [d1,d2];
}

function startHeroTurn(){
  if (gameOver) return;
  // Update UI to show it's hero's turn
  document.body.classList.remove('enemy-turn');
  document.body.classList.add('hero-turn');
  turnIndicator.textContent = "Hero's Turn";
  turnIndicator.style.background = "#5d0e0e";
  
  hasRolled = false;
  rollBtn.disabled = false;
  endTurnBtn.disabled = true;
  reinforceBtn.disabled = false;
  fortifyBtn.disabled = false;
  
  if (hero.inDungeon){
    showDungeonManagement();
  }
}

rollBtn.addEventListener('click', ()=>{
  if (currentPlayer !== 'hero' || isMoving || hasRolled) return;
  
  hasRolled = true;
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
  // roll
  const [d1,d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  const total = d1 + d2;
  if (hero.inDungeon){
    // if doubles, escape and move; otherwise increase dungeonTurns
    if (d1 === d2){
      hero.inDungeon=false;
      hero.dungeonTurns=0;
      log("You rolled doubles and escaped the dungeon!");
      showNotification("You rolled doubles and escaped the dungeon!");
      animateAndResolve(hero,total,d1===d2);
    } else {
      hero.dungeonTurns++;
      log("You failed to roll doubles in the Dungeon.");
      showNotification("You failed to roll doubles in the Dungeon.");
      if (hero.dungeonTurns>=3){
        // must pay 50 and escape
        if (hero.army>=50){ pay(hero,50); hero.inDungeon=false; hero.dungeonTurns=0; log("Sacrificed 50 soldiers to escape the Dungeon."); animateAndResolve(hero,total,false); }
        else { log("Can't sacrifice to escape; still in dungeon."); endTurnBtn.disabled = false; }
      } else {
        endTurnBtn.disabled = false;
      }
    }
  } else {
    // normal move
    if (d1===d2) doublesCount++; else doublesCount=0;
    if (doublesCount>=3){
      // three doubles -> dungeon
      sendToDungeon(hero);
      doublesCount=0;
      endTurnBtn.disabled = false;
      return;
    }
    animateAndResolve(hero,total,d1===d2);
  }
});

function animateAndResolve(playerObj, steps, rolledDouble){
  movePlayerAnimated(playerObj, steps, ()=>{
    updateTokenPosition(playerObj);
    handleLanding(playerObj, steps);
    updateStats();
    // decide if player gets extra turn for doubles (hero)
    if (playerObj===hero && rolledDouble && !playerObj.inDungeon && !gameOver){
      showNotification("You rolled doubles! You get another turn.");
      // Enable roll button for another turn
      hasRolled = false;
      rollBtn.disabled = false;
      return;
    } else {
      // after hero moves, enable end turn button
      endTurnBtn.disabled = false;
    }
  });
}

function endTurn(){
  if (gameOver) return;
  
  // toggle turn
  currentPlayer = currentPlayer==='hero'?'enemy':'hero';
  updateControlsForTurn();
  
  if (currentPlayer==='enemy'){
    // Update UI to show it's enemy's turn
    document.body.classList.remove('hero-turn');
    document.body.classList.add('enemy-turn');
    turnIndicator.textContent = "Enemy's Turn";
    turnIndicator.style.background = "#295d7a";
    
    setTimeout(()=>enemyPlay(), 1000);
  } else {
    // hero turn
    startHeroTurn();
  }
}

/* -------------------------
   Enemy play
   ------------------------- */
function enemyPlay(){
  if (gameOver) return;
  
  // Disable all buttons during enemy turn
  rollBtn.disabled = true;
  endTurnBtn.disabled = true;
  reinforceBtn.disabled = true;
  fortifyBtn.disabled = true;
  
  // if in dungeon, do dungeon logic
  if (enemy.inDungeon){
    enemy.dungeonTurns++;
    if (enemy.dungeonTurns>=3){
      if (enemy.army>=50){ pay(enemy,50); enemy.inDungeon=false; log("Enemy sacrificed 50 soldiers to escape the dungeon."); }
      else log("Enemy cannot sacrifice to escape the dungeon.");
    } else {
      log("Enemy is in the dungeon and stays this turn.");
      setTimeout(endTurn, 1000);
      return;
    }
  }
  // Enemy rolls
  const [d1,d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  const total = d1+d2;
  let enemyDoubles = (d1===d2);
  // handle double rules for enemy
  if (enemyDoubles) doublesCount++;
  else doublesCount=0;
  if (doublesCount>=3){
    sendToDungeon(enemy);
    doublesCount=0;
    setTimeout(endTurn, 1000);
    return;
  }
  movePlayerAnimated(enemy, total, ()=>{
    updateTokenPosition(enemy);
    handleLanding(enemy,total);
    updateStats();
    // Enemy reinforces with simple logic
    enemyReinforces();
    // if rolled doubles and not in dungeon -> extra enemy turn
    if (enemyDoubles && !enemy.inDungeon){
      setTimeout(()=>{ enemyPlay(); }, 800);
    } else {
      // back to hero
      setTimeout(endTurn, 1000);
    }
  });
}

/* Enemy reinforce heuristics */
function enemyReinforces(){
  // if enemy controls full set, attempt to reinforce on cheapest territory in that set if army > threshold
  const colorGroups = {};
  board.forEach((s,i)=>{ if (s.color) { colorGroups[s.color] = colorGroups[s.color] || []; colorGroups[s.color].push(i); }});
  for (const color in colorGroups){
    const idxs = colorGroups[color];
    if (idxs.every(i=>board[i].owner==='enemy')){
      // affordable?
      const cheapest = idxs.map(i=>board[i]).sort((a,b)=>a.price-b.price)[0];
      const garrisonCost = Math.round(cheapest.price*0.5);
      if (enemy.army > garrisonCost + 200){
        // reinforce first territory with less than 5 garrisons
        const target = idxs.map(i=>board[i]).find(s=>s.garrisons < 5);
        if (target){ target.garrisons++; enemy.army -= garrisonCost; log(`Enemy reinforced ${target.name} for ${fmtArmy(garrisonCost)}.`); updateBoardOwners(); updateStats(); }
      }
    }
  }
}

/* -------------------------
   Controls update & stats
   ------------------------- */
function updateControlsForTurn(){
  if (currentPlayer==='hero'){
    rollBtn.disabled = false;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = false;
    fortifyBtn.disabled = false;
  } else {
    rollBtn.disabled = true;
    endTurnBtn.disabled = true;
    reinforceBtn.disabled = true;
    fortifyBtn.disabled = true;
  }
}

endTurnBtn.addEventListener('click', ()=>{
  endTurn();
});

/* -------------------------
   Event listeners for new UI elements
   ------------------------- */
cardClose.addEventListener('click', () => {
  cardDisplay.style.display = 'none';
  // Re-enable controls
  endTurnBtn.disabled = false;
});

territoryConquestBuy.addEventListener('click', () => {
  const sq = board[hero.pos];
  conquerTerritory(hero, 'hero', sq);
  territoryConquest.style.display = 'none';
  // Re-enable controls
  endTurnBtn.disabled = false;
});

territoryConquestPass.addEventListener('click', () => {
  territoryConquest.style.display = 'none';
  log(`You passed on conquering ${board[hero.pos].name}.`);
  // Re-enable controls
  endTurnBtn.disabled = false;
});

dungeonPay.addEventListener('click', () => {
  if (hero.army >= 50) {
    pay(hero, 50);
    hero.inDungeon = false;
    hero.dungeonTurns = 0;
    log("You sacrificed 50 soldiers to escape the Dungeon.");
    showNotification("You sacrificed 50 soldiers to escape the Dungeon.");
    dungeonManagement.style.display = 'none';
    // Re-enable controls
    rollBtn.disabled = false;
    endTurnBtn.disabled = false;
  } else {
    showNotification("You don't have enough soldiers to sacrifice.");
  }
});

dungeonRoll.addEventListener('click', () => {
  dungeonManagement.style.display = 'none';
  // Simulate a roll for dungeon
  const [d1, d2] = rollDiceVals();
  diceDisplay.textContent = `Initiative: ${d1} + ${d2} = ${d1+d2}`;
  if (d1 === d2) {
    hero.inDungeon = false;
    hero.dungeonTurns = 0;
    log("You rolled doubles and escaped the dungeon!");
    showNotification("You rolled doubles and escaped the dungeon!");
    animateAndResolve(hero, d1+d2, true);
  } else {
    hero.dungeonTurns++;
    log("You failed to roll doubles in the Dungeon.");
    showNotification("You failed to roll doubles in the Dungeon.");
    if (hero.dungeonTurns >= 3) {
      log("You have been in the dungeon for 3 turns. You must sacrifice 50 soldiers next turn.");
    }
    endTurnBtn.disabled = false;
  }
});

// Class selection
classOptions.forEach(option => {
  option.addEventListener('click', () => {
    classOptions.forEach(opt => opt.classList.remove('selected'));
    option.classList.add('selected');
    hero.class = option.getAttribute('data-class');
    heroClassEl.textContent = hero.class;
    startGameBtn.disabled = false;
  });
});

startGameBtn.addEventListener('click', () => {
  classSelection.style.display = 'none';
  startHeroTurn();
  log("Game ready. Click 'Roll Initiative' to start your turn.");
});

/* -------------------------
   Utility: UI & Stats initial
   ------------------------- */
function updateStats(){
  heroArmyEl.textContent = "Army: " + fmtArmy(hero.army);
  enemyArmyEl.textContent = "Army: " + fmtArmy(enemy.army);
  heroTerritoriesEl.textContent = "Territories: " + (hero.territories.length? hero.territories.map(i=>board[i].name).join(', ') : 'None');
  enemyTerritoriesEl.textContent = "Territories: " + (enemy.territories.length? enemy.territories.map(i=>board[i].name).join(', ') : 'None');
  heroDungeonEl.textContent = hero.inDungeon ? `In Dungeon (${hero.dungeonTurns} turns)` : '';
  enemyDungeonEl.textContent = enemy.inDungeon ? `In Dungeon (${enemy.dungeonTurns} turns)` : '';
  
  // Check for defeat
  if (hero.army <= 0) {
    showNotification("Enemy wins! Your army has been defeated.");
    gameOver = true;
    document.body.classList.add('game-over');
  } else if (enemy.army <= 0) {
    showNotification("You win! The enemy army has been defeated.");
    gameOver = true;
    document.body.classList.add('game-over');
  }
}

/* -------------------------
   Utility: events & init
   ------------------------- */
window.addEventListener('resize', ()=>{ updateTokenPosition(hero); updateTokenPosition(enemy);});
createBoardUI();
updateBoardOwners();
updateTokenPosition(hero);
updateTokenPosition(enemy);
updateStats();

// Show class selection at start
classSelection.style.display = 'block';
heroClassEl.textContent = hero.class;
enemyClassEl.textContent = enemy.class;

/* -------------------------
   End of script
   ------------------------- */
</script>
</body>
</html>
