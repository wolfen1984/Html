<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Deadlands Beyond the Pass (1987) - Nightfalls Games</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #e0a060;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #e0a060;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #e0a060;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            align-items: center;
        }
        #prompt {
            margin-right: 8px;
            white-space: nowrap;
        }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid #e0a060;
            color: #e0a060;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 4px 0;
        }
        #status {
            border-top: 1px solid #e0a060;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        .command {
            color: #ffcc80;
        }
        .error {
            color: #ff5555;
        }
        .item {
            color: #80d0ff;
        }
        .enemy {
            color: #ff80c0;
        }
        .npc {
            color: #ffcc80;
        }
        .success {
            color: #80ff80;
        }
        .quest {
            color: #ffff80;
        }
        .loot {
            color: #ffb0ff;
        }
        .system {
            color: #aaa;
        }
        .damage {
            color: #ff5555;
        }
        .heal {
            color: #80ff80;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #e0a060;
            color: #e0a060;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        .quick-command {
            display: inline-block;
            background: #222;
            border: 1px solid #e0a060;
            color: #e0a060;
            padding: 2px 6px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        #quick-commands {
            margin-top: 8px;
            text-align: center;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #e0a060;
            color: #e0a060;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        .deadlands-text {
            text-shadow: 0 0 5px #e0a060, 0 0 10px #e0a060;
        }
        .document {
            color: #ffdd80;
            font-style: italic;
        }
        .object {
            color: #aa88ff;
        }
        .trap {
            color: #ff5555;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .secret {
            color: #80ff80;
            font-style: italic;
        }
        .puzzle {
            color: #ffaa80;
        }
        .corruption {
            color: #aa55ff;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .deadlands-bg {
            background: linear-gradient(0deg, rgba(0,0,0,1) 0%, rgba(32,16,0,1) 100%);
        }
    </style>
</head>
<body class="deadlands-bg">
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
        <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    <div id="header">
        <h1 class="deadlands-text">THE DEADLANDS BEYOND THE PASS</h1>
        <div>1987 â€¢ NIGHTFALLS GAMES</div>
        <div>FOURTH IN THE TERROR SERIES</div>
    </div>
    <div id="game-container">
        <div id="output">Welcome to the Deadlands Beyond the Pass! Type 'help' for commands.</div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="quick-commands">
            <span class="quick-command" onclick="quickCommand('n')">N</span>
            <span class="quick-command" onclick="quickCommand('s')">S</span>
            <span class="quick-command" onclick="quickCommand('e')">E</span>
            <span class="quick-command" onclick="quickCommand('w')">W</span>
            <span class="quick-command" onclick="quickCommand('look')">LOOK</span>
            <span class="quick-command" onclick="quickCommand('attack')">ATTACK</span>
            <span class="quick-command" onclick="quickCommand('inventory')">INV</span>
            <span class="quick-command" onclick="quickCommand('search')">SEARCH</span>
        </div>
        <div id="status"></div>
    </div>

    <script>
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.2;
                    this.sfxGain.gain.value = 0.5;
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            // ==================== NEW DEADLANDS THEME MUSIC ====================
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                this.stopBackground();
                
                this.currentBgName = musicName;
                
                switch(musicName) {
                    case 'wasteland':
                        this.playWastelandTheme(loop);
                        break;
                    case 'desolate':
                        this.playDesolateMusic(loop);
                        break;
                    case 'corrupted':
                        this.playCorruptedMusic(loop);
                        break;
                    case 'boss':
                        this.playBossMusic(loop);
                        break;
                    case 'victory':
                        this.playVictoryMusic(loop);
                        break;
                    case 'mystery':
                        this.playMysteryMusic(loop);
                        break;
                    default:
                        this.playWastelandTheme(loop);
                }
            }
            
            playWastelandTheme(loop) {
                // New Deadlands theme - desolate and atmospheric
                const melody = [
                    {note: 82.41, duration: 0.8},  // E
                    {note: 65.41, duration: 0.4},  // C
                    {note: 73.42, duration: 0.8},  // D
                    {note: 55.00, duration: 0.4},  // A
                    {note: 49.00, duration: 1.2},  // G
                    {note: 41.20, duration: 0.4},  // F
                    {note: 36.71, duration: 0.8},  // D
                    {note: 32.70, duration: 0.4},  // C
                    {note: 30.87, duration: 1.0},  // B
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.15);
            }
            
            playDesolateMusic(loop) {
                const melody = [
                    {note: 98.00, duration: 0.6},  // G
                    {note: 87.31, duration: 0.3},  // F
                    {note: 73.42, duration: 0.6},  // D
                    {note: 65.41, duration: 0.3},  // C
                    {note: 58.27, duration: 0.9},  // A#
                    {note: 49.00, duration: 0.3},  // G
                    {note: 43.65, duration: 0.6},  // F
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.12);
            }
            
            playCorruptedMusic(loop) {
                const melody = [
                    {note: 110, duration: 0.7},    // A
                    {note: 103.83, duration: 0.2}, // G#
                    {note: 110, duration: 0.2},    // A
                    {note: 123.47, duration: 0.7}, // B
                    {note: 116.54, duration: 0.2}, // A#
                    {note: 123.47, duration: 0.2}, // B
                    {note: 130.81, duration: 1.0}, // C
                ];
                
                this.playMelody(melody, 'square', loop, 0.1);
            }
            
            playBossMusic(loop) {
                const melody = [
                    {note: 130.81, duration: 0.2}, // C
                    {note: 164.81, duration: 0.2}, // E
                    {note: 196.00, duration: 0.2}, // G
                    {note: 261.63, duration: 0.2}, // C
                    {note: 329.63, duration: 0.2}, // E
                    {note: 392.00, duration: 0.2}, // G
                    {note: 523.25, duration: 0.4}, // C
                ];
                
                this.playMelody(melody, 'square', loop, 0.2);
            }
            
            playVictoryMusic(loop) {
                const melody = [
                    {note: 392.00, duration: 0.2}, // G
                    {note: 440.00, duration: 0.2}, // A
                    {note: 493.88, duration: 0.2}, // B
                    {note: 523.25, duration: 0.5}, // C
                    {note: 659.25, duration: 0.2}, // E
                    {note: 587.33, duration: 0.2}, // D
                    {note: 523.25, duration: 0.5}, // C
                    {note: 493.88, duration: 1.0}, // B
                ];
                
                this.playMelody(melody, 'sine', loop, 0.25);
            }
            
            playMysteryMusic(loop) {
                const melody = [
                    {note: 329.63, duration: 0.3}, // E
                    {note: 293.66, duration: 0.3}, // D
                    {note: 261.63, duration: 0.6}, // C
                    {note: 246.94, duration: 0.3}, // B
                    {note: 220.00, duration: 0.6}, // A
                    {note: 196.00, duration: 0.3}, // G
                    {note: 174.61, duration: 0.6}, // F
                ];
                
                this.playMelody(melody, 'sine', loop, 0.12);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                let currentTime = now;
                melody.forEach((note, index) => {
                    source.frequency.setValueAtTime(note.note, currentTime);
                    
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    
                    currentTime += note.duration;
                });
                
                if (loop) {
                    source.start(now);
                    source.stop(now + currentTime - now);
                    
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try {
                        this.currentBgSource.stop();
                    } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            // ==================== SOUND EFFECTS ====================
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                switch(soundName) {
                    case 'click':
                        this.playClick(volume);
                        break;
                    case 'notification':
                        this.playNotification(volume);
                        break;
                    case 'levelup':
                        this.playLevelUp(volume);
                        break;
                    case 'attack':
                        this.playAttack(volume);
                        break;
                    case 'enemyHit':
                        this.playEnemyHit(volume);
                        break;
                    case 'playerHit':
                        this.playPlayerHit(volume);
                        break;
                    case 'victory':
                        this.playVictory(volume);
                        break;
                    case 'defeat':
                        this.playDefeat(volume);
                        break;
                    case 'pickup':
                        this.playPickup(volume);
                        break;
                    case 'equip':
                        this.playEquip(volume);
                        break;
                    case 'door':
                        this.playDoor(volume);
                        break;
                    case 'step':
                        this.playStep(volume);
                        break;
                    case 'trap':
                        this.playTrap(volume);
                        break;
                    case 'secret':
                        this.playSecret(volume);
                        break;
                    case 'puzzle':
                        this.playPuzzle(volume);
                        break;
                    case 'stone':
                        this.playStone(volume);
                        break;
                    case 'wind':
                        this.playWind(volume);
                        break;
                    case 'magic':
                        this.playMagic(volume);
                        break;
                    case 'lever':
                        this.playLever(volume);
                        break;
                    case 'chest':
                        this.playChest(volume);
                        break;
                    case 'corruption':
                        this.playCorruption(volume);
                        break;
                    case 'ritual':
                        this.playRitual(volume);
                        break;
                    case 'scream':
                        this.playScream(volume);
                        break;
                }
            }
            
            playClick(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playNotification(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playLevelUp(volume) {
                const now = this.audioContext.currentTime;
                
                const notes = [523.25, 659.25, 783.99, 1046.50];
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.2);
                });
            }
            
            playAttack(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playEnemyHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playPlayerHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playVictory(volume) {
                const now = this.audioContext.currentTime;
                
                const notes = [
                    {freq: 523.25, time: 0.0, duration: 0.2},
                    {freq: 659.25, time: 0.2, duration: 0.2},
                    {freq: 783.99, time: 0.4, duration: 0.2},
                    {freq: 1046.50, time: 0.6, duration: 0.5},
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    gainNode.gain.setValueAtTime(0, now + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + note.time + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + note.time);
                    oscillator.stop(now + note.time + note.duration);
                });
            }
            
            playDefeat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, now);
                oscillator.frequency.exponentialRampToValueAtTime(110, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playPickup(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, now);
                oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playEquip(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playDoor(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStep(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playTrap(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playSecret(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playPuzzle(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.1, now + 0.4);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStone(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.4);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playWind(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.setValueAtTime(250, now + 0.1);
                oscillator.frequency.setValueAtTime(350, now + 0.2);
                oscillator.frequency.setValueAtTime(280, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playMagic(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.6);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.6);
            }
            
            playLever(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.setValueAtTime(100, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playChest(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playCorruption(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.setValueAtTime(250, now + 0.1);
                oscillator.frequency.setValueAtTime(180, now + 0.2);
                oscillator.frequency.setValueAtTime(300, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playRitual(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.2, now + 0.4);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playScream(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            // ==================== UTILITY METHODS ====================
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            survivor: { 
                hp: 55, mp: 10, str: 10, def: 7, agility: 4, 
                desc: "A hardened survivor of the wasteland, skilled with improvised weapons.",
                skills: ['scavenge', 'endurance']
            },
            scout: { 
                hp: 40, mp: 15, str: 7, def: 5, agility: 11,
                desc: "A stealthy wanderer who excels at avoiding danger and finding paths.",
                skills: ['sneak', 'tracking']
            },
            occultist: { 
                hp: 30, mp: 35, str: 4, def: 3, agility: 6,
                desc: "A scholar of forbidden knowledge who can manipulate the corrupting energies.",
                skills: ['purify', 'ward']
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 4, type: 'weapon', value: 0, desc: "Your bare hands." },
            rusty_pipe: { name: "Rusty Pipe", dmg: 9, type: 'weapon', value: 25, desc: "A length of corroded metal pipe." },
            bone_club: { name: "Bone Club", dmg: 11, type: 'weapon', value: 35, desc: "A heavy club made from giant bones.", vs_undead: 5 },
            poisoned_dagger: { name: "Poisoned Dagger", dmg: 10, type: 'weapon', value: 40, desc: "A blade coated with wasteland toxins.", poison: 4 },
            hunting_bow: { name: "Hunting Bow", dmg: 14, type: 'weapon', value: 65, desc: "A sturdy bow for hunting wasteland creatures.", range: true },
            machete: { name: "Machete", dmg: 16, type: 'weapon', value: 80, desc: "A sharp blade for clearing brush and enemies." },
            corrupted_staff: { name: "Corrupted Staff", dmg: 12, type: 'weapon', value: 70, desc: "A staff that channels corrupt energies.", corruption: 8 },
            ancient_sword: { name: "Ancient Sword", dmg: 22, type: 'weapon', value: 220, desc: "A pre-fall sword of remarkable quality.", vs_corrupted: 10 }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather_coat: { name: "Leather Coat", def: 6, type: 'armor', value: 40, desc: "A thick leather coat that offers decent protection.", agility: 2 },
            scavenged_armor: { name: "Scavenged Armor", def: 10, type: 'armor', value: 75, desc: "Armor pieced together from various sources." },
            occult_robe: { name: "Occult Robe", def: 4, type: 'armor', value: 35, desc: "A robe that enhances connection to corrupt energies.", corruption: 10, agility: 1 },
            metal_plates: { name: "Metal Plates", def: 13, type: 'armor', value: 130, desc: "Heavy metal plates strapped to the body.", agility: -2 },
            shadow_cloak: { name: "Shadow Cloak", def: 3, type: 'armor', value: 55, desc: "A cloak that blends with the darkness.", agility: 6, stealth: 5 },
            purified_armor: { name: "Purified Armor", def: 15, type: 'armor', value: 190, desc: "Armor cleansed of corruption.", corruption_resist: 15 }
        };

        const items = {
            health_brew: { 
                type: 'consumable', 
                effect: { hp: 35 }, 
                value: 30, 
                desc: "A herbal brew that heals 35 HP.",
                use: "You drink the health brew. It restores 35 HP." 
            },
            energy_elixir: { 
                type: 'consumable', 
                effect: { mp: 30 }, 
                value: 35, 
                desc: "A strange elixir that restores 30 MP.",
                use: "You drink the energy elixir. It restores 30 MP." 
            },
            antitoxin: { 
                type: 'consumable', 
                effect: { cure_poison: true }, 
                value: 25, 
                desc: "Cures poisoning from wasteland creatures.",
                use: "You drink the antitoxin, neutralizing any poison in your system." 
            },
            torch: { 
                type: 'tool', 
                value: 8, 
                desc: "A lit torch. Illuminates the perpetual gloom.",
                use: "You light the torch, pushing back the darkness." 
            },
            lockpick: { 
                type: 'tool', 
                value: 20, 
                desc: "A set of lockpicks for opening sealed doors.",
                use: "You attempt to pick the lock." 
            },
            skeleton_key: { 
                type: 'key', 
                value: 1, 
                desc: "An ancient key that can open most locks.",
                use: "You use the skeleton key to unlock a door." 
            },
            deadlands_map: { 
                type: 'document', 
                value: 60, 
                desc: "A map showing the Deadlands layout.",
                read: "The map shows twisted canyons and corrupted zones. A strange structure is marked at the center.",
                use: "You study the map, gaining knowledge of the Deadlands." 
            },
            forbidden_tome: { 
                type: 'quest', 
                value: 1, 
                desc: "A tome of forbidden knowledge. The occultist wants this.",
                read: "The tome speaks of 'The Great Corruption' that twists the land. 'The source lies within the central spire...'",
                use: "The tome glows with dark energy." 
            },
            corruption_shard: { 
                type: 'quest', 
                value: 1, 
                desc: "A shard of pure corruption. The purifier wants it for study.",
                examine: "A pulsating crystal of dark energy. It feels cold yet alive.",
                use: "The shard vibrates when held." 
            },
            ancient_key: { 
                type: 'key', 
                value: 1, 
                desc: "A key of ancient design.",
                use: "You use the ancient key to unlock a mechanism." 
            },
            rope: { 
                type: 'tool', 
                value: 15, 
                desc: "A strong rope for climbing or securing.",
                use: "You use the rope to secure your position." 
            },
            climbing_gear: { 
                type: 'tool', 
                value: 45, 
                desc: "Gear for scaling treacherous terrain.",
                use: "You prepare your climbing gear." 
            },
            purification_talisman: { 
                type: 'tool', 
                value: 40, 
                desc: "A talisman that wards off corruption.",
                examine: "A silver talisman that feels warm to the touch.",
                use: "You hold up the purification talisman. Nearby corruption recedes." 
            },
            // Documents that can be found
            survivors_journal: {
                type: 'document',
                value: 10,
                desc: "A journal from a previous survivor.",
                read: "Day 12: The corruption spreads daily. The creatures... they're not natural. I've seen things move in the shadows that shouldn't exist. The central spire pulses with dark energy. Avoid it at all costs.",
                examine: "A leather-bound journal with desperate handwriting."
            },
            researchers_notes: {
                type: 'document',
                value: 15,
                desc: "Research notes on the corruption.",
                read: "Hypothesis: The corruption is a form of energy that twists reality. It mutates living things and animates the dead. The source appears to be a crystalline structure at the Deadlands' heart. Exposure causes madness and physical mutation.",
                examine: "Scientific notes with diagrams of corrupted creatures."
            },
            cultist_manifesto: {
                type: 'document',
                value: 20,
                desc: "A cultist's manifesto.",
                read: "The Great Corruption is not a curse but a blessing! It will cleanse this world of weakness. The Spire calls to the worthy. We shall ascend as the corruption remakes us in its image.",
                examine: "Crazed writing on human skin parchment."
            },
            treasure_map: {
                type: 'document',
                value: 80,
                desc: "A map to hidden caches in the Deadlands.",
                read: "X marks three caches: Behind the waterfall in the ravine, under the altar in the ruins, and within the beast's lair (if you're brave enough).",
                examine: "A well-drawn map on aged parchment.",
                use: "You study the map, memorizing the cache locations."
            },
            // New consumables
            bandage: {
                type: 'consumable',
                effect: { hp: 20 },
                value: 12,
                desc: "Clean bandages for treating wounds.",
                use: "You apply the bandage to your wounds, healing 20 HP."
            },
            explosive_charge: {
                type: 'consumable',
                effect: { damage: 50 },
                value: 40,
                desc: "A volatile explosive charge.",
                use: "You place the explosive charge! It creates a massive blast."
            },
            corruption_purge: {
                type: 'consumable',
                effect: { cure_corruption: true },
                value: 50,
                desc: "Purges corruption from your system.",
                use: "You drink the purge, feeling corruption leave your body."
            }
        };

        // Enhanced enemies for Deadlands theme
        const enemies = {
            mutated_rat: { 
                name: "Mutated Rat", 
                hp: 25, dmg: 6, gold: 8, xp: 18, 
                desc: "A giant rat twisted by corruption, with extra limbs.",
                loot: ['bandage'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'desolate',
                type: 'mutated'
            },
            corrupted_skeleton: { 
                name: "Corrupted Skeleton", 
                hp: 35, dmg: 9, gold: 18, xp: 30,
                desc: "Animated bones glowing with corrupt energy.",
                loot: ['bone_club', 'health_brew'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'corrupted',
                type: 'undead'
            },
            venom_creeper: { 
                name: "Venom Creeper", 
                hp: 30, dmg: 8, gold: 15, xp: 25,
                desc: "A plant-like creature that drips corrosive sap.",
                loot: ['antitoxin', 'rope'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'desolate',
                type: 'plant',
                poison: true
            },
            scavenger: { 
                name: "Wasteland Scavenger", 
                hp: 40, dmg: 11, gold: 22, xp: 35,
                desc: "A desperate survivor turned violent.",
                loot: ['rusty_pipe', 'gold'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'desolate',
                type: 'human'
            },
            ghoul: { 
                name: "Wasteland Ghoul", 
                hp: 45, dmg: 12, gold: 25, xp: 40,
                desc: "A human corrupted beyond recognition, driven by hunger.",
                loot: ['leather_coat', 'bandage'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'corrupted',
                type: 'mutated'
            },
            shadow_wraith: { 
                name: "Shadow Wraith", 
                hp: 50, dmg: 14, gold: 35, xp: 45,
                desc: "A spectral entity formed from despair and corruption.",
                loot: ['purification_talisman', 'energy_elixir'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'corrupted',
                type: 'spirit'
            },
            mutated_beast: { 
                name: "Mutated Beast", 
                hp: 80, dmg: 20, gold: 60, xp: 70,
                desc: "A massive creature with multiple mutations.",
                loot: ['machete', 'health_brew'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'desolate',
                type: 'mutated'
            },
            corrupted_knight: { 
                name: "Corrupted Knight", 
                hp: 100, dmg: 22, gold: 80, xp: 85,
                desc: "An ancient warrior twisted by corruption, still clad in rusted armor.",
                loot: ['scavenged_armor', 'hunting_bow'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'corrupted',
                type: 'undead'
            },
            corruptor: { 
                name: "Corruptor", 
                hp: 160, dmg: 32, gold: 130, xp: 110,
                desc: "A being of pure corruption that spreads decay.",
                loot: ['corrupted_staff', 'forbidden_tome', 'energy_elixir'], 
                sounds: { attack: 'corruption', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss',
                type: 'corrupted'
            },
            corruption_behemoth: { 
                name: "Corruption Behemoth", 
                hp: 280, dmg: 38, gold: 220, xp: 170,
                desc: "A massive entity formed from concentrated corruption.",
                loot: ['ancient_sword', 'purified_armor', 'corruption_shard', 'corruption_shard'], 
                sounds: { attack: 'corruption', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss',
                type: 'corrupted'
            }
        };

        // Enhanced NPCs with Deadlands theme
        const npcs = {
            survivor: { 
                name: "Wounded Survivor", 
                desc: "A ragged, injured man hiding in the ruins.", 
                dialog: "The corruption... it's spreading. Don't let it touch you! The cultists are making it worse at the central spire.",
                quest: { item: 'antitoxin', reward: { gold: 90, item: 'deadlands_map', xp: 45 }, completed: false },
                hostile: false,
                acceptsItems: ['survivors_journal']
            },
            occultist: {
                name: "Exiled Occultist",
                desc: "A robed figure studying the corruption from a safe distance.",
                dialog: "The forbidden tome holds the key to understanding the corruption! Bring it to me!",
                quest: { item: 'forbidden_tome', reward: { gold: 110, item: 'corrupted_staff', xp: 55 }, completed: false },
                hostile: false,
                acceptsItems: ['researchers_notes', 'cultist_manifesto']
            },
            purifier: {
                name: "Purifier",
                desc: "A determined woman cleansing areas of corruption.",
                dialog: "A pure corruption shard! With it, I can create a weapon against the corruption! Bring me one!",
                quest: { item: 'corruption_shard', reward: { gold: 160, item: 'purified_armor', xp: 80 }, completed: false },
                hostile: false
            },
            trader: {
                name: "Wasteland Trader",
                desc: "A heavily armed trader with a makeshift stall.",
                dialog: "What do you need? I've got supplies... for the right price.",
                quest: null,
                hostile: false,
                shopItems: ['health_brew', 'energy_elixir', 'antitoxin', 'torch', 'lockpick', 'rope', 'bandage', 'explosive_charge', 'corruption_purge', 'rusty_pipe', 'leather_coat']
            },
            scavenger_leader: {
                name: "Scavenger Leader",
                desc: "A scarred man with a gang of followers.",
                dialog: "This is our territory! Pay tribute or get out!",
                quest: null,
                hostile: true
            },
            tormented_spirit: {
                name: "Tormented Spirit",
                desc: "A ghostly figure bound to a corrupted site.",
                dialog: "Free me... The corruption binds my soul... Find my remains in the ruins...",
                quest: { item: 'cultist_manifesto', reward: { gold: 100, item: 'purification_talisman', xp: 50 }, completed: false },
                hostile: false
            },
            cultist_leader: {
                name: "Cultist Leader",
                desc: "A fanatic covered in corruption sigils.",
                dialog: "The Great Corruption will remake this world! Join us or be purged!",
                quest: null,
                hostile: true
            },
            miner: {
                name: "Trapped Miner",
                desc: "A dust-covered man in a collapsed tunnel.",
                dialog: "The cave-in trapped me here. If you have climbing gear, I can show you a secret path.",
                quest: null,
                hostile: false
            }
        };

        // Deadlands location descriptions
        const deadlandsDescriptions = [
            { 
                desc: "THE PASS ENTRANCE. A narrow path between towering cliffs. The air feels heavy here.", 
                sound: 'wasteland',
                objects: {
                    'cliffs': "Sheer rock faces that block most of the sky.",
                    'path': "A treacherous, winding path into the Deadlands.",
                    'warning signs': "Faded signs reading 'DANGER' and 'TURN BACK'."
                },
                hiddenItems: ['survivors_journal'],
                trap: null
            },
            { 
                desc: "TWISTED CANYON. The rock walls seem to twist unnaturally. Strange growths cover the stone.", 
                sound: 'wasteland',
                objects: {
                    'walls': "Rock that curves in impossible ways.",
                    'growths': "Pulsating, fleshy growths that seem to breathe.",
                    'crystals': "Dark crystals that hum with energy."
                },
                trap: 'corruption_field'
            },
            { 
                desc: "ABANDONED OUTPOST. Broken buildings lean precariously. The wind whistles through empty windows.", 
                sound: 'desolate',
                objects: {
                    'buildings': "Structures half-collapsed from age and corruption.",
                    'windows': "Empty frames where glass once was.",
                    'debris': "Piles of rusted metal and broken furniture."
                },
                npc: 'survivor',
                trap: null
            },
            { 
                desc: "CORRUPTED GROVE. Twisted trees with black leaves. The ground squirms with strange life.", 
                sound: 'corrupted',
                objects: {
                    'trees': "Trees bent into agonized shapes.",
                    'ground': "Soil that moves as if alive.",
                    'fungus': "Bioluminescent mushrooms in sickly colors."
                },
                hiddenItems: ['rope'],
                trap: 'ambush_vines'
            },
            { 
                desc: "RUINED TEMPLE. Ancient pillars carved with forgotten symbols. A dark altar dominates the center.", 
                sound: 'corrupted',
                objects: {
                    'pillars': "Stone columns etched with disturbing symbols.",
                    'altar': "A black stone altar stained with dark substances.",
                    'statues': "Broken statues of forgotten deities."
                },
                hiddenItems: ['cultist_manifesto'],
                trap: 'ritual_trap'
            },
            { 
                desc: "FORGOTTEN LIBRARY. Shelves of decayed books. Some float in the air, pages turning.", 
                sound: 'mystery',
                objects: {
                    'books': "Tomes written in languages no one remembers.",
                    'floating books': "Books that hover and turn pages on their own.",
                    'desk': "A massive desk covered in dust and strange artifacts."
                },
                npc: 'occultist',
                trap: null
            },
            { 
                desc: "ALCHEMIST'S LAB. Strange apparatus bubbles with colorful liquids. The smell is overwhelming.", 
                sound: 'mystery',
                objects: {
                    'apparatus': "Glass tubes and metal instruments of unknown purpose.",
                    'liquids': "Bubbling fluids in unnatural colors.",
                    'ingredients': "Jars containing things best not examined closely."
                },
                hiddenItems: ['researchers_notes', 'explosive_charge'],
                trap: 'chemical_trap'
            },
            { 
                desc: "SCAVENGER CAMP. Makeshift shelters and stolen goods. A crude barricade surrounds the area.", 
                sound: 'desolate',
                objects: {
                    'shelters': "Tents and lean-tos made from scavenged materials.",
                    'barricade': "A wall of debris and sharpened stakes.",
                    'fire pit': "A smoldering fire with suspicious meat cooking."
                },
                npc: 'scavenger_leader',
                trap: 'pit_trap'
            },
            { 
                desc: "UNDERGROUND RIVER. Black water flows through a cavern. Shapes move beneath the surface.", 
                sound: 'desolate',
                objects: {
                    'river': "A river of dark, slow-moving water.",
                    'water': "The liquid is thick and smells of decay.",
                    'bridge': "A rickety wooden bridge spanning the river."
                },
                trap: 'water_ambush'
            },
            { 
                desc: "CRYSTAL CAVERN. Glowing crystals of pure corruption illuminate the space. The air crackles with energy.", 
                sound: 'mystery',
                objects: {
                    'crystals': "Geometric formations pulsing with dark light.",
                    'energy': "Visible waves of corrupt power ripple through the air.",
                    'formations': "Strange crystal structures in impossible shapes."
                },
                puzzle: 'crystal_puzzle',
                trap: null
            },
            { 
                desc: "TREASURE VAULT. Piles of pre-fall artifacts and gold. A corrupted guardian watches over the hoard.", 
                sound: 'boss',
                objects: {
                    'artifacts': "Technology from before the corruption.",
                    'gold': "Ancient coins and jewelry.",
                    'guardian': "A massive, corrupted construct."
                },
                hiddenItems: ['treasure_map'],
                trap: 'guardian_trap'
            },
            { 
                desc: "COLLAPSED TUNNEL. Fresh cave-in blocks the way. Mining tools lie abandoned.", 
                sound: 'desolate',
                objects: {
                    'cave-in': "A wall of fallen rock and debris.",
                    'tools': "Pickaxes and shovels left in a hurry.",
                    'support beams': "Wooden beams that groan under the weight."
                },
                npc: 'miner',
                trap: 'cave_in'
            },
            { 
                desc: "SHRINE TO CORRUPTION. A monument to the corrupting force. The air feels wrong here.", 
                sound: 'corrupted',
                objects: {
                    'monument': "A twisted sculpture of black stone.",
                    'offerings': "Bizarre items left by cultists.",
                    'sigils': "Glowing symbols carved into the floor."
                },
                trap: 'corruption_trap'
            },
            { 
                desc: "MUTATION FIELD. Plants and creatures here have been twisted into horrible forms.", 
                sound: 'corrupted',
                objects: {
                    'plants': "Flora fused with animal characteristics.",
                    'creatures': "Half-formed beings trapped in agony.",
                    'pools': "Pools of mutagenic liquid."
                },
                trap: 'mutation_trap'
            },
            { 
                desc: "BONE PIT. A massive pit filled with bones. Some still move.", 
                sound: 'corrupted',
                objects: {
                    'pit': "A deep chasm filled with skeletal remains.",
                    'bones': "Skulls, ribs, and other bones in great piles.",
                    'movement': "Some bones twitch and rattle on their own."
                },
                trap: 'bone_ambush'
            },
            { 
                desc: "ARMORY. Rusted weapons on racks. A few still gleam with ancient craftsmanship.", 
                sound: 'wasteland',
                objects: {
                    'weapons': "Swords, axes, and spears from before the fall.",
                    'racks': "Wooden stands holding the ancient arms.",
                    'workbench': "A table with tools for weapon maintenance."
                },
                hiddenItems: ['rusty_pipe'],
                trap: 'weapon_trap'
            },
            { 
                desc: "COMMISSARY. Rotted food stores and cooking implements. Something was recently butchered here.", 
                sound: 'desolate',
                objects: {
                    'stores': "Barrels of long-spoiled food.",
                    'implements': "Knives and cleavers on a bloody block.",
                    'oven': "A large stone oven, still warm."
                },
                trap: 'kitchen_ambush'
            },
            { 
                desc: "BURIAL CRYPT. Stone coffins line the walls. Some have been broken open from the inside.", 
                sound: 'corrupted',
                objects: {
                    'coffins': "Stone sarcophagi with ancient inscriptions.",
                    'broken coffins': "Lids smashed outward by great force.",
                    'ashes': "Urns containing the remains of the honored dead."
                },
                npc: 'tormented_spirit',
                trap: 'undead_ambush'
            },
            { 
                desc: "FORGE. A massive anvil and bellows. The air smells of ozone and corruption.", 
                sound: 'desolate',
                objects: {
                    'anvil': "A huge steel anvil, covered in strange scorch marks.",
                    'bellows': "Leather bellows that wheeze when stepped on.",
                    'forge': "A furnace burning with corrupted green fire."
                },
                npc: 'purifier',
                trap: null
            },
            { 
                desc: "TRADER'S POST. Makeshift stalls line the walls. A heavily armed woman watches you.", 
                sound: 'wasteland',
                objects: {
                    'stalls': "Wooden tables displaying various goods.",
                    'goods': "Supplies, weapons, and oddities for sale.",
                    'counter': "A reinforced metal counter."
                },
                npc: 'trader',
                trap: null
            },
            { 
                desc: "CULTIST SANCTUARY. Ritual implements and corrupt symbols cover every surface.", 
                sound: 'boss',
                objects: {
                    'altar': "A massive altar covered in fresh blood.",
                    'symbols': "Corruption sigils painted in glowing colors.",
                    'trophies': "Bizarre specimens in jars and on spikes."
                },
                npc: 'cultist_leader',
                trap: 'ritual_trap'
            },
            { 
                desc: "CORRUPTION SPIRE. A towering structure of pure corruption energy pulsates at the center. The Behemoth awaits.", 
                sound: 'boss',
                objects: {
                    'spire': "A crystalline structure of immense size.",
                    'energy': "Radiant waves of corrupt power wash over you.",
                    'core': "A pulsating heart of darkness at the spire's center."
                },
                puzzle: 'final_puzzle',
                trap: 'spire_trap'
            }
        ];

        // Generate Deadlands locations
        const locations = [];
        for (let i = 0; i < 22; i++) {
            locations.push({
                id: i,
                desc: deadlandsDescriptions[i].desc,
                sound: deadlandsDescriptions[i].sound,
                objects: deadlandsDescriptions[i].objects || {},
                hiddenItems: deadlandsDescriptions[i].hiddenItems || [],
                puzzle: deadlandsDescriptions[i].puzzle || null,
                trap: deadlandsDescriptions[i].trap || null,
                exits: { 
                    n: i < 12 ? i + 10 : null, 
                    s: i >= 10 ? i - 10 : null, 
                    e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                    w: i % 10 !== 0 ? i - 1 : null,
                    u: i === 5 ? 15 : null, // Library to upper level
                    d: i === 15 ? 5 : null  // Upper level back to library
                },
                items: [],
                enemy: null,
                npc: deadlandsDescriptions[i].npc || null,
                explored: false,
                dark: i !== 0 && i !== 9 && i !== 20, // Some locations are dark
                locked: i === 20 || i === 21, // Sanctuary and spire locked
                searched: false,
                trapActive: deadlandsDescriptions[i].trap !== null,
                puzzleSolved: false,
                corrupted: i >= 2 && i <= 18 // Most areas are corrupted
            });
        }

        // Place items, enemies, and NPCs
        locations[0].items = ['torch', 'bandage'];
        locations[1].enemy = 'mutated_rat';
        locations[2].items = ['ancient_key'];
        locations[3].enemy = 'venom_creeper';
        locations[4].enemy = 'ghoul';
        locations[5].items = ['forbidden_tome'];
        locations[6].enemy = 'shadow_wraith';
        locations[7].enemy = 'scavenger';
        locations[8].items = ['climbing_gear'];
        locations[9].enemy = 'mutated_beast';
        locations[10].enemy = 'corrupted_knight';
        locations[11].enemy = 'mutated_rat';
        locations[12].enemy = 'corrupted_skeleton';
        locations[13].enemy = 'venom_creeper';
        locations[14].items = ['skeleton_key'];
        locations[15].enemy = 'ghoul';
        locations[16].enemy = 'shadow_wraith';
        locations[17].enemy = 'corrupted_skeleton';
        locations[18].items = ['machete'];
        locations[19].enemy = 'scavenger';
        locations[20].enemy = 'corruptor';
        locations[21].enemy = 'corruption_behemoth';

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            agility: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: true,
            moves: 0,
            poisoned: false,
            corrupted: 0, // New corruption meter
            effects: [],
            knownDocuments: [],
            trapDetection: 0,
            secretAreasFound: 0,
            corruptionResistance: 0
        };

        // ==================== GAME SYSTEMS ====================
        const lootTable = ['health_brew', 'energy_elixir', 'antitoxin', 'torch', 'bandage', 'rope', 'gold', 'lockpick', 'survivors_journal'];
        let gameStarted = false;
        let currentBackground = 'wasteland';
        const soundSystem = new SoundSystem();
        let enemyHealthReset = JSON.parse(JSON.stringify(enemies));

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            if (className === 'success' || className === 'loot' || className === 'quest') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            } else if (className === 'trap') {
                soundSystem.playSound('trap', 0.5);
            } else if (className === 'secret') {
                soundSystem.playSound('secret', 0.5);
            } else if (className === 'puzzle') {
                soundSystem.playSound('puzzle', 0.5);
            } else if (className === 'corruption') {
                soundSystem.playSound('corruption', 0.5);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            let statusText = 
                `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} AGI:${player.agility} ` +
                `LVL:${player.level} GOLD:${player.gold}${combat}`;
            
            if (player.corrupted > 0) {
                statusText += ` COR:${player.corrupted}`;
            }
            
            status.textContent = statusText;
                
            const equippedLine = `Weapon: ${weapon} | Armor: ${armor}`;
            if (!status.textContent.includes(equippedLine)) {
                status.textContent += `\n${equippedLine}`;
            }
            
            if (player.poisoned) {
                status.textContent += `\nPOISONED!`;
            }
            
            if (player.corrupted >= 50) {
                status.textContent += `\nCORRUPTED!`;
            }
        }

        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            player.agility = classes[player.class].agility + (armor.agility || 0);
            player.trapDetection = Math.floor(player.agility / 3);
            player.corruptionResistance = (armor.corruption_resist || 0) + Math.floor(player.level / 2);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 100;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 22;
                player.hp = player.maxHp;
                player.maxMp += 12;
                player.mp = player.maxMp;
                player.str += 2;
                player.def += 1;
                player.agility += 1;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        // ==================== CORRUPTION SYSTEM ====================
        function checkCorruption() {
            const location = locations[player.location];
            
            if (!location.corrupted || player.corruptionResistance >= 100) return;
            
            // Chance to gain corruption in corrupted areas
            if (Math.random() > 0.7) {
                const corruptionGain = Math.max(1, 5 - Math.floor(player.corruptionResistance / 20));
                player.corrupted += corruptionGain;
                
                if (corruptionGain > 0) {
                    print(`You feel the corruption seeping into you... (+${corruptionGain} corruption)`, 'corruption');
                    soundSystem.playSound('corruption', 0.3);
                }
            }
            
            // Apply corruption effects
            if (player.corrupted >= 100) {
                print("The corruption overwhelms you! You become one with the Deadlands... GAME OVER.", 'error');
                soundSystem.playSound('scream');
                resetGame();
                return;
            } else if (player.corrupted >= 75) {
                if (Math.random() > 0.9) {
                    player.hp -= 5;
                    print("The corruption writhes within you, causing pain!", 'damage');
                }
            } else if (player.corrupted >= 50) {
                if (Math.random() > 0.95) {
                    player.str -= 1;
                    print("The corruption weakens your body!", 'corruption');
                }
            }
        }

        // ==================== TRAP SYSTEM ====================
        function checkTrap() {
            const location = locations[player.location];
            
            if (!location.trapActive || !location.trap) return false;
            
            // Chance to detect trap based on agility
            const detectChance = player.trapDetection * 10;
            if (Math.random() * 100 < detectChance) {
                print(`You spot a ${location.trap.replace('_', ' ')}!`, 'trap');
                print("You can attempt to 'disarm trap' or proceed carefully.", 'system');
                return true;
            }
            
            return false;
        }

        function triggerTrap() {
            const location = locations[player.location];
            
            if (!location.trapActive || !location.trap) return;
            
            soundSystem.playSound('trap', 0.7);
            
            switch(location.trap) {
                case 'corruption_field':
                    player.corrupted += 20;
                    print("A field of pure corruption surrounds you!", 'trap');
                    print("You gain 20 corruption!", 'corruption');
                    break;
                case 'ambush_vines':
                    player.hp -= 18;
                    player.poisoned = true;
                    print("Vines spring from the ground, entangling and poisoning you!", 'trap');
                    print("You take 18 damage and are poisoned!", 'damage');
                    break;
                case 'ritual_trap':
                    player.hp -= 25;
                    player.corrupted += 15;
                    print("A ritual circle activates, draining your life!", 'trap');
                    print("You take 25 damage and gain 15 corruption!", 'damage');
                    break;
                case 'chemical_trap':
                    player.hp -= 22;
                    print("A chemical reaction creates a toxic cloud!", 'trap');
                    print("You take 22 damage!", 'damage');
                    break;
                case 'pit_trap':
                    player.hp -= 32;
                    print("The ground gives way beneath you!", 'trap');
                    print("You fall into a pit, taking 32 damage!", 'damage');
                    break;
                case 'water_ambush':
                    player.hp -= 20;
                    print("Creatures leap from the water, attacking you!", 'trap');
                    print("You take 20 damage!", 'damage');
                    break;
                case 'guardian_trap':
                    player.hp -= 45;
                    print("The guardian animates and attacks!", 'trap');
                    print("You take 45 damage!", 'damage');
                    break;
                case 'cave_in':
                    player.hp -= 38;
                    print("The ceiling collapses on you!", 'trap');
                    print("You take 38 damage!", 'damage');
                    break;
                case 'corruption_trap':
                    player.corrupted += 25;
                    print("A wave of pure corruption washes over you!", 'trap');
                    print("You gain 25 corruption!", 'corruption');
                    break;
                case 'mutation_trap':
                    player.hp -= 28;
                    player.corrupted += 10;
                    print("Mutagenic fluids spray over you!", 'trap');
                    print("You take 28 damage and gain 10 corruption!", 'damage');
                    break;
                case 'bone_ambush':
                    player.hp -= 26;
                    print("Animated bones rise and attack!", 'trap');
                    print("You take 26 damage!", 'damage');
                    break;
                case 'weapon_trap':
                    player.hp -= 24;
                    print("Weapons fly from the racks and strike you!", 'trap');
                    print("You take 24 damage!", 'damage');
                    break;
                case 'kitchen_ambush':
                    player.hp -= 20;
                    print("The butcher's tools animate and attack!", 'trap');
                    print("You take 20 damage!", 'damage');
                    break;
                case 'undead_ambush':
                    player.hp -= 30;
                    print("Undead rise from the crypts!", 'trap');
                    print("You take 30 damage!", 'damage');
                    break;
                case 'spire_trap':
                    player.hp -= 55;
                    player.corrupted += 30;
                    print("The spire unleashes a wave of pure corruption!", 'trap');
                    print("You take 55 damage and gain 30 corruption!", 'damage');
                    break;
            }
            
            location.trapActive = false;
            
            if (player.hp <= 0) {
                print("The trap kills you... GAME OVER.", 'error');
                soundSystem.playSound('defeat');
                resetGame();
            }
            
            updateStatus();
        }

        function disarmTrap() {
            const location = locations[player.location];
            
            if (!location.trapActive) {
                print("There's no trap here to disarm.", 'error');
                return;
            }
            
            const successChance = player.agility * 5;
            if (Math.random() * 100 < successChance) {
                location.trapActive = false;
                print(`You successfully disarm the ${location.trap.replace('_', ' ')}!`, 'success');
                soundSystem.playSound('secret');
                player.xp += 30;
                checkLevelUp();
            } else {
                print("You fail to disarm the trap!", 'error');
                triggerTrap();
            }
        }

        // ==================== PUZZLE SYSTEM ====================
        function solvePuzzle(puzzleType) {
            const location = locations[player.location];
            
            if (!location.puzzle) {
                print("There's no puzzle here to solve.", 'error');
                return;
            }
            
            if (location.puzzleSolved) {
                print("You've already solved this puzzle.", 'system');
                return;
            }
            
            soundSystem.playSound('puzzle', 0.5);
            
            switch(puzzleType) {
                case 'crystal_puzzle':
                    if (player.inventory.includes('corrupted_staff') || player.class === 'occultist') {
                        location.puzzleSolved = true;
                        location.items.push('energy_elixir', 'energy_elixir');
                        print("You channel energy into the crystals!", 'puzzle');
                        print("The crystals pulse, revealing hidden elixirs!", 'success');
                        soundSystem.playSound('magic');
                        player.xp += 60;
                    } else {
                        print("The crystals hum with corrupt energy, but you don't know how to interact with them.", 'puzzle');
                        print("Perhaps occult knowledge or a corrupted staff would help.", 'system');
                    }
                    break;
                case 'final_puzzle':
                    if (player.inventory.includes('forbidden_tome') && player.inventory.includes('purification_talisman')) {
                        location.puzzleSolved = true;
                        enemies['corruption_behemoth'].dmg -= 12;
                        print("You combine the tome's knowledge with purification energy!", 'puzzle');
                        print("The Behemoth's power weakens as its nature is revealed!", 'success');
                        soundSystem.playSound('ritual');
                        player.xp += 120;
                    } else {
                        print("The spire pulses with immense corrupt power.", 'puzzle');
                        print("You need both forbidden knowledge and purification to understand how to weaken it.", 'system');
                    }
                    break;
            }
            
            checkLevelUp();
        }

        // ==================== ENHANCED SEARCH FUNCTION ====================
        function searchArea() {
            const location = locations[player.location];
            
            if (location.dark && !player.torch) {
                print("It's too dark to search!", 'error');
                return;
            }
            
            soundSystem.playSound('stone', 0.3);
            
            if (!location.searched) {
                location.searched = true;
                player.xp += 12;
                
                // Chance to find hidden items
                if (location.hiddenItems.length > 0 && Math.random() > 0.5) {
                    const hiddenItem = location.hiddenItems[0];
                    location.items.push(hiddenItem);
                    print(`You find a hidden ${hiddenItem.replace('_', ' ')}!`, 'secret');
                    soundSystem.playSound('secret');
                    location.hiddenItems.shift();
                }
                
                // Chance to find secret area
                if (Math.random() > 0.7 && player.secretAreasFound < 3) {
                    player.secretAreasFound++;
                    print("You discover a secret passage!", 'secret');
                    print("A new path has been revealed!", 'success');
                    player.xp += 35;
                }
                
                print("You search the area thoroughly.", 'system');
                print(`+12 XP for searching!`, 'system');
                
                // Check for traps
                if (location.trapActive) {
                    if (checkTrap()) {
                        print("Be careful! There's a trap here.", 'trap');
                    }
                }
            } else {
                print("You've already searched this area.", 'system');
            }
            
            if (location.items.length > 0) {
                print(`Items here: ${location.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
        }

        // ==================== GAME LOGIC ====================
        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.agility = c.agility;
            player.gold = 60;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['health_brew', 'torch', 'bandage'];
            if (className === 'scout') player.inventory.push('lockpick');
            if (className === 'occultist') player.inventory.push('energy_elixir');
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.corrupted = 0;
            player.knownDocuments = [];
            player.trapDetection = Math.floor(player.agility / 3);
            player.secretAreasFound = 0;
            player.corruptionResistance = 0;
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 60 gold, basic supplies, and a torch.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateStatus();
        }

        function look() {
            const location = locations[player.location];
            
            if (location.enemy && enemies[location.enemy].bgSound) {
                currentBackground = enemies[location.enemy].bgSound;
            } else if (location.puzzle) {
                currentBackground = 'mystery';
            } else {
                currentBackground = location.sound;
            }
            soundSystem.playBackground(currentBackground);
            
            if (location.dark && !player.torch) {
                print("The area is shrouded in darkness. You can't see anything!", 'error');
                print("You need a light source.", 'error');
                return;
            }
            
            if (!location.explored) {
                location.explored = true;
                player.xp += 6;
                print(`+6 XP for exploring!`, 'system');
                soundSystem.playSound('notification', 0.5);
            }
            
            print(location.desc);
            
            // List objects in location
            if (Object.keys(location.objects).length > 0) {
                print(`You see: ${Object.keys(location.objects).join(', ')}`, 'object');
                print("You can 'examine [object]' to look closer.", 'system');
            }
            
            if (location.items.length > 0) {
                print(`Items here: ${location.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
            
            if (location.enemy) {
                const enemy = enemies[location.enemy];
                print(`${enemy.desc}`, 'enemy');
                print(`It looks ${enemy.hp <= enemyHealthReset[location.enemy].hp / 2 ? 'badly wounded' : 'powerful'}.`, 'enemy');
            }
            
            if (location.npc) {
                const npc = npcs[location.npc];
                print(`${npc.name} is here. ${npc.desc}`, 'npc');
            }
            
            if (location.puzzle && !location.puzzleSolved) {
                print("There's a puzzle here to solve.", 'puzzle');
            }
            
            if (location.locked) {
                print("The path is blocked or locked!", 'error');
            }
            
            if (location.corrupted) {
                print("The area is corrupted. You feel uneasy.", 'corruption');
            }
            
            let exits = [];
            for (let dir in location.exits) if (location.exits[dir] !== null) exits.push(dir);
            print(`Exits: ${exits.join(' ')}`);
            
            updateStatus();
        }

        function move(direction) {
            const location = locations[player.location];
            const target = location.exits[direction];
            
            if (target === null) {
                print("You can't go that way.", 'error');
                soundSystem.playSound('click');
                return;
            }
            
            const targetLocation = locations[target];
            if (targetLocation.locked) {
                if (player.inventory.includes('skeleton_key')) {
                    targetLocation.locked = false;
                    print("You use the skeleton key to unlock the path.", 'success');
                    soundSystem.playSound('door');
                } else if (player.inventory.includes('lockpick') && (player.class === 'scout' || Math.random() > 0.4)) {
                    targetLocation.locked = false;
                    print("You pick the lock successfully!", 'success');
                    soundSystem.playSound('lever');
                } else {
                    print("The path is locked!", 'error');
                    return;
                }
            }
            
            soundSystem.playSound('step', 0.3);
            
            player.moves++;
            
            // Check for trap triggering
            if (location.trapActive && Math.random() > 0.6) {
                triggerTrap();
                if (player.hp <= 0) return;
            }
            
            // Apply poison damage if poisoned
            if (player.poisoned) {
                const poisonDmg = Math.floor(player.maxHp * 0.06);
                player.hp -= poisonDmg;
                print(`The poison courses through your veins, dealing ${poisonDmg} damage!`, 'damage');
                soundSystem.playSound('playerHit', 0.3);
                if (player.hp <= 0) {
                    print("The poison kills you... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                    return;
                }
            }
            
            // Apply corruption effects
            checkCorruption();
            
            // Random encounter chance
            if (player.moves % 4 === 0 && !targetLocation.enemy && !targetLocation.npc) {
                const encounterChance = Math.max(30 - player.agility, 8);
                if (Math.random() * 100 < encounterChance) {
                    const randomEnemies = ['mutated_rat', 'corrupted_skeleton', 'venom_creeper', 'scavenger'];
                    const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
                    targetLocation.enemy = enemyType;
                }
            }
            
            player.location = target;
            print(`You go ${direction}.`, 'command');
            
            look();
            updateStatus();
        }

        function take(itemName) {
            const location = locations[player.location];
            
            if (location.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            const index = location.items.indexOf(itemName);
            if (index === -1) {
                print("That item isn't here.", 'error');
                return;
            }
            
            location.items.splice(index, 1);
            player.inventory.push(itemName);
            print(`You take the ${itemName}.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function talk(target) {
            const location = locations[player.location];
            
            if (!location.npc) {
                print("There's no one here to talk to.", 'error');
                return;
            }
            
            const npc = npcs[location.npc];
            
            if (npc.hostile) {
                print(`${npc.name}: "I have nothing to say to you, intruder!"`, 'npc');
                return;
            }
            
            soundSystem.playSound('notification', 0.5);
            print(`${npc.name}: "${npc.dialog}"`, 'npc');
            
            if (npc.quest) {
                if (npc.quest.completed) {
                    print(`${npc.name}: "Thank you again for your help."`, 'npc');
                } else if (npc.quest.item) {
                    const hasItem = player.inventory.includes(npc.quest.item);
                    print(`${npc.name}: "Bring me the ${npc.quest.item}."`, 'quest');
                    if (hasItem) {
                        print(`You have the ${npc.quest.item}. Type 'give ${location.npc}' to complete the quest.`, 'quest');
                    }
                }
            }
            
            if (npc.acceptsItems) {
                print(`${npc.name}: "I'm interested in notes and documents. Show me what you've found."`, 'npc');
            }
            
            if (location.npc === 'trader') {
                print(`${npc.name}: "Want to see my wares? Type 'list'."`, 'npc');
            }
        }

        function give(npcName) {
            const location = locations[player.location];
            
            if (!location.npc || location.npc !== npcName) {
                print("That NPC isn't here.", 'error');
                return;
            }
            
            const npc = npcs[npcName];
            
            if (!npc.quest || npc.quest.completed) {
                print(`${npc.name} doesn't want anything from you.`, 'npc');
                return;
            }
            
            const index = player.inventory.indexOf(npc.quest.item);
            if (index === -1) {
                print(`You don't have the ${npc.quest.item}.`, 'error');
                return;
            }
            
            player.inventory.splice(index, 1);
            npc.quest.completed = true;
            player.gold += npc.quest.reward.gold;
            player.xp += npc.quest.reward.xp;
            if (npc.quest.reward.item) {
                player.inventory.push(npc.quest.reward.item);
            }
            
            print(`${npc.name}: "Thank you! Here is your reward."`, 'success');
            print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
            if (npc.quest.reward.item) {
                print(`You receive: ${npc.quest.reward.item}`, 'loot');
            }
            
            soundSystem.playSound('victory');
            checkLevelUp();
            updateStatus();
        }

        function examine(itemName) {
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                // Try to examine object in location
                const location = locations[player.location];
                const normalizedObjectName = itemName.toLowerCase();
                
                for (const obj in location.objects) {
                    if (obj.toLowerCase().includes(normalizedObjectName)) {
                        print(`You examine the ${obj}:`, 'object');
                        print(location.objects[obj], 'system');
                        soundSystem.playSound('notification', 0.5);
                        
                        // Small chance to find hidden item when examining
                        if (Math.random() < 0.2 && location.hiddenItems.length > 0) {
                            const hiddenItem = location.hiddenItems[0];
                            if (!location.items.includes(hiddenItem)) {
                                location.items.push(hiddenItem);
                                print(`You find a hidden ${hiddenItem.replace('_', ' ')}!`, 'secret');
                                soundSystem.playSound('secret');
                                location.hiddenItems.shift();
                            }
                        }
                        return;
                    }
                }
                print(`You don't see a ${itemName} here.`, 'error');
                return;
            }
            
            print(`${item.name || itemName}:`, 'item');
            print(`  ${item.desc}`);
            
            if (weapons[itemName]) {
                print(`  Damage: ${item.dmg}`);
                if (item.vs_undead) print(`  vs Undead: +${item.vs_undead}`);
                if (item.vs_corrupted) print(`  vs Corrupted: +${item.vs_corrupted}`);
                if (item.poison) print(`  Poison: ${item.poison} damage per turn`);
                if (item.corruption) print(`  Corruption Power: +${item.corruption}`);
            } else if (armors[itemName]) {
                print(`  Defense: ${item.def}`);
                if (item.agility) print(`  Agility: ${item.agility > 0 ? '+' : ''}${item.agility}`);
                if (item.corruption_resist) print(`  Corruption Resist: +${item.corruption_resist}`);
                if (item.corruption) print(`  Corruption Power: +${item.corruption}`);
                if (item.stealth) print(`  Stealth: +${item.stealth}`);
            } else if (items[itemName]) {
                print(`  Type: ${item.type}`);
                print(`  Value: ${item.value} gold`);
                if (item.examine) {
                    print(`  ${item.examine}`);
                }
            }
        }

        function useItem(itemName, target = null) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            // Handle document reading
            if (item.type === 'document') {
                if (item.read) {
                    print(`You read the ${itemName.replace('_', ' ')}:`, 'document');
                    print(item.read, 'document');
                    soundSystem.playSound('notification', 0.3);
                    
                    if (!player.knownDocuments.includes(itemName)) {
                        player.knownDocuments.push(itemName);
                        player.xp += 18;
                    }
                } else {
                    print("The document is written in an unknown language.", 'error');
                }
                return;
            }
            
            // Handle consumables
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(item.use || `You use the ${itemName}, healing ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(item.use || `You use the ${itemName}, restoring ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.cure_poison && player.poisoned) {
                    player.poisoned = false;
                    print(item.use || "The antitoxin cures your poisoning!", 'success');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.cure_corruption && player.corrupted > 0) {
                    const reduction = Math.min(player.corrupted, 40);
                    player.corrupted -= reduction;
                    print(item.use || `The corruption purge removes ${reduction} corruption!`, 'success');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.damage) {
                    const location = locations[player.location];
                    if (location.enemy) {
                        const damage = item.effect.damage;
                        enemies[location.enemy].hp -= damage;
                        print(item.use || `The explosive charge deals ${damage} damage to the enemy!`, 'damage');
                        soundSystem.playSound('attack');
                        if (enemies[location.enemy].hp <= 0) {
                            print(`The ${location.enemy} is defeated!`, 'success');
                            location.enemy = null;
                            player.inCombat = null;
                        }
                    } else {
                        print("The explosive charge fizzles with no target.", 'error');
                    }
                    player.inventory.splice(index, 1);
                }
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(item.use || (player.torch ? "You light the torch." : "You extinguish the torch."), 'system');
                soundSystem.playSound('click');
            } else if (item.type === 'key') {
                const location = locations[player.location];
                if (location.locked) {
                    location.locked = false;
                    print(item.use || "You use the key to unlock the path.", 'success');
                    soundSystem.playSound('door');
                } else {
                    print("There's nothing to unlock here.", 'error');
                }
            } else if (item.type === 'tool') {
                if (itemName === 'purification_talisman') {
                    const location = locations[player.location];
                    if (location.corrupted) {
                        print(item.use || "You hold up the purification talisman. The corruption recedes!", 'success');
                        player.corrupted = Math.max(0, player.corrupted - 20);
                        soundSystem.playSound('magic');
                    } else {
                        print(item.use || "You hold up the purification talisman. It glows faintly.", 'system');
                    }
                } else if (itemName === 'lockpick') {
                    const location = locations[player.location];
                    if (location.locked) {
                        if (player.class === 'scout' || Math.random() > 0.5) {
                            location.locked = false;
                            print(item.use || "You successfully pick the lock!", 'success');
                            soundSystem.playSound('lever');
                        } else {
                            print(item.use || "You fail to pick the lock.", 'error');
                        }
                    } else {
                        print("There's nothing locked here to pick.", 'error');
                    }
                } else {
                    print(item.use || `You use the ${itemName}.`, 'system');
                }
            } else {
                print("You can't use that now.");
            }
            
            updateStatus();
        }

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

        function attack(target) {
            const location = locations[player.location];
            
            if (target) {
                if (location.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        location.enemy = 'corrupted_knight';
                        location.npc = null;
                        player.inCombat = 'corrupted_knight';
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        location.npc = null;
                        player.agility = Math.max(0, player.agility - 3);
                        print("Your reputation suffers! Agility -3.", 'error');
                        player.xp += 25;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    return;
                }
            }
            
            if (!location.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyType = location.enemy;
            const enemy = enemies[enemyType];
            player.inCombat = enemyType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemy.name}!`, 'command');
            
            let playerDmg = player.dmg + Math.floor(Math.random() * 6);
            const weapon = weapons[player.equipped.weapon];
            
            if (enemy.type === 'undead' && weapon.vs_undead) {
                playerDmg += weapon.vs_undead;
                print(`Your weapon is especially effective against undead!`, 'damage');
            }
            if ((enemy.type === 'corrupted' || enemy.type === 'mutated') && weapon.vs_corrupted) {
                playerDmg += weapon.vs_corrupted;
                print(`Your weapon is especially effective against corrupted beings!`, 'damage');
            }
            
            enemy.hp -= playerDmg;
            print(`You hit for ${playerDmg} damage.`, 'damage');
            soundSystem.playSound(enemy.sounds.hit, 0.5);
            
            if (weapon.poison && Math.random() > 0.7) {
                print(`Your weapon poisons the ${enemy.name}!`, 'damage');
            }
            
            if (enemy.hp <= 0) {
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 25) + 8;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.6) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 8;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'corruption_behemoth') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Corruption Behemoth!", 'success');
                    print("The Deadlands begin to heal as the corruption fades!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('wasteland'), 10000);
                } else if (enemyType === 'corruptor') {
                    print("You have defeated the Corruptor!", 'success');
                    print("The area feels less oppressive as the corruption weakens.", 'success');
                }
                
                location.enemy = null;
                player.inCombat = null;
                enemy.hp = enemyHealthReset[enemyType].hp;
                
                checkLevelUp();
            } else {
                print(`The ${enemy.name} has ${enemy.hp} HP left.`);
                let enemyDmg = Math.max(enemy.dmg - player.def + Math.floor(Math.random() * 6), 1);
                
                // Dodge chance based on agility
                const dodgeChance = player.agility * 3;
                if (Math.random() * 100 < dodgeChance) {
                    print(`You dodge the ${enemy.name}'s attack!`, 'success');
                } else {
                    player.hp -= enemyDmg;
                    print(`The ${enemy.name} hits you for ${enemyDmg} damage.`, 'damage');
                    soundSystem.playSound('playerHit', 0.5);
                    
                    if (enemy.poison && Math.random() > 0.8) {
                        player.poisoned = true;
                        print(`The ${enemy.name} poisons you!`, 'error');
                    }
                    
                    if (enemy.type === 'corrupted' && Math.random() > 0.7) {
                        player.corrupted += 5;
                        print(`The ${enemy.name}'s corrupting touch affects you!`, 'corruption');
                    }
                    
                    if (player.hp <= 0) {
                        print("You have been slain... GAME OVER.", 'error');
                        soundSystem.playSound('defeat');
                        resetGame();
                    }
                }
            }
            
            updateStatus();
        }

        function showInventory() {
            if (player.inventory.length === 0) {
                print("Your inventory is empty.");
            } else {
                print("Inventory:");
                const counts = {};
                player.inventory.forEach(item => {
                    counts[item] = (counts[item] || 0) + 1;
                });
                
                Object.keys(counts).forEach(itemName => {
                    const item = weapons[itemName] || armors[itemName] || items[itemName];
                    const count = counts[itemName];
                    const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
                    print(`${itemName} x${count}: ${itemDesc}`, 'item');
                });
            }
            const weapon = weapons[player.equipped.weapon];
            const armor = armors[player.equipped.armor];
            print(`Equipped: ${weapon.name} (${weapon.dmg + player.str} DMG), ${armor.name} (${armor.def} DEF)`);
            print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.agility} AGILITY`);
            if (player.poisoned) {
                print(`STATUS: POISONED!`, 'error');
            }
            if (player.corrupted > 0) {
                print(`CORRUPTION: ${player.corrupted}`, 'corruption');
            }
            if (player.knownDocuments.length > 0) {
                print(`Documents read: ${player.knownDocuments.length}`, 'document');
            }
            if (player.secretAreasFound > 0) {
                print(`Secret areas found: ${player.secretAreasFound}`, 'secret');
            }
        }

        function listShop() {
            const location = locations[player.location];
            if (!location.npc || location.npc !== 'trader') {
                print("There's no trader here.", 'error');
                return;
            }
            
            const npc = npcs[location.npc];
            print(`${npc.name}'s Wares:`, 'npc');
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (item) {
                    const price = item.value;
                    print(`${item.name || itemName} - ${price} gold: ${item.desc}`, 'item');
                }
            });
            print("Sell items for 75% of value.", 'npc');
        }

        function buy(itemName) {
            const location = locations[player.location];
            if (!location.npc || location.npc !== 'trader') {
                print("There's no trader here.", 'error');
                return;
            }
            
            const npc = npcs[location.npc];
            if (!npc.shopItems.includes(itemName)) {
                print("The trader doesn't sell that.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                print("That item doesn't exist.", 'error');
                return;
            }
            
            if (player.gold < item.value) {
                print(`You need ${item.value} gold, but only have ${player.gold}.`, 'error');
                return;
            }
            
            player.gold -= item.value;
            player.inventory.push(itemName);
            print(`You buy ${item.name || itemName} for ${item.value} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function sell(itemName) {
            const location = locations[player.location];
            if (!location.npc || location.npc !== 'trader') {
                print("There's no trader here.", 'error');
                return;
            }
            
            const index = player.inventory.indexOf(itemName);
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item || item.type === 'quest') {
                print("You can't sell that.", 'error');
                return;
            }
            
            const sellPrice = Math.floor(item.value * 0.75);
            player.gold += sellPrice;
            player.inventory.splice(index, 1);
            print(`You sell ${item.name || itemName} for ${sellPrice} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function help() {
            print("=== THE DEADLANDS COMMANDS ===", 'command');
            print("MOVEMENT: n, s, e, w, u, d, look", 'system');
            print("EXPLORATION: search, examine [object/item]", 'system');
            print("TRAPS: disarm trap (scouts are best at this)", 'system');
            print("PUZZLES: solve puzzle (when you see one)", 'system');
            print("CORRUPTION: Manage with talismans and purges", 'corruption');
            print("COMBAT: attack [target], use [item]", 'system');
            print("NPCs: talk, give [npc]", 'system');
            print("TRADER: list, buy [item], sell [item]", 'system');
            print("ITEMS: take [item], equip [item], use [item], examine [item]", 'system');
            print("INVENTORY: inventory, status", 'system');
            print("OTHER: help, quit", 'system');
            print("=== NEW FEATURES ===", 'command');
            print("- Corruption system that builds over time", 'corruption');
            print("- Corrupted areas that affect your character", 'corruption');
            print("- Purification items to cleanse corruption", 'system');
            print("- New Deadlands theme music and sounds", 'system');
            print("- Class-specific abilities for new classes", 'system');
            print("- Enhanced traps with corruption effects", 'trap');
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            soundSystem.playBackground('wasteland');
            print("GAME OVER", 'error');
            print("Choose a class: survivor, scout, occultist.");
            updateStatus();
        }

        function quickCommand(cmd) {
            document.getElementById('input').value = cmd;
            const event = new KeyboardEvent('keydown', { key: 'Enter' });
            document.getElementById('input').dispatchEvent(event);
        }

        // ==================== COMMAND PARSER ====================
        input.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                const cmd = input.value.trim().toLowerCase();
                input.value = '';
                if (!cmd) return;

                soundSystem.playSound('click', 0.3);
                print(`> ${cmd}`, 'command');
                const parts = cmd.split(' ');
                const verb = parts[0];
                const arg = parts[1];
                const arg2 = parts[2];
                const arg3 = parts[3];

                // Class selection
                if (!player.class && ['survivor', 'scout', 'occultist'].includes(verb)) {
                    startGame(verb);
                    return;
                }
                if (!player.class) {
                    print("Choose a class first: survivor, scout, occultist.", 'error');
                    return;
                }

                // Game commands
                switch (verb) {
                    case 'n': case 'north': move('n'); break;
                    case 's': case 'south': move('s'); break;
                    case 'e': case 'east': move('e'); break;
                    case 'w': case 'west': move('w'); break;
                    case 'u': case 'up': move('u'); break;
                    case 'd': case 'down': move('d'); break;
                    case 'go': if (arg) move(arg); else print("Go where?"); break;
                    case 'l': case 'look': 
                        if (arg === 'at' && arg2) {
                            examine(arg2);
                        } else if (arg) {
                            examine(arg);
                        } else {
                            look();
                        }
                        break;
                    case 'search': 
                        searchArea();
                        break;
                    case 'examine': 
                        if (arg) examine(arg); else print("Examine what?"); 
                        break;
                    case 'disarm':
                        if (arg === 'trap') disarmTrap(); else print("Disarm what?"); 
                        break;
                    case 'solve':
                        if (arg === 'puzzle') solvePuzzle(locations[player.location].puzzle); else print("Solve what?"); 
                        break;
                    case 'take': 
                        if (arg) take(arg); else print("Take what?"); break;
                    case 'talk': talk(arg); break;
                    case 'give': 
                        if (arg) give(arg); else print("Give to who?"); break;
                    case 'list': listShop(); break;
                    case 'buy': if (arg) buy(arg); else print("Buy what?"); break;
                    case 'sell': if (arg) sell(arg); else print("Sell what?"); break;
                    case 'attack': if (arg) attack(arg); else attack(); break;
                    case 'use': if (arg) useItem(arg, arg2); else print("Use what?"); break;
                    case 'equip': if (arg) equip(arg); else print("Equip what?"); break;
                    case 'i': case 'inventory': case 'inv': showInventory(); break;
                    case 'status': updateStatus(); break;
                    case 'help': case '?': help(); break;
                    case 'quit': resetGame(); break;
                    default: print("Unknown command. Type 'help'.", 'error');
                }
            }
        });

        // Sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundSystem.toggle();
        });

        // Initialize audio on first user interaction
        document.addEventListener('click', function initAudio() {
            soundSystem.resumeAudioContext();
            if (!gameStarted) {
                soundSystem.playBackground('wasteland');
            }
            document.removeEventListener('click', initAudio);
        }, { once: true });

        // ==================== INIT ====================
        print("THE DEADLANDS BEYOND THE PASS (1987)", 'success');
        print("NIGHTFALLS GAMES PRESENTS", 'system');
        print("FOURTH IN THE TERROR SERIES", 'deadlands-text');
        print("", 'system');
        print("A journey into corrupted lands beyond the mountain pass!", 'system');
        print("Face corruption, mutated horrors, and fanatical cultists!", 'system');
        print("", 'system');
        print("NEW FEATURES:", 'success');
        print("- Corruption system that affects gameplay", 'corruption');
        print("- New Deadlands theme music and soundscape", 'system');
        print("- Purification mechanics to cleanse corruption", 'system');
        print("- Three new character classes", 'system');
        print("- Corrupted areas with environmental hazards", 'corruption');
        print("", 'system');
        print("Touch sound button to toggle audio", 'system');
        print("Use quick buttons for mobile play", 'system');
        print("", 'system');
        print("Choose your class: survivor, scout, occultist.", 'system');
        updateStatus();
        input.focus();
    </script>
</body>
</html>
