<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atari DnD Adventure - Enhanced</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.5;
            padding: 10px;
            max-width: 1200px;
            margin: 0 auto;
            overflow-x: hidden;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            border: 2px solid #fff;
            padding: 15px;
            background-color: #000;
            min-height: 95vh;
        }
        
        .screen-title {
            text-align: center;
            font-size: 18px;
            margin-bottom: 10px;
            color: #fff;
            border-bottom: 2px solid #fff;
            padding-bottom: 10px;
        }
        
        .game-area {
            display: flex;
            gap: 15px;
            min-height: 600px;
        }
        
        .main-display {
            flex: 3;
            border: 2px solid #fff;
            padding: 15px;
            display: flex;
            flex-direction: column;
            background-color: #111;
        }
        
        .stats-panel {
            flex: 1;
            border: 2px solid #fff;
            padding: 15px;
            background-color: #111;
            min-width: 320px;
            max-width: 320px;
        }
        
        .text-log {
            flex: 1;
            border: 2px solid #fff;
            padding: 10px;
            margin-bottom: 15px;
            overflow-y: auto;
            max-height: 400px;
            background-color: #000;
            line-height: 1.8;
            font-size: 11px;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .shop-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        button {
            background-color: #000;
            color: #fff;
            border: 2px solid #fff;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        button:hover {
            background-color: #333;
            color: #0f0;
            transform: translateY(-2px);
        }
        
        button:active {
            background-color: #555;
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .stat-block {
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .stat-name {
            color: #0f0;
            margin-bottom: 5px;
            font-size: 11px;
        }
        
        .stat-value {
            color: #fff;
            margin-left: 10px;
            font-size: 11px;
        }
        
        .character-creator {
            border: 2px solid #fff;
            padding: 15px;
            background-color: #111;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            color: #0f0;
            margin-bottom: 5px;
            font-size: 11px;
        }
        
        select, input {
            background-color: #000;
            color: #fff;
            border: 1px solid #fff;
            font-family: 'Press Start 2P', monospace;
            padding: 8px;
            width: 100%;
            font-size: 11px;
        }
        
        .game-message {
            color: #fff;
            margin-bottom: 10px;
        }
        
        .combat-log {
            color: #f00;
        }
        
        .loot-log {
            color: #ff0;
        }
        
        .heal-log {
            color: #0f0;
        }
        
        .skill-log {
            color: #0af;
        }
        
        .shop-log {
            color: #ff9900;
        }
        
        .health-bar {
            width: 100%;
            height: 15px;
            border: 1px solid #fff;
            background-color: #000;
            margin-top: 5px;
        }
        
        .health-fill {
            height: 100%;
            background-color: #f00;
            width: 100%;
            transition: width 0.5s;
        }
        
        .mana-bar {
            width: 100%;
            height: 15px;
            border: 1px solid #fff;
            background-color: #000;
            margin-top: 5px;
        }
        
        .mana-fill {
            height: 100%;
            background-color: #0af;
            width: 100%;
            transition: width 0.5s;
        }
        
        .xp-bar {
            width: 100%;
            height: 8px;
            border: 1px solid #fff;
            background-color: #000;
            margin-top: 5px;
        }
        
        .xp-fill {
            height: 100%;
            background-color: #0f0;
            width: 0%;
            transition: width 0.5s;
        }
        
        .hidden {
            display: none;
        }
        
        .game-over {
            color: #f00;
            font-size: 24px;
            text-align: center;
            margin: 20px 0;
            text-shadow: 0 0 5px #f00;
        }
        
        .victory {
            color: #0f0;
            font-size: 24px;
            text-align: center;
            margin: 20px 0;
            text-shadow: 0 0 5px #0f0;
        }
        
        .stat-allocation {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .stat-controls {
            display: flex;
            gap: 5px;
        }
        
        .stat-btn {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            padding: 0;
            text-align: center;
        }
        
        .stat-current {
            min-width: 40px;
            text-align: center;
            color: #fff;
        }
        
        .points-remaining {
            color: #0f0;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
        }
        
        .inventory-items {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .inventory-item {
            border: 1px solid #fff;
            padding: 5px;
            background-color: #222;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .inventory-item:hover {
            background-color: #444;
            color: #0f0;
            transform: scale(1.05);
        }
        
        .enemy-health {
            border: 1px solid #fff;
            padding: 5px;
            margin: 10px 0;
            background-color: #222;
        }
        
        .location-info {
            color: #0af;
            margin-bottom: 10px;
        }
        
        .skill-button {
            background-color: #000;
            color: #0af;
            border: 1px solid #0af;
            font-size: 9px;
            padding: 5px;
            margin: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .skill-button:hover {
            background-color: #0af;
            color: #000;
        }
        
        .quest-log {
            border: 1px solid #fff;
            padding: 5px;
            margin-top: 10px;
            background-color: #111;
            font-size: 9px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            border: 1px solid #444;
            background-color: #222;
        }
        
        .shop-item-name {
            color: #ff9900;
        }
        
        .shop-item-price {
            color: #ff0;
        }
        
        .shop-buy {
            background-color: #000;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            font-size: 9px;
            cursor: pointer;
        }
        
        .shop-buy:hover {
            background-color: #0f0;
            color: #000;
        }
        
        .shop-buy:disabled {
            background-color: #333;
            color: #666;
            border-color: #666;
        }
        
        .combat-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px;
            background-color: #222;
            border: 1px solid #f00;
        }
        
        .status-effects {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .status-effect {
            padding: 3px 6px;
            background-color: #333;
            border: 1px solid #ff0;
            font-size: 8px;
            color: #ff0;
        }
        
        .special-ability {
            background-color: #000;
            color: #f0f;
            border: 1px solid #f0f;
        }
        
        .special-ability:hover {
            background-color: #f0f;
            color: #000;
        }
        
        .shop-display {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ff9900;
            background-color: #111;
        }
        
        .equipment-slot {
            border: 1px dashed #666;
            padding: 3px;
            margin: 2px;
            font-size: 8px;
        }
        
        .equipment-slot-filled {
            border: 1px solid #0f0;
            background-color: #0f0;
            color: #000;
        }
        
        .damage-popup {
            position: absolute;
            color: #f00;
            font-weight: bold;
            animation: floatUp 1s forwards;
            pointer-events: none;
            z-index: 1000;
        }
        
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        .save-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .save-button {
            background-color: #000;
            color: #ff9900;
            border: 1px solid #ff9900;
            font-size: 9px;
            padding: 5px;
            flex: 1;
        }
        
        .save-button:hover {
            background-color: #ff9900;
            color: #000;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #000;
            border: 2px solid #0f0;
            padding: 10px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            font-size: 11px;
            max-width: 300px;
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        
        .critical-hit {
            animation: criticalFlash 0.3s;
        }
        
        @keyframes criticalFlash {
            0%, 100% { color: #fff; }
            50% { color: #f00; }
        }
        
        .tooltip {
            position: relative;
        }
        
        .tooltip-text {
            visibility: hidden;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #000;
            color: #fff;
            border: 1px solid #0f0;
            padding: 5px;
            font-size: 9px;
            white-space: nowrap;
            z-index: 1000;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
        }
        
        .character-summary {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #fff;
            background-color: #111;
        }
        
        .combat-animation {
            position: relative;
            height: 60px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .player-icon, .enemy-icon {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #0f0;
            border: 2px solid #fff;
        }
        
        .player-icon {
            left: 20px;
            top: 10px;
        }
        
        .enemy-icon {
            right: 20px;
            top: 10px;
            background-color: #f00;
        }
        
        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
            }
            
            .stats-panel {
                max-width: 100%;
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="screen-title">ATARI DUNGEONS & DRAGONS - ENHANCED</div>
        
        <!-- Character Creation Screen -->
        <div id="character-creation" class="character-creator">
            <div class="screen-title">CHARACTER CREATION</div>
            
            <div class="form-group">
                <label for="char-name">NAME:</label>
                <input type="text" id="char-name" value="VALEROS" maxlength="12">
            </div>
            
            <div class="form-group">
                <label for="char-race">RACE:</label>
                <select id="char-race">
                    <option value="Human">HUMAN (+1 ALL STATS)</option>
                    <option value="Elf">ELF (+2 DEX, +1 INT)</option>
                    <option value="Dwarf">DWARF (+2 CON, +1 STR)</option>
                    <option value="Halfling">HALFLING (+2 DEX, +1 CHA)</option>
                    <option value="Half-Orc">HALF-ORC (+2 STR, +1 CON)</option>
                    <option value="Dragonborn">DRAGONBORN (+2 STR, +1 CHA)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="char-class">CLASS:</label>
                <select id="char-class">
                    <option value="Fighter">FIGHTER</option>
                    <option value="Wizard">WIZARD</option>
                    <option value="Rogue">ROGUE</option>
                    <option value="Cleric">CLERIC</option>
                    <option value="Ranger">RANGER</option>
                    <option value="Paladin">PALADIN</option>
                    <option value="Barbarian">BARBARIAN</option>
                    <option value="Bard">BARD</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>STAT ALLOCATION (27 POINTS):</label>
                <div class="points-remaining" id="points-remaining">POINTS REMAINING: 27</div>
                <div class="stat-block" id="stat-allocation">
                    <!-- Stats will be populated by JavaScript -->
                </div>
            </div>
            
            <div class="form-group">
                <label>BACKGROUND:</label>
                <select id="char-background">
                    <option value="Soldier">SOLDIER (+1 STR, Combat Training)</option>
                    <option value="Acolyte">ACOLYTE (+1 WIS, Healing Knowledge)</option>
                    <option value="Urchin">URCHIN (+1 DEX, Stealthy)</option>
                    <option value="Sage">SAGE (+1 INT, Lore Knowledge)</option>
                    <option value="Noble">NOBLE (+1 CHA, Wealthy)</option>
                    <option value="Outlander">OUTLANDER (+1 CON, Survivalist)</option>
                </select>
            </div>
            
            <div class="character-summary">
                <div class="stat-name">SELECTED CLASS INFO:</div>
                <div class="stat-value" id="class-description">FIGHTER: High HP, combat specialist</div>
            </div>
            
            <button id="start-game">BEGIN ADVENTURE</button>
        </div>
        
        <!-- Main Game Screen -->
        <div id="game-screen" class="hidden">
            <div class="game-area">
                <div class="main-display">
                    <div id="combat-display" class="combat-stats hidden">
                        <div>
                            <div class="stat-name">ENEMY:</div>
                            <div class="stat-value" id="enemy-name">GOBLIN</div>
                            <div class="stat-value" id="enemy-hp">HP: 10/10</div>
                            <div class="health-bar">
                                <div class="health-fill" id="enemy-health-fill"></div>
                            </div>
                            <div class="stat-value" id="enemy-status">STATUS: NORMAL</div>
                        </div>
                        <div>
                            <div class="stat-name">SPECIAL:</div>
                            <div class="stat-value" id="enemy-special">Throw Rocks</div>
                            <div class="status-effects" id="enemy-effects"></div>
                        </div>
                    </div>
                    
                    <div class="combat-animation hidden" id="combat-animation">
                        <div class="player-icon" id="player-icon"></div>
                        <div class="enemy-icon" id="enemy-icon"></div>
                    </div>
                    
                    <div class="text-log" id="game-text">
                        <div class="game-message">WELCOME TO THE DUNGEON OF INFINITE PERIL!</div>
                    </div>
                    
                    <div class="action-buttons" id="action-buttons">
                        <!-- Buttons will be populated by JavaScript -->
                    </div>
                    
                    <div class="shop-display hidden" id="shop-display">
                        <!-- Shop items will be populated by JavaScript -->
                    </div>
                    
                    <div class="quest-log" id="quest-log">
                        <div class="stat-name">ACTIVE QUESTS:</div>
                        <div id="quest-list">- FIND THE AMULET OF YENDOR</div>
                    </div>
                </div>
                
                <div class="stats-panel">
                    <div class="screen-title">CHARACTER STATS</div>
                    
                    <div class="save-buttons">
                        <button class="save-button" id="save-game">SAVE GAME</button>
                        <button class="save-button" id="load-game">LOAD GAME</button>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">NAME:</div>
                        <div class="stat-value" id="stat-name">VALEROS</div>
                        
                        <div class="stat-name">RACE/CLASS:</div>
                        <div class="stat-value" id="stat-race-class">HUMAN FIGHTER</div>
                        
                        <div class="stat-name">LEVEL:</div>
                        <div class="stat-value" id="stat-level">1</div>
                        
                        <div class="stat-name">DUNGEON LEVEL:</div>
                        <div class="stat-value" id="stat-dungeon-level">1</div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">HEALTH:</div>
                        <div class="stat-value" id="stat-hp">10/10</div>
                        <div class="health-bar">
                            <div class="health-fill" id="health-fill"></div>
                        </div>
                        
                        <div class="stat-name">MANA:</div>
                        <div class="stat-value" id="stat-mana">10/10</div>
                        <div class="mana-bar">
                            <div class="mana-fill" id="mana-fill"></div>
                        </div>
                        
                        <div class="stat-name">EXPERIENCE:</div>
                        <div class="stat-value" id="stat-xp">0/100</div>
                        <div class="xp-bar">
                            <div class="xp-fill" id="xp-fill"></div>
                        </div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">ARMOR CLASS:</div>
                        <div class="stat-value" id="stat-ac">15</div>
                        
                        <div class="stat-name">DAMAGE BONUS:</div>
                        <div class="stat-value" id="stat-damage">+3</div>
                        
                        <div class="stat-name">GOLD:</div>
                        <div class="stat-value" id="stat-gold">100</div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">ATTRIBUTES:</div>
                        <div class="stat-value">STR: <span id="stat-str-display">16</span> (+<span id="stat-str-mod">3</span>)</div>
                        <div class="stat-value">DEX: <span id="stat-dex-display">12</span> (+<span id="stat-dex-mod">1</span>)</div>
                        <div class="stat-value">CON: <span id="stat-con-display">14</span> (+<span id="stat-con-mod">2</span>)</div>
                        <div class="stat-value">INT: <span id="stat-int-display">10</span> (+<span id="stat-int-mod">0</span>)</div>
                        <div class="stat-value">WIS: <span id="stat-wis-display">8</span> (-<span id="stat-wis-mod">1</span>)</div>
                        <div class="stat-value">CHA: <span id="stat-cha-display">13</span> (+<span id="stat-cha-mod">1</span>)</div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">EQUIPMENT:</div>
                        <div id="equipment-slots">
                            <div class="equipment-slot" id="slot-weapon">WEAPON: <span id="equipped-weapon">IRON SWORD</span></div>
                            <div class="equipment-slot" id="slot-armor">ARMOR: <span id="equipped-armor">LEATHER ARMOR</span></div>
                            <div class="equipment-slot" id="slot-shield">SHIELD: <span id="equipped-shield">NONE</span></div>
                        </div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">INVENTORY:</div>
                        <div class="inventory-items" id="inventory-items">
                            <!-- Inventory items will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">SKILLS & ABILITIES:</div>
                        <div id="skill-buttons">
                            <!-- Skill buttons will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="stat-block">
                        <div class="stat-name">STATUS EFFECTS:</div>
                        <div class="status-effects" id="player-effects"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Game Over Screen -->
        <div id="game-over-screen" class="hidden">
            <div class="game-over">GAME OVER</div>
            <div class="text-log" id="game-over-text"></div>
            <button id="restart-game">START NEW GAME</button>
        </div>
        
        <!-- Victory Screen -->
        <div id="victory-screen" class="hidden">
            <div class="victory">VICTORY!</div>
            <div class="text-log" id="victory-text"></div>
            <button id="new-game-plus">NEW GAME+ (HARDER)</button>
            <button id="restart-victory">MAIN MENU</button>
        </div>
    </div>

    <script>
        // Audio Manager using Web Audio API
        const AudioManager = {
            context: null,
            initialized: false,
            init() {
                if (this.initialized) return;
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.warn("Web Audio API not supported");
                }
            },
            async resume() {
                if (this.context && this.context.state === 'suspended') {
                    await this.context.resume();
                }
            },
            playButtonClick() {
                this.init();
                if (!this.context) return;
                this.resume();
                const now = this.context.currentTime;
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.frequency.value = 600;
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            },
            playNotification() {
                this.init();
                if (!this.context) return;
                this.resume();
                const now = this.context.currentTime;
                // Two tones
                for (let i = 0; i < 2; i++) {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.frequency.value = 400 + i * 200;
                    gain.gain.setValueAtTime(0.1, now + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.1);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.1);
                }
            },
            playCombatHit() {
                this.init();
                if (!this.context) return;
                this.resume();
                const now = this.context.currentTime;
                // Short noise burst (white noise)
                const bufferSize = 4096;
                const noiseBuffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                const noise = this.context.createBufferSource();
                noise.buffer = noiseBuffer;
                const gain = this.context.createGain();
                noise.connect(gain);
                gain.connect(this.context.destination);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                noise.start(now);
                noise.stop(now + 0.15);
                // Add a low thump
                const osc = this.context.createOscillator();
                osc.type = 'triangle';
                osc.frequency.value = 100;
                const gainOsc = this.context.createGain();
                osc.connect(gainOsc);
                gainOsc.connect(this.context.destination);
                gainOsc.gain.setValueAtTime(0.1, now);
                gainOsc.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            },
            playLevelUp() {
                this.init();
                if (!this.context) return;
                this.resume();
                const now = this.context.currentTime;
                // Ascending arpeggio
                const notes = [262, 330, 392, 523]; // C4, E4, G4, C5
                notes.forEach((freq, i) => {
                    const osc = this.context.createOscillator();
                    const gain = this.context.createGain();
                    osc.connect(gain);
                    gain.connect(this.context.destination);
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.1, now + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.15);
                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.15);
                });
            },
            playReward() {
                this.init();
                if (!this.context) return;
                this.resume();
                const now = this.context.currentTime;
                // "Coin" sound: short high beep with decay
                const osc = this.context.createOscillator();
                const gain = this.context.createGain();
                osc.connect(gain);
                gain.connect(this.context.destination);
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
        };

        // Enhanced Game State with save/load support
        const gameState = {
            screen: 'character',
            version: '2.0',
            player: {
                name: 'Valeros',
                race: 'Human',
                class: 'Fighter',
                background: 'Soldier',
                level: 1,
                hp: 100,
                maxHp: 100,
                mana: 10,
                maxMana: 10,
                ac: 15,
                str: 16,
                dex: 12,
                con: 14,
                int: 10,
                wis: 8,
                cha: 13,
                xp: 0,
                nextLevelXp: 100,
                gold: 100,
                inventory: ['Health Potion', 'Iron Sword', 'Leather Armor', 'Minor Healing Potion'],
                equipped: {
                    weapon: 'Iron Sword',
                    armor: 'Leather Armor',
                    shield: null
                },
                spells: [],
                skills: [],
                abilities: [],
                statusEffects: [],
                abilityCooldowns: {},
                dungeonLevel: 1,
                quests: {
                    main: { name: 'Find the Amulet of Yendor', completed: false, reward: 1000 },
                    side1: { name: 'Clear the Goblin Nest', completed: false, progress: 0, required: 5, reward: 250 },
                    side2: { name: 'Recover the Lost Artifact', completed: false, reward: 500 },
                    side3: { name: 'Slay the Dragon', completed: false, reward: 2000 }
                },
                totalEnemiesDefeated: 0,
                totalGoldCollected: 100,
                playTime: 0
            },
            location: 'entrance',
            inCombat: false,
            enemy: null,
            enemyStatusEffects: [],
            gameLog: [],
            gameActive: true,
            shopOpen: false,
            pointsRemaining: 27,
            statCosts: { 8: 0, 9: 1, 10: 2, 11: 3, 12: 4, 13: 5, 14: 7, 15: 9 },
            lastSave: null,
            difficulty: 1
        };

        // Enhanced Enemies database with better balancing
        const enemies = {
            goblin: { 
                name: 'Goblin', 
                hp: 10, 
                maxHp: 10, 
                ac: 13, 
                damage: '1d4+1', 
                xp: 50, 
                gold: '1d10+5', 
                special: 'Throw Rocks (1d4 damage)',
                abilities: ['dodge'],
                weaknesses: ['fire'],
                resistances: [],
                description: 'Small, cunning humanoid'
            },
            skeleton: { 
                name: 'Skeleton', 
                hp: 18, 
                maxHp: 18, 
                ac: 13, 
                damage: '1d6+2', 
                xp: 100, 
                gold: '2d10+10', 
                special: 'Resistant to piercing',
                abilities: ['bone_shield'],
                weaknesses: ['bludgeoning', 'radiant'],
                resistances: ['piercing', 'poison'],
                description: 'Undead warrior'
            },
            orc: { 
                name: 'Orc Warrior', 
                hp: 30, 
                maxHp: 30, 
                ac: 14, 
                damage: '1d12+3', 
                xp: 200, 
                gold: '3d12+15', 
                special: 'Aggressive Charge',
                abilities: ['rage', 'power_attack'],
                weaknesses: [],
                resistances: [],
                description: 'Brutish humanoid warrior'
            },
            troll: { 
                name: 'Cave Troll', 
                hp: 84, 
                maxHp: 84, 
                ac: 15, 
                damage: '2d6+4', 
                xp: 450, 
                gold: '5d20+50', 
                special: 'Regeneration (5 hp/round)',
                abilities: ['regenerate', 'swipe'],
                weaknesses: ['fire', 'acid'],
                resistances: ['bludgeoning'],
                description: 'Large regenerating creature'
            },
            dragon: { 
                name: 'Ancient Red Dragon', 
                hp: 350, 
                maxHp: 350, 
                ac: 22, 
                damage: '2d10+2d6+8', 
                xp: 5000, 
                gold: '20d100+500', 
                special: 'Fire Breath (10d6 damage)',
                abilities: ['fire_breath', 'wing_buffet', 'fear_aura'],
                weaknesses: ['cold'],
                resistances: ['fire', 'slashing'],
                description: 'Legendary fire-breathing dragon'
            },
            wolf: { 
                name: 'Dire Wolf', 
                hp: 37, 
                maxHp: 37, 
                ac: 14, 
                damage: '2d6+3', 
                xp: 100, 
                gold: '2d10+10', 
                special: 'Pack Tactics',
                abilities: ['pounce', 'knockdown'],
                weaknesses: [],
                resistances: [],
                description: 'Giant predatory wolf'
            },
            bandit: { 
                name: 'Bandit Captain', 
                hp: 65, 
                maxHp: 65, 
                ac: 15, 
                damage: '1d8+3', 
                xp: 300, 
                gold: '5d20+30', 
                special: 'Parry (+2 AC)',
                abilities: ['parry', 'dirty_fight'],
                weaknesses: [],
                resistances: [],
                description: 'Skilled human outlaw'
            },
            mimic: { 
                name: 'Mimic', 
                hp: 58, 
                maxHp: 58, 
                ac: 12, 
                damage: '1d8+3', 
                xp: 250, 
                gold: '3d20+20', 
                special: 'Adhesive (restrains target)',
                abilities: ['adhesive', 'surprise_attack'],
                weaknesses: [],
                resistances: ['slashing'],
                description: 'Shape-changing monster'
            },
            zombie: { 
                name: 'Zombie Horde', 
                hp: 45, 
                maxHp: 45, 
                ac: 8, 
                damage: '1d6+1', 
                xp: 50, 
                gold: '1d6+5', 
                special: 'Undead Fortitude',
                abilities: ['undead_fortitude', 'grapple'],
                weaknesses: ['radiant', 'fire'],
                resistances: ['poison'],
                description: 'Group of undead creatures'
            },
            spider: { 
                name: 'Giant Spider', 
                hp: 26, 
                maxHp: 26, 
                ac: 14, 
                damage: '1d8+2', 
                xp: 200, 
                gold: '2d10+10', 
                special: 'Poison Bite (1d8 poison)',
                abilities: ['web', 'poison_bite'],
                weaknesses: ['fire'],
                resistances: [],
                description: 'Large venomous arachnid'
            }
        };

        // Enhanced Items database with better organization
        const items = {
            // Healing Items
            'Health Potion': { 
                type: 'consumable', 
                effect: 'heal', 
                value: '2d4+2', 
                cost: 50,
                description: 'RESTORES 2D4+2 HP',
                rarity: 'common'
            },
            'Minor Healing Potion': { 
                type: 'consumable', 
                effect: 'heal', 
                value: '1d4+1', 
                cost: 25,
                description: 'RESTORES 1D4+1 HP',
                rarity: 'common'
            },
            'Greater Healing Potion': { 
                type: 'consumable', 
                effect: 'heal', 
                value: '4d4+4', 
                cost: 100,
                description: 'RESTORES 4D4+4 HP',
                rarity: 'uncommon'
            },
            'Superior Healing Potion': { 
                type: 'consumable', 
                effect: 'heal', 
                value: '8d4+8', 
                cost: 200,
                description: 'RESTORES 8D4+8 HP',
                rarity: 'rare'
            },
            'Mana Potion': { 
                type: 'consumable', 
                effect: 'mana', 
                value: '2d4+2', 
                cost: 75,
                description: 'RESTORES 2D4+2 MANA',
                rarity: 'uncommon'
            },
            
            // Weapons
            'Iron Sword': { 
                type: 'weapon', 
                damage: '1d8', 
                cost: 150,
                description: '1D8 SLASHING DAMAGE',
                slot: 'weapon',
                rarity: 'common'
            },
            'Steel Sword': { 
                type: 'weapon', 
                damage: '1d10', 
                cost: 300,
                description: '1D10 SLASHING DAMAGE',
                slot: 'weapon',
                rarity: 'uncommon'
            },
            'Magic Wand': { 
                type: 'weapon', 
                damage: '1d6+1', 
                cost: 500,
                description: '1D6+1 MAGIC DAMAGE',
                slot: 'weapon',
                rarity: 'rare'
            },
            'Longbow': { 
                type: 'weapon', 
                damage: '1d8', 
                cost: 200,
                description: '1D8 PIERCING DAMAGE',
                slot: 'weapon',
                rarity: 'common'
            },
            'Warhammer': { 
                type: 'weapon', 
                damage: '1d10', 
                cost: 350,
                description: '1D10 BLUDGEONING DAMAGE',
                slot: 'weapon',
                rarity: 'uncommon'
            },
            
            // Armor
            'Leather Armor': { 
                type: 'armor', 
                ac: 2, 
                cost: 100,
                description: '+2 AC, LIGHT ARMOR',
                slot: 'armor',
                rarity: 'common'
            },
            'Chain Mail': { 
                type: 'armor', 
                ac: 4, 
                cost: 300,
                description: '+4 AC, MEDIUM ARMOR',
                slot: 'armor',
                rarity: 'uncommon'
            },
            'Plate Armor': { 
                type: 'armor', 
                ac: 6, 
                cost: 750,
                description: '+6 AC, HEAVY ARMOR',
                slot: 'armor',
                rarity: 'rare'
            },
            
            // Shields
            'Shield': { 
                type: 'shield', 
                ac: 2, 
                cost: 100,
                description: '+2 AC',
                slot: 'shield',
                rarity: 'common'
            },
            'Magic Shield': { 
                type: 'shield', 
                ac: 3, 
                cost: 400,
                description: '+3 AC, MAGIC RESISTANCE',
                slot: 'shield',
                rarity: 'rare'
            },
            
            // Consumables
            'Healing Scroll': { 
                type: 'consumable', 
                effect: 'heal', 
                value: '3d8', 
                cost: 200,
                description: 'SCROLL OF HEALING (3D8)',
                rarity: 'uncommon'
            },
            'Fire Bomb': { 
                type: 'consumable', 
                effect: 'damage', 
                value: '3d6', 
                cost: 150,
                description: '3D6 FIRE DAMAGE TO ALL ENEMIES',
                rarity: 'common'
            },
            'Poison Vial': { 
                type: 'consumable', 
                effect: 'poison', 
                value: '1d4', 
                cost: 100,
                description: 'APPLIES POISON (1D4/TURN)',
                rarity: 'common'
            },
            'Antidote': { 
                type: 'consumable', 
                effect: 'cure', 
                value: 'poison', 
                cost: 80,
                description: 'CURES POISON',
                rarity: 'common'
            },
            'Strength Potion': { 
                type: 'consumable', 
                effect: 'buff', 
                value: 'str', 
                cost: 200,
                description: '+2 STR FOR 5 TURNS',
                rarity: 'uncommon'
            },
            'Invisibility Potion': { 
                type: 'consumable', 
                effect: 'invisibility', 
                value: 3, 
                cost: 300,
                description: 'INVISIBLE FOR 3 TURNS',
                rarity: 'rare'
            },
            
            // Materials
            'Dragon Scale': { 
                type: 'material', 
                value: 500,
                cost: 0,
                description: 'RARE CRAFTING MATERIAL',
                rarity: 'legendary'
            },
            'Goblin Ear': { 
                type: 'material', 
                value: 10,
                cost: 0,
                description: 'PROOF OF GOBLIN SLAYING',
                rarity: 'common'
            }
        };

        // Enhanced Skills database
        const skills = {
            // Fighter skills
            'Power Attack': {
                class: 'Fighter',
                cost: 0,
                effect: 'Deal double damage but attack with disadvantage',
                type: 'combat',
                cooldown: 3,
                uses: null
            },
            'Second Wind': {
                class: 'Fighter',
                cost: 0,
                effect: 'Heal 1d10 + level HP once per combat',
                type: 'heal',
                cooldown: 0,
                uses: 1
            },
            'Parry': {
                class: 'Fighter',
                cost: 0,
                effect: 'Increase AC by 5 against next attack',
                type: 'defense',
                cooldown: 2,
                uses: null
            },
            
            // Wizard skills
            'Fireball': {
                class: 'Wizard',
                cost: 10,
                effect: 'Deal 8d6 fire damage to all enemies',
                type: 'spell',
                cooldown: 3,
                uses: null
            },
            'Magic Missile': {
                class: 'Wizard',
                cost: 5,
                effect: '3 missiles that always hit for 1d4+1 each',
                type: 'spell',
                cooldown: 1,
                uses: null
            },
            'Shield': {
                class: 'Wizard',
                cost: 5,
                effect: '+5 AC until your next turn',
                type: 'spell',
                cooldown: 2,
                uses: null
            },
            
            // Rogue skills
            'Sneak Attack': {
                class: 'Rogue',
                cost: 0,
                effect: 'Deal extra 2d6 damage if enemy hasn\'t attacked',
                type: 'combat',
                cooldown: 1,
                uses: null
            },
            'Evasion': {
                class: 'Rogue',
                cost: 0,
                effect: 'Take half damage from area effects',
                type: 'defense',
                cooldown: 3,
                uses: null
            },
            'Backstab': {
                class: 'Rogue',
                cost: 0,
                effect: 'Triple damage if attacking from surprise',
                type: 'combat',
                cooldown: 4,
                uses: null
            },
            
            // Cleric skills
            'Turn Undead': {
                class: 'Cleric',
                cost: 15,
                effect: 'Frighten undead enemies, may destroy weak ones',
                type: 'spell',
                cooldown: 5,
                uses: null
            },
            'Divine Smite': {
                class: 'Cleric',
                cost: 10,
                effect: 'Add 2d8 radiant damage to attack',
                type: 'spell',
                cooldown: 2,
                uses: null
            },
            'Cure Wounds': {
                class: 'Cleric',
                cost: 5,
                effect: 'Heal 1d8 + WIS modifier',
                type: 'spell',
                cooldown: 1,
                uses: null
            },
            
            // Barbarian skills
            'Rage': {
                class: 'Barbarian',
                cost: 0,
                effect: 'Resistance to damage, +2 damage for 3 rounds',
                type: 'combat',
                cooldown: 5,
                uses: null
            },
            
            // Ranger skills
            'Hunter\'s Mark': {
                class: 'Ranger',
                cost: 0,
                effect: 'Mark target for +1d6 damage per attack',
                type: 'combat',
                cooldown: 3,
                uses: null
            },
            
            // Paladin skills
            'Lay on Hands': {
                class: 'Paladin',
                cost: 0,
                effect: 'Heal 5 x level HP once per day',
                type: 'heal',
                cooldown: 0,
                uses: 1
            },
            
            // Bard skills
            'Bardic Inspiration': {
                class: 'Bard',
                cost: 0,
                effect: 'Grant +1d6 to next attack roll or skill check',
                type: 'support',
                cooldown: 3,
                uses: null
            }
        };

        // Shop inventory with categories
        const shopInventory = {
            healing: ['Health Potion', 'Minor Healing Potion', 'Greater Healing Potion', 'Antidote'],
            weapons: ['Steel Sword', 'Longbow', 'Warhammer'],
            armor: ['Chain Mail', 'Shield'],
            special: ['Mana Potion', 'Healing Scroll', 'Fire Bomb', 'Strength Potion', 'Invisibility Potion']
        };

        // Locations with more details
        const locations = {
            entrance: {
                name: 'Dungeon Entrance',
                description: 'YOU STAND AT THE ENTRANCE TO A FORBIDDING DUNGEON. THE STONE ARCHWAY IS CARVED WITH ANCIENT RUNES. TWO TORCHES FLANK THE ENTRANCE.',
                actions: ['explore', 'rest', 'inspect', 'camp', 'shop'],
                encounters: ['goblin', 'wolf', 'trap', 'nothing', 'chest', 'zombie'],
                shops: true,
                connections: ['crossroads'],
                danger: 1
            },
            crossroads: {
                name: 'Crossroads',
                description: 'A LARGE INTERSECTION WITH THREE PATHS. TORCHES BURN IN IRON BRACKETS. AN OLD SIGNPOST POINTS IN DIFFERENT DIRECTIONS.',
                actions: ['north', 'east', 'west', 'rest', 'inspect', 'shop', 'back'],
                encounters: ['goblin', 'bandit', 'chest', 'nothing', 'skeleton'],
                shops: true,
                connections: ['corridor', 'chamber', 'depths', 'entrance'],
                danger: 2
            },
            corridor: {
                name: 'Dark Corridor',
                description: 'A DAMP, NARROW CORRIDOR STRETCHES BEFORE YOU. TORCHLIGHT FLICKERS AGAINST THE MOSS-COVERED WALLS. YOU HEAR ECHOES IN THE DISTANCE.',
                actions: ['explore', 'rest', 'inspect', 'back', 'search'],
                encounters: ['skeleton', 'bandit', 'trap', 'nothing', 'chest', 'zombie'],
                shops: false,
                connections: ['chamber', 'crossroads'],
                danger: 3
            },
            chamber: {
                name: 'Great Chamber',
                description: 'YOU ENTER A VAST CHAMBER. ANCIENT PILLARS REACH UP INTO DARKNESS. THE AIR IS THICK WITH DUST AND THE SCENT OF OLD MAGIC.',
                actions: ['explore', 'rest', 'inspect', 'back', 'search'],
                encounters: ['orc', 'wolf', 'mimic', 'chest', 'nothing', 'bandit'],
                shops: false,
                connections: ['depths', 'corridor'],
                danger: 4
            },
            depths: {
                name: 'Frozen Depths',
                description: 'YOU DESCEND INTO ICY DEPTHS. THE AIR GROWS BITTERLY COLD. STRANGE CRYSTALS EMIT A FAINT GLOW. FROST COVERS THE WALLS.',
                actions: ['explore', 'rest', 'inspect', 'back', 'search'],
                encounters: ['troll', 'skeleton', 'spider', 'chest', 'nothing'],
                shops: false,
                connections: ['throne', 'chamber'],
                danger: 5
            },
            throne: {
                name: 'Dragon\'s Throne Room',
                description: 'BEFORE YOU STANDS A MASSIVE STONE THRONE ADORNED WITH GEMS. UPON IT RESTS THE GLOWING AMULET OF YENDOR! A DEEP GROWL ECHOES.',
                actions: ['take', 'inspect', 'flee'],
                encounters: ['dragon'],
                shops: false,
                connections: [],
                danger: 10
            }
        };

        // Initialize DOM elements
        const characterCreation = document.getElementById('character-creation');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const victoryScreen = document.getElementById('victory-screen');
        const gameText = document.getElementById('game-text');
        const actionButtons = document.getElementById('action-buttons');
        const shopDisplay = document.getElementById('shop-display');
        const combatDisplay = document.getElementById('combat-display');
        const questList = document.getElementById('quest-list');
        const startGameBtn = document.getElementById('start-game');
        const restartGameBtn = document.getElementById('restart-game');
        const newGamePlusBtn = document.getElementById('new-game-plus');
        const restartVictoryBtn = document.getElementById('restart-victory');
        const saveGameBtn = document.getElementById('save-game');
        const loadGameBtn = document.getElementById('load-game');
        const combatAnimation = document.getElementById('combat-animation');
        
        // Character creation elements
        const charNameInput = document.getElementById('char-name');
        const charRaceSelect = document.getElementById('char-race');
        const charClassSelect = document.getElementById('char-class');
        const charBackgroundSelect = document.getElementById('char-background');
        const statAllocationDiv = document.getElementById('stat-allocation');
        const pointsRemainingDiv = document.getElementById('points-remaining');
        const classDescription = document.getElementById('class-description');
        
        // Stat display elements
        const statName = document.getElementById('stat-name');
        const statRaceClass = document.getElementById('stat-race-class');
        const statLevel = document.getElementById('stat-level');
        const statHp = document.getElementById('stat-hp');
        const statMana = document.getElementById('stat-mana');
        const statXp = document.getElementById('stat-xp');
        const statAc = document.getElementById('stat-ac');
        const statDamage = document.getElementById('stat-damage');
        const statGold = document.getElementById('stat-gold');
        const statDungeonLevel = document.getElementById('stat-dungeon-level');
        const healthFill = document.getElementById('health-fill');
        const manaFill = document.getElementById('mana-fill');
        const xpFill = document.getElementById('xp-fill');
        const inventoryItems = document.getElementById('inventory-items');
        const skillButtons = document.getElementById('skill-buttons');
        const equipmentSlots = document.getElementById('equipment-slots');
        const playerEffects = document.getElementById('player-effects');
        
        // Stat mod displays
        const statStrDisplay = document.getElementById('stat-str-display');
        const statDexDisplay = document.getElementById('stat-dex-display');
        const statConDisplay = document.getElementById('stat-con-display');
        const statIntDisplay = document.getElementById('stat-int-display');
        const statWisDisplay = document.getElementById('stat-wis-display');
        const statChaDisplay = document.getElementById('stat-cha-display');
        const statStrMod = document.getElementById('stat-str-mod');
        const statDexMod = document.getElementById('stat-dex-mod');
        const statConMod = document.getElementById('stat-con-mod');
        const statIntMod = document.getElementById('stat-int-mod');
        const statWisMod = document.getElementById('stat-wis-mod');
        const statChaMod = document.getElementById('stat-cha-mod');

        // Combat display elements
        const enemyName = document.getElementById('enemy-name');
        const enemyHp = document.getElementById('enemy-hp');
        const enemyHealthFill = document.getElementById('enemy-health-fill');
        const enemyStatus = document.getElementById('enemy-status');
        const enemySpecial = document.getElementById('enemy-special');
        const enemyEffects = document.getElementById('enemy-effects');

        // Class descriptions
        const classDescriptions = {
            'Fighter': 'HIGH HP, COMBAT SPECIALIST, PROFIENCY WITH ALL WEAPONS AND ARMOR',
            'Wizard': 'MASTER OF ARCANE MAGIC, LOW HP, HIGH INTELLIGENCE REQUIRED',
            'Rogue': 'STEALTH AND PRECISION, HIGH DEXTERITY, SKILLED WITH TRAPS',
            'Cleric': 'DIVINE MAGIC, HEALING AND SUPPORT, MEDIUM ARMOR PROFICIENCY',
            'Ranger': 'WILDERNESS EXPERT, RANGED COMBAT, ANIMAL COMPANION',
            'Paladin': 'HOLY WARRIOR, HEAVY ARMOR, DIVINE SMITES',
            'Barbarian': 'RAGING BERSERKER, HIGH DAMAGE, DAMAGE RESISTANCE',
            'Bard': 'CHARISMATIC SUPPORT, BUFFS AND DEBUFFS, VERSATILE'
        };

        // Initialize game
        function initGame() {
            initCharacterCreation();
            
            // Event listeners
            startGameBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                startGame();
            });
            restartGameBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                restartGame();
            });
            newGamePlusBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                startNewGamePlus();
            });
            restartVictoryBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                restartGame();
            });
            saveGameBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                saveGame();
            });
            loadGameBtn.addEventListener('click', () => {
                AudioManager.playButtonClick();
                loadGame();
            });
            
            charRaceSelect.addEventListener('change', updateRaceBonuses);
            charClassSelect.addEventListener('change', updateClassInfo);
            charBackgroundSelect.addEventListener('change', updateBackgroundInfo);
            
            // Check for saved game
            if (localStorage.getItem('atariDnDSave')) {
                addToLog('SAVED GAME DETECTED. PRESS "LOAD GAME" TO CONTINUE.');
            }
            
            addToLog('WELCOME TO THE DUNGEON OF INFINITE PERIL!');
            addToLog('YOUR QUEST: RETRIEVE THE LOST AMULET OF YENDOR FROM THE DEPTHS.');
            
            // Start game timer
            setInterval(() => {
                if (gameState.gameActive && gameState.screen === 'game') {
                    gameState.player.playTime++;
                }
            }, 1000);
        }

        // Initialize character creation
        function initCharacterCreation() {
            statAllocationDiv.innerHTML = '';
            const stats = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
            const baseValues = { STR: 8, DEX: 8, CON: 8, INT: 8, WIS: 8, CHA: 8 };
            
            stats.forEach(stat => {
                const statDiv = document.createElement('div');
                statDiv.className = 'stat-allocation';
                
                const statLabel = document.createElement('div');
                statLabel.className = 'stat-name';
                statLabel.textContent = `${stat}:`;
                
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'stat-controls';
                
                const minusBtn = document.createElement('button');
                minusBtn.className = 'stat-btn';
                minusBtn.textContent = '-';
                minusBtn.dataset.stat = stat;
                minusBtn.addEventListener('click', () => adjustStat(stat, -1));
                
                const valueDisplay = document.createElement('div');
                valueDisplay.className = 'stat-current';
                valueDisplay.id = `stat-${stat.toLowerCase()}-value`;
                valueDisplay.textContent = baseValues[stat];
                
                const plusBtn = document.createElement('button');
                plusBtn.className = 'stat-btn';
                plusBtn.textContent = '+';
                plusBtn.dataset.stat = stat;
                plusBtn.addEventListener('click', () => adjustStat(stat, 1));
                
                controlsDiv.appendChild(minusBtn);
                controlsDiv.appendChild(valueDisplay);
                controlsDiv.appendChild(plusBtn);
                
                statDiv.appendChild(statLabel);
                statDiv.appendChild(controlsDiv);
                
                statAllocationDiv.appendChild(statDiv);
            });
            
            gameState.pointsRemaining = 27;
            updatePointsDisplay();
            updateClassInfo();
        }

        // Adjust stat value
        function adjustStat(stat, change) {
            const valueDisplay = document.getElementById(`stat-${stat.toLowerCase()}-value`);
            let currentValue = parseInt(valueDisplay.textContent);
            const newValue = currentValue + change;
            
            if (newValue < 8 || newValue > 15) return;
            
            const currentCost = gameState.statCosts[currentValue] || 0;
            const newCost = gameState.statCosts[newValue] || 0;
            const pointDifference = newCost - currentCost;
            
            if (change > 0 && gameState.pointsRemaining < pointDifference) return;
            
            valueDisplay.textContent = newValue;
            gameState.pointsRemaining -= pointDifference;
            updatePointsDisplay();
            updateStatButtons();
            AudioManager.playButtonClick(); // Added sound for stat adjustment
        }

        // Update points display
        function updatePointsDisplay() {
            pointsRemainingDiv.textContent = `POINTS REMAINING: ${gameState.pointsRemaining}`;
            pointsRemainingDiv.style.color = gameState.pointsRemaining >= 0 ? '#0f0' : '#f00';
            startGameBtn.disabled = gameState.pointsRemaining !== 0;
        }

        // Update stat button states
        function updateStatButtons() {
            const stats = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
            
            stats.forEach(stat => {
                const valueDisplay = document.getElementById(`stat-${stat.toLowerCase()}-value`);
                const currentValue = parseInt(valueDisplay.textContent);
                const minusBtn = valueDisplay.previousElementSibling;
                const plusBtn = valueDisplay.nextElementSibling;
                
                minusBtn.disabled = currentValue <= 8;
                plusBtn.disabled = currentValue >= 15 || gameState.pointsRemaining < 1;
            });
        }

        // Update race bonuses display
        function updateRaceBonuses() {
            const race = charRaceSelect.value;
            let bonusText = '';
            
            switch(race) {
                case 'Human': bonusText = '+1 TO ALL STATS'; break;
                case 'Elf': bonusText = '+2 DEX, +1 INT'; break;
                case 'Dwarf': bonusText = '+2 CON, +1 STR'; break;
                case 'Halfling': bonusText = '+2 DEX, +1 CHA'; break;
                case 'Half-Orc': bonusText = '+2 STR, +1 CON'; break;
                case 'Dragonborn': bonusText = '+2 STR, +1 CHA'; break;
            }
            
            addToLog(`RACE SELECTED: ${race.toUpperCase()} (${bonusText})`, false, false, false, true);
        }

        // Update class info
        function updateClassInfo() {
            const selectedClass = charClassSelect.value;
            classDescription.textContent = classDescriptions[selectedClass] || 'CLASS INFORMATION NOT AVAILABLE';
            
            // Update stat recommendations based on class
            const statRecommendations = {
                'Fighter': 'STR, CON',
                'Wizard': 'INT, DEX',
                'Rogue': 'DEX, INT',
                'Cleric': 'WIS, STR',
                'Ranger': 'DEX, WIS',
                'Paladin': 'STR, CHA',
                'Barbarian': 'STR, CON',
                'Bard': 'CHA, DEX'
            };
            
            addToLog(`CLASS SELECTED: ${selectedClass.toUpperCase()} - FOCUS ON ${statRecommendations[selectedClass]}`, false, false, false, true);
        }

        // Update background info
        function updateBackgroundInfo() {
            const background = charBackgroundSelect.value;
            addToLog(`BACKGROUND SELECTED: ${background.toUpperCase()}`, false, false, false, true);
        }

        // Start the game
        function startGame() {
            gameState.player.name = charNameInput.value.toUpperCase() || 'VALEROS';
            gameState.player.race = charRaceSelect.value.split(' ')[0];
            gameState.player.class = charClassSelect.value;
            gameState.player.background = charBackgroundSelect.value.split(' ')[0];
            
            // Get allocated stats
            const stats = ['STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'];
            stats.forEach(stat => {
                const value = parseInt(document.getElementById(`stat-${stat.toLowerCase()}-value`).textContent);
                gameState.player[stat.toLowerCase()] = value;
            });
            
            // Apply bonuses and setup
            applyRaceBonuses();
            applyBackgroundBonuses();
            calculateDerivedStats();
            setupClassSkills();
            updateStatsDisplay();
            updateQuestLog();
            updateEquipmentDisplay();
            updatePlayerEffects();
            
            // Switch to game screen
            characterCreation.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameState.screen = 'game';
            
            addToLog(`WELCOME, ${gameState.player.name}!`);
            addToLog(`YOU ARE A ${gameState.player.race} ${gameState.player.class}.`);
            addToLog(`BACKGROUND: ${gameState.player.background.toUpperCase()}`);
            addToLog('YOUR QUEST BEGINS...');
            addToLog(locations[gameState.location].description);
            
            updateActionButtons();
        }

        // Apply race bonuses
        function applyRaceBonuses() {
            const race = gameState.player.race;
            switch(race) {
                case 'Human':
                    gameState.player.str += 1;
                    gameState.player.dex += 1;
                    gameState.player.con += 1;
                    gameState.player.int += 1;
                    gameState.player.wis += 1;
                    gameState.player.cha += 1;
                    break;
                case 'Elf':
                    gameState.player.dex += 2;
                    gameState.player.int += 1;
                    break;
                case 'Dwarf':
                    gameState.player.con += 2;
                    gameState.player.str += 1;
                    break;
                case 'Halfling':
                    gameState.player.dex += 2;
                    gameState.player.cha += 1;
                    break;
                case 'Half-Orc':
                    gameState.player.str += 2;
                    gameState.player.con += 1;
                    break;
                case 'Dragonborn':
                    gameState.player.str += 2;
                    gameState.player.cha += 1;
                    break;
            }
        }

        // Apply background bonuses
        function applyBackgroundBonuses() {
            const background = gameState.player.background;
            switch(background) {
                case 'Soldier':
                    gameState.player.str += 1;
                    gameState.player.skills.push('Intimidation');
                    gameState.player.inventory.push('Health Potion');
                    break;
                case 'Acolyte':
                    gameState.player.wis += 1;
                    gameState.player.skills.push('Religion');
                    gameState.player.inventory.push('Healing Scroll');
                    break;
                case 'Urchin':
                    gameState.player.dex += 1;
                    gameState.player.skills.push('Stealth');
                    gameState.player.gold += 50;
                    break;
                case 'Sage':
                    gameState.player.int += 1;
                    gameState.player.skills.push('Arcana');
                    gameState.player.inventory.push('Magic Wand');
                    break;
                case 'Noble':
                    gameState.player.cha += 1;
                    gameState.player.gold += 200;
                    gameState.player.skills.push('Persuasion');
                    break;
                case 'Outlander':
                    gameState.player.con += 1;
                    gameState.player.skills.push('Survival');
                    gameState.player.inventory.push('Longbow');
                    break;
            }
        }

        // Calculate derived stats
        function calculateDerivedStats() {
            const player = gameState.player;
            
            // Calculate HP based on class and CON
            let baseHP = 10;
            switch(player.class) {
                case 'Fighter': case 'Paladin': case 'Barbarian': baseHP = 90; break;
                case 'Ranger': case 'Cleric': baseHP = 80; break;
                case 'Rogue': case 'Bard': baseHP = 70; break;
                case 'Wizard': baseHP = 60; break;
            }
            
            const conMod = Math.floor((player.con - 10) / 2);
            player.maxHp = baseHP + conMod * player.level;
            player.hp = Math.min(player.hp, player.maxHp);
            
            // Calculate Mana based on class and INT/WIS/CHA
            let manaStat = 0;
            switch(player.class) {
                case 'Wizard': case 'Bard': manaStat = player.int; break;
                case 'Cleric': case 'Paladin': manaStat = player.wis; break;
                case 'Sorcerer': manaStat = player.cha; break;
                default: manaStat = 0;
            }
            
            if (manaStat > 0) {
                player.maxMana = 10 + Math.floor((manaStat - 10) / 2) * player.level;
            } else {
                player.maxMana = 0;
            }
            player.mana = Math.min(player.mana, player.maxMana);
            
            // Calculate AC based on DEX and armor
            const dexMod = Math.floor((player.dex - 10) / 2);
            player.baseAc = 10 + dexMod;
            player.ac = player.baseAc;
            
            // Add armor if equipped
            if (player.equipped.armor) {
                const armor = items[player.equipped.armor];
                if (armor) {
                    player.ac = armor.ac + (player.class === 'Barbarian' || player.class === 'Monk' ? dexMod : Math.min(dexMod, 2));
                }
            }
            
            // Add shield if equipped
            if (player.equipped.shield) {
                const shield = items[player.equipped.shield];
                if (shield) player.ac += shield.ac;
            }
            
            // Calculate damage bonus based on class primary stat
            let primaryStat = 'str';
            switch(player.class) {
                case 'Wizard': primaryStat = 'int'; break;
                case 'Rogue': case 'Ranger': primaryStat = 'dex'; break;
                case 'Cleric': case 'Paladin': case 'Druid': primaryStat = 'wis'; break;
                case 'Bard': case 'Sorcerer': case 'Warlock': primaryStat = 'cha'; break;
            }
            player.damageBonus = Math.floor((player[primaryStat] - 10) / 2);
            
            // Set spells for spellcasting classes
            if (player.class === 'Wizard') {
                player.spells = ['Magic Missile', 'Shield', 'Fireball'];
            } else if (player.class === 'Cleric') {
                player.spells = ['Cure Wounds', 'Divine Smite', 'Turn Undead'];
            } else if (player.class === 'Bard') {
                player.spells = ['Bardic Inspiration'];
            }
            
            // Update stat modifiers display
            updateStatModifiers();
        }

        // Update stat modifiers display
        function updateStatModifiers() {
            const player = gameState.player;
            const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
            
            stats.forEach(stat => {
                const mod = Math.floor((player[stat] - 10) / 2);
                const modElement = document.getElementById(`stat-${stat}-mod`);
                if (modElement) {
                    modElement.textContent = Math.abs(mod);
                    // Update the sign display
                    const displayElement = document.getElementById(`stat-${stat}-display`);
                    const sign = mod >= 0 ? '+' : '-';
                    if (displayElement.nextElementSibling && displayElement.nextElementSibling.classList.contains('mod-sign')) {
                        displayElement.nextElementSibling.textContent = sign;
                    }
                }
            });
            
            // Update damage bonus display
            document.getElementById('stat-damage').textContent = player.damageBonus >= 0 ? `+${player.damageBonus}` : player.damageBonus;
        }

        // Set up class skills
        function setupClassSkills() {
            const player = gameState.player;
            player.abilities = [];
            
            // Add class-specific abilities
            switch(player.class) {
                case 'Fighter':
                    player.abilities.push('Power Attack', 'Second Wind', 'Parry');
                    break;
                case 'Wizard':
                    player.abilities.push('Magic Missile', 'Shield', 'Fireball');
                    break;
                case 'Rogue':
                    player.abilities.push('Sneak Attack', 'Evasion', 'Backstab');
                    break;
                case 'Cleric':
                    player.abilities.push('Cure Wounds', 'Divine Smite', 'Turn Undead');
                    break;
                case 'Ranger':
                    player.abilities.push('Hunter\'s Mark');
                    break;
                case 'Paladin':
                    player.abilities.push('Divine Smite', 'Lay on Hands');
                    break;
                case 'Barbarian':
                    player.abilities.push('Rage');
                    break;
                case 'Bard':
                    player.abilities.push('Bardic Inspiration');
                    break;
            }
            
            // Update skill buttons
            updateSkillButtons();
        }

        // Update skill buttons
        function updateSkillButtons() {
            skillButtons.innerHTML = '';
            
            // Add class abilities
            gameState.player.abilities.forEach(ability => {
                const skill = skills[ability];
                if (skill) {
                    const skillBtn = document.createElement('button');
                    skillBtn.className = 'skill-button tooltip';
                    skillBtn.textContent = ability;
                    
                    // Create tooltip
                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip-text';
                    tooltip.textContent = `${skill.effect}${skill.cost > 0 ? ` (${skill.cost} MP)` : ''}${skill.cooldown > 0 ? ` [CD: ${skill.cooldown}]` : ''}`;
                    skillBtn.appendChild(tooltip);
                    
                    // Check cooldown
                    const cooldown = gameState.player.abilityCooldowns[ability] || 0;
                    if (cooldown > 0) {
                        skillBtn.disabled = true;
                        skillBtn.textContent = `${ability} (${cooldown})`;
                    } else if (skill.cost > 0 && gameState.player.mana < skill.cost) {
                        skillBtn.disabled = true;
                    }
                    
                    skillBtn.addEventListener('click', () => useAbility(ability));
                    skillButtons.appendChild(skillBtn);
                }
            });
            
            // Add spells if any
            gameState.player.spells.forEach(spell => {
                const skill = skills[spell];
                if (skill) {
                    const skillBtn = document.createElement('button');
                    skillBtn.className = 'skill-button special-ability tooltip';
                    skillBtn.textContent = spell;
                    
                    // Create tooltip
                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip-text';
                    tooltip.textContent = `${skill.effect} (${skill.cost} MP)${skill.cooldown > 0 ? ` [CD: ${skill.cooldown}]` : ''}`;
                    skillBtn.appendChild(tooltip);
                    
                    // Check mana and cooldown
                    const cooldown = gameState.player.abilityCooldowns[spell] || 0;
                    if (cooldown > 0) {
                        skillBtn.disabled = true;
                        skillBtn.textContent = `${spell} (${cooldown})`;
                    } else if (gameState.player.mana < skill.cost) {
                        skillBtn.disabled = true;
                    }
                    
                    skillBtn.addEventListener('click', () => castSpell(spell));
                    skillButtons.appendChild(skillBtn);
                }
            });
        }

        // Use ability
        function useAbility(ability) {
            AudioManager.playButtonClick(); // Added sound for ability use
            if (!gameState.gameActive || !gameState.inCombat) {
                addToLog('YOU CAN ONLY USE ABILITIES IN COMBAT!');
                return;
            }
            
            const skill = skills[ability];
            if (!skill) return;
            
            // Check cooldown
            const cooldown = gameState.player.abilityCooldowns[ability] || 0;
            if (cooldown > 0) {
                addToLog(`${ability} IS ON COOLDOWN FOR ${cooldown} MORE TURNS!`, true);
                return;
            }
            
            // Check mana cost
            if (skill.cost > 0 && gameState.player.mana < skill.cost) {
                addToLog('NOT ENOUGH MANA!', true);
                return;
            }
            
            // Deduct mana
            if (skill.cost > 0) {
                gameState.player.mana -= skill.cost;
                updateStatsDisplay();
            }
            
            // Set cooldown
            if (skill.cooldown > 0) {
                gameState.player.abilityCooldowns[ability] = skill.cooldown;
            }
            
            addToLog(`YOU USE ${ability.toUpperCase()}!`, true);
            
            // Handle different abilities
            switch(ability) {
                case 'Power Attack':
                    performPowerAttack();
                    break;
                case 'Second Wind':
                    useSecondWind();
                    break;
                case 'Parry':
                    useParry();
                    break;
                case 'Rage':
                    useRage();
                    break;
                case 'Hunter\'s Mark':
                    useHuntersMark();
                    break;
                case 'Lay on Hands':
                    useLayOnHands();
                    break;
                case 'Bardic Inspiration':
                    useBardicInspiration();
                    break;
                case 'Sneak Attack':
                    performSneakAttack();
                    break;
                case 'Evasion':
                    useEvasion();
                    break;
                case 'Backstab':
                    performBackstab();
                    break;
                default:
                    addToLog('ABILITY NOT YET IMPLEMENTED!');
            }
            
            updateSkillButtons();
        }

        // Cast spell
        function castSpell(spell) {
            AudioManager.playButtonClick(); // Added sound for spell cast
            if (!gameState.gameActive || !gameState.inCombat) {
                addToLog('YOU CAN ONLY CAST SPELLS IN COMBAT!');
                return;
            }
            
            const skill = skills[spell];
            if (!skill) return;
            
            // Check cooldown
            const cooldown = gameState.player.abilityCooldowns[spell] || 0;
            if (cooldown > 0) {
                addToLog(`${spell} IS ON COOLDOWN FOR ${cooldown} MORE TURNS!`, true);
                return;
            }
            
            // Check mana
            if (gameState.player.mana < skill.cost) {
                addToLog('NOT ENOUGH MANA!', true);
                return;
            }
            
            // Deduct mana
            gameState.player.mana -= skill.cost;
            
            // Set cooldown
            if (skill.cooldown > 0) {
                gameState.player.abilityCooldowns[spell] = skill.cooldown;
            }
            
            addToLog(`YOU CAST ${spell.toUpperCase()}!`, true);
            
            // Handle spells
            switch(spell) {
                case 'Magic Missile':
                    castMagicMissile();
                    break;
                case 'Fireball':
                    castFireball();
                    break;
                case 'Shield':
                    castShield();
                    break;
                case 'Cure Wounds':
                    castCureWounds();
                    break;
                case 'Divine Smite':
                    castDivineSmite();
                    break;
                case 'Turn Undead':
                    castTurnUndead();
                    break;
                default:
                    addToLog('SPELL NOT YET IMPLEMENTED!');
            }
            
            updateStatsDisplay();
            updateSkillButtons();
        }

        // Update stats display
        function updateStatsDisplay() {
            const player = gameState.player;
            
            statName.textContent = player.name;
            statRaceClass.textContent = `${player.race} ${player.class}`;
            statLevel.textContent = player.level;
            statHp.textContent = `${player.hp}/${player.maxHp}`;
            statMana.textContent = `${player.mana}/${player.maxMana}`;
            statXp.textContent = `${player.xp}/${player.nextLevelXp}`;
            statAc.textContent = player.ac;
            statGold.textContent = player.gold;
            statDungeonLevel.textContent = player.dungeonLevel;
            
            // Update bars
            const healthPercent = (player.hp / player.maxHp) * 100;
            healthFill.style.width = `${healthPercent}%`;
            
            const manaPercent = player.maxMana > 0 ? (player.mana / player.maxMana) * 100 : 0;
            manaFill.style.width = `${manaPercent}%`;
            
            const xpPercent = (player.xp / player.nextLevelXp) * 100;
            xpFill.style.width = `${xpPercent}%`;
            
            // Update stat displays
            statStrDisplay.textContent = player.str;
            statDexDisplay.textContent = player.dex;
            statConDisplay.textContent = player.con;
            statIntDisplay.textContent = player.int;
            statWisDisplay.textContent = player.wis;
            statChaDisplay.textContent = player.cha;
            
            // Update inventory display
            updateInventoryDisplay();
            updatePlayerEffects();
        }

        // Update equipment display
        function updateEquipmentDisplay() {
            document.getElementById('equipped-weapon').textContent = 
                gameState.player.equipped.weapon || 'NONE';
            document.getElementById('equipped-armor').textContent = 
                gameState.player.equipped.armor || 'NONE';
            document.getElementById('equipped-shield').textContent = 
                gameState.player.equipped.shield || 'NONE';
            
            // Update slot styles
            const slots = ['weapon', 'armor', 'shield'];
            slots.forEach(slot => {
                const slotElement = document.getElementById(`slot-${slot}`);
                if (gameState.player.equipped[slot]) {
                    slotElement.classList.add('equipment-slot-filled');
                } else {
                    slotElement.classList.remove('equipment-slot-filled');
                }
            });
        }

        // Update inventory display
        function updateInventoryDisplay() {
            inventoryItems.innerHTML = '';
            
            // Group items by type
            const itemGroups = {};
            gameState.player.inventory.forEach(item => {
                const itemData = items[item];
                if (itemData) {
                    const type = itemData.type;
                    if (!itemGroups[type]) itemGroups[type] = [];
                    itemGroups[type].push(item);
                } else {
                    if (!itemGroups['other']) itemGroups['other'] = [];
                    itemGroups['other'].push(item);
                }
            });
            
            // Display items
            for (const type in itemGroups) {
                const typeHeader = document.createElement('div');
                typeHeader.className = 'stat-name';
                typeHeader.textContent = `${type.toUpperCase()}:`;
                typeHeader.style.fontSize = '8px';
                inventoryItems.appendChild(typeHeader);
                
                itemGroups[type].forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item tooltip';
                    itemDiv.textContent = item;
                    
                    const itemData = items[item];
                    if (itemData) {
                        const tooltip = document.createElement('span');
                        tooltip.className = 'tooltip-text';
                        tooltip.textContent = itemData.description;
                        itemDiv.appendChild(tooltip);
                    }
                    
                    itemDiv.addEventListener('click', () => useItem(item));
                    inventoryItems.appendChild(itemDiv);
                });
            }
        }

        // Update player status effects
        function updatePlayerEffects() {
            playerEffects.innerHTML = '';
            
            gameState.player.statusEffects.forEach(effect => {
                const effectDiv = document.createElement('div');
                effectDiv.className = 'status-effect';
                effectDiv.textContent = effect.type.toUpperCase();
                if (effect.duration) {
                    effectDiv.textContent += ` (${effect.duration})`;
                }
                playerEffects.appendChild(effectDiv);
            });
        }

        // Use item
        function useItem(item) {
            AudioManager.playButtonClick(); // Added sound for item use
            if (!gameState.gameActive) return;
            
            const itemData = items[item];
            if (!itemData) {
                addToLog(`${item} CANNOT BE USED.`);
                return;
            }
            
            switch(itemData.type) {
                case 'consumable':
                    useConsumable(item, itemData);
                    break;
                case 'weapon':
                case 'armor':
                case 'shield':
                    equipItem(item, itemData);
                    break;
                default:
                    addToLog(`CAN'T USE ${item} RIGHT NOW.`);
            }
        }

        // Use consumable item
        function useConsumable(item, itemData) {
            if (gameState.inCombat && itemData.effect !== 'heal' && itemData.effect !== 'mana' && itemData.effect !== 'cure') {
                addToLog(`YOU USE ${item} IN COMBAT!`, true);
            }
            
            switch(itemData.effect) {
                case 'heal':
                    const healRoll = itemData.value.split('d');
                    const dice = parseInt(healRoll[0]);
                    const sides = parseInt(healRoll[1].split('+')[0]);
                    const bonus = parseInt(healRoll[1].split('+')[1]) || 0;
                    
                    let healAmount = bonus;
                    for (let i = 0; i < dice; i++) {
                        healAmount += rollDice(sides);
                    }
                    
                    gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                    addToLog(`YOU USE ${item} AND HEAL ${healAmount} HP!`, false, false, true);
                    break;
                    
                case 'mana':
                    const manaRoll = itemData.value.split('d');
                    const manaDice = parseInt(manaRoll[0]);
                    const manaSides = parseInt(manaRoll[1].split('+')[0]);
                    const manaBonus = parseInt(manaRoll[1].split('+')[1]) || 0;
                    
                    let manaAmount = manaBonus;
                    for (let i = 0; i < manaDice; i++) {
                        manaAmount += rollDice(manaSides);
                    }
                    
                    gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + manaAmount);
                    addToLog(`YOU USE ${item} AND RESTORE ${manaAmount} MANA!`, false, false, true);
                    break;
                    
                case 'damage':
                    if (gameState.inCombat && gameState.enemy) {
                        const damageRoll = itemData.value.split('d');
                        const damageDice = parseInt(damageRoll[0]);
                        const damageSides = parseInt(damageRoll[1]);
                        
                        let damage = 0;
                        for (let i = 0; i < damageDice; i++) {
                            damage += rollDice(damageSides);
                        }
                        
                        // Check for fire weakness
                        if (item === 'Fire Bomb') {
                            const enemy = enemies[gameState.enemy];
                            if (enemy.weaknesses && enemy.weaknesses.includes('fire')) {
                                damage = Math.floor(damage * 1.5);
                                addToLog(`${enemy.name} IS WEAK TO FIRE!`, true);
                            }
                        }
                        
                        enemies[gameState.enemy].hp -= damage;
                        addToLog(`YOU THROW ${item} FOR ${damage} DAMAGE!`, true);
                        
                        if (enemies[gameState.enemy].hp <= 0) {
                            defeatEnemy();
                            return;
                        }
                    } else {
                        addToLog(`CAN ONLY USE ${item} IN COMBAT!`);
                        return;
                    }
                    break;
                    
                case 'buff':
                    addToLog(`YOU DRINK ${item}! +2 ${itemData.value.toUpperCase()} FOR 5 TURNS!`, false, false, true);
                    gameState.player.statusEffects.push({
                        type: itemData.value + '_buff',
                        value: 2,
                        duration: 5
                    });
                    updatePlayerEffects();
                    break;
                    
                case 'cure':
                    // Remove poison
                    gameState.player.statusEffects = gameState.player.statusEffects.filter(
                        effect => !effect.type.includes('poison')
                    );
                    addToLog(`YOU USE ${item} AND ARE CURED OF POISON!`, false, false, true);
                    updatePlayerEffects();
                    break;
                    
                case 'invisibility':
                    addToLog(`YOU DRINK ${item} AND BECOME INVISIBLE FOR ${itemData.value} TURNS!`, false, false, true);
                    gameState.player.statusEffects.push({
                        type: 'invisible',
                        duration: itemData.value
                    });
                    updatePlayerEffects();
                    break;
            }
            
            // Remove from inventory
            const index = gameState.player.inventory.indexOf(item);
            if (index > -1) {
                gameState.player.inventory.splice(index, 1);
                updateInventoryDisplay();
            }
            
            updateStatsDisplay();
            
            // If in combat, enemy gets a turn (except for healing items)
            if (gameState.inCombat && itemData.effect !== 'heal' && itemData.effect !== 'mana' && itemData.effect !== 'cure') {
                setTimeout(enemyAttack, 1000);
            }
        }

        // Equip item
        function equipItem(item, itemData) {
            const slot = itemData.slot;
            const oldItem = gameState.player.equipped[slot];
            
            // Unequip old item if exists
            if (oldItem) {
                gameState.player.inventory.push(oldItem);
            }
            
            // Equip new item
            gameState.player.equipped[slot] = item;
            
            // Remove from inventory
            const index = gameState.player.inventory.indexOf(item);
            if (index > -1) {
                gameState.player.inventory.splice(index, 1);
            }
            
            // Recalculate stats
            calculateDerivedStats();
            updateStatsDisplay();
            updateEquipmentDisplay();
            updateInventoryDisplay();
            
            addToLog(`YOU EQUIP ${item}!`, false, true);
        }

        // Update action buttons
        function updateActionButtons() {
            actionButtons.innerHTML = '';
            const location = locations[gameState.location];
            
            if (gameState.shopOpen) {
                // Shop actions
                const shopActions = [
                    { id: 'buy', text: 'BUY ITEMS' },
                    { id: 'sell', text: 'SELL ITEMS' },
                    { id: 'talk', text: 'TALK' },
                    { id: 'leave', text: 'LEAVE SHOP' }
                ];
                
                shopActions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.id = `btn-${action.id}`;
                    btn.textContent = action.text;
                    btn.addEventListener('click', () => {
                        AudioManager.playButtonClick();
                        handleShopAction(action.id);
                    });
                    actionButtons.appendChild(btn);
                });
                
                // Show shop display
                shopDisplay.classList.remove('hidden');
                displayShopItems();
            } else if (gameState.inCombat) {
                // Combat actions
                combatDisplay.classList.remove('hidden');
                combatAnimation.classList.remove('hidden');
                
                const combatActions = [
                    { id: 'attack', text: 'ATTACK' },
                    { id: 'defend', text: 'DEFEND' },
                    { id: 'flee', text: 'FLEE' },
                    { id: 'item', text: 'USE ITEM' }
                ];
                
                // Add spell action for casters
                if (gameState.player.spells.length > 0 || gameState.player.abilities.some(a => skills[a]?.cost > 0)) {
                    combatActions.push({ id: 'spell', text: 'CAST SPELL' });
                }
                
                combatActions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.id = `btn-${action.id}`;
                    btn.textContent = action.text;
                    btn.addEventListener('click', () => {
                        AudioManager.playButtonClick();
                        handleCombatAction(action.id);
                    });
                    actionButtons.appendChild(btn);
                });
            } else {
                // Location actions
                combatDisplay.classList.add('hidden');
                combatAnimation.classList.add('hidden');
                shopDisplay.classList.add('hidden');
                
                location.actions.forEach(action => {
                    const btn = document.createElement('button');
                    btn.id = `btn-${action}`;
                    btn.textContent = action.toUpperCase();
                    btn.addEventListener('click', () => {
                        AudioManager.playButtonClick();
                        handleAction(action);
                    });
                    actionButtons.appendChild(btn);
                });
            }
        }

        // Handle location actions
        function handleAction(action) {
            if (!gameState.gameActive) return;
            
            switch(action) {
                case 'explore':
                    explore();
                    break;
                case 'rest':
                    rest();
                    break;
                case 'inspect':
                    inspect();
                    break;
                case 'back':
                    goBack();
                    break;
                case 'search':
                    searchArea();
                    break;
                case 'north':
                case 'east':
                case 'west':
                    moveDirection(action);
                    break;
                case 'shop':
                    enterShop();
                    break;
                case 'take':
                    takeAmulet();
                    break;
                case 'camp':
                    camp();
                    break;
                case 'flee':
                    if (gameState.location === 'throne') {
                        addToLog('YOU FLEE FROM THE THRONE ROOM!', true);
                        gameState.location = 'depths';
                        addToLog(locations[gameState.location].description);
                        updateActionButtons();
                    }
                    break;
                default:
                    addToLog(`ACTION ${action.toUpperCase()} NOT IMPLEMENTED YET.`);
            }
        }

        // Explore action
        function explore() {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            addToLog('YOU VENTURE DEEPER INTO THE DUNGEON...');
            
            const location = locations[gameState.location];
            const connections = location.connections;
            
            if (connections && connections.length > 0) {
                // Move to a random connected location
                const randomIndex = Math.floor(Math.random() * connections.length);
                const newLocation = connections[randomIndex];
                gameState.location = newLocation;
                
                // Increase dungeon level for certain locations
                if (!['entrance', 'crossroads'].includes(newLocation)) {
                    gameState.player.dungeonLevel++;
                }
                
                addToLog(`YOU ENTER ${locations[newLocation].name.toUpperCase()}!`);
                addToLog(locations[newLocation].description);
                
                // Trigger random encounter based on danger level
                const encounterChance = Math.random() * 0.5 + (locations[newLocation].danger * 0.1);
                if (encounterChance > 0.6) {
                    triggerRandomEncounter();
                } else if (encounterChance > 0.4) {
                    findTreasure();
                } else {
                    addToLog('THE AREA SEEMS PEACEFUL FOR NOW.');
                }
                
                updateStatsDisplay();
                updateActionButtons();
            } else {
                addToLog('YOU CANNOT EXPLORE FURTHER FROM HERE.');
            }
        }

        // Rest action
        function rest() {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            const healAmount = Math.floor(gameState.player.maxHp * 0.3) + Math.floor((gameState.player.con - 10) / 2);
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
            
            if (gameState.player.maxMana > 0) {
                const manaAmount = Math.floor(gameState.player.maxMana * 0.5);
                gameState.player.mana = Math.min(gameState.player.maxMana, gameState.player.mana + manaAmount);
                addToLog(`YOU REST AND HEAL ${healAmount} HP AND ${manaAmount} MANA.`, false, false, true);
            } else {
                addToLog(`YOU REST AND HEAL ${healAmount} HP.`, false, false, true);
            }
            
            // Reduce cooldowns
            Object.keys(gameState.player.abilityCooldowns).forEach(ability => {
                if (gameState.player.abilityCooldowns[ability] > 0) {
                    gameState.player.abilityCooldowns[ability]--;
                }
            });
            
            // Chance of encounter while resting
            if (Math.random() < 0.3) {
                addToLog('AN ENEMY DISTURBS YOUR REST!', true);
                const enemiesList = Object.keys(enemies).filter(e => enemies[e].name !== 'Ancient Red Dragon');
                const randomEnemy = enemiesList[Math.floor(Math.random() * enemiesList.length)];
                startCombat(randomEnemy);
            }
            
            updateStatsDisplay();
            updateSkillButtons();
        }

        // Inspect action
        function inspect() {
            if (!gameState.gameActive) return;
            
            const location = locations[gameState.location];
            addToLog(`YOU INSPECT ${location.name.toUpperCase()}...`);
            addToLog(location.description);
            
            // Chance to find something
            const findChance = Math.random();
            if (findChance < 0.4) {
                if (findChance < 0.2) {
                    // Find gold
                    const goldFound = Math.floor(Math.random() * 30) + 10;
                    gameState.player.gold += goldFound;
                    gameState.player.totalGoldCollected += goldFound;
                    addToLog(`YOU FIND ${goldFound} GOLD HIDDEN IN A CRACK!`, false, true);
                    AudioManager.playReward(); // Added sound for gold
                } else if (findChance < 0.35) {
                    // Find item
                    const possibleItems = ['Minor Healing Potion', 'Poison Vial', 'Fire Bomb'];
                    const foundItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                    gameState.player.inventory.push(foundItem);
                    addToLog(`YOU FIND A ${foundItem.toUpperCase()}!`, false, true);
                    AudioManager.playReward(); // Added sound for item
                    updateInventoryDisplay();
                } else {
                    // Find clue
                    const clues = [
                        'YOU FIND ANCIENT MARKINGS SPEAKING OF A POWERFUL AMULET.',
                        'A FADED MAP SHOWS SECRET PASSAGES DEEPER IN THE DUNGEON.',
                        'BLOODSTAINS LEAD TOWARDS THE EASTERN PASSAGE.',
                        'SCRATCH MARKS SUGGEST LARGE CREATURES PASS THROUGH HERE OFTEN.',
                        'A BROKEN SHIELD BEARS THE INSIGNIA OF A FAILED EXPEDITION.'
                    ];
                    const clue = clues[Math.floor(Math.random() * clues.length)];
                    addToLog(clue);
                }
            } else {
                addToLog('YOU FIND NOTHING OF INTEREST.');
            }
            
            updateStatsDisplay();
        }

        // Camp action
        function camp() {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            // Full heal and mana restore
            const oldHp = gameState.player.hp;
            const oldMana = gameState.player.mana;
            
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.mana = gameState.player.maxMana;
            
            const hpHealed = gameState.player.hp - oldHp;
            const manaRestored = gameState.player.mana - oldMana;
            
            addToLog('YOU SET UP CAMP AND REST THOROUGHLY.');
            addToLog(`YOU HEAL ${hpHealed} HP!`, false, false, true);
            
            if (manaRestored > 0) {
                addToLog(`YOU RESTORE ${manaRestored} MANA!`, false, false, true);
            }
            
            // Reset all cooldowns
            Object.keys(gameState.player.abilityCooldowns).forEach(ability => {
                gameState.player.abilityCooldowns[ability] = 0;
            });
            
            // Clear status effects
            gameState.player.statusEffects = [];
            updatePlayerEffects();
            
            // Higher chance of encounter while camping
            if (Math.random() < 0.5) {
                addToLog('ENEMIES DISCOVER YOUR CAMP!', true);
                const enemiesList = Object.keys(enemies).filter(e => enemies[e].name !== 'Ancient Red Dragon');
                const randomEnemy = enemiesList[Math.floor(Math.random() * enemiesList.length)];
                startCombat(randomEnemy);
            }
            
            updateStatsDisplay();
            updateSkillButtons();
        }

        // Search area action
        function searchArea() {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            addToLog('YOU SEARCH THE AREA THOROUGHLY...');
            
            const searchRoll = Math.random();
            const locationDanger = locations[gameState.location].danger;
            
            if (searchRoll < 0.7 - (locationDanger * 0.05)) {
                if (searchRoll < 0.3) {
                    // Find good treasure
                    const goldFound = Math.floor(Math.random() * 100) + 50;
                    gameState.player.gold += goldFound;
                    gameState.player.totalGoldCollected += goldFound;
                    addToLog(`YOU FIND A HIDDEN CACHE WITH ${goldFound} GOLD!`, false, true);
                    AudioManager.playReward(); // Added sound for gold
                } else if (searchRoll < 0.5) {
                    // Find good item
                    const possibleItems = ['Health Potion', 'Healing Scroll', 'Fire Bomb', 'Strength Potion'];
                    const foundItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                    gameState.player.inventory.push(foundItem);
                    addToLog(`YOU FIND A ${foundItem.toUpperCase()} HIDDEN BEHIND A ROCK!`, false, true);
                    AudioManager.playReward(); // Added sound for item
                    updateInventoryDisplay();
                } else if (searchRoll < 0.6) {
                    // Find equipment
                    const possibleEquipment = ['Chain Mail', 'Shield', 'Longbow'];
                    const foundItem = possibleEquipment[Math.floor(Math.random() * possibleEquipment.length)];
                    gameState.player.inventory.push(foundItem);
                    addToLog(`YOU FIND ${foundItem.toUpperCase()} IN AN OLD CHEST!`, false, true);
                    AudioManager.playReward(); // Added sound for item
                    updateInventoryDisplay();
                } else {
                    // Find quest item or clue
                    addToLog('YOU FIND AN ANCIENT SCROLL WITH VITAL INFORMATION!');
                    addToLog('IT SPEAKS OF THE DRAGON\'S WEAKNESS TO COLD!');
                }
            } else {
                addToLog('YOUR SEARCH YIELDS NOTHING.');
            }
            
            // Chance to trigger trap based on location danger
            if (Math.random() < 0.1 + (locationDanger * 0.05)) {
                triggerTrap();
            }
            
            updateStatsDisplay();
        }

        // Move in direction
        function moveDirection(direction) {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            const directionMap = {
                north: {from: 'crossroads', to: 'corridor'},
                east: {from: 'crossroads', to: 'chamber'},
                west: {from: 'crossroads', to: 'depths'}
            };
            
            const move = directionMap[direction];
            if (move && gameState.location === move.from) {
                gameState.location = move.to;
                gameState.player.dungeonLevel++;
                
                addToLog(`YOU HEAD ${direction.toUpperCase()}...`);
                addToLog(`YOU ENTER ${locations[move.to].name.toUpperCase()}!`);
                addToLog(locations[move.to].description);
                
                // Trigger encounter based on danger level
                const encounterChance = Math.random() * 0.5 + (locations[move.to].danger * 0.1);
                if (encounterChance > 0.6) {
                    triggerRandomEncounter();
                } else {
                    addToLog('THE PATH IS CLEAR FOR NOW.');
                }
                
                updateStatsDisplay();
                updateActionButtons();
            } else {
                addToLog(`YOU CANNOT GO ${direction.toUpperCase()} FROM HERE.`);
            }
        }

        // Go back
        function goBack() {
            if (!gameState.gameActive || gameState.inCombat) return;
            
            const locationOrder = ['entrance', 'crossroads', 'corridor', 'chamber', 'depths', 'throne'];
            const currentIndex = locationOrder.indexOf(gameState.location);
            
            if (currentIndex > 0) {
                const previousLocation = locationOrder[currentIndex - 1];
                gameState.location = previousLocation;
                gameState.player.dungeonLevel = Math.max(1, gameState.player.dungeonLevel - 1);
                
                addToLog('YOU RETREAT TO THE PREVIOUS AREA...');
                addToLog(locations[previousLocation].description);
                
                updateStatsDisplay();
                updateActionButtons();
            } else {
                addToLog('YOU CANNOT GO BACK FROM HERE.');
            }
        }

        // Take amulet
        function takeAmulet() {
            if (!gameState.gameActive) return;
            
            if (gameState.location === 'throne') {
                if (gameState.enemy && enemies[gameState.enemy].hp > 0) {
                    addToLog('YOU REACH FOR THE AMULET, BUT THE DRAGON AWAKENS!', true);
                } else {
                    addToLog('WITH THE DRAGON DEFEATED, YOU CLAIM THE AMULET OF YENDOR!', false, true);
                    victory();
                }
            } else {
                addToLog('THERE IS NO AMULET TO TAKE HERE.');
            }
        }

        // Trigger random encounter
        function triggerRandomEncounter() {
            const location = locations[gameState.location];
            if (!location.encounters || location.encounters.length === 0) return;
            
            const encounterRoll = Math.random();
            let encounter;
            
            // Weight encounters based on location danger
            if (encounterRoll < 0.4) {
                encounter = location.encounters[0];
            } else if (encounterRoll < 0.7) {
                encounter = location.encounters[1] || location.encounters[0];
            } else if (encounterRoll < 0.9) {
                encounter = location.encounters[2] || location.encounters[0];
            } else {
                encounter = location.encounters[3] || 'nothing';
            }
            
            if (encounter === 'nothing') {
                addToLog('THE AREA IS CLEAR.');
            } else if (encounter === 'chest') {
                findTreasure();
            } else if (encounter === 'trap') {
                triggerTrap();
            } else if (enemies[encounter]) {
                startCombat(encounter);
            }
        }

        // Find treasure
        function findTreasure() {
            addToLog('YOU FIND A TREASURE CHEST!', false, true);
            
            const treasureRoll = Math.random();
            
            if (treasureRoll < 0.5) {
                const gold = Math.floor(Math.random() * 150) + 100;
                gameState.player.gold += gold;
                gameState.player.totalGoldCollected += gold;
                addToLog(`THE CHEST CONTAINS ${gold} GOLD PIECES!`, false, true);
                AudioManager.playReward(); // Added sound for gold
            } else if (treasureRoll < 0.8) {
                const items = ['Health Potion', 'Greater Healing Potion', 'Mana Potion', 'Healing Scroll'];
                const foundItem = items[Math.floor(Math.random() * items.length)];
                gameState.player.inventory.push(foundItem);
                addToLog(`THE CHEST CONTAINS A ${foundItem.toUpperCase()}!`, false, true);
                AudioManager.playReward(); // Added sound for item
                updateInventoryDisplay();
            } else if (treasureRoll < 0.95) {
                const equipment = ['Chain Mail', 'Steel Sword', 'Shield', 'Longbow'];
                const foundItem = equipment[Math.floor(Math.random() * equipment.length)];
                gameState.player.inventory.push(foundItem);
                addToLog(`THE CHEST CONTAINS ${foundItem.toUpperCase()}!`, false, true);
                AudioManager.playReward(); // Added sound for item
                updateInventoryDisplay();
            } else {
                addToLog('THE CHEST IS TRAPPED!', true);
                triggerTrap();
            }
            
            updateStatsDisplay();
        }

        // Trigger trap
        function triggerTrap() {
            addToLog('YOU TRIGGER A TRAP!', true);
            
            const trapTypes = [
                { name: 'POISON DART', damage: '1d6+3', effect: 'poison' },
                { name: 'PIT TRAP', damage: '2d6+5', effect: null },
                { name: 'SWINGING BLADE', damage: '1d8+4', effect: null },
                { name: 'FALLING ROCKS', damage: '2d8+6', effect: 'stun' }
            ];
            
            const trap = trapTypes[Math.floor(Math.random() * trapTypes.length)];
            const damageRoll = trap.damage.split('d');
            const dice = parseInt(damageRoll[0]);
            const sides = parseInt(damageRoll[1].split('+')[0]);
            const bonus = parseInt(trap.damage.split('+')[1]) || 0;
            
            let damage = bonus;
            for (let i = 0; i < dice; i++) {
                damage += rollDice(sides);
            }
            
            gameState.player.hp -= damage;
            addToLog(`${trap.name} HITS YOU FOR ${damage} DAMAGE!`, true);
            AudioManager.playCombatHit(); // Added sound for trap damage
            
            if (trap.effect === 'poison') {
                gameState.player.statusEffects.push({ type: 'poisoned', duration: 3, damage: 2 });
                addToLog('YOU ARE POISONED!', true);
                updatePlayerEffects();
            } else if (trap.effect === 'stun') {
                gameState.player.statusEffects.push({ type: 'stunned', duration: 1 });
                addToLog('YOU ARE STUNNED!', true);
                updatePlayerEffects();
            }
            
            if (gameState.player.hp <= 0) {
                gameOver();
            }
            
            updateStatsDisplay();
        }

        // Handle shop actions
        function handleShopAction(action) {
            switch(action) {
                case 'buy':
                    displayShopItems();
                    break;
                case 'sell':
                    displaySellItems();
                    break;
                case 'talk':
                    talkToShopkeeper();
                    break;
                case 'leave':
                    leaveShop();
                    break;
            }
        }

        // Handle combat actions
        function handleCombatAction(action) {
            switch(action) {
                case 'attack':
                    attack();
                    break;
                case 'defend':
                    defend();
                    break;
                case 'flee':
                    flee();
                    break;
                case 'item':
                    showInventoryForUse();
                    break;
                case 'spell':
                    showSpells();
                    break;
            }
        }

        // Show inventory for use in combat
        function showInventoryForUse() {
            addToLog('SELECT AN ITEM FROM YOUR INVENTORY TO USE:');
            gameState.player.inventory.forEach(item => {
                const itemData = items[item];
                if (itemData && itemData.type === 'consumable') {
                    addToLog(`- ${item}: ${itemData.description}`);
                }
            });
            addToLog('CLICK ON ITEMS IN YOUR INVENTORY PANEL TO USE THEM.');
        }

        // Show spells
        function showSpells() {
            addToLog('AVAILABLE SPELLS:');
            gameState.player.spells.forEach(spell => {
                const skill = skills[spell];
                if (skill) {
                    addToLog(`- ${spell}: ${skill.effect} (${skill.cost} MP)`);
                }
            });
            addToLog('CLICK ON SPELLS IN YOUR SKILLS PANEL TO CAST THEM.');
        }

        // Enter shop
        function enterShop() {
            gameState.shopOpen = true;
            addToLog('YOU ENTER THE MYSTERIOUS SHOP...', false, true);
            addToLog('"WELCOME, ADVENTURER! BUY SOMETHING NICE!"', false, true);
            updateActionButtons();
        }

        // Display shop items
        function displayShopItems() {
            shopDisplay.innerHTML = '<div class="stat-name">SHOP INVENTORY:</div>';
            
            // Display items by category
            for (const category in shopInventory) {
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'stat-name';
                categoryHeader.textContent = `${category.toUpperCase()}:`;
                categoryHeader.style.fontSize = '10px';
                shopDisplay.appendChild(categoryHeader);
                
                shopInventory[category].forEach(itemName => {
                    const item = items[itemName];
                    if (!item) return;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item';
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'shop-item-name';
                    nameSpan.textContent = itemName;
                    
                    const priceSpan = document.createElement('span');
                    priceSpan.className = 'shop-item-price';
                    priceSpan.textContent = `${item.cost} GOLD`;
                    
                    const buyBtn = document.createElement('button');
                    buyBtn.className = 'shop-buy';
                    buyBtn.textContent = 'BUY';
                    buyBtn.disabled = gameState.player.gold < item.cost;
                    buyBtn.addEventListener('click', () => buyItem(itemName, item));
                    itemDiv.appendChild(nameSpan);
                    itemDiv.appendChild(priceSpan);
                    itemDiv.appendChild(buyBtn);
                    shopDisplay.appendChild(itemDiv);
                });
            }
        }

        // Display items for sale
        function displaySellItems() {
            shopDisplay.innerHTML = '<div class="stat-name">YOUR ITEMS FOR SALE:</div>';
            
            if (gameState.player.inventory.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.textContent = 'NO ITEMS TO SELL';
                shopDisplay.appendChild(emptyDiv);
                return;
            }
            
            gameState.player.inventory.forEach(itemName => {
                const item = items[itemName];
                if (!item) return;
                
                const sellValue = Math.floor(item.cost * 0.5);
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'shop-item-name';
                nameSpan.textContent = itemName;
                
                const priceSpan = document.createElement('span');
                priceSpan.className = 'shop-item-price';
                priceSpan.textContent = `${sellValue} GOLD`;
                
                const sellBtn = document.createElement('button');
                sellBtn.className = 'shop-buy';
                sellBtn.textContent = 'SELL';
                sellBtn.style.backgroundColor = '#300';
                sellBtn.style.color = '#f00';
                sellBtn.style.borderColor = '#f00';
                sellBtn.addEventListener('click', () => sellItem(itemName, sellValue));
                
                itemDiv.appendChild(nameSpan);
                itemDiv.appendChild(priceSpan);
                itemDiv.appendChild(sellBtn);
                shopDisplay.appendChild(itemDiv);
            });
        }

        // Buy item
        function buyItem(itemName, item) {
            if (gameState.player.gold < item.cost) {
                addToLog('NOT ENOUGH GOLD!', false, true);
                return;
            }
            
            gameState.player.gold -= item.cost;
            gameState.player.inventory.push(itemName);
            
            addToLog(`YOU BUY ${itemName} FOR ${item.cost} GOLD!`, false, true);
            addToLog(`GOLD REMAINING: ${gameState.player.gold}`, false, true);
            AudioManager.playReward(); // Added sound for purchase
            
            updateStatsDisplay();
            displayShopItems();
            updateInventoryDisplay();
        }

        // Sell item
        function sellItem(itemName, sellValue) {
            // Don't sell equipped items
            const equipped = Object.values(gameState.player.equipped);
            if (equipped.includes(itemName)) {
                addToLog('CANNOT SELL EQUIPPED ITEM!', false, true);
                return;
            }
            
            const index = gameState.player.inventory.indexOf(itemName);
            if (index > -1) {
                gameState.player.inventory.splice(index, 1);
                gameState.player.gold += sellValue;
                
                addToLog(`YOU SELL ${itemName} FOR ${sellValue} GOLD!`, false, true);
                addToLog(`GOLD: ${gameState.player.gold}`, false, true);
                AudioManager.playReward(); // Added sound for sale
                
                updateStatsDisplay();
                displaySellItems();
                updateInventoryDisplay();
            }
        }

        // Talk to shopkeeper
        function talkToShopkeeper() {
            const dialogues = [
                '"POTIONS, SCROLLS, WEAPONS... ALL FOR A REASONABLE PRICE!"',
                '"THE DEEPER YOU GO, THE BETTER THE LOOT... AND THE DEADLIER THE TRAPS!"',
                '"I HEARD THE DRAGON HAS AWOKEN. YOU\'LL NEED STRONGER GEAR."',
                '"MANY HAVE SOUGHT THE AMULET. BRING ME THEIR TREASURE AND I\'LL PAY WELL."',
                '"DON\'T FORGET TO CHECK YOUR EQUIPMENT. A GOOD SHIELD CAN SAVE YOUR LIFE!"'
            ];
            
            const dialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
            addToLog('SHOPKEEPER: ' + dialogue, false, true);
        }

        // Leave shop
        function leaveShop() {
            gameState.shopOpen = false;
            addToLog('YOU LEAVE THE SHOP.', false, true);
            updateActionButtons();
        }

        // Attack action
        function attack() {
            if (!gameState.inCombat || !gameState.enemy) return;
            
            const player = gameState.player;
            const enemy = enemies[gameState.enemy];
            
            // Calculate attack roll
            const attackRoll = rollDice(20);
            let attackBonus = Math.floor((player.str - 10) / 2);
            
            // Check for buffs
            const strBuff = player.statusEffects.find(effect => effect.type === 'str_buff');
            if (strBuff) attackBonus += strBuff.value;
            
            const totalAttack = attackRoll + attackBonus;
            
            // Check for critical hit
            const isCritical = attackRoll === 20;
            
            addToLog(`YOU ATTACK THE ${enemy.name}...`, true);
            addToLog(`ATTACK ROLL: ${attackRoll} + ${attackBonus} = ${totalAttack} vs AC ${enemy.ac}`, true);
            
            if (totalAttack >= enemy.ac || isCritical) {
                // Calculate damage
                let damage = player.damageBonus;
                
                if (player.equipped.weapon) {
                    const weapon = items[player.equipped.weapon];
                    if (weapon) {
                        const weaponRoll = weapon.damage.split('d');
                        const dice = parseInt(weaponRoll[0]);
                        const sides = parseInt(weaponRoll[1]);
                        
                        for (let i = 0; i < dice; i++) {
                            damage += rollDice(sides);
                        }
                    }
                } else {
                    damage += rollDice(4); // Unarmed
                }
                
                // Critical hit
                if (isCritical) {
                    damage *= 2;
                    addToLog('CRITICAL HIT!', true);
                    document.getElementById('player-icon').classList.add('critical-hit');
                    setTimeout(() => document.getElementById('player-icon').classList.remove('critical-hit'), 300);
                }
                
                // Apply enemy resistances
                if (enemy.resistances && enemy.resistances.length > 0) {
                    // Check if resistant to physical damage
                    if (enemy.resistances.includes('slashing') || enemy.resistances.includes('bludgeoning') || enemy.resistances.includes('piercing')) {
                        damage = Math.floor(damage / 2);
                        addToLog(`${enemy.name} RESISTS SOME DAMAGE!`, true);
                    }
                }
                
                enemy.hp -= damage;
                addToLog(`YOU HIT FOR ${damage} DAMAGE!`, true);
                AudioManager.playCombatHit(); // Added sound for hit
                
                // Create damage popup
                createDamagePopup(damage, isCritical);
                
                // Check if enemy is defeated
                if (enemy.hp <= 0) {
                    defeatEnemy();
                    return;
                }
            } else {
                addToLog('YOUR ATTACK MISSES!', true);
            }
            
            updateEnemyDisplay();
            
            // Reduce cooldowns
            Object.keys(gameState.player.abilityCooldowns).forEach(ability => {
                if (gameState.player.abilityCooldowns[ability] > 0) {
                    gameState.player.abilityCooldowns[ability]--;
                }
            });
            
            // Update status effects duration
            updateStatusEffects();
            
            updateSkillButtons();
            enemyAttack();
        }

        // Defend action
        function defend() {
            if (!gameState.inCombat || !gameState.enemy) return;
            
            addToLog('YOU TAKE A DEFENSIVE STANCE.', true);
            
            // Player gets temporary AC boost
            gameState.player.ac += 2;
            gameState.player.statusEffects.push({ type: 'defending', duration: 1 });
            updatePlayerEffects();
            
            updateStatsDisplay();
            
            // Reduce cooldowns
            Object.keys(gameState.player.abilityCooldowns).forEach(ability => {
                if (gameState.player.abilityCooldowns[ability] > 0) {
                    gameState.player.abilityCooldowns[ability]--;
                }
            });
            
            // Update status effects duration
            updateStatusEffects();
            
            updateSkillButtons();
            enemyAttack();
        }

        // Flee action
        function flee() {
            if (!gameState.inCombat) return;
            
            const fleeChance = Math.floor((gameState.player.dex - 10) / 2) + 5;
            const fleeRoll = rollDice(20);
            
            addToLog('YOU ATTEMPT TO FLEE!', true);
            addToLog(`FLEE ROLL: ${fleeRoll} vs ${fleeChance}`, true);
            
            if (fleeRoll >= fleeChance) {
                addToLog('YOU SUCCESSFULLY FLEE FROM COMBAT!', true);
                endCombat();
            } else {
                addToLog('YOU FAIL TO ESCAPE!', true);
                
                // Reduce cooldowns
                Object.keys(gameState.player.abilityCooldowns).forEach(ability => {
                    if (gameState.player.abilityCooldowns[ability] > 0) {
                        gameState.player.abilityCooldowns[ability]--;
                    }
                });
                
                enemyAttack();
            }
        }

        // Create damage popup
        function createDamagePopup(damage, isCritical = false) {
            const popup = document.createElement('div');
            popup.className = 'damage-popup';
            popup.textContent = damage;
            popup.style.color = isCritical ? '#ff0' : '#f00';
            popup.style.fontSize = isCritical ? '20px' : '16px';
            popup.style.left = Math.random() * 200 + 100 + 'px';
            popup.style.top = '200px';
            
            document.querySelector('.main-display').appendChild(popup);
            
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 1000);
        }

        // Enemy attack
        function enemyAttack() {
            const player = gameState.player;
            const enemy = enemies[gameState.enemy];
            
            addToLog(`${enemy.name} ATTACKS!`, true);
            
            const attackRoll = rollDice(20);
            const totalAttack = attackRoll;
            
            addToLog(`${enemy.name} ATTACK ROLL: ${attackRoll} vs AC ${player.ac}`, true);
            
            // Check for player defensive effects
            let effectiveAC = player.ac;
            const defending = player.statusEffects.find(effect => effect.type === 'defending');
            if (defending) effectiveAC += 2;
            
            const shield = player.statusEffects.find(effect => effect.type === 'shield');
            if (shield) effectiveAC += 5;
            
            // Check for invisibility
            const invisible = player.statusEffects.find(effect => effect.type === 'invisible');
            if (invisible && Math.random() < 0.5) {
                addToLog(`${enemy.name} CAN'T FIND YOU!`, true);
                return;
            }
            
            if (totalAttack >= effectiveAC || attackRoll === 20) {
                // Calculate damage
                let damage = 0;
                if (enemy.damage.includes('d')) {
                    const parts = enemy.damage.split('d');
                    const dice = parseInt(parts[0]);
                    const sides = parseInt(parts[1].split('+')[0]);
                    const bonus = parseInt(parts[1].split('+')[1]) || 0;
                    
                    for (let i = 0; i < dice; i++) {
                        damage += rollDice(sides);
                    }
                    damage += bonus;
                }
                
                // Critical hit
                const isCritical = attackRoll === 20;
                if (isCritical) {
                    damage *= 2;
                    addToLog('CRITICAL HIT!', true);
                    document.getElementById('enemy-icon').classList.add('critical-hit');
                    setTimeout(() => document.getElementById('enemy-icon').classList.remove('critical-hit'), 300);
                }
                
                // Check for player resistances/abilities
                const rage = player.statusEffects.find(effect => effect.type === 'rage');
                if (rage) {
                    damage = Math.floor(damage / 2);
                    addToLog('YOUR RAGE REDUCES THE DAMAGE!', true);
                }
                
                const evasion = player.statusEffects.find(effect => effect.type === 'evasion');
                if (evasion && isCritical) {
                    damage = Math.floor(damage / 2);
                    addToLog('YOUR EVASION HALVES THE CRITICAL DAMAGE!', true);
                }
                
                player.hp -= damage;
                addToLog(`${enemy.name} HITS YOU FOR ${damage} DAMAGE!`, true);
                AudioManager.playCombatHit(); // Added sound for enemy hit
                
                // Create damage popup on player
                createDamagePopup(damage, isCritical);
                
                // Check if player is defeated
                if (player.hp <= 0) {
                    gameOver();
                    return;
                }
                
                updateStatsDisplay();
            } else {
                addToLog(`${enemy.name} MISSES!`, true);
            }
            
            // Update enemy status effects duration
            updateEnemyStatusEffects();
        }

        // Update enemy display
        function updateEnemyDisplay() {
            if (!gameState.enemy) return;
            
            const enemy = enemies[gameState.enemy];
            enemyName.textContent = enemy.name;
            enemyHp.textContent = `HP: ${enemy.hp}/${enemy.maxHp}`;
            enemySpecial.textContent = enemy.special;
            
            const healthPercent = (enemy.hp / enemy.maxHp) * 100;
            enemyHealthFill.style.width = `${healthPercent}%`;
            
            // Update enemy status
            if (gameState.enemyStatusEffects.length > 0) {
                enemyStatus.textContent = `STATUS: ${gameState.enemyStatusEffects.map(effect => effect.type.toUpperCase()).join(', ')}`;
                enemyEffects.innerHTML = '';
                
                gameState.enemyStatusEffects.forEach(effect => {
                    const effectDiv = document.createElement('div');
                    effectDiv.className = 'status-effect';
                    effectDiv.textContent = effect.type.toUpperCase();
                    if (effect.duration) {
                        effectDiv.textContent += ` (${effect.duration})`;
                    }
                    enemyEffects.appendChild(effectDiv);
                });
            } else {
                enemyStatus.textContent = 'STATUS: NORMAL';
                enemyEffects.innerHTML = '';
            }
        }

        // Update enemy status effects
        function updateEnemyStatusEffects() {
            gameState.enemyStatusEffects = gameState.enemyStatusEffects.filter(effect => {
                effect.duration--;
                return effect.duration > 0;
            });
            
            // Apply poison damage if poisoned
            const poisonEffect = gameState.enemyStatusEffects.find(effect => effect.type === 'poisoned');
            if (poisonEffect && poisonEffect.damage) {
                const enemy = enemies[gameState.enemy];
                enemy.hp -= poisonEffect.damage;
                addToLog(`${enemy.name} TAKES ${poisonEffect.damage} POISON DAMAGE!`, true);
                
                if (enemy.hp <= 0) {
                    defeatEnemy();
                    return;
                }
            }
            
            updateEnemyDisplay();
        }

        // Update player status effects
        function updateStatusEffects() {
            // Update player status effects
            gameState.player.statusEffects = gameState.player.statusEffects.filter(effect => {
                if (effect.duration) {
                    effect.duration--;
                    return effect.duration > 0;
                }
                return true;
            });
            
            // Apply poison damage if poisoned
            const poisonEffect = gameState.player.statusEffects.find(effect => effect.type === 'poisoned');
            if (poisonEffect && poisonEffect.damage) {
                gameState.player.hp -= poisonEffect.damage;
                addToLog(`YOU TAKE ${poisonEffect.damage} POISON DAMAGE!`, true);
                
                if (gameState.player.hp <= 0) {
                    gameOver();
                    return;
                }
                updateStatsDisplay();
            }
            
            // Remove temporary AC bonuses from defending
            gameState.player.statusEffects = gameState.player.statusEffects.filter(effect => {
                if (effect.type === 'defending' && effect.duration <= 0) {
                    gameState.player.ac -= 2;
                    return false;
                }
                return true;
            });
            
            updatePlayerEffects();
            updateStatsDisplay();
        }

        // Start combat
        function startCombat(enemyType) {
            gameState.inCombat = true;
            gameState.enemy = enemyType;
            gameState.enemyStatusEffects = [];
            
            const enemy = enemies[enemyType];
            addToLog(`A ${enemy.name} APPEARS! COMBAT BEGINS!`, true);
            addToLog(enemy.description);
            
            updateEnemyDisplay();
            updateActionButtons();
            
            // Check for surprise round
            const stealthBonus = Math.floor((gameState.player.dex - 10) / 2);
            const surpriseChance = rollDice(20) + stealthBonus;
            
            if (surpriseChance >= 15) {
                addToLog('YOU CAUGHT THE ENEMY BY SURPRISE! YOU GET A FREE ATTACK!', true);
            } else {
                // Enemy might get first attack
                if (rollDice(20) >= 15) {
                    addToLog('THE ENEMY ACTS FIRST!', true);
                    setTimeout(enemyAttack, 1000);
                }
            }
        }

        // End combat
        function endCombat() {
            gameState.inCombat = false;
            gameState.enemy = null;
            gameState.enemyStatusEffects = [];
            
            // Reset player status effects from combat
            gameState.player.statusEffects = gameState.player.statusEffects.filter(
                effect => !['defending', 'shield', 'rage', 'hunters_mark', 'evasion'].includes(effect.type)
            );
            
            // Reset AC
            calculateDerivedStats();
            
            updateStatsDisplay();
            updateActionButtons();
            updatePlayerEffects();
        }

        // Defeat enemy
        function defeatEnemy() {
            const enemy = enemies[gameState.enemy];
            
            addToLog(`YOU DEFEATED THE ${enemy.name}!`, true);
            gameState.player.totalEnemiesDefeated++;
            
            // Award XP
            let xpAwarded = enemy.xp * gameState.difficulty;
            gameState.player.xp += xpAwarded;
            addToLog(`YOU GAIN ${xpAwarded} EXPERIENCE POINTS!`, false, true);
            AudioManager.playReward(); // Added sound for XP
            
            // Award gold
            const goldRoll = enemy.gold.split('d');
            const goldDice = parseInt(goldRoll[0]);
            const goldSides = parseInt(goldRoll[1].split('+')[0]);
            const goldBonus = parseInt(goldRoll[1].split('+')[1]) || 0;
            
            let goldAwarded = goldBonus;
            for (let i = 0; i < goldDice; i++) {
                goldAwarded += rollDice(goldSides);
            }
            
            gameState.player.gold += goldAwarded;
            gameState.player.totalGoldCollected += goldAwarded;
            addToLog(`YOU FIND ${goldAwarded} GOLD ON THE CORPSE.`, false, true);
            AudioManager.playReward(); // Added sound for gold
            
            // Random loot drop
            if (Math.random() < 0.3) {
                const possibleLoot = ['Health Potion', 'Minor Healing Potion', 'Poison Vial'];
                const loot = possibleLoot[Math.floor(Math.random() * possibleLoot.length)];
                gameState.player.inventory.push(loot);
                addToLog(`YOU FIND A ${loot.toUpperCase()}!`, false, true);
                AudioManager.playReward(); // Added sound for item
                updateInventoryDisplay();
            }
            
            // Special loot for specific enemies
            if (enemy.name === 'Goblin') {
                gameState.player.inventory.push('Goblin Ear');
                addToLog('YOU COLLECT A GOBLIN EAR AS PROOF.', false, true);
                AudioManager.playReward(); // Added sound for item
                updateInventoryDisplay();
            }
            
            if (enemy.name === 'Ancient Red Dragon') {
                gameState.player.inventory.push('Dragon Scale');
                addToLog('YOU FIND A RARE DRAGON SCALE!', false, true);
                AudioManager.playReward(); // Added sound for item
                updateInventoryDisplay();
            }
            
            // Update quest progress
            if (enemy.name === 'Goblin') {
                gameState.player.quests.side1.progress++;
                if (gameState.player.quests.side1.progress >= gameState.player.quests.side1.required) {
                    gameState.player.quests.side1.completed = true;
                    addToLog('QUEST COMPLETED: CLEARED THE GOBLIN NEST!', false, true);
                    gameState.player.xp += gameState.player.quests.side1.reward;
                    gameState.player.gold += 100;
                } else {
                    addToLog(`GOBLINS SLAIN: ${gameState.player.quests.side1.progress}/${gameState.player.quests.side1.required}`, false, true);
                }
                updateQuestLog();
            }
            
            if (enemy.name === 'Ancient Red Dragon') {
                gameState.player.quests.side3.completed = true;
                addToLog('QUEST COMPLETED: SLAY THE DRAGON!', false, true);
                updateQuestLog();
            }
            
            // Check for level up
            checkLevelUp();
            
            // End combat
            endCombat();
        }

        // Update quest log
        function updateQuestLog() {
            const quests = gameState.player.quests;
            let questHTML = '';
            
            for (const key in quests) {
                const quest = quests[key];
                if (quest.name) {
                    let status = '';
                    if (quest.completed) {
                        status = '[COMPLETED]';
                    } else if (quest.progress !== undefined) {
                        status = `[${quest.progress}/${quest.required}]`;
                    } else {
                        status = '[ACTIVE]';
                    }
                    questHTML += `<div>${status} ${quest.name}</div>`;
                }
            }
            
            questList.innerHTML = questHTML;
        }

        // Check for level up
        function checkLevelUp() {
            const player = gameState.player;
            
            while (player.xp >= player.nextLevelXp) {
                player.level++;
                const excessXp = player.xp - player.nextLevelXp;
                player.nextLevelXp = Math.floor(player.nextLevelXp * 1.5);
                player.xp = excessXp;
                
                // Increase HP
                const hpIncrease = rollDice(6) + Math.floor((player.con - 10) / 2);
                player.maxHp += hpIncrease;
                player.hp += hpIncrease;
                
                // Increase Mana for casters
                if (player.maxMana > 0) {
                    const manaIncrease = rollDice(4) + 1;
                    player.maxMana += manaIncrease;
                    player.mana += manaIncrease;
                }
                
                // Ability score improvement every 4 levels
                if (player.level % 4 === 0) {
                    const stats = ['str', 'dex', 'con', 'int', 'wis', 'cha'];
                    const statToIncrease = stats[Math.floor(Math.random() * stats.length)];
                    player[statToIncrease]++;
                    addToLog(`YOUR ${statToIncrease.toUpperCase()} INCREASES BY 1!`, false, true);
                    calculateDerivedStats();
                }
                
                addToLog(`CONGRATULATIONS! YOU ADVANCE TO LEVEL ${player.level}!`, false, true);
                addToLog(`MAX HP INCREASED BY ${hpIncrease}!`, false, true);
                AudioManager.playLevelUp(); // Added sound for level up
                
                if (player.maxMana > 0) {
                    addToLog(`MAX MANA INCREASED!`, false, true);
                }
                
                updateStatsDisplay();
            }
        }

        // Save game
        function saveGame() {
            gameState.lastSave = new Date().toISOString();
            localStorage.setItem('atariDnDSave', JSON.stringify(gameState));
            addToLog('GAME SAVED SUCCESSFULLY!', false, true);
            showNotification('GAME SAVED!');
        }

        // Load game
        function loadGame() {
            const savedGame = localStorage.getItem('atariDnDSave');
            if (!savedGame) {
                addToLog('NO SAVED GAME FOUND!');
                showNotification('NO SAVED GAME!');
                return;
            }
            
            try {
                const loadedState = JSON.parse(savedGame);
                
                // Validate saved game
                if (!loadedState.version || loadedState.version !== gameState.version) {
                    addToLog('SAVED GAME VERSION IS INCOMPATIBLE!');
                    showNotification('VERSION INCOMPATIBLE!');
                    return;
                }
                
                // Merge loaded state with current state
                Object.assign(gameState, loadedState);
                
                // Update UI
                updateStatsDisplay();
                updateQuestLog();
                updateEquipmentDisplay();
                updateInventoryDisplay();
                updateSkillButtons();
                updatePlayerEffects();
                
                // Switch to game screen if not already
                if (gameState.screen !== 'game') {
                    characterCreation.classList.add('hidden');
                    gameScreen.classList.remove('hidden');
                    gameOverScreen.classList.add('hidden');
                    victoryScreen.classList.add('hidden');
                    gameState.screen = 'game';
                }
                
                addToLog('GAME LOADED SUCCESSFULLY!', false, true);
                addToLog(`WELCOME BACK, ${gameState.player.name}!`);
                addToLog(locations[gameState.location].description);
                
                updateActionButtons();
                showNotification('GAME LOADED!');
            } catch (error) {
                addToLog('ERROR LOADING SAVED GAME!');
                showNotification('LOAD ERROR!');
            }
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notification.style.color = '#0f0';
            
            document.body.appendChild(notification);
            AudioManager.playNotification(); // Added sound for notification
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        // Restart game
        function restartGame() {
            // Reset game state
            gameState.player = {
                name: 'Valeros',
                race: 'Human',
                class: 'Fighter',
                background: 'Soldier',
                level: 1,
                hp: 10,
                maxHp: 10,
                mana: 10,
                maxMana: 10,
                ac: 15,
                str: 16,
                dex: 12,
                con: 14,
                int: 10,
                wis: 8,
                cha: 13,
                xp: 0,
                nextLevelXp: 100,
                gold: 100,
                inventory: ['Health Potion', 'Iron Sword', 'Leather Armor', 'Minor Healing Potion'],
                equipped: {
                    weapon: 'Iron Sword',
                    armor: 'Leather Armor',
                    shield: null
                },
                spells: [],
                skills: [],
                abilities: [],
                statusEffects: [],
                abilityCooldowns: {},
                dungeonLevel: 1,
                quests: {
                    main: { name: 'Find the Amulet of Yendor', completed: false, reward: 1000 },
                    side1: { name: 'Clear the Goblin Nest', completed: false, progress: 0, required: 5, reward: 250 },
                    side2: { name: 'Recover the Lost Artifact', completed: false, reward: 500 },
                    side3: { name: 'Slay the Dragon', completed: false, reward: 2000 }
                },
                totalEnemiesDefeated: 0,
                totalGoldCollected: 100,
                playTime: 0
            };
            
            gameState.location = 'entrance';
            gameState.inCombat = false;
            gameState.enemy = null;
            gameState.enemyStatusEffects = [];
            gameState.gameLog = [];
            gameState.gameActive = true;
            gameState.shopOpen = false;
            gameState.pointsRemaining = 27;
            gameState.lastSave = null;
            gameState.difficulty = 1;
            
            // Update UI
            updateStatsDisplay();
            updateQuestLog();
            updateEquipmentDisplay();
            gameText.innerHTML = '';
            
            // Switch screens
            gameOverScreen.classList.add('hidden');
            victoryScreen.classList.add('hidden');
            characterCreation.classList.remove('hidden');
            gameState.screen = 'character';
            
            // Reset character creation form
            charNameInput.value = 'VALEROS';
            charRaceSelect.value = 'Human';
            charClassSelect.value = 'Fighter';
            charBackgroundSelect.value = 'Soldier';
            
            // Reset stat allocation
            initCharacterCreation();
            
            addToLog('WELCOME TO THE DUNGEON OF INFINITE PERIL!');
            addToLog('YOUR QUEST: RETRIEVE THE LOST AMULET OF YENDOR FROM THE DEPTHS.');
        }

        // New Game+
        function startNewGamePlus() {
            // Keep character stats but increase difficulty
            gameState.player.level = Math.max(1, gameState.player.level - 2);
            gameState.player.xp = 0;
            gameState.player.nextLevelXp = 100 * gameState.difficulty;
            gameState.player.dungeonLevel = 1;
            gameState.location = 'entrance';
            gameState.inCombat = false;
            gameState.enemy = null;
            gameState.gameActive = true;
            gameState.gameLog = [];
            gameState.difficulty++;
            
            // Reset quests
            gameState.player.quests.main.completed = false;
            gameState.player.quests.side1.completed = false;
            gameState.player.quests.side1.progress = 0;
            gameState.player.quests.side2.completed = false;
            gameState.player.quests.side3.completed = false;
            
            // Update UI
            updateStatsDisplay();
            updateQuestLog();
            gameText.innerHTML = '';
            
            // Switch to game screen
            victoryScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameState.screen = 'game';
            
            addToLog('NEW GAME+ MODE ACTIVATED!');
            addToLog(`DIFFICULTY LEVEL: ${gameState.difficulty}`);
            addToLog('ENEMIES ARE STRONGER AND YOU NEED MORE EXPERIENCE.');
            addToLog('YOUR QUEST BEGINS ANEW...');
            addToLog(locations[gameState.location].description);
            
            updateActionButtons();
        }

        // Game over
        function gameOver() {
            gameState.gameActive = false;
            
            addToLog('YOU HAVE BEEN DEFEATED...', true);
            addToLog('GAME OVER', true);
            
            // Show game over screen
            gameScreen.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            
            // Display game over text
            const gameOverText = document.getElementById('game-over-text');
            gameOverText.innerHTML = '';
            
            const summary = document.createElement('div');
            const playTime = formatPlayTime(gameState.player.playTime);
            summary.innerHTML = `
                <div>FINAL STATS:</div>
                <div>NAME: ${gameState.player.name}</div>
                <div>LEVEL: ${gameState.player.level}</div>
                <div>GOLD: ${gameState.player.gold}</div>
                <div>DUNGEON LEVEL REACHED: ${gameState.player.dungeonLevel}</div>
                <div>TOTAL XP: ${gameState.player.xp}</div>
                <div>ENEMIES DEFEATED: ${gameState.player.totalEnemiesDefeated}</div>
                <div>TOTAL GOLD COLLECTED: ${gameState.player.totalGoldCollected}</div>
                <div>PLAY TIME: ${playTime}</div>
                <br>
                <div>BETTER LUCK NEXT TIME!</div>
            `;
            gameOverText.appendChild(summary);
        }

        // Victory
        function victory() {
            gameState.gameActive = false;
            
            // Mark main quest as completed
            gameState.player.quests.main.completed = true;
            updateQuestLog();
            
            // Award quest rewards
            gameState.player.xp += gameState.player.quests.main.reward;
            gameState.player.gold += 1000;
            
            // Show victory screen
            gameScreen.classList.add('hidden');
            victoryScreen.classList.remove('hidden');
            
            // Display victory text
            const victoryText = document.getElementById('victory-text');
            victoryText.innerHTML = '';
            
            const summary = document.createElement('div');
            const playTime = formatPlayTime(gameState.player.playTime);
            summary.innerHTML = `
                <div>YOU HAVE RETRIEVED THE AMULET OF YENDOR!</div>
                <div>YOUR QUEST IS COMPLETE!</div>
                <br>
                <div>FINAL STATS:</div>
                <div>NAME: ${gameState.player.name}</div>
                <div>RACE/CLASS: ${gameState.player.race} ${gameState.player.class}</div>
                <div>LEVEL: ${gameState.player.level}</div>
                <div>GOLD: ${gameState.player.gold}</div>
                <div>DUNGEON LEVEL REACHED: ${gameState.player.dungeonLevel}</div>
                <div>TOTAL XP: ${gameState.player.xp}</div>
                <div>ENEMIES DEFEATED: ${gameState.player.totalEnemiesDefeated}</div>
                <div>TOTAL GOLD COLLECTED: ${gameState.player.totalGoldCollected}</div>
                <div>PLAY TIME: ${playTime}</div>
                <br>
                <div>CONGRATULATIONS!</div>
            `;
            victoryText.appendChild(summary);
        }

        // Format play time
        function formatPlayTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${hours}h ${minutes}m ${secs}s`;
        }

        // Utility function to roll dice
        function rollDice(sides) {
            return Math.floor(Math.random() * sides) + 1;
        }

        // Add text to log
        function addToLog(text, isCombat = false, isLoot = false, isHeal = false, isSkill = false, isShop = false) {
            const logEntry = document.createElement('div');
            if (isCombat) logEntry.classList.add('combat-log');
            else if (isLoot) logEntry.classList.add('loot-log');
            else if (isHeal) logEntry.classList.add('heal-log');
            else if (isSkill) logEntry.classList.add('skill-log');
            else if (isShop) logEntry.classList.add('shop-log');
            
            logEntry.textContent = text;
            gameText.appendChild(logEntry);
            
            // Auto-scroll to bottom
            gameText.scrollTop = gameText.scrollHeight;
            
            // Add to game state log
            gameState.gameLog.push(text);
        }

        // Initialize the game
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
```
