<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Dungeon of Dread (1986) - Nightfalls Games</title>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            line-height: 1.4;
            background-color: #000;
            color: #0f0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 5px;
            touch-action: manipulation;
        }
        #header {
            text-align: center;
            border-bottom: 2px solid #0f0;
            padding-bottom: 8px;
            margin-bottom: 8px;
            flex-shrink: 0;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
            border: 1px solid #0f0;
            padding: 8px;
            margin-bottom: 8px;
            background-color: #111;
            -webkit-overflow-scrolling: touch;
        }
        #input-line {
            display: flex;
            flex-shrink: 0;
            align-items: center;
        }
        #prompt {
            margin-right: 8px;
            white-space: nowrap;
        }
        #input {
            flex-grow: 1;
            background: transparent;
            border: none;
            border-bottom: 1px solid #0f0;
            color: #0f0;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 4px 0;
        }
        #status {
            border-top: 1px solid #0f0;
            padding-top: 8px;
            margin-top: 8px;
            flex-shrink: 0;
            white-space: pre;
            font-size: 15px;
        }
        .command {
            color: #ff0;
        }
        .error {
            color: #ff4500;
        }
        .item {
            color: #0ff;
        }
        .enemy {
            color: #f0f;
        }
        .npc {
            color: #ffa500;
        }
        .success {
            color: #0f0;
        }
        .quest {
            color: #ffff00;
        }
        .loot {
            color: #ff69b4;
        }
        .system {
            color: #888;
        }
        .damage {
            color: #ff4500;
        }
        .heal {
            color: #32cd32;
        }
        #sound-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            z-index: 1000;
        }
        .quick-command {
            display: inline-block;
            background: #222;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 2px 6px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
        }
        #quick-commands {
            margin-top: 8px;
            text-align: center;
        }
        #volume-control {
            position: fixed;
            top: 40px;
            right: 10px;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 4px;
            font-size: 10px;
            z-index: 999;
        }
        #volume-slider {
            width: 80px;
            margin-top: 4px;
        }
        .dungeon-text {
            text-shadow: 0 0 5px #0f0;
        }
        .document {
            color: #ffcc00;
            font-style: italic;
        }
        .object {
            color: #aa55ff;
        }
        .trap {
            color: #ff5555;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .secret {
            color: #55ff55;
            font-style: italic;
        }
        .puzzle {
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <button id="sound-toggle">ðŸ”Š ON</button>
    <div id="volume-control">
        <div>Volume:</div>
               <input type="range" id="volume-slider" min="0" max="100" value="70">
    </div>
    <div id="header">
        <h1 class="dungeon-text">THE DUNGEON OF DREAD</h1>
        <div>1986 â€¢ NIGHTFALLS GAMES</div>
        <div>THIRD IN THE TERROR SERIES</div>
    </div>
    <div id="game-container">
        <div id="output">Welcome to the Dungeon of Dread! Type 'help' for commands.</div>
        <div id="input-line">
            <span id="prompt">&gt;</span>
            <input type="text" id="input" autocomplete="off" autofocus>
        </div>
        <div id="quick-commands">
            <span class="quick-command" onclick="quickCommand('n')">N</span>
            <span class="quick-command" onclick="quickCommand('s')">S</span>
            <span class="quick-command" onclick="quickCommand('e')">E</span>
            <span class="quick-command" onclick="quickCommand('w')">W</span>
            <span class="quick-command" onclick="quickCommand('look')">LOOK</span>
            <span class="quick-command" onclick="quickCommand('attack')">ATTACK</span>
            <span class="quick-command" onclick="quickCommand('inventory')">INV</span>
            <span class="quick-command" onclick="quickCommand('search')">SEARCH</span>
        </div>
        <div id="status"></div>
    </div>

    <script>
        // ==================== SOUND SYSTEM ====================
        class SoundSystem {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.bgGain = null;
                this.sfxGain = null;
                this.enabled = true;
                this.currentBg = null;
                this.currentBgSource = null;
                this.currentBgName = null;
                
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.bgGain = this.audioContext.createGain();
                    this.sfxGain = this.audioContext.createGain();
                    
                    // Set initial volumes
                    this.masterGain.gain.value = 0.7;
                    this.bgGain.gain.value = 0.25;
                    this.sfxGain.gain.value = 0.5;
                    
                    // Connect nodes
                    this.bgGain.connect(this.masterGain);
                    this.sfxGain.connect(this.masterGain);
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Volume control
                    document.getElementById('volume-slider').addEventListener('input', (e) => {
                        const volume = e.target.value / 100;
                        this.setMasterVolume(volume);
                    });
                    
                } catch (e) {
                    console.log('Web Audio API not supported:', e);
                    this.enabled = false;
                }
            }
            
            // ==================== NEW DUNGEON THEME MUSIC ====================
            playBackground(musicName, loop = true) {
                if (!this.enabled || !musicName) return;
                
                if (this.currentBgName === musicName && this.currentBgSource) {
                    return;
                }
                
                this.stopBackground();
                
                this.currentBgName = musicName;
                
                switch(musicName) {
                    case 'entrance':
                        this.playEntranceTheme(loop);
                        break;
                    case 'cavern':
                        this.playCavernMusic(loop);
                        break;
                    case 'eerie':
                        this.playEerieMusic(loop);
                        break;
                    case 'boss':
                        this.playBossMusic(loop);
                        break;
                    case 'victory':
                        this.playVictoryMusic(loop);
                        break;
                    case 'puzzle':
                        this.playPuzzleMusic(loop);
                        break;
                    default:
                        this.playEntranceTheme(loop);
                }
            }
            
            playEntranceTheme(loop) {
                // New dungeon theme - more ominous and deep
                const melody = [
                    {note: 87.31, duration: 0.6},  // F
                    {note: 97.99, duration: 0.3},  // G
                    {note: 130.81, duration: 0.6}, // C
                    {note: 110.00, duration: 0.3}, // A
                    {note: 87.31, duration: 0.9},  // F
                    {note: 73.42, duration: 0.3},  // D
                    {note: 65.41, duration: 0.6},  // C
                    {note: 55.00, duration: 0.3},  // A
                    {note: 49.00, duration: 0.9},  // G
                ];
                
                this.playMelody(melody, 'sawtooth', loop, 0.2);
            }
            
            playCavernMusic(loop) {
                const melody = [
                    {note: 65.41, duration: 0.5},  // C
                    {note: 82.41, duration: 0.5},  // E
                    {note: 98.00, duration: 0.5},  // G
                    {note: 73.42, duration: 0.5},  // D
                    {note: 87.31, duration: 1.0},  // F
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.15);
            }
            
            playEerieMusic(loop) {
                const melody = [
                    {note: 110, duration: 1.0},    // A
                    {note: 103.83, duration: 0.5}, // G#
                    {note: 98.00, duration: 1.0},  // G
                    {note: 92.50, duration: 0.5},  // F#
                    {note: 87.31, duration: 1.0},  // F
                ];
                
                this.playMelody(melody, 'triangle', loop, 0.1);
            }
            
            playBossMusic(loop) {
                const melody = [
                    {note: 130.81, duration: 0.2}, // C
                    {note: 164.81, duration: 0.2}, // E
                    {note: 196.00, duration: 0.2}, // G
                    {note: 261.63, duration: 0.4}, // C
                    {note: 196.00, duration: 0.2}, // G
                    {note: 164.81, duration: 0.2}, // E
                    {note: 130.81, duration: 0.4}, // C
                ];
                
                this.playMelody(melody, 'square', loop, 0.25);
            }
            
            playVictoryMusic(loop) {
                const melody = [
                    {note: 261.63, duration: 0.2}, // C
                    {note: 329.63, duration: 0.2}, // E
                    {note: 392.00, duration: 0.2}, // G
                    {note: 523.25, duration: 0.5}, // C
                    {note: 392.00, duration: 0.2}, // G
                    {note: 523.25, duration: 0.5}, // C
                    {note: 659.25, duration: 1.0}, // E
                ];
                
                this.playMelody(melody, 'sine', loop, 0.3);
            }
            
            playPuzzleMusic(loop) {
                const melody = [
                    {note: 523.25, duration: 0.3}, // C
                    {note: 493.88, duration: 0.3}, // B
                    {note: 440.00, duration: 0.3}, // A
                    {note: 392.00, duration: 0.3}, // G
                    {note: 349.23, duration: 0.6}, // F
                    {note: 329.63, duration: 0.3}, // E
                    {note: 293.66, duration: 0.6}, // D
                ];
                
                this.playMelody(melody, 'sine', loop, 0.15);
            }
            
            playMelody(melody, waveType, loop, volume) {
                if (!this.enabled) return;
                
                const now = this.audioContext.currentTime;
                const source = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                source.type = waveType;
                gainNode.connect(this.bgGain);
                source.connect(gainNode);
                
                let currentTime = now;
                melody.forEach((note, index) => {
                    source.frequency.setValueAtTime(note.note, currentTime);
                    
                    gainNode.gain.setValueAtTime(0, currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.3, currentTime + note.duration - 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, currentTime + note.duration);
                    
                    currentTime += note.duration;
                });
                
                if (loop) {
                    source.start(now);
                    source.stop(now + currentTime - now);
                    
                    this.currentBg = setTimeout(() => {
                        this.playMelody(melody, waveType, loop, volume);
                    }, (currentTime - now) * 1000);
                } else {
                    source.start(now);
                    source.stop(now + currentTime - now);
                }
                
                this.currentBgSource = source;
            }
            
            stopBackground() {
                if (this.currentBg) {
                    clearTimeout(this.currentBg);
                    this.currentBg = null;
                }
                if (this.currentBgSource) {
                    try {
                        this.currentBgSource.stop();
                    } catch (e) {}
                    this.currentBgSource = null;
                }
                this.currentBgName = null;
            }
            
            // ==================== SOUND EFFECTS ====================
            playSound(soundName, volume = 1.0) {
                if (!this.enabled) return;
                
                switch(soundName) {
                    case 'click':
                        this.playClick(volume);
                        break;
                    case 'notification':
                        this.playNotification(volume);
                        break;
                    case 'levelup':
                        this.playLevelUp(volume);
                        break;
                    case 'attack':
                        this.playAttack(volume);
                        break;
                    case 'enemyHit':
                        this.playEnemyHit(volume);
                        break;
                    case 'playerHit':
                        this.playPlayerHit(volume);
                        break;
                    case 'victory':
                        this.playVictory(volume);
                        break;
                    case 'defeat':
                        this.playDefeat(volume);
                        break;
                    case 'pickup':
                        this.playPickup(volume);
                        break;
                    case 'equip':
                        this.playEquip(volume);
                        break;
                    case 'door':
                        this.playDoor(volume);
                        break;
                    case 'step':
                        this.playStep(volume);
                        break;
                    case 'trap':
                        this.playTrap(volume);
                        break;
                    case 'secret':
                        this.playSecret(volume);
                        break;
                    case 'puzzle':
                        this.playPuzzle(volume);
                        break;
                    case 'stone':
                        this.playStone(volume);
                        break;
                    case 'water':
                        this.playWater(volume);
                        break;
                    case 'magic':
                        this.playMagic(volume);
                        break;
                    case 'lever':
                        this.playLever(volume);
                        break;
                    case 'chest':
                        this.playChest(volume);
                        break;
                }
            }
            
            playClick(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playNotification(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playLevelUp(volume) {
                const now = this.audioContext.currentTime;
                
                const notes = [523.25, 659.25, 783.99, 1046.50];
                
                notes.forEach((note, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note, now + (index * 0.1));
                    
                    gainNode.gain.setValueAtTime(0, now + (index * 0.1));
                    gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + (index * 0.1) + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + (index * 0.1) + 0.2);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + (index * 0.1));
                    oscillator.stop(now + (index * 0.1) + 0.2);
                });
            }
            
            playAttack(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playEnemyHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playPlayerHit(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playVictory(volume) {
                const now = this.audioContext.currentTime;
                
                const notes = [
                    {freq: 523.25, time: 0.0, duration: 0.2},
                    {freq: 659.25, time: 0.2, duration: 0.2},
                    {freq: 783.99, time: 0.4, duration: 0.2},
                    {freq: 1046.50, time: 0.6, duration: 0.5},
                ];
                
                notes.forEach(note => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(note.freq, now + note.time);
                    
                    gainNode.gain.setValueAtTime(0, now + note.time);
                    gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + note.time + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.time + note.duration);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGain);
                    
                    oscillator.start(now + note.time);
                    oscillator.stop(now + note.time + note.duration);
                });
            }
            
            playDefeat(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(220, now);
                oscillator.frequency.exponentialRampToValueAtTime(110, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playPickup(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, now);
                oscillator.frequency.exponentialRampToValueAtTime(1500, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playEquip(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playDoor(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStep(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            }
            
            playTrap(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.6, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            playSecret(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, now);
                oscillator.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playPuzzle(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.5);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(volume * 0.1, now + 0.4);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.5);
            }
            
            playStone(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(150, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.4);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.5, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playWater(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, now);
                oscillator.frequency.setValueAtTime(500, now + 0.1);
                oscillator.frequency.setValueAtTime(600, now + 0.2);
                oscillator.frequency.setValueAtTime(500, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.2, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
            
            playMagic(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, now);
                oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.6);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.6);
            }
            
            playLever(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.setValueAtTime(100, now + 0.1);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.4, now + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
            
            playChest(volume) {
                const now = this.audioContext.currentTime;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume * 0.3, now + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            }
            
            // ==================== UTILITY METHODS ====================
            setMasterVolume(volume) {
                if (this.masterGain) {
                    this.masterGain.gain.value = Math.max(0, Math.min(1, volume));
                }
            }
            
            toggle() {
                this.enabled = !this.enabled;
                const toggleBtn = document.getElementById('sound-toggle');
                toggleBtn.textContent = this.enabled ? 'ðŸ”Š ON' : 'ðŸ”‡ OFF';
                
                if (!this.enabled) {
                    this.stopBackground();
                } else if (gameStarted) {
                    this.playBackground(currentBackground);
                }
                
                this.playSound('click');
            }
            
            resumeAudioContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        // ==================== GAME DATA ====================
        const classes = {
            warrior: { 
                hp: 50, mp: 5, str: 11, def: 8, agility: 3, 
                desc: "A hardened fighter skilled with all weapons.",
                skills: ['shield_bash', 'cleave']
            },
            rogue: { 
                hp: 35, mp: 10, str: 6, def: 4, agility: 12,
                desc: "A stealthy adventurer who excels at traps and locks.",
                skills: ['backstab', 'disarm_trap']
            },
            wizard: { 
                hp: 25, mp: 30, str: 3, def: 2, agility: 5,
                desc: "A master of arcane arts and ancient knowledge.",
                skills: ['fireball', 'detect_magic']
            }
        };

        const weapons = {
            fists: { name: "Fists", dmg: 3, type: 'weapon', value: 0, desc: "Your bare hands." },
            rusty_sword: { name: "Rusty Sword", dmg: 8, type: 'weapon', value: 20, desc: "An old but serviceable blade." },
            iron_mace: { name: "Iron Mace", dmg: 12, type: 'weapon', value: 40, desc: "A heavy mace that crushes armor.", vs_skeleton: 6 },
            poisoned_dagger: { name: "Poisoned Dagger", dmg: 9, type: 'weapon', value: 35, desc: "A blade coated with deadly toxin.", poison: 3 },
            crossbow: { name: "Crossbow", dmg: 15, type: 'weapon', value: 60, desc: "A ranged weapon with iron bolts.", range: true },
            battle_axe: { name: "Battle Axe", dmg: 18, type: 'weapon', value: 75, desc: "A massive axe that cleaves through armor." },
            enchanted_staff: { name: "Enchanted Staff", dmg: 10, type: 'weapon', value: 65, desc: "A staff that channels magical energy.", magic: 10 },
            dragon_slayer: { name: "Dragon Slayer", dmg: 25, type: 'weapon', value: 200, desc: "A legendary sword that glows with power.", vs_dragon: 15 }
        };

        const armors = {
            none: { name: "None", def: 0, type: 'armor', value: 0, desc: "No armor." },
            leather_armor: { name: "Leather Armor", def: 5, type: 'armor', value: 35, desc: "Light armor made from toughened hide.", agility: 2 },
            chainmail: { name: "Chainmail", def: 9, type: 'armor', value: 70, desc: "Interlocking metal rings provide solid protection." },
            wizard_robe: { name: "Wizard Robe", def: 3, type: 'armor', value: 30, desc: "A robe that enhances magical ability.", magic: 8, agility: 1 },
            plate_armor: { name: "Plate Armor", def: 14, type: 'armor', value: 120, desc: "Heavy steel plates covering the entire body.", agility: -3 },
            shadow_cloak: { name: "Cloak of Shadows", def: 2, type: 'armor', value: 50, desc: "A cloak that blends with darkness.", agility: 5, stealth: 4 },
            dragon_scale: { name: "Dragon Scale Armor", def: 16, type: 'armor', value: 180, desc: "Armor crafted from dragon scales.", fire_resist: 10 }
        };

        const items = {
            health_potion: { 
                type: 'consumable', 
                effect: { hp: 30 }, 
                value: 25, 
                desc: "Heals 30 HP.",
                use: "You drink the health potion. It restores 30 HP." 
            },
            mana_potion: { 
                type: 'consumable', 
                effect: { mp: 25 }, 
                value: 30, 
                desc: "Restores 25 MP.",
                use: "You drink the mana potion. It restores 25 MP." 
            },
            antidote: { 
                type: 'consumable', 
                effect: { cure_poison: true }, 
                value: 20, 
                desc: "Cures poison and venom.",
                use: "You drink the antidote, neutralizing any poison in your system." 
            },
            torch: { 
                type: 'tool', 
                value: 5, 
                desc: "A lit torch. Illuminates dark areas.",
                use: "You light the torch, illuminating the dark area." 
            },
            lockpick: { 
                type: 'tool', 
                value: 15, 
                desc: "A set of lockpicks for opening locked doors.",
                use: "You attempt to pick the lock." 
            },
            skeleton_key: { 
                type: 'key', 
                value: 1, 
                desc: "A magical key that can open most locks.",
                use: "You use the skeleton key to unlock a door." 
            },
            dungeon_map: { 
                type: 'document', 
                value: 50, 
                desc: "A map showing the dungeon layout.",
                read: "The map shows the dungeon's twisting passages. You notice a secret room marked near the prison cells.",
                use: "You study the map, gaining knowledge of the dungeon layout." 
            },
            ancient_scroll: { 
                type: 'quest', 
                value: 1, 
                desc: "An ancient scroll of forbidden knowledge. The wizard wants this.",
                read: "The scroll contains forbidden arcane formulae. 'The lich draws power from the crystal heart in the deepest chamber...'",
                use: "The scroll glows with magical energy." 
            },
            dragon_egg: { 
                type: 'quest', 
                value: 1, 
                desc: "A precious dragon egg. The blacksmith wants it for crafting.",
                examine: "A warm, scaled egg that pulses with inner fire. It's heavier than it looks.",
                use: "The egg glows faintly when held." 
            },
            prison_key: { 
                type: 'key', 
                value: 1, 
                desc: "A heavy iron key for prison cells.",
                use: "You use the prison key to unlock a cell." 
            },
            // New dungeon-themed items
            rope: { 
                type: 'tool', 
                value: 10, 
                desc: "A strong rope for climbing or tying.",
                use: "You use the rope to secure your position." 
            },
            climbing_gear: { 
                type: 'tool', 
                value: 40, 
                desc: "Specialized gear for scaling walls.",
                use: "You prepare your climbing gear." 
            },
            holy_symbol: { 
                type: 'tool', 
                value: 30, 
                desc: "A blessed symbol that repels undead.",
                examine: "A silver symbol that feels warm to the touch.",
                use: "You hold up the holy symbol. Nearby undead recoil." 
            },
            // Documents that can be found
            prisoners_note: {
                type: 'document',
                value: 5,
                desc: "A desperate note from a prisoner.",
                read: "Day 47: They took Jenkins to the torture chamber today. I hear screams from the lower levels. The Warden has gone mad with power. If you find this, tell my family I tried to escape.",
                examine: "A scrap of parchment with shaky handwriting."
            },
            wardens_log: {
                type: 'document',
                value: 10,
                desc: "The Warden's personal log.",
                read: "Entry: The prisoners whisper of a 'Dragon's Tomb' beneath the deepest dungeon. Fools. The real treasure is the crystal heart that powers this place. Soon, its power will be mine alone.",
                examine: "A leather-bound logbook with precise, cruel handwriting."
            },
            alchemy_notes: {
                type: 'document',
                value: 15,
                desc: "Alchemical research notes.",
                read: "Experiment 73: Combining drake blood with shadow moss creates a volatile explosive. Useful for clearing blocked passages. Warning: Keep away from open flame.",
                examine: "Precise notes with chemical diagrams and formulas."
            },
            treasure_map: {
                type: 'document',
                value: 75,
                desc: "A map showing hidden treasure locations.",
                read: "X marks three spots: Behind the false wall in the guardroom, under the loose stone in the torture chamber, and in the dragon's hoard (if you're brave enough).",
                examine: "A well-drawn map on aged parchment with three red X marks.",
                use: "You study the map, memorizing the treasure locations."
            },
            // New consumables
            bandage: {
                type: 'consumable',
                effect: { hp: 15 },
                value: 10,
                desc: "A clean bandage for treating wounds.",
                use: "You apply the bandage to your wounds, healing 15 HP."
            },
            explosive_powder: {
                type: 'consumable',
                effect: { damage: 40 },
                value: 35,
                desc: "Volatile powder that explodes when ignited.",
                use: "You throw the explosive powder! It creates a loud bang and deals damage."
            }
        };

        // Enhanced enemies for dungeon theme
        const enemies = {
            giant_rat: { 
                name: "Giant Rat", 
                hp: 20, dmg: 5, gold: 5, xp: 15, 
                desc: "A massive, disease-ridden rodent with sharp teeth.",
                loot: ['bandage'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'cavern',
                type: 'beast'
            },
            skeleton: { 
                name: "Skeleton Warrior", 
                hp: 30, dmg: 8, gold: 15, xp: 25,
                desc: "An animated skeleton wielding a rusty sword.",
                loot: ['rusty_sword', 'health_potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie',
                type: 'undead'
            },
            cave_spider: { 
                name: "Cave Spider", 
                hp: 25, dmg: 7, gold: 12, xp: 20,
                desc: "A giant spider that spins webs and injects venom.",
                loot: ['antidote', 'rope'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'cavern',
                type: 'beast',
                poison: true
            },
            goblin: { 
                name: "Dungeon Goblin", 
                hp: 35, dmg: 9, gold: 18, xp: 30,
                desc: "A cunning creature that ambushes from the shadows.",
                loot: ['lockpick', 'gold'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'cavern',
                type: 'humanoid'
            },
            zombie: { 
                name: "Dungeon Zombie", 
                hp: 40, dmg: 10, gold: 22, xp: 35,
                desc: "A reanimated corpse that shambles mindlessly.",
                loot: ['leather_armor', 'bandage'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie',
                type: 'undead'
            },
            ghost: { 
                name: "Dungeon Ghost", 
                hp: 45, dmg: 12, gold: 30, xp: 40,
                desc: "A spectral apparition that chills the soul.",
                loot: ['holy_symbol', 'mana_potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie',
                type: 'spirit'
            },
            ogre: { 
                name: "Cave Ogre", 
                hp: 75, dmg: 18, gold: 50, xp: 60,
                desc: "A massive, brutish creature that crushes its foes.",
                loot: ['iron_mace', 'health_potion'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'cavern',
                type: 'giant'
            },
            dark_knight: { 
                name: "Dark Knight", 
                hp: 90, dmg: 20, gold: 70, xp: 75,
                desc: "A fallen knight cursed to guard the dungeon eternally.",
                loot: ['chainmail', 'battle_axe'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'eerie',
                type: 'undead'
            },
            lich: { 
                name: "Dungeon Lich", 
                hp: 150, dmg: 30, gold: 120, xp: 100,
                desc: "An undead wizard of immense magical power.",
                loot: ['enchanted_staff', 'ancient_scroll', 'mana_potion'], 
                sounds: { attack: 'magic', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss',
                type: 'undead'
            },
            dungeon_dragon: { 
                name: "Dungeon Dragon", 
                hp: 250, dmg: 35, gold: 200, xp: 150,
                desc: "A fearsome dragon that guards the deepest treasure.",
                loot: ['dragon_slayer', 'dragon_scale', 'dragon_egg', 'dragon_egg'], 
                sounds: { attack: 'attack', hit: 'enemyHit', death: 'victory' },
                bgSound: 'boss',
                type: 'dragon'
            }
        };

        // Enhanced NPCs with dungeon theme
        const npcs = {
            prisoner: { 
                name: "Old Prisoner", 
                desc: "A ragged, weary man chained to the wall.", 
                dialog: "Please... help me escape... The Warden is mad! He experiments on prisoners!",
                quest: { item: 'prison_key', reward: { gold: 80, item: 'dungeon_map', xp: 40 }, completed: false },
                hostile: false,
                acceptsItems: ['prisoners_note']
            },
            wizard: {
                name: "Crazy Wizard",
                desc: "A wild-eyed mage surrounded by magical artifacts.",
                dialog: "The ancient scroll! It holds the secret to defeating the lich! Bring it to me!",
                quest: { item: 'ancient_scroll', reward: { gold: 100, item: 'enchanted_staff', xp: 50 }, completed: false },
                hostile: false,
                acceptsItems: ['alchemy_notes', 'wardens_log']
            },
            blacksmith: {
                name: "Dwarf Blacksmith",
                desc: "A sturdy dwarf with a makeshift forge.",
                dialog: "A dragon egg! With that, I can forge armor that would make kings weep! Bring me one!",
                quest: { item: 'dragon_egg', reward: { gold: 150, item: 'dragon_scale', xp: 75 }, completed: false },
                hostile: false
            },
            merchant: {
                name: "Shady Merchant",
                desc: "A hooded figure with a pack full of goods.",
                dialog: "Psst... Looking for supplies? I have what you need... for the right price.",
                quest: null,
                hostile: false,
                shopItems: ['health_potion', 'mana_potion', 'antidote', 'torch', 'lockpick', 'rope', 'bandage', 'explosive_powder', 'rusty_sword', 'leather_armor']
            },
            goblin_chief: {
                name: "Goblin Chief",
                desc: "A larger, meaner goblin wearing stolen jewelry.",
                dialog: "You not from here! Give treasure or we eat you!",
                quest: null,
                hostile: true
            },
            tortured_soul: {
                name: "Tortured Soul",
                desc: "A ghostly figure that weeps silently.",
                dialog: "Free me... The Warden's experiments bound me here... Find my remains in the torture chamber...",
                quest: { item: 'wardens_log', reward: { gold: 90, item: 'holy_symbol', xp: 45 }, completed: false },
                hostile: false
            },
            warden: {
                name: "The Warden",
                desc: "A cruel, power-mad man in elaborate armor.",
                dialog: "You dare invade my domain? The crystal heart's power will be mine alone!",
                quest: null,
                hostile: true
            },
            miner: {
                name: "Lost Miner",
                desc: "A dust-covered man with a pickaxe.",
                dialog: "The cave-in trapped me here weeks ago. If you have climbing gear, we could escape together.",
                quest: null,
                hostile: false
            }
        };

        // Dungeon room descriptions with traps and secrets
        const dungeonRoomDescriptions = [
            { 
                desc: "DUNGEON ENTRANCE. A crumbling stone archway leads into darkness. Chains hang from the ceiling.", 
                sound: 'entrance',
                objects: {
                    'archway': "Ancient stonework covered in moss and strange carvings.",
                    'chains': "Rusted iron chains that clink softly in the draft.",
                    'torch sconces': "Empty metal brackets for torches, long since extinguished."
                },
                hiddenItems: ['prisoners_note'],
                trap: null
            },
            { 
                desc: "GUARD ROOM. Empty weapon racks line the walls. A broken table sits in the corner.", 
                sound: 'entrance',
                objects: {
                    'racks': "Wooden racks that once held weapons, now empty.",
                    'table': "A splintered wooden table with old playing cards scattered on it.",
                    'chair': "An overturned wooden chair."
                },
                trap: 'pressure_plate'
            },
            { 
                desc: "PRISON CELLS. Iron bars separate small, filthy cells. Chains hang from the walls.", 
                sound: 'eerie',
                objects: {
                    'cells': "Tiny stone rooms with straw bedding that's mostly mold.",
                    'bars': "Thick iron bars, some bent or broken.",
                    'manacles': "Iron cuffs attached to the walls by chains."
                },
                npc: 'prisoner',
                trap: null
            },
            { 
                desc: "STORAGE ROOM. Crates and barrels are stacked haphazardly. The air smells of rot.", 
                sound: 'cavern',
                objects: {
                    'crates': "Wooden boxes, some broken open to reveal moldy contents.",
                    'barrels': "Large wooden barrels, most empty or leaking foul liquid.",
                    'shelves': "Rotted wooden shelves collapsing under their own weight."
                },
                hiddenItems: ['rope'],
                trap: 'falling_barrel'
            },
            { 
                desc: "TORTURE CHAMBER. Rusty implements line the walls. A rack holds a skeletal figure.", 
                sound: 'eerie',
                objects: {
                    'implements': "Iron maidens, thumb screws, and other cruel devices.",
                    'rack': "A stretching device with a skeleton still attached.",
                    'brazier': "A fire pit with cold coals and burnt bones."
                },
                hiddenItems: ['wardens_log'],
                trap: 'spike_trap'
            },
            { 
                desc: "LIBRARY. Water-damaged books line sagging shelves. Some books float in mid-air.", 
                sound: 'eerie',
                objects: {
                    'books': "Leather-bound tomes with titles in forgotten languages.",
                    'floating books': "Several books hover in the air, pages turning as if read by invisible hands.",
                    'desk': "A mahogany desk covered in dust and strange symbols."
                },
                npc: 'wizard',
                trap: null
            },
            { 
                desc: "ALCHEMY LAB. Glass vials bubble with strange liquids. The smell is overwhelming.", 
                sound: 'eerie',
                objects: {
                    'vials': "Colorful liquids bubble in glass containers. Some glow with inner light.",
                    'lab': "An alchemical workstation with a skull, mortar and pestle.",
                    'ingredients': "Jars containing strange powders, herbs, and unidentifiable substances."
                },
                hiddenItems: ['alchemy_notes', 'explosive_powder'],
                trap: 'poison_gas'
            },
            { 
                desc: "GOBLIN DEN. Makeshift beds and stolen goods clutter the floor. The stench is terrible.", 
                sound: 'cavern',
                objects: {
                    'beds': "Piles of rags and stolen blankets in nest-like arrangements.",
                    'goods': "Mismatched items stolen from prisoners and other creatures.",
                    'fire pit': "A circle of stones containing cold ashes and burnt bones."
                },
                npc: 'goblin_chief',
                trap: 'pit_trap'
            },
            { 
                desc: "UNDERGROUND RIVER. A dark river flows through a cavern. Something moves in the water.", 
                sound: 'cavern',
                objects: {
                    'river': "A black river that flows silently through the cavern.",
                    'water': "The water is clear but incredibly deep and dark.",
                    'boat': "A small, leaky wooden boat tied to a stone post."
                },
                trap: 'water_trap'
            },
            { 
                desc: "CRYSTAL CAVE. Glowing crystals illuminate the cavern. Strange fungi grow on the walls.", 
                sound: 'puzzle',
                objects: {
                    'crystals': "Geometric crystals that emit a soft, pulsating light.",
                    'fungi': "Bioluminescent mushrooms and mosses in alien colors.",
                    'cavern': "A vast underground chamber with stalactites and stalagmites."
                },
                puzzle: 'crystal_puzzle',
                trap: null
            },
            { 
                desc: "TREASURE VAULT. Piles of gold and jewels sparkle in the dim light. A dragon skeleton guards the hoard.", 
                sound: 'boss',
                objects: {
                    'gold': "Mountains of coins, goblets, and jewelry.",
                    'jewels': "Gemstones of every color glittering in the crystal light.",
                    'dragon skeleton': "The massive skeleton of a dragon, arranged as if still alive."
                },
                hiddenItems: ['treasure_map'],
                trap: 'dragon_trap'
            },
            { 
                desc: "MINED TUNNEL. Fresh excavation marks line the walls. A collapsed section blocks the way forward.", 
                sound: 'cavern',
                objects: {
                    'excavation': "Recent pickaxe marks in the stone walls.",
                    'collapse': "A pile of rubble blocking the tunnel ahead.",
                    'tools': "A discarded pickaxe and shovel leaning against the wall."
                },
                npc: 'miner',
                trap: 'cave_in'
            },
            { 
                desc: "SHRINE. A statue of a forgotten god. Offerings of gold and gems at its feet.", 
                sound: 'eerie',
                objects: {
                    'statue': "A marble deity with features worn away by time.",
                    'offerings': "Piles of treasure left by desperate worshippers.",
                    'altar': "A stone altar stained with dark substances."
                },
                trap: 'curse_trap'
            },
            { 
                desc: "FUNGUS GROVE. Giant mushrooms tower overhead. Spores float in the air.", 
                sound: 'cavern',
                objects: {
                    'mushrooms': "Enormous fungi in bizarre shapes and colors.",
                    'spores': "Glowing particles that float through the air like dust.",
                    'growth': "Thick fungal mats covering the floor and walls."
                },
                trap: 'spore_trap'
            },
            { 
                desc: "BONE PIT. A massive pit filled with bones. The stench of death is overwhelming.", 
                sound: 'eerie',
                objects: {
                    'pit': "A deep chasm filled with skeletal remains.",
                    'bones': "Skulls, ribs, and other bones piled high.",
                    'stench': "The smell of decay and rot that makes your eyes water."
                },
                trap: 'bone_trap'
            },
            { 
                desc: "ARMORY. Weapons racks hold rusted swords and shields. A faint glow comes from one corner.", 
                sound: 'entrance',
                objects: {
                    'weapons': "Ancient swords, maces, and axes covered in rust.",
                    'shields': "Wooden shields bearing emblems, all rotting.",
                    'glow': "A faint silver glow from a pile of discarded weapons."
                },
                hiddenItems: ['rusty_sword'],
                trap: 'weapon_trap'
            },
            { 
                desc: "KITCHEN. A giant cauldron hangs over cold ashes. Butcher's tools gleam on a block.", 
                sound: 'cavern',
                objects: {
                    'cauldron': "A massive iron pot containing a congealed, foul-smelling stew.",
                    'tools': "Cleavers, knives, and meat hooks on a stained wooden block.",
                    'pantry': "Sacks of moldy flour and jars of unidentifiable preserves."
                },
                trap: 'kitchen_trap'
            },
            { 
                desc: "CRYPT. Stone coffins line the walls. Some lids have been pushed aside.", 
                sound: 'eerie',
                objects: {
                    'coffins': "Stone sarcophagi carved with names and dates.",
                    'lids': "Some coffin lids lie broken on the floor.",
                    'ashes': "Piles of grey dust in ceremonial urns."
                },
                npc: 'tortured_soul',
                trap: 'undead_trap'
            },
            { 
                desc: "FORGE. A massive anvil and bellows. The air is hot and smells of sulfur.", 
                sound: 'cavern',
                objects: {
                    'anvil': "A huge steel anvil, dented from years of use.",
                    'bellows': "Leather bellows that wheeze when stepped on.",
                    'forge': "A stone furnace that glows with residual heat."
                },
                npc: 'blacksmith',
                trap: null
            },
            { 
                desc: "MERCHANT'S NOOK. Makeshift stalls line the walls. A hooded figure watches you.", 
                sound: 'entrance',
                objects: {
                    'stalls': "Wooden tables displaying various goods.",
                    'goods': "Potions, tools, and basic equipment for sale.",
                    'counter': "A wooden counter with a scale and abacus."
                },
                npc: 'merchant',
                trap: null
            },
            { 
                desc: "WARDEN'S QUARTERS. Lavishly furnished with stolen goods. A large desk dominates the room.", 
                sound: 'boss',
                objects: {
                    'desk': "A massive oak desk covered in papers and maps.",
                    'bed': "A large four-poster bed with silk curtains.",
                    'trophies': "Weapons and armor mounted on the walls as decorations."
                },
                npc: 'warden',
                trap: 'warden_trap'
            },
            { 
                desc: "CRYSTAL HEART CHAMBER. A massive crystal pulsates with energy in the center of the room. The Lich awaits.", 
                sound: 'boss',
                objects: {
                    'crystal': "A gigantic crystal that pulses with rainbow light.",
                    'energy': "Visible waves of power radiate from the crystal.",
                    'pedestal': "A stone dais upon which the crystal rests."
                },
                puzzle: 'final_puzzle',
                trap: 'lich_trap'
            }
        ];

        // Generate dungeon rooms
        const rooms = [];
        for (let i = 0; i < 22; i++) {
            rooms.push({
                id: i,
                desc: dungeonRoomDescriptions[i].desc,
                sound: dungeonRoomDescriptions[i].sound,
                objects: dungeonRoomDescriptions[i].objects || {},
                hiddenItems: dungeonRoomDescriptions[i].hiddenItems || [],
                puzzle: dungeonRoomDescriptions[i].puzzle || null,
                trap: dungeonRoomDescriptions[i].trap || null,
                exits: { 
                    n: i < 12 ? i + 10 : null, 
                    s: i >= 10 ? i - 10 : null, 
                    e: (i + 1) % 10 !== 0 ? i + 1 : null, 
                    w: i % 10 !== 0 ? i - 1 : null,
                    u: i === 5 ? 15 : null, // Library to upper level
                    d: i === 15 ? 5 : null  // Upper level back to library
                },
                items: [],
                enemy: null,
                npc: dungeonRoomDescriptions[i].npc || null,
                explored: false,
                dark: i !== 0 && i !== 9 && i !== 20, // Some rooms are dark
                locked: i === 20 || i === 21, // Warden's quarters and final chamber locked
                searched: false,
                trapActive: dungeonRoomDescriptions[i].trap !== null,
                puzzleSolved: false
            });
        }

        // Place items, enemies, and NPCs
        rooms[0].items = ['torch', 'bandage'];
        rooms[1].enemy = 'giant_rat';
        rooms[2].items = ['prison_key'];
        rooms[3].enemy = 'cave_spider';
        rooms[4].enemy = 'zombie';
        rooms[5].items = ['ancient_scroll'];
        rooms[6].enemy = 'ghost';
        rooms[7].enemy = 'goblin';
        rooms[8].items = ['climbing_gear'];
        rooms[9].enemy = 'ogre';
        rooms[10].enemy = 'dark_knight';
        rooms[11].enemy = 'giant_rat';
        rooms[12].enemy = 'skeleton';
        rooms[13].enemy = 'cave_spider';
        rooms[14].items = ['skeleton_key'];
        rooms[15].enemy = 'zombie';
        rooms[16].enemy = 'ghost';
        rooms[17].enemy = 'skeleton';
        rooms[18].items = ['iron_mace'];
        rooms[19].enemy = 'goblin';
        rooms[20].enemy = 'lich';
        rooms[21].enemy = 'dungeon_dragon';

        // ==================== GAME STATE ====================
        let player = {
            class: null,
            hp: 0,
            maxHp: 0,
            mp: 0,
            maxMp: 0,
            str: 0,
            def: 0,
            dmg: 0,
            agility: 0,
            gold: 0,
            xp: 0,
            level: 1,
            inventory: [],
            equipped: { weapon: 'fists', armor: 'none' },
            location: 0,
            inCombat: null,
            quests: [],
            torch: true,
            moves: 0,
            poisoned: false,
            effects: [],
            knownDocuments: [],
            trapDetection: 0,
            secretRoomsFound: 0
        };

        // ==================== GAME SYSTEMS ====================
        const lootTable = ['health_potion', 'mana_potion', 'antidote', 'torch', 'bandage', 'rope', 'gold', 'lockpick', 'prisoners_note'];
        let gameStarted = false;
        let currentBackground = 'entrance';
        const soundSystem = new SoundSystem();
        let enemyHealthReset = JSON.parse(JSON.stringify(enemies));

        // ==================== UI FUNCTIONS ====================
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const status = document.getElementById('status');

        function print(text, className = '') {
            const line = document.createElement('div');
            line.textContent = text;
            if (className) line.className = className;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
            
            if (className === 'success' || className === 'loot' || className === 'quest') {
                soundSystem.playSound('notification', 0.7);
            } else if (className === 'error') {
                soundSystem.playSound('defeat', 0.3);
            } else if (className === 'trap') {
                soundSystem.playSound('trap', 0.5);
            } else if (className === 'secret') {
                soundSystem.playSound('secret', 0.5);
            } else if (className === 'puzzle') {
                soundSystem.playSound('puzzle', 0.5);
            }
        }

        function updateStatus() {
            const combat = player.inCombat ? ` (COMBAT!)` : '';
            const weapon = player.equipped.weapon ? weapons[player.equipped.weapon].name : 'Fists';
            const armor = player.equipped.armor ? armors[player.equipped.armor].name : 'None';
            
            status.textContent =
                `HP:${player.hp}/${player.maxHp} MP:${player.mp}/${player.maxMp} ` +
                `DMG:${player.dmg} DEF:${player.def} AGI:${player.agility} ` +
                `LVL:${player.level} GOLD:${player.gold}${combat}`;
                
            const equippedLine = `Weapon: ${weapon} | Armor: ${armor}`;
            if (!status.textContent.includes(equippedLine)) {
                status.textContent += `\n${equippedLine}`;
            }
            
            if (player.poisoned) {
                status.textContent += `\nPOISONED!`;
            }
        }

        function updatePlayerStats() {
            const weapon = weapons[player.equipped.weapon] || weapons.fists;
            player.dmg = player.str + weapon.dmg;
            
            const armor = armors[player.equipped.armor] || armors.none;
            player.def = classes[player.class].def + armor.def;
            
            player.agility = classes[player.class].agility + (armor.agility || 0);
            player.trapDetection = Math.floor(player.agility / 3);
        }

        function checkLevelUp() {
            const xpNeeded = player.level * 100;
            if (player.xp >= xpNeeded) {
                player.level++;
                player.xp -= xpNeeded;
                player.maxHp += 20;
                player.hp = player.maxHp;
                player.maxMp += 10;
                player.mp = player.maxMp;
                player.str += 2;
                player.def += 1;
                player.agility += 1;
                print(`You leveled up to level ${player.level}! Stats increased.`, 'success');
                soundSystem.playSound('levelup');
                updateStatus();
                updatePlayerStats();
            }
        }

        // ==================== TRAP SYSTEM ====================
        function checkTrap() {
            const room = rooms[player.location];
            
            if (!room.trapActive || !room.trap) return false;
            
            // Chance to detect trap based on agility
            const detectChance = player.trapDetection * 10;
            if (Math.random() * 100 < detectChance) {
                print(`You spot a ${room.trap.replace('_', ' ')}!`, 'trap');
                print("You can attempt to 'disarm trap' or proceed carefully.", 'system');
                return true;
            }
            
            return false;
        }

        function triggerTrap() {
            const room = rooms[player.location];
            
            if (!room.trapActive || !room.trap) return;
            
            soundSystem.playSound('trap', 0.7);
            
            switch(room.trap) {
                case 'pressure_plate':
                    player.hp -= 15;
                    print("A pressure plate triggers, firing darts from the wall!", 'trap');
                    print("You take 15 damage!", 'damage');
                    break;
                case 'falling_barrel':
                    player.hp -= 20;
                    print("A barrel falls from above, crushing you!", 'trap');
                    print("You take 20 damage!", 'damage');
                    break;
                case 'spike_trap':
                    player.hp -= 25;
                    player.poisoned = true;
                    print("Poisoned spikes shoot from the floor!", 'trap');
                    print("You take 25 damage and are poisoned!", 'damage');
                    break;
                case 'poison_gas':
                    player.hp -= 10;
                    player.poisoned = true;
                    print("Poisonous gas fills the room!", 'trap');
                    print("You take 10 damage and are poisoned!", 'damage');
                    break;
                case 'pit_trap':
                    player.hp -= 30;
                    print("The floor gives way beneath you!", 'trap');
                    print("You fall into a pit, taking 30 damage!", 'damage');
                    break;
                case 'water_trap':
                    player.hp -= 15;
                    print("The water suddenly rises, dragging you under!", 'trap');
                    print("You take 15 damage!", 'damage');
                    break;
                case 'dragon_trap':
                    player.hp -= 40;
                    print("The dragon skeleton animates and breathes fire!", 'trap');
                    print("You take 40 damage!", 'damage');
                    break;
                case 'cave_in':
                    player.hp -= 35;
                    print("The ceiling collapses on you!", 'trap');
                    print("You take 35 damage!", 'damage');
                    break;
                case 'curse_trap':
                    player.hp -= 20;
                    player.maxHp -= 5;
                    print("A curse from the shrine saps your vitality!", 'trap');
                    print("You take 20 damage and lose 5 maximum HP!", 'damage');
                    break;
                case 'spore_trap':
                    player.hp -= 15;
                    player.str -= 2;
                    print("Toxic spores weaken your muscles!", 'trap');
                    print("You take 15 damage and lose 2 strength!", 'damage');
                    break;
                case 'bone_trap':
                    player.hp -= 25;
                    print("Animated bones rise and attack you!", 'trap');
                    print("You take 25 damage!", 'damage');
                    break;
                case 'weapon_trap':
                    player.hp -= 20;
                    print("Weapons fly from the racks and strike you!", 'trap');
                    print("You take 20 damage!", 'damage');
                    break;
                case 'kitchen_trap':
                    player.hp -= 18;
                    print("The butcher's tools animate and attack!", 'trap');
                    print("You take 18 damage!", 'damage');
                    break;
                case 'undead_trap':
                    player.hp -= 22;
                    print("Skeletons rise from the coffins!", 'trap');
                    print("You take 22 damage!", 'damage');
                    break;
                case 'warden_trap':
                    player.hp -= 30;
                    print("The Warden's security system activates!", 'trap');
                    print("You take 30 damage!", 'damage');
                    break;
                case 'lich_trap':
                    player.hp -= 50;
                    print("The Lich's magical trap unleashes dark energy!", 'trap');
                    print("You take 50 damage!", 'damage');
                    break;
            }
            
            room.trapActive = false;
            
            if (player.hp <= 0) {
                print("The trap kills you... GAME OVER.", 'error');
                soundSystem.playSound('defeat');
                resetGame();
            }
            
            updateStatus();
        }

        function disarmTrap() {
            const room = rooms[player.location];
            
            if (!room.trapActive) {
                print("There's no trap here to disarm.", 'error');
                return;
            }
            
            const successChance = player.agility * 5;
            if (Math.random() * 100 < successChance) {
                room.trapActive = false;
                print(`You successfully disarm the ${room.trap.replace('_', ' ')}!`, 'success');
                soundSystem.playSound('secret');
                player.xp += 25;
                checkLevelUp();
            } else {
                print("You fail to disarm the trap!", 'error');
                triggerTrap();
            }
        }

        // ==================== PUZZLE SYSTEM ====================
        function solvePuzzle(puzzleType) {
            const room = rooms[player.location];
            
            if (!room.puzzle) {
                print("There's no puzzle here to solve.", 'error');
                return;
            }
            
            if (room.puzzleSolved) {
                print("You've already solved this puzzle.", 'system');
                return;
            }
            
            soundSystem.playSound('puzzle', 0.5);
            
            switch(puzzleType) {
                case 'crystal_puzzle':
                    if (player.inventory.includes('enchanted_staff') || player.class === 'wizard') {
                        room.puzzleSolved = true;
                        room.items.push('mana_potion', 'mana_potion');
                        print("You channel magical energy into the crystals!", 'puzzle');
                        print("The crystals glow brightly, revealing hidden potions!", 'success');
                        soundSystem.playSound('magic');
                        player.xp += 50;
                    } else {
                        print("The crystals hum with energy, but you don't know how to interact with them.", 'puzzle');
                        print("Perhaps magical knowledge or an enchanted staff would help.", 'system');
                    }
                    break;
                case 'final_puzzle':
                    if (player.inventory.includes('ancient_scroll')) {
                        room.puzzleSolved = true;
                        enemies['lich'].dmg -= 10;
                        print("You read from the ancient scroll!", 'puzzle');
                        print("The Lich's power weakens as its secrets are revealed!", 'success');
                        soundSystem.playSound('magic');
                        player.xp += 100;
                    } else {
                        print("The crystal heart pulses with immense power.", 'puzzle');
                        print("You need ancient knowledge to understand how to weaken it.", 'system');
                    }
                    break;
            }
            
            checkLevelUp();
        }

        // ==================== ENHANCED SEARCH FUNCTION ====================
        function searchRoom() {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to search!", 'error');
                return;
            }
            
            soundSystem.playSound('stone', 0.3);
            
            if (!room.searched) {
                room.searched = true;
                player.xp += 10;
                
                // Chance to find hidden items
                if (room.hiddenItems.length > 0 && Math.random() > 0.5) {
                    const hiddenItem = room.hiddenItems[0];
                    room.items.push(hiddenItem);
                    print(`You find a hidden ${hiddenItem.replace('_', ' ')}!`, 'secret');
                    soundSystem.playSound('secret');
                    room.hiddenItems.shift();
                }
                
                // Chance to find secret passage
                if (Math.random() > 0.7 && player.secretRoomsFound < 3) {
                    player.secretRoomsFound++;
                    print("You discover a secret passage!", 'secret');
                    print("A new exit has been revealed!", 'success');
                    // Add a secret exit (simplified - in full game would add actual room)
                    player.xp += 30;
                }
                
                print("You search the room thoroughly.", 'system');
                print(`+10 XP for searching!`, 'system');
                
                // Check for traps
                if (room.trapActive) {
                    if (checkTrap()) {
                        print("Be careful! There's a trap here.", 'trap');
                    }
                }
            } else {
                print("You've already searched this room.", 'system');
            }
            
            if (room.items.length > 0) {
                print(`Items here: ${room.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
        }

        // ==================== GAME LOGIC ====================
        function startGame(className) {
            player.class = className;
            const c = classes[className];
            player.maxHp = player.hp = c.hp;
            player.maxMp = player.mp = c.mp;
            player.str = c.str;
            player.def = c.def;
            player.agility = c.agility;
            player.gold = 50;
            player.xp = 0;
            player.level = 1;
            player.inventory = ['health_potion', 'torch', 'bandage'];
            if (className === 'rogue') player.inventory.push('lockpick');
            if (className === 'wizard') player.inventory.push('mana_potion');
            player.equipped = { weapon: 'fists', armor: 'none' };
            player.location = 0;
            player.inCombat = null;
            player.quests = [];
            player.torch = true;
            player.moves = 0;
            player.poisoned = false;
            player.knownDocuments = [];
            player.trapDetection = Math.floor(player.agility / 3);
            player.secretRoomsFound = 0;
            
            updatePlayerStats();
            
            print(`You are a ${className}. ${c.desc}`, 'success');
            print(`You start with 50 gold, basic supplies, and a torch.`, 'success');
            print(`Your fists deal ${player.dmg} damage.`, 'system');
            
            gameStarted = true;
            soundSystem.playBackground(currentBackground);
            soundSystem.playSound('notification');
            
            look();
            updateStatus();
        }

        function look() {
            const room = rooms[player.location];
            
            if (room.enemy && enemies[room.enemy].bgSound) {
                currentBackground = enemies[room.enemy].bgSound;
            } else if (room.puzzle) {
                currentBackground = 'puzzle';
            } else {
                currentBackground = room.sound;
            }
            soundSystem.playBackground(currentBackground);
            
            if (room.dark && !player.torch) {
                print("The room is pitch black. You can't see anything!", 'error');
                print("You need a light source.", 'error');
                return;
            }
            
            if (!room.explored) {
                room.explored = true;
                player.xp += 5;
                print(`+5 XP for exploring!`, 'system');
                soundSystem.playSound('notification', 0.5);
            }
            
            print(room.desc);
            
            // List objects in room
            if (Object.keys(room.objects).length > 0) {
                print(`You see: ${Object.keys(room.objects).join(', ')}`, 'object');
                print("You can 'examine [object]' to look closer.", 'system');
            }
            
            if (room.items.length > 0) {
                print(`Items here: ${room.items.map(item => items[item]?.desc.split('.')[0] || item).join(', ')}`, 'item');
            }
            
            if (room.enemy) {
                const enemy = enemies[room.enemy];
                print(`${enemy.desc}`, 'enemy');
                print(`It looks ${enemy.hp <= enemyHealthReset[room.enemy].hp / 2 ? 'badly wounded' : 'healthy'}.`, 'enemy');
            }
            
            if (room.npc) {
                const npc = npcs[room.npc];
                print(`${npc.name} is here. ${npc.desc}`, 'npc');
            }
            
            if (room.puzzle && !room.puzzleSolved) {
                print("There's a puzzle here to solve.", 'puzzle');
            }
            
            if (room.locked) {
                print("The door is locked!", 'error');
            }
            
            let exits = [];
            for (let dir in room.exits) if (room.exits[dir] !== null) exits.push(dir);
            print(`Exits: ${exits.join(' ')}`);
            
            updateStatus();
        }

        function move(direction) {
            const room = rooms[player.location];
            const target = room.exits[direction];
            
            if (target === null) {
                print("You can't go that way.", 'error');
                soundSystem.playSound('click');
                return;
            }
            
            const targetRoom = rooms[target];
            if (targetRoom.locked) {
                if (player.inventory.includes('skeleton_key')) {
                    targetRoom.locked = false;
                    print("You use the skeleton key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else if (player.inventory.includes('lockpick') && player.class === 'rogue') {
                    if (Math.random() > 0.3) {
                        targetRoom.locked = false;
                        print("You pick the lock successfully!", 'success');
                        soundSystem.playSound('lever');
                    } else {
                        print("You fail to pick the lock.", 'error');
                        return;
                    }
                } else {
                    print("The door is locked!", 'error');
                    return;
                }
            }
            
            soundSystem.playSound('step', 0.3);
            
            player.moves++;
            
            // Check for trap triggering
            if (room.trapActive && Math.random() > 0.6) {
                triggerTrap();
                if (player.hp <= 0) return;
            }
            
            // Apply poison damage if poisoned
            if (player.poisoned) {
                const poisonDmg = Math.floor(player.maxHp * 0.05);
                player.hp -= poisonDmg;
                print(`The poison courses through your veins, dealing ${poisonDmg} damage!`, 'damage');
                soundSystem.playSound('playerHit', 0.3);
                if (player.hp <= 0) {
                    print("The poison kills you... GAME OVER.", 'error');
                    soundSystem.playSound('defeat');
                    resetGame();
                    return;
                }
            }
            
            // Random encounter chance
            if (player.moves % 4 === 0 && !targetRoom.enemy && !targetRoom.npc) {
                const encounterChance = Math.max(25 - player.agility, 5);
                if (Math.random() * 100 < encounterChance) {
                    const randomEnemies = ['giant_rat', 'skeleton', 'cave_spider', 'goblin'];
                    const enemyType = randomEnemies[Math.floor(Math.random() * randomEnemies.length)];
                    targetRoom.enemy = enemyType;
                }
            }
            
            player.location = target;
            print(`You go ${direction}.`, 'command');
            
            look();
            updateStatus();
        }

        function take(itemName) {
            const room = rooms[player.location];
            
            if (room.dark && !player.torch) {
                print("It's too dark to see items!", 'error');
                return;
            }
            
            const index = room.items.indexOf(itemName);
            if (index === -1) {
                print("That item isn't here.", 'error');
                return;
            }
            
            room.items.splice(index, 1);
            player.inventory.push(itemName);
            print(`You take the ${itemName}.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function talk(target) {
            const room = rooms[player.location];
            
            if (!room.npc) {
                print("There's no one here to talk to.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            
            if (npc.hostile) {
                print(`${npc.name}: "I have nothing to say to you, intruder!"`, 'npc');
                return;
            }
            
            soundSystem.playSound('notification', 0.5);
            print(`${npc.name}: "${npc.dialog}"`, 'npc');
            
            if (npc.quest) {
                if (npc.quest.completed) {
                    print(`${npc.name}: "Thank you again for your help."`, 'npc');
                } else if (npc.quest.item) {
                    const hasItem = player.inventory.includes(npc.quest.item);
                    print(`${npc.name}: "Bring me the ${npc.quest.item}."`, 'quest');
                    if (hasItem) {
                        print(`You have the ${npc.quest.item}. Type 'give ${room.npc}' to complete the quest.`, 'quest');
                    }
                }
            }
            
            if (npc.acceptsItems) {
                print(`${npc.name}: "I'm interested in notes and documents. Show me what you've found."`, 'npc');
            }
            
            if (room.npc === 'merchant') {
                print(`${npc.name}: "Want to see my wares? Type 'list'."`, 'npc');
            }
        }

        function give(npcName) {
            const room = rooms[player.location];
            
            if (!room.npc || room.npc !== npcName) {
                print("That NPC isn't here.", 'error');
                return;
            }
            
            const npc = npcs[npcName];
            
            if (!npc.quest || npc.quest.completed) {
                print(`${npc.name} doesn't want anything from you.`, 'npc');
                return;
            }
            
            const index = player.inventory.indexOf(npc.quest.item);
            if (index === -1) {
                print(`You don't have the ${npc.quest.item}.`, 'error');
                return;
            }
            
            player.inventory.splice(index, 1);
            npc.quest.completed = true;
            player.gold += npc.quest.reward.gold;
            player.xp += npc.quest.reward.xp;
            if (npc.quest.reward.item) {
                player.inventory.push(npc.quest.reward.item);
            }
            
            print(`${npc.name}: "Thank you! Here is your reward."`, 'success');
            print(`+${npc.quest.reward.gold} gold! +${npc.quest.reward.xp} XP!`, 'success');
            if (npc.quest.reward.item) {
                print(`You receive: ${npc.quest.reward.item}`, 'loot');
            }
            
            soundSystem.playSound('victory');
            checkLevelUp();
            updateStatus();
        }

        function examine(itemName) {
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                // Try to examine object in room
                const room = rooms[player.location];
                const normalizedObjectName = itemName.toLowerCase();
                
                for (const obj in room.objects) {
                    if (obj.toLowerCase().includes(normalizedObjectName)) {
                        print(`You examine the ${obj}:`, 'object');
                        print(room.objects[obj], 'system');
                        soundSystem.playSound('notification', 0.5);
                        
                        // Small chance to find hidden item when examining
                        if (Math.random() < 0.2 && room.hiddenItems.length > 0) {
                            const hiddenItem = room.hiddenItems[0];
                            if (!room.items.includes(hiddenItem)) {
                                room.items.push(hiddenItem);
                                print(`You find a hidden ${hiddenItem.replace('_', ' ')}!`, 'secret');
                                soundSystem.playSound('secret');
                                room.hiddenItems.shift();
                            }
                        }
                        return;
                    }
                }
                print(`You don't see a ${itemName} here.`, 'error');
                return;
            }
            
            print(`${item.name || itemName}:`, 'item');
            print(`  ${item.desc}`);
            
            if (weapons[itemName]) {
                print(`  Damage: ${item.dmg}`);
                if (item.vs_skeleton) print(`  vs Skeletons: +${item.vs_skeleton}`);
                if (item.vs_dragon) print(`  vs Dragons: +${item.vs_dragon}`);
                if (item.poison) print(`  Poison: ${item.poison} damage per turn`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
            } else if (armors[itemName]) {
                print(`  Defense: ${item.def}`);
                if (item.agility) print(`  Agility: ${item.agility > 0 ? '+' : ''}${item.agility}`);
                if (item.fire_resist) print(`  Fire Resistance: +${item.fire_resist}`);
                if (item.magic) print(`  Magic Power: +${item.magic}`);
                if (item.stealth) print(`  Stealth: +${item.stealth}`);
            } else if (items[itemName]) {
                print(`  Type: ${item.type}`);
                print(`  Value: ${item.value} gold`);
                if (item.examine) {
                    print(`  ${item.examine}`);
                }
            }
        }

        function useItem(itemName, target = null) {
            const item = items[itemName];
            const index = player.inventory.indexOf(itemName);
            
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            // Handle document reading
            if (item.type === 'document') {
                if (item.read) {
                    print(`You read the ${itemName.replace('_', ' ')}:`, 'document');
                    print(item.read, 'document');
                    soundSystem.playSound('read');
                    
                    if (!player.knownDocuments.includes(itemName)) {
                        player.knownDocuments.push(itemName);
                        player.xp += 15;
                    }
                } else {
                    print("The document is written in an unknown language.", 'error');
                }
                return;
            }
            
            // Handle consumables
            if (item.type === 'consumable') {
                if (item.effect.hp) {
                    const healAmount = item.effect.hp;
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    print(item.use || `You use the ${itemName}, healing ${healAmount} HP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.mp) {
                    const manaAmount = item.effect.mp;
                    player.mp = Math.min(player.maxMp, player.mp + manaAmount);
                    print(item.use || `You use the ${itemName}, restoring ${manaAmount} MP.`, 'heal');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.cure_poison && player.poisoned) {
                    player.poisoned = false;
                    print(item.use || "The antidote cures your poisoning!", 'success');
                    soundSystem.playSound('notification', 0.3);
                    player.inventory.splice(index, 1);
                }
                if (item.effect.damage) {
                    const room = rooms[player.location];
                    if (room.enemy) {
                        const damage = item.effect.damage;
                        enemies[room.enemy].hp -= damage;
                        print(item.use || `The explosive powder deals ${damage} damage to the enemy!`, 'damage');
                        soundSystem.playSound('attack');
                        if (enemies[room.enemy].hp <= 0) {
                            print(`The ${room.enemy} is defeated!`, 'success');
                            room.enemy = null;
                            player.inCombat = null;
                        }
                    } else {
                        print("The explosive powder fizzles with no target.", 'error');
                    }
                    player.inventory.splice(index, 1);
                }
            } else if (itemName === 'torch') {
                player.torch = !player.torch;
                print(item.use || (player.torch ? "You light the torch." : "You extinguish the torch."), 'system');
                soundSystem.playSound('click');
            } else if (item.type === 'key') {
                const room = rooms[player.location];
                if (room.locked) {
                    room.locked = false;
                    print(item.use || "You use the key to unlock the door.", 'success');
                    soundSystem.playSound('door');
                } else {
                    print("There's nothing to unlock here.", 'error');
                }
            } else if (item.type === 'tool') {
                if (itemName === 'holy_symbol') {
                    const room = rooms[player.location];
                    if (room.enemy && (enemies[room.enemy].type === 'undead' || enemies[room.enemy].type === 'spirit')) {
                        print(item.use || "You hold up the holy symbol. The undead recoils in fear!", 'success');
                        enemies[room.enemy].hp -= 20;
                        soundSystem.playSound('attack');
                        if (enemies[room.enemy].hp <= 0) {
                            print(`The ${room.enemy} is destroyed!`, 'success');
                            room.enemy = null;
                            player.inCombat = null;
                        }
                    } else {
                        print(item.use || "You hold up the holy symbol. It glows faintly.", 'system');
                    }
                } else if (itemName === 'lockpick') {
                    const room = rooms[player.location];
                    if (room.locked) {
                        if (player.class === 'rogue' || Math.random() > 0.6) {
                            room.locked = false;
                            print(item.use || "You successfully pick the lock!", 'success');
                            soundSystem.playSound('lever');
                        } else {
                            print(item.use || "You fail to pick the lock.", 'error');
                        }
                    } else {
                        print("There's nothing locked here to pick.", 'error');
                    }
                } else {
                    print(item.use || `You use the ${itemName}.`, 'system');
                }
            } else {
                print("You can't use that now.");
            }
            
            updateStatus();
        }

        function equip(itemName) {
            if (weapons[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that weapon.", 'error');
                    return;
                }
                
                if (player.equipped.weapon !== 'fists') {
                    player.inventory.push(player.equipped.weapon);
                }
                
                player.equipped.weapon = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${weapons[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else if (armors[itemName]) {
                const index = player.inventory.indexOf(itemName);
                if (index === -1) {
                    print("You don't have that armor.", 'error');
                    return;
                }
                
                if (player.equipped.armor !== 'none') {
                    player.inventory.push(player.equipped.armor);
                }
                
                player.equipped.armor = itemName;
                player.inventory.splice(index, 1);
                print(`You equip the ${armors[itemName].name}.`, 'success');
                soundSystem.playSound('equip');
                
            } else {
                print("That's not equipment you can equip.", 'error');
                return;
            }
            
            updatePlayerStats();
            updateStatus();
        }

        function attack(target) {
            const room = rooms[player.location];
            
            if (target) {
                if (room.npc === target) {
                    const npc = npcs[target];
                    print(`You attack ${npc.name}!`, 'command');
                    soundSystem.playSound('attack');
                    
                    if (npc.hostile) {
                        room.enemy = 'dark_knight';
                        room.npc = null;
                        player.inCombat = 'dark_knight';
                    } else {
                        print(`You murder ${npc.name} in cold blood!`, 'error');
                        room.npc = null;
                        player.agility = Math.max(0, player.agility - 3);
                        print("Your reputation suffers! Agility -3.", 'error');
                        player.xp += 20;
                        soundSystem.playSound('victory');
                    }
                    updateStatus();
                    updatePlayerStats();
                    return;
                }
            }
            
            if (!room.enemy) {
                print("There's nothing to attack here.", 'error');
                return;
            }
            
            const enemyType = room.enemy;
            const enemy = enemies[enemyType];
            player.inCombat = enemyType;
            
            soundSystem.playSound('attack');
            print(`You attack the ${enemy.name}!`, 'command');
            
            let playerDmg = player.dmg + Math.floor(Math.random() * 5);
            const weapon = weapons[player.equipped.weapon];
            
            if (enemy.type === 'undead' && weapon.vs_skeleton) {
                playerDmg += weapon.vs_skeleton;
                print(`Your weapon is especially effective against undead!`, 'damage');
            }
            if (enemy.type === 'dragon' && weapon.vs_dragon) {
                playerDmg += weapon.vs_dragon;
                print(`Your weapon is especially effective against dragons!`, 'damage');
            }
            
            enemy.hp -= playerDmg;
            print(`You hit for ${playerDmg} damage.`, 'damage');
            soundSystem.playSound(enemy.sounds.hit, 0.5);
            
            if (weapon.poison && Math.random() > 0.7) {
                print(`Your weapon poisons the ${enemy.name}!`, 'damage');
                // In full game, would add poison effect to enemy
            }
            
            if (enemy.hp <= 0) {
                print(`You defeated the ${enemy.name}!`, 'success');
                player.gold += enemy.gold;
                player.xp += enemy.xp;
                print(`+${enemy.gold} gold! +${enemy.xp} XP!`, 'success');
                soundSystem.playSound(enemy.sounds.death);
                
                if (enemy.loot && Math.random() > 0.3) {
                    const loot = enemy.loot[Math.floor(Math.random() * enemy.loot.length)];
                    if (loot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 20) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} extra gold on the corpse!`, 'loot');
                    } else {
                        player.inventory.push(loot);
                        print(`The enemy drops: ${loot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (Math.random() > 0.6) {
                    const randomLoot = lootTable[Math.floor(Math.random() * lootTable.length)];
                    if (randomLoot === 'gold') {
                        const extraGold = Math.floor(Math.random() * 15) + 5;
                        player.gold += extraGold;
                        print(`You find ${extraGold} gold in the debris!`, 'loot');
                    } else {
                        player.inventory.push(randomLoot);
                        print(`You find: ${randomLoot}!`, 'loot');
                        soundSystem.playSound('pickup');
                    }
                }
                
                if (enemyType === 'dungeon_dragon') {
                    print("*** CONGRATULATIONS! ***", 'success');
                    print("You have defeated the Dungeon Dragon!", 'success');
                    print("The Dungeon of Dread is conquered!", 'success');
                    soundSystem.playBackground('victory');
                    setTimeout(() => soundSystem.playBackground('entrance'), 10000);
                } else if (enemyType === 'lich') {
                    print("You have defeated the Lich!", 'success');
                    print("The dungeon trembles as its magical hold weakens.", 'success');
                }
                
                room.enemy = null;
                player.inCombat = null;
                enemy.hp = enemyHealthReset[enemyType].hp;
                
                checkLevelUp();
            } else {
                print(`The ${enemy.name} has ${enemy.hp} HP left.`);
                let enemyDmg = Math.max(enemy.dmg - player.def + Math.floor(Math.random() * 5), 1);
                
                // Dodge chance based on agility
                const dodgeChance = player.agility * 3;
                if (Math.random() * 100 < dodgeChance) {
                    print(`You dodge the ${enemy.name}'s attack!`, 'success');
                } else {
                    player.hp -= enemyDmg;
                    print(`The ${enemy.name} hits you for ${enemyDmg} damage.`, 'damage');
                    soundSystem.playSound('playerHit', 0.5);
                    
                    if (enemy.poison && Math.random() > 0.8) {
                        player.poisoned = true;
                        print(`The ${enemy.name} poisons you!`, 'error');
                    }
                    
                    if (player.hp <= 0) {
                        print("You have been slain... GAME OVER.", 'error');
                        soundSystem.playSound('defeat');
                        resetGame();
                    }
                }
            }
            
            updateStatus();
        }

        function showInventory() {
            if (player.inventory.length === 0) {
                print("Your inventory is empty.");
            } else {
                print("Inventory:");
                const counts = {};
                player.inventory.forEach(item => {
                    counts[item] = (counts[item] || 0) + 1;
                });
                
                Object.keys(counts).forEach(itemName => {
                    const item = weapons[itemName] || armors[itemName] || items[itemName];
                    const count = counts[itemName];
                    const itemDesc = item ? item.desc.split('.')[0] : 'Unknown item';
                    print(`${itemName} x${count}: ${itemDesc}`, 'item');
                });
            }
            const weapon = weapons[player.equipped.weapon];
            const armor = armors[player.equipped.armor];
            print(`Equipped: ${weapon.name} (${weapon.dmg + player.str} DMG), ${armor.name} (${armor.def} DEF)`);
            print(`Total Stats: ${player.dmg} DMG | ${player.def} DEF | ${player.agility} AGILITY`);
            if (player.poisoned) {
                print(`STATUS: POISONED!`, 'error');
            }
            if (player.knownDocuments.length > 0) {
                print(`Documents read: ${player.knownDocuments.length}`, 'document');
            }
            if (player.secretRoomsFound > 0) {
                print(`Secret rooms found: ${player.secretRoomsFound}`, 'secret');
            }
        }

        function listShop() {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            print(`${npc.name}'s Wares:`, 'npc');
            npc.shopItems.forEach(itemName => {
                const item = weapons[itemName] || armors[itemName] || items[itemName];
                if (item) {
                    const price = item.value;
                    print(`${item.name || itemName} - ${price} gold: ${item.desc}`, 'item');
                }
            });
            print("Sell items for 75% of value.", 'npc');
        }

        function buy(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const npc = npcs[room.npc];
            if (!npc.shopItems.includes(itemName)) {
                print("The merchant doesn't sell that.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item) {
                print("That item doesn't exist.", 'error');
                return;
            }
            
            if (player.gold < item.value) {
                print(`You need ${item.value} gold, but only have ${player.gold}.`, 'error');
                return;
            }
            
            player.gold -= item.value;
            player.inventory.push(itemName);
            print(`You buy ${item.name || itemName} for ${item.value} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function sell(itemName) {
            const room = rooms[player.location];
            if (!room.npc || room.npc !== 'merchant') {
                print("There's no merchant here.", 'error');
                return;
            }
            
            const index = player.inventory.indexOf(itemName);
            if (index === -1) {
                print("You don't have that item.", 'error');
                return;
            }
            
            const item = weapons[itemName] || armors[itemName] || items[itemName];
            if (!item || item.type === 'quest') {
                print("You can't sell that.", 'error');
                return;
            }
            
            const sellPrice = Math.floor(item.value * 0.75);
            player.gold += sellPrice;
            player.inventory.splice(index, 1);
            print(`You sell ${item.name || itemName} for ${sellPrice} gold.`, 'success');
            soundSystem.playSound('pickup');
            updateStatus();
        }

        function help() {
            print("=== THE DUNGEON OF DREAD COMMANDS ===", 'command');
            print("MOVEMENT: n, s, e, w, u, d, look", 'system');
            print("EXPLORATION: search, examine [object/item]", 'system');
            print("TRAPS: disarm trap (rogues are best at this)", 'system');
            print("PUZZLES: solve puzzle (when you see one)", 'system');
            print("COMBAT: attack [target], use [item]", 'system');
            print("NPCs: talk, give [npc]", 'system');
            print("MERCHANT: list, buy [item], sell [item]", 'system');
            print("ITEMS: take [item], equip [item], use [item], examine [item]", 'system');
            print("INVENTORY: inventory, status", 'system');
            print("OTHER: help, quit", 'system');
            print("=== NEW FEATURES ===", 'command');
            print("- Traps that can damage or poison you", 'trap');
            print("- Puzzles to solve for rewards", 'puzzle');
            print("- Secret rooms to discover", 'secret');
            print("- Poison system that damages over time", 'system');
            print("- Dodge chance based on agility", 'system');
            print("- Class-specific abilities and starting items", 'system');
        }

        function resetGame() {
            player.class = null;
            gameStarted = false;
            soundSystem.playBackground('entrance');
            print("GAME OVER", 'error');
            print("Choose a class: warrior, rogue, wizard.");
            updateStatus();
        }

        function quickCommand(cmd) {
            document.getElementById('input').value = cmd;
            const event = new KeyboardEvent('keydown', { key: 'Enter' });
            document.getElementById('input').dispatchEvent(event);
        }

        // ==================== COMMAND PARSER ====================
        input.addEventListener('keydown', function (e) {
            if (e.key === 'Enter') {
                const cmd = input.value.trim().toLowerCase();
                input.value = '';
                if (!cmd) return;

                soundSystem.playSound('click', 0.3);
                print(`> ${cmd}`, 'command');
                const parts = cmd.split(' ');
                const verb = parts[0];
                const arg = parts[1];
                const arg2 = parts[2];
                const arg3 = parts[3];

                // Class selection
                if (!player.class && ['warrior', 'rogue', 'wizard'].includes(verb)) {
                    startGame(verb);
                    return;
                }
                if (!player.class) {
                    print("Choose a class first: warrior, rogue, wizard.", 'error');
                    return;
                }

                // Game commands
                switch (verb) {
                    case 'n': case 'north': move('n'); break;
                    case 's': case 'south': move('s'); break;
                    case 'e': case 'east': move('e'); break;
                    case 'w': case 'west': move('w'); break;
                    case 'u': case 'up': move('u'); break;
                    case 'd': case 'down': move('d'); break;
                    case 'go': if (arg) move(arg); else print("Go where?"); break;
                    case 'l': case 'look': 
                        if (arg === 'at' && arg2) {
                            examine(arg2);
                        } else if (arg) {
                            examine(arg);
                        } else {
                            look();
                        }
                        break;
                    case 'search': 
                        searchRoom();
                        break;
                    case 'examine': 
                        if (arg) examine(arg); else print("Examine what?"); 
                        break;
                    case 'disarm':
                        if (arg === 'trap') disarmTrap(); else print("Disarm what?"); 
                        break;
                    case 'solve':
                        if (arg === 'puzzle') solvePuzzle(rooms[player.location].puzzle); else print("Solve what?"); 
                        break;
                    case 'take': 
                        if (arg) take(arg); else print("Take what?"); break;
                    case 'talk': talk(arg); break;
                    case 'give': 
                        if (arg) give(arg); else print("Give to who?"); break;
                    case 'list': listShop(); break;
                    case 'buy': if (arg) buy(arg); else print("Buy what?"); break;
                    case 'sell': if (arg) sell(arg); else print("Sell what?"); break;
                    case 'attack': if (arg) attack(arg); else attack(); break;
                    case 'use': if (arg) useItem(arg, arg2); else print("Use what?"); break;
                    case 'equip': if (arg) equip(arg); else print("Equip what?"); break;
                    case 'i': case 'inventory': case 'inv': showInventory(); break;
                    case 'status': updateStatus(); break;
                    case 'help': case '?': help(); break;
                    case 'quit': resetGame(); break;
                    default: print("Unknown command. Type 'help'.", 'error');
                }
            }
        });

        // Sound toggle button
        document.getElementById('sound-toggle').addEventListener('click', () => {
            soundSystem.toggle();
        });

        // Initialize audio on first user interaction
        document.addEventListener('click', function initAudio() {
            soundSystem.resumeAudioContext();
            if (!gameStarted) {
                soundSystem.playBackground('entrance');
            }
            document.removeEventListener('click', initAudio);
        }, { once: true });

        // ==================== INIT ====================
        print("THE DUNGEON OF DREAD (1986)", 'success');
        print("NIGHTFALLS GAMES PRESENTS", 'system');
        print("THIRD IN THE TERROR SERIES", 'dungeon-text');
        print("", 'system');
        print("A dark dungeon crawl through endless depths!", 'system');
        print("Face traps, puzzles, and monstrous foes!", 'system');
        print("", 'system');
        print("NEW FEATURES:", 'success');
        print("- Trap and puzzle system", 'system');
        print("- Poison and status effects", 'system');
        print("- Class-specific abilities", 'system');
        print("- Secret rooms to discover", 'system');
        print("", 'system');
        print("Touch sound button to toggle audio", 'system');
        print("Use quick buttons for mobile play", 'system');
        print("", 'system');
        print("Choose your class: warrior, rogue, wizard.", 'system');
        updateStatus();
        input.focus();
    </script>
</body>
</html>
