<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronicles of Aethelgard: Enhanced Edition</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            background-color: #000;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.5;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 3fr 1fr;
            grid-gap: 20px;
            height: calc(100vh - 40px);
        }
        
        .main-screen {
            border: 2px solid #fff;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            background-color: #111;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        .sidebar {
            border: 2px solid #fff;
            padding: 20px;
            background-color: #111;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        .screen-title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid #fff;
            padding-bottom: 10px;
        }
        
        .output-text {
            flex-grow: 1;
            margin-bottom: 20px;
            line-height: 1.6;
            overflow-y: auto;
            min-height: 300px;
        }
        
        .input-area {
            display: flex;
            border-top: 1px solid #fff;
            padding-top: 15px;
        }
        
        #commandInput {
            flex-grow: 1;
            background-color: #000;
            color: #fff;
            border: 1px solid #fff;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 8px;
        }
        
        #submitButton {
            background-color: #000;
            color: #fff;
            border: 1px solid #fff;
            font-family: 'VT323', monospace;
            font-size: 20px;
            padding: 8px 15px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        #submitButton:hover {
            background-color: #222;
        }
        
        .player-stats {
            border-bottom: 1px solid #fff;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .inventory, .location-info, .quest-log {
            margin-bottom: 20px;
        }
        
        .inventory-items, .quest-items {
            margin-top: 5px;
            padding-left: 20px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .class-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 10px;
            margin: 20px 0;
        }
        
        .class-option {
            border: 1px solid #fff;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        
        .class-option:hover {
            background-color: #333;
        }
        
        .class-option.selected {
            background-color: #fff;
            color: #000;
        }
        
        .blink {
            animation: blink 1s step-start infinite;
        }
        
        @keyframes blink {
            50% { opacity: 0; }
        }
        
        .combat-log {
            color: #fff;
            border-top: 1px dashed #fff;
            margin-top: 15px;
            padding-top: 15px;
        }
        
        .game-over {
            color: #fff;
            font-size: 24px;
            text-align: center;
            margin-top: 20px;
        }
        
        .victory {
            color: #fff;
            font-size: 24px;
            text-align: center;
            margin-top: 20px;
        }
        
        .command-history {
            font-size: 16px;
            color: #aaa;
            margin-top: 10px;
            border-top: 1px dashed #aaa;
            padding-top: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .npc-dialogue {
            color: #aaffaa;
            font-style: italic;
            margin: 10px 0;
            padding-left: 20px;
            border-left: 2px solid #aaffaa;
        }
        
        .quest-update {
            color: #ffffaa;
            margin: 5px 0;
        }
        
        .item-effect {
            color: #aaaaff;
            font-style: italic;
        }
        
        /* CRT monitor effect */
        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            z-index: 9999;
        }
        
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                height: auto;
            }
            
            .class-selector {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="crt-overlay"></div>
    
    <div class="game-container">
        <div class="main-screen">
            <div class="screen-title">CHRONICLES OF AETHELGARD: ENHANCED</div>
            <div class="output-text" id="outputText">
                <p>WELCOME TO CHRONICLES OF AETHELGARD - ENHANCED EDITION</p>
                <p>A TRUE TEXT ADVENTURE RPG</p>
                <p>LOADING GAME SYSTEMS...</p>
                <p class="blink">_</p>
            </div>
            
            <div class="input-area">
                <input type="text" id="commandInput" placeholder="ENTER COMMAND...">
                <button id="submitButton">EXECUTE</button>
            </div>
            
            <div class="command-history" id="commandHistory">
                LAST COMMANDS:
            </div>
        </div>
        
        <div class="sidebar">
            <div class="player-stats">
                <h3>CHARACTER</h3>
                <div id="playerStats">
                    <p>NAME: <span id="playerName">-</span></p>
                    <p>CLASS: <span id="playerClass">-</span></p>
                    <p>LEVEL: <span id="playerLevel">1</span></p>
                    <div class="stat-row">
                        <span>HP:</span>
                        <span id="playerHP">-</span>
                    </div>
                    <div class="stat-row">
                        <span>MP:</span>
                        <span id="playerMP">-</span>
                    </div>
                    <div class="stat-row">
                        <span>XP:</span>
                        <span id="playerXP">0</span>
                    </div>
                    <div class="stat-row">
                        <span>GOLD:</span>
                        <span id="playerGold">0</span>
                    </div>
                    <div class="stat-row">
                        <span>ARMOR:</span>
                        <span id="playerArmor">0</span>
                    </div>
                    <div class="stat-row">
                        <span>DMG:</span>
                        <span id="playerDamage">1d4</span>
                    </div>
                </div>
            </div>
            
            <div class="location-info">
                <h3>LOCATION</h3>
                <p id="currentLocation">-</p>
            </div>
            
            <div class="quest-log">
                <h3>ACTIVE QUESTS</h3>
                <div class="quest-items" id="questList">
                    <p>NONE</p>
                </div>
            </div>
            
            <div class="inventory">
                <h3>INVENTORY</h3>
                <div class="inventory-items" id="inventoryList">
                    <p>EMPTY</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===================== ENHANCED GAME STATE =====================
        const gameState = {
            player: {
                name: "",
                class: "",
                level: 1,
                hp: 0,
                maxHP: 0,
                mp: 0,
                maxMP: 0,
                xp: 0,
                xpToNextLevel: 100,
                gold: 0,
                inventory: [],
                equipped: {
                    weapon: { name: "FISTS", damage: "1d4", type: "melee" },
                    armor: { name: "CLOTHES", defense: 0, type: "light" },
                    accessory: null
                },
                armorBonus: 0,
                damageBonus: 0,
                spells: [],
                abilities: [],
                quests: []
            },
            currentLocation: "town_square",
            gamePhase: "character_creation",
            combatEnemy: null,
            commandHistory: [],
            lastCommand: "",
            npcInConversation: null,
            shopOpen: false
        };

        // ===================== ENHANCED CLASSES =====================
        const classes = {
            WARRIOR: { 
                name: "WARRIOR", 
                hp: 25, 
                mp: 5, 
                desc: "A MIGHTY FIGHTER SKILLED WITH WEAPONS AND ARMOR. HIGH HP, STRONG MELEE.",
                startingItems: ["IRON_SWORD", "LEATHER_ARMOR", "HEALTH_POTION"],
                abilities: ["STRIKE", "CHARGE", "SHIELD_BASH"],
                spells: [],
                damageBonus: 2,
                armorBonus: 3
            },
            WIZARD: { 
                name: "WIZARD", 
                hp: 12, 
                mp: 30, 
                desc: "A SCHOLAR OF THE ARCANE ARTS, MASTER OF SPELLS. HIGH MP, POWERFUL SPELLS.",
                startingItems: ["OAK_STAFF", "ROBE", "MANA_POTION", "SCROLL_OF_FIREBALL"],
                abilities: [],
                spells: ["FIREBALL", "ICE_BOLT", "TELEPORT", "SHIELD"],
                damageBonus: 0,
                armorBonus: 0
            },
            ROGUE: { 
                name: "ROGUE", 
                hp: 18, 
                mp: 10, 
                desc: "A STEALTHY SCOUNDREL, DEADLY WITH DAGGERS AND TRAPS. HIGH CRITICAL CHANCE.",
                startingItems: ["DAGGER", "LEATHER_ARMOR", "LOCKPICK", "POISON"],
                abilities: ["BACKSTAB", "PICK_LOCK", "HIDE", "TRAP_DISARM"],
                spells: [],
                damageBonus: 3,
                armorBonus: 1
            },
            NECROMANCER: { 
                name: "NECROMANCER", 
                hp: 15, 
                mp: 25, 
                desc: "A DARK MAGE WHO COMMANDS THE DEAD AND DRAINS LIFE. CAN SUMMON MINIONS.",
                startingItems: ["BONE_STAFF", "DARK_ROBE", "SCROLL_OF_RAISE_DEAD"],
                abilities: [],
                spells: ["RAISE_DEAD", "LIFE_DRAIN", "FEAR", "DARK_BOLT"],
                damageBonus: 1,
                armorBonus: 0
            },
            THIEF: { 
                name: "THIEF", 
                hp: 16, 
                mp: 8, 
                desc: "A SNEAKY TRICKSTER, EXPERT AT STEALING AND EVASION. CAN POCKET GOLD.",
                startingItems: ["DAGGER", "LEATHER_ARMOR", "LOCKPICK", "THIEVES_TOOLS"],
                abilities: ["STEAL", "SNEAK_ATTACK", "PICKPOCKET", "EVADE"],
                spells: [],
                damageBonus: 2,
                armorBonus: 1
            },
            PRIEST: { 
                name: "PRIEST", 
                hp: 20, 
                mp: 20, 
                desc: "A HOLY SERVANT, HEALER AND BANE OF THE UNDEAD. EXCELLENT SUPPORT.",
                startingItems: ["MACE", "CHAIN_MAIL", "HEALTH_POTION", "HOLY_SYMBOL"],
                abilities: [],
                spells: ["HEAL", "TURN_UNDEAD", "BLESS", "SMITE"],
                damageBonus: 1,
                armorBonus: 2
            },
            SORCERER: { 
                name: "SORCERER", 
                hp: 14, 
                mp: 28, 
                desc: "A NATURAL BORN MAGIC USER WITH RAW POWER. VARIED ELEMENTAL SPELLS.",
                startingItems: ["WAND", "ROBE", "MANA_POTION", "SCROLL_OF_LIGHTNING"],
                abilities: [],
                spells: ["LIGHTNING_BOLT", "FIRE_BLAST", "ICE_STORM", "CHARM"],
                damageBonus: 0,
                armorBonus: 0
            },
            HEALER: { 
                name: "HEALER", 
                hp: 22, 
                mp: 18, 
                desc: "A DEVOTED MEDIC, SPECIALIZED IN HEALING AND PROTECTION. TEAM SUPPORT.",
                startingItems: ["STAFF", "ROBE", "HEALTH_POTION", "HEALING_HERBS"],
                abilities: [],
                spells: ["CURE", "PROTECTION", "REVIVE", "REGENERATE"],
                damageBonus: 0,
                armorBonus: 1
            }
        };

        // ===================== ENHANCED ITEMS =====================
        const items = {
            // Weapons
            IRON_SWORD: { name: "IRON SWORD", type: "weapon", damage: "1d8", value: 50, desc: "A basic iron sword." },
            OAK_STAFF: { name: "OAK STAFF", type: "weapon", damage: "1d6", magicBonus: 1, value: 40, desc: "A wooden staff that enhances magic." },
            DAGGER: { name: "DAGGER", type: "weapon", damage: "1d6", critChance: 0.2, value: 25, desc: "A small, concealable dagger." },
            BONE_STAFF: { name: "BONE STAFF", type: "weapon", damage: "1d6", necroBonus: 2, value: 60, desc: "A staff made of bones, enhances necromancy." },
            MACE: { name: "MACE", type: "weapon", damage: "1d8", holyBonus: 2, value: 45, desc: "A blunt weapon effective against undead." },
            WAND: { name: "WAND", type: "weapon", damage: "1d4", magicBonus: 2, value: 35, desc: "A wand that focuses magical energy." },
            STAFF: { name: "STAFF", type: "weapon", damage: "1d6", healingBonus: 2, value: 40, desc: "A staff that enhances healing magic." },
            DRAGONBANE_SWORD: { name: "DRAGONBANE SWORD", type: "weapon", damage: "2d8", dragonBonus: 5, value: 500, desc: "A legendary sword effective against dragons." },
            
            // Armor
            LEATHER_ARMOR: { name: "LEATHER ARMOR", type: "armor", defense: 2, value: 40, desc: "Light armor made of leather." },
            ROBE: { name: "ROBE", type: "armor", defense: 1, magicDefense: 2, value: 30, desc: "A simple robe with magical protection." },
            DARK_ROBE: { name: "DARK ROBE", type: "armor", defense: 1, necroDefense: 3, value: 55, desc: "A dark robe that enhances necromancy." },
            CHAIN_MAIL: { name: "CHAIN MAIL", type: "armor", defense: 4, value: 80, desc: "Medium armor made of interlocking chains." },
            PLATE_ARMOR: { name: "PLATE ARMOR", type: "armor", defense: 6, value: 150, desc: "Heavy plate armor offering great protection." },
            DRAGONSCALE_ARMOR: { name: "DRAGONSCALE ARMOR", type: "armor", defense: 8, fireResist: 5, value: 400, desc: "Armor made from dragon scales." },
            
            // Consumables
            HEALTH_POTION: { name: "HEALTH POTION", type: "consumable", effect: "heal", amount: 20, value: 25, desc: "Restores 20 HP." },
            MANA_POTION: { name: "MANA POTION", type: "consumable", effect: "mana", amount: 20, value: 30, desc: "Restores 20 MP." },
            POISON: { name: "POISON", type: "consumable", effect: "poison", amount: 10, value: 40, desc: "Poisons a weapon for 10 damage over 3 turns." },
            HEALING_HERBS: { name: "HEALING HERBS", type: "consumable", effect: "heal", amount: 10, value: 15, desc: "Simple herbs that heal 10 HP." },
            
            // Scrolls
            SCROLL_OF_FIREBALL: { name: "SCROLL OF FIREBALL", type: "scroll", spell: "FIREBALL", value: 100, desc: "Cast Fireball spell once." },
            SCROLL_OF_RAISE_DEAD: { name: "SCROLL OF RAISE DEAD", type: "scroll", spell: "RAISE_DEAD", value: 150, desc: "Cast Raise Dead spell once." },
            SCROLL_OF_LIGHTNING: { name: "SCROLL OF LIGHTNING", type: "scroll", spell: "LIGHTNING_BOLT", value: 120, desc: "Cast Lightning Bolt spell once." },
            SCROLL_OF_TELEPORT: { name: "SCROLL OF TELEPORT", type: "scroll", spell: "TELEPORT", value: 200, desc: "Cast Teleport spell once." },
            
            // Quest Items
            GOBLIN_EARS: { name: "GOBLIN EARS", type: "quest", value: 5, desc: "Proof of slain goblins." },
            DRAGON_SCALE: { name: "DRAGON SCALE", type: "quest", value: 100, desc: "A scale from a dragon." },
            ANCIENT_AMULET: { name: "ANCIENT AMULET", type: "quest", value: 250, desc: "An ancient magical amulet." },
            HOLY_SYMBOL: { name: "HOLY SYMBOL", type: "accessory", holyBonus: 3, value: 120, desc: "A symbol that enhances holy magic." },
            
            // Tools
            LOCKPICK: { name: "LOCKPICK", type: "tool", value: 20, desc: "Used to pick locks." },
            THIEVES_TOOLS: { name: "THIEVES TOOLS", type: "tool", value: 50, desc: "A set of tools for thievery." },
            TORCH: { name: "TORCH", type: "tool", value: 5, desc: "Provides light in dark places." }
        };

        // ===================== ENHANCED LOCATIONS =====================
        const locations = {
            town_square: {
                name: "TOWN SQUARE",
                desc: "THE HEART OF AETHELGARD. TO THE NORTH IS THE DARK FOREST, EAST THE DRAGON'S CAVE, SOUTH THE MARKET, WEST THE ABANDONED TEMPLE. A FOUNTAIN BUBBLES IN THE CENTER.",
                exits: {north: "dark_forest", east: "dragons_cave", south: "market", west: "abandoned_temple"},
                items: ["TORCH"],
                npcs: ["GUARD_CAPTAIN"],
                encounters: []
            },
            dark_forest: {
                name: "DARK FOREST",
                desc: "AN EERIE FOREST WITH TWISTED TREES. THE AIR IS COLD AND STILL. YOU HEAR STRANGE NOISES IN THE DISTANCE.",
                exits: {south: "town_square", east: "witch_hut", north: "forest_deep"},
                items: ["HEALING_HERBS", "HEALING_HERBS"],
                npcs: [],
                encounters: ["GOBLIN", "WOLF", "GOBLIN"]
            },
            forest_deep: {
                name: "DEEP FOREST",
                desc: "THE DEEPEST PART OF THE FOREST WHERE LIGHT BARELY PENETRATES. DANGEROUS CREATURES LURK HERE.",
                exits: {south: "dark_forest"},
                items: ["ANCIENT_AMULET"],
                npcs: [],
                encounters: ["WOLF", "BEAR", "GOBLIN_SHAMAN"]
            },
            dragons_cave: {
                name: "DRAGON'S CAVE ENTRANCE",
                desc: "A MASSIVE CAVE MOUTH EMITS HEAT AND THE SMELL OF SULFUR. TREASURE LIES WITHIN, BUT SO DOES THE DRAGON.",
                exits: {west: "town_square", enter: "dragons_lair"},
                items: ["DRAGON_SCALE"],
                npcs: [],
                encounters: ["FIRE_SNAKE", "FIRE_SNAKE"]
            },
            market: {
                name: "MARKETPLACE",
                desc: "A BUSY MARKET WITH VARIOUS VENDORS. YOU CAN BUY SUPPLIES HERE. THE BLACKSMITH AND ALCHEMIST HAVE SHOPS HERE.",
                exits: {north: "town_square", east: "tavern", west: "blacksmith", south: "alchemist"},
                items: [],
                npcs: ["MERCHANT", "BLACKSMITH", "ALCHEMIST"],
                encounters: []
            },
            abandoned_temple: {
                name: "ABANDONED TEMPLE",
                desc: "A CRUMBLING TEMPLE FILLED WITH BROKEN STATUES. DARK ENERGY PERVADES THE AIR.",
                exits: {east: "town_square", down: "crypt"},
                items: ["HOLY_SYMBOL"],
                npcs: [],
                encounters: ["ZOMBIE", "SKELETON"]
            },
            witch_hut: {
                name: "WITCH'S HUT",
                desc: "A SMALL COTTAGE SURROUNDED BY STRANGE PLANTS. A WITCH OFFERS POTIONS AND ADVICE.",
                exits: {west: "dark_forest"},
                items: [],
                npcs: ["WITCH"],
                encounters: []
            },
            tavern: {
                name: "THE DRUNKEN DRAGON TAVERN",
                desc: "A NOISY TAVERN FILLED WITH ADVENTURERS. YOU CAN HEAR RUMORS HERE AND FIND WORK.",
                exits: {west: "market"},
                items: [],
                npcs: ["BARKEEP", "MERCENARY"],
                encounters: ["DRUNKEN_SALLOR"]
            },
            crypt: {
                name: "ANCIENT CRYPT",
                desc: "A DANK UNDERGROUND BURIAL PLACE. BONES LITTER THE FLOOR. THE AIR IS THICK WITH DARK MAGIC.",
                exits: {up: "abandoned_temple"},
                items: ["ANCIENT_AMULET"],
                npcs: [],
                encounters: ["VAMPIRE", "WRAITH", "SKELETON"]
            },
            dragons_lair: {
                name: "DRAGON'S LAIR",
                desc: "A VAST CAVERN PILED HIGH WITH GOLD AND TREASURE. THE DRAGON SLEEPS AHEAD.",
                exits: {out: "dragons_cave"},
                items: ["DRAGONBANE_SWORD", "DRAGONSCALE_ARMOR", "DRAGON_SCALE", "DRAGON_SCALE", "DRAGON_SCALE"],
                npcs: [],
                encounters: ["DRAGON_LORD"]
            },
            blacksmith: {
                name: "BLACKSMITH'S SHOP",
                desc: "A HOT FORGE DOMINATES THE ROOM. WEAPONS AND ARMOR LINE THE WALLS.",
                exits: {east: "market"},
                items: [],
                npcs: ["BLACKSMITH"],
                encounters: []
            },
            alchemist: {
                name: "ALCHEMIST'S SHOP",
                desc: "GLASS BOTTLES AND STRANGE INGREDIENTS FILL THE SHELVES. POTIONS BUBBLE GENTLY.",
                exits: {north: "market"},
                items: [],
                npcs: ["ALCHEMIST"],
                encounters: []
            }
        };

        // ===================== ENHANCED NPCS =====================
        const npcs = {
            GUARD_CAPTAIN: {
                name: "GUARD CAPTAIN",
                location: "town_square",
                dialogue: [
                    "WE'VE HAD GOBLIN TROUBLES LATELY. BRING ME 5 GOBLIN EARS AND I'LL REWARD YOU.",
                    "THE DRAGON TO THE EAST IS BECOMING BOLDER. SOMEONE NEEDS TO DEAL WITH IT."
                ],
                quest: "GOBLIN_HUNT",
                shop: null,
                givesGold: 100,
                givesItems: ["CHAIN_MAIL"]
            },
            MERCHANT: {
                name: "MERCHANT",
                location: "market",
                dialogue: [
                    "WELCOME TRAVELER! I HAVE MANY GOODS FOR SALE.",
                    "CAREFUL IN THE FOREST, GOBLINS HAVE BEEN ACTIVE."
                ],
                quest: null,
                shop: ["HEALTH_POTION", "MANA_POTION", "TORCH", "LEATHER_ARMOR", "DAGGER"],
                givesGold: 0,
                givesItems: []
            },
            WITCH: {
                name: "WITCH",
                location: "witch_hut",
                dialogue: [
                    "I SENSE DARK MAGIC FROM THE CRYPT. THE DEAD REST UNEASILY.",
                    "I CAN SELL YOU POTIONS AND SCROLLS, FOR A PRICE."
                ],
                quest: "CLEANSE_CRYPT",
                shop: ["HEALTH_POTION", "MANA_POTION", "SCROLL_OF_FIREBALL", "SCROLL_OF_TELEPORT"],
                givesGold: 200,
                givesItems: ["SCROLL_OF_TELEPORT"]
            },
            BARKEEP: {
                name: "BARKEEP",
                location: "tavern",
                dialogue: [
                    "WHAT'LL IT BE? ALE'S 5 GOLD. FOOD'S 10.",
                    "HEARD THE BLACKSMITH NEEDS DRAGON SCALES. PAYS WELL."
                ],
                quest: null,
                shop: ["HEALTH_POTION", "TORCH"],
                givesGold: 0,
                givesItems: []
            },
            MERCENARY: {
                name: "MERCENARY",
                location: "tavern",
                dialogue: [
                    "THE DRAGON'S HOARD IS LEGENDARY. TOO BAD THE BEAST'S TOO STRONG.",
                    "I'D JOIN YOU, BUT I'M TOO SMART TO FIGHT A DRAGON."
                ],
                quest: null,
                shop: null,
                givesGold: 0,
                givesItems: []
            },
            BLACKSMITH: {
                name: "BLACKSMITH",
                location: "blacksmith",
                dialogue: [
                    "NEED SOME DRAGON SCALES FOR SPECIAL ARMOR. I'LL PAY 100 GOLD EACH.",
                    "MY BEST WORK REQUIRES RARE MATERIALS."
                ],
                quest: "DRAGON_SCALES",
                shop: ["IRON_SWORD", "MACE", "CHAIN_MAIL", "PLATE_ARMOR"],
                givesGold: 100,
                givesItems: []
            },
            ALCHEMIST: {
                name: "ALCHEMIST",
                location: "alchemist",
                dialogue: [
                    "POTIONS, ELIXIRS, REMEDIES FOR WHAT AILS YOU.",
                    "I HEAR THE WITCH HAS RARE SCROLLS FOR SALE."
                ],
                quest: null,
                shop: ["HEALTH_POTION", "MANA_POTION", "POISON", "HEALING_HERBS"],
                givesGold: 0,
                givesItems: []
            }
        };

        // ===================== ENHANCED ENEMIES =====================
        const enemies = {
            GOBLIN: { 
                name: "GOBLIN", 
                hp: 15, 
                damage: "1d6", 
                xp: 25, 
                gold: "1d10",
                loot: ["GOBLIN_EARS"],
                resistance: [],
                weakness: []
            },
            WOLF: { 
                name: "WOLF", 
                hp: 12, 
                damage: "1d8", 
                xp: 20, 
                gold: "0",
                loot: [],
                resistance: [],
                weakness: ["fire"]
            },
            BEAR: { 
                name: "BEAR", 
                hp: 35, 
                damage: "2d6", 
                xp: 50, 
                gold: "0",
                loot: [],
                resistance: [],
                weakness: []
            },
            GOBLIN_SHAMAN: { 
                name: "GOBLIN SHAMAN", 
                hp: 25, 
                damage: "1d8", 
                magicDamage: "2d4",
                xp: 60, 
                gold: "3d10",
                loot: ["GOBLIN_EARS", "HEALING_HERBS"],
                resistance: ["magic"],
                weakness: []
            },
            ZOMBIE: { 
                name: "ZOMBIE", 
                hp: 22, 
                damage: "1d6", 
                xp: 30, 
                gold: "1d6",
                loot: [],
                resistance: ["poison"],
                weakness: ["holy", "fire"]
            },
            SKELETON: { 
                name: "SKELETON", 
                hp: 18, 
                damage: "1d8", 
                xp: 35, 
                gold: "2d6",
                loot: [],
                resistance: ["piercing"],
                weakness: ["blunt", "holy"]
            },
            DRUNKEN_SALLOR: { 
                name: "DRUNKEN SALLOR", 
                hp: 10, 
                damage: "1d4", 
                xp: 10, 
                gold: "2d8",
                loot: [],
                resistance: [],
                weakness: []
            },
            VAMPIRE: { 
                name: "VAMPIRE", 
                hp: 40, 
                damage: "2d8", 
                xp: 100, 
                gold: "5d10",
                loot: ["ANCIENT_AMULET"],
                resistance: ["dark"],
                weakness: ["holy", "fire"]
            },
            WRAITH: { 
                name: "WRAITH", 
                hp: 30, 
                damage: "2d6", 
                xp: 80, 
                gold: "3d10",
                loot: [],
                resistance: ["physical"],
                weakness: ["holy", "light"]
            },
            FIRE_SNAKE: { 
                name: "FIRE SNAKE", 
                hp: 25, 
                damage: "1d10", 
                fireDamage: "1d6",
                xp: 50, 
                gold: "2d8",
                loot: [],
                resistance: ["fire"],
                weakness: ["ice", "water"]
            },
            DRAGON: { 
                name: "DRAGON", 
                hp: 80, 
                damage: "3d10", 
                fireBreath: "4d8",
                xp: 300, 
                gold: "10d20",
                loot: ["DRAGON_SCALE"],
                resistance: ["fire"],
                weakness: ["ice", "dragonbane"]
            },
            DRAGON_LORD: { 
                name: "DRAGON LORD", 
                hp: 150, 
                damage: "4d12", 
                fireBreath: "5d10",
                xp: 1000, 
                gold: "20d50",
                loot: ["DRAGON_SCALE", "DRAGON_SCALE", "DRAGON_SCALE"],
                resistance: ["fire", "magic"],
                weakness: ["dragonbane", "holy"]
            }
        };

        // ===================== QUESTS =====================
        const quests = {
            GOBLIN_HUNT: {
                name: "GOBLIN HUNT",
                description: "THE GUARD CAPTAIN WANTS YOU TO ELIMINATE GOBLIN THREATS. BRING HIM 5 GOBLIN EARS.",
                objective: { type: "collect", item: "GOBLIN_EARS", amount: 5 },
                reward: { gold: 100, item: "CHAIN_MAIL", xp: 200 },
                completed: false
            },
            CLEANSE_CRYPT: {
                name: "CLEANSE THE CRYPT",
                description: "THE WITCH ASKS YOU TO CLEANSE THE ANCIENT CRYPT OF UNDEAD. DEFEAT THE VAMPIRE WITHIN.",
                objective: { type: "kill", enemy: "VAMPIRE" },
                reward: { gold: 200, item: "SCROLL_OF_TELEPORT", xp: 300 },
                completed: false
            },
            DRAGON_SCALES: {
                name: "DRAGON SCALES",
                description: "THE BLACKSMITH NEEDS DRAGON SCALES FOR SPECIAL ARMOR. BRING HIM 3 DRAGON SCALES.",
                objective: { type: "collect", item: "DRAGON_SCALE", amount: 3 },
                reward: { gold: 300, item: "PLATE_ARMOR", xp: 400 },
                completed: false
            },
            SLAY_DRAGON_LORD: {
                name: "SLAY THE DRAGON LORD",
                description: "THE ULTIMATE QUEST. DEFEAT THE DRAGON LORD IN HIS LAIR AND SAVE AETHELGARD.",
                objective: { type: "kill", enemy: "DRAGON_LORD" },
                reward: { gold: 1000, item: null, xp: 1000 },
                completed: false
            }
        };

        // ===================== SPELLS =====================
        const spells = {
            FIREBALL: {
                name: "FIREBALL",
                mpCost: 10,
                damage: "3d8",
                type: "fire",
                desc: "LAUNCHES A BALL OF FIRE AT ENEMIES.",
                aoe: true
            },
            ICE_BOLT: {
                name: "ICE BOLT",
                mpCost: 8,
                damage: "2d10",
                type: "ice",
                desc: "FIRES A BOLT OF ICY ENERGY.",
                aoe: false
            },
            LIGHTNING_BOLT: {
                name: "LIGHTNING BOLT",
                mpCost: 12,
                damage: "3d10",
                type: "lightning",
                desc: "STRIKES WITH A BOLT OF LIGHTNING.",
                aoe: false
            },
            HEAL: {
                name: "HEAL",
                mpCost: 8,
                heal: "2d8+5",
                type: "healing",
                desc: "RESTORES HEALTH TO THE CASTER OR ALLY.",
                aoe: false
            },
            RAISE_DEAD: {
                name: "RAISE DEAD",
                mpCost: 15,
                type: "necromancy",
                desc: "SUMMONS A SKELETON ALLY TO FIGHT FOR YOU.",
                aoe: false
            },
            LIFE_DRAIN: {
                name: "LIFE DRAIN",
                mpCost: 10,
                damage: "2d8",
                heal: "1d8",
                type: "necromancy",
                desc: "DRAINS LIFE FROM THE TARGET TO HEAL THE CASTER.",
                aoe: false
            },
            TELEPORT: {
                name: "TELEPORT",
                mpCost: 20,
                type: "utility",
                desc: "TELEPORTS THE CASTER BACK TO TOWN SQUARE.",
                aoe: false
            },
            SHIELD: {
                name: "SHIELD",
                mpCost: 5,
                defense: 5,
                type: "protection",
                desc: "CREATES A MAGICAL SHIELD THAT REDUCES DAMAGE.",
                aoe: false
            },
            TURN_UNDEAD: {
                name: "TURN UNDEAD",
                mpCost: 10,
                damage: "4d6",
                type: "holy",
                desc: "DAMAGES UNDEAD ENEMIES AND MAY DESTROY WEAK ONES.",
                aoe: true
            },
            BLESS: {
                name: "BLESS",
                mpCost: 6,
                type: "holy",
                desc: "INCREASES ATTACK AND DEFENSE FOR A SHORT TIME.",
                aoe: false
            }
        };

        // ===================== DOM ELEMENTS =====================
        const outputText = document.getElementById('outputText');
        const commandInput = document.getElementById('commandInput');
        const submitButton = document.getElementById('submitButton');
        const commandHistory = document.getElementById('commandHistory');
        
        const playerNameEl = document.getElementById('playerName');
        const playerClassEl = document.getElementById('playerClass');
        const playerLevelEl = document.getElementById('playerLevel');
        const playerHPElement = document.getElementById('playerHP');
        const playerMPElement = document.getElementById('playerMP');
        const playerXPElement = document.getElementById('playerXP');
        const playerGoldElement = document.getElementById('playerGold');
        const playerArmorEl = document.getElementById('playerArmor');
        const playerDamageEl = document.getElementById('playerDamage');
        const currentLocationEl = document.getElementById('currentLocation');
        const inventoryList = document.getElementById('inventoryList');
        const questList = document.getElementById('questList');

        // ===================== GAME INITIALIZATION =====================
        function initGame() {
            clearOutput();
            output("CHRONICLES OF AETHELGARD: ENHANCED EDITION");
            output("A TRUE TEXT ADVENTURE RPG");
            output("");
            output("FEATURES:");
            output("- 8 UNIQUE CLASSES WITH DIFFERENT ABILITIES");
            output("- FUNCTIONAL ITEMS, SPELLS, AND EQUIPMENT");
            output("- NPCs WITH QUESTS AND SHOPS");
            output("- ECONOMY WITH BUYING/SELLING");
            output("- QUEST SYSTEM WITH REWARDS");
            output("");
            output("ENTER YOUR NAME, ADVENTURER:");
            
            commandInput.focus();
            
            submitButton.addEventListener('click', processCommand);
            commandInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    processCommand();
                }
            });
            
            gameState.gamePhase = "character_creation_name";
        }

        // ===================== COMMAND PROCESSING =====================
        function processCommand() {
            const command = commandInput.value.trim().toUpperCase();
            if (!command) return;
            
            gameState.commandHistory.unshift(command);
            if (gameState.commandHistory.length > 5) {
                gameState.commandHistory.pop();
            }
            
            updateCommandHistory();
            gameState.lastCommand = command;
            commandInput.value = "";
            
            switch(gameState.gamePhase) {
                case "character_creation_name":
                    processName(command);
                    break;
                case "character_creation_class":
                    processClass(command);
                    break;
                case "playing":
                    processGameCommand(command);
                    break;
                case "combat":
                    processCombatCommand(command);
                    break;
                case "shop":
                    processShopCommand(command);
                    break;
                case "npc_talk":
                    processNPCTalk(command);
                    break;
                case "game_over":
                    if (command === "RESTART") restartGame();
                    break;
                case "victory":
                    if (command === "RESTART") restartGame();
                    break;
            }
        }

        function processName(name) {
            if (name.length < 2) {
                output("NAME MUST BE AT LEAST 2 CHARACTERS LONG.");
                output("ENTER YOUR NAME:");
                return;
            }
            
            gameState.player.name = name;
            gameState.gamePhase = "character_creation_class";
            
            clearOutput();
            output(`WELCOME, ${name}!`);
            output("CHOOSE YOUR CLASS:");
            output("");
            
            const classKeys = Object.keys(classes);
            for (let i = 0; i < classKeys.length; i += 2) {
                const class1 = classes[classKeys[i]];
                const class2 = classes[classKeys[i+1]];
                
                if (class2) {
                    output(`${class1.name.padEnd(15)} ${class2.name}`);
                } else {
                    output(class1.name);
                }
            }
            
            output("");
            output("ENTER THE NAME OF YOUR CHOSEN CLASS:");
        }

        function processClass(className) {
            const selectedClass = Object.values(classes).find(c => c.name === className);
            
            if (!selectedClass) {
                output("INVALID CLASS. PLEASE ENTER A VALID CLASS NAME:");
                return;
            }
            
            // Initialize player with class
            gameState.player.class = selectedClass.name;
            gameState.player.maxHP = selectedClass.hp;
            gameState.player.hp = selectedClass.hp;
            gameState.player.maxMP = selectedClass.mp;
            gameState.player.mp = selectedClass.mp;
            gameState.player.armorBonus = selectedClass.armorBonus;
            gameState.player.damageBonus = selectedClass.damageBonus;
            gameState.player.spells = [...selectedClass.spells];
            gameState.player.abilities = [...selectedClass.abilities];
            
            // Add starting items
            selectedClass.startingItems.forEach(itemName => {
                addItemToInventory(itemName);
            });
            
            // Equip starting gear
            const weaponItem = selectedClass.startingItems.find(itemName => items[itemName]?.type === "weapon");
            const armorItem = selectedClass.startingItems.find(itemName => items[itemName]?.type === "armor");
            
            if (weaponItem) equipItem(weaponItem);
            if (armorItem) equipItem(armorItem);
            
            // Add main quest
            gameState.player.quests.push({...quests.SLAY_DRAGON_LORD});
            
            updateUI();
            gameState.gamePhase = "playing";
            
            clearOutput();
            output(`YOU ARE ${gameState.player.name}, A ${gameState.player.class}.`);
            output(selectedClass.desc);
            output("");
            output("YOUR ADVENTURE BEGINS!");
            output("TYPE 'HELP' FOR A LIST OF COMMANDS.");
            output("");
            describeLocation();
        }

        function processGameCommand(command) {
    const words = command.split(' ');
    const verb = words[0];
    const noun = words.slice(1).join(' ');
    
    // Check if we're in conversation with an NPC
    if (gameState.npcInConversation) {
        // Check if this is a conversation-specific command
        if (verb === 'QUEST' || verb === 'COMPLETE' || verb === 'SHOP' || 
            verb === 'BYE' || verb === 'GOODBYE' || verb === 'LEAVE' ||
            verb === 'BUY' || verb === 'SELL') {
            processNPCTalk(command);
            return;
        }
        // If it's a general command, allow it but stay in conversation
        // This lets players check inventory, stats, etc while talking
    }
    
    // Handle shop commands if shop is open
    if (gameState.shopOpen) {
        processShopCommand(command);
        return;
    }
    
    // Now process the command based on verb
    switch(verb) {
        case 'HELP':
            showHelp();
            break;
        case 'LOOK':
        case 'L':
            // If in conversation, show location but keep NPC reference
            if (gameState.npcInConversation) {
                output(`(You glance around while talking to ${gameState.npcInConversation.name})`);
                describeLocationBrief();
            } else {
                describeLocation();
            }
            break;
        case 'GO':
        case 'MOVE':
        case 'WALK':
            // If in conversation, moving away should end conversation
            if (gameState.npcInConversation) {
                output(`You end the conversation with ${gameState.npcInConversation.name} and walk away.`);
                gameState.npcInConversation = null;
                gameState.shopOpen = false;
            }
            movePlayer(noun);
            break;
        case 'NORTH':
        case 'N':
        case 'SOUTH':
        case 'S':
        case 'EAST':
        case 'E':
        case 'WEST':
        case 'W':
        case 'UP':
        case 'U':
        case 'DOWN':
        case 'D':
            // Movement ends conversation
            if (gameState.npcInConversation) {
                output(`You end the conversation with ${gameState.npcInConversation.name} and walk away.`);
                gameState.npcInConversation = null;
                gameState.shopOpen = false;
            }
            movePlayer(verb);
            break;
        case 'ENTER':
            if (gameState.npcInConversation) {
                output(`You end the conversation with ${gameState.npcInConversation.name}.`);
                gameState.npcInConversation = null;
                gameState.shopOpen = false;
            }
            movePlayer('ENTER');
            break;
        case 'OUT':
            if (gameState.npcInConversation) {
                output(`You end the conversation with ${gameState.npcInConversation.name}.`);
                gameState.npcInConversation = null;
                gameState.shopOpen = false;
            }
            movePlayer('OUT');
            break;
        case 'INVENTORY':
        case 'I':
            showInventory();
            break;
        case 'GET':
        case 'TAKE':
            if (gameState.npcInConversation) {
                output(`You can't take items while talking to ${gameState.npcInConversation.name}.`);
            } else {
                takeItem(noun);
            }
            break;
        case 'DROP':
            if (gameState.npcInConversation) {
                output(`You can't drop items while talking to ${gameState.npcInConversation.name}.`);
            } else {
                dropItem(noun);
            }
            break;
        case 'USE':
            if (gameState.npcInConversation) {
                output(`You can't use items while talking to ${gameState.npcInConversation.name}.`);
            } else {
                useItem(noun);
            }
            break;
        case 'EQUIP':
            if (gameState.npcInConversation) {
                output(`You can't equip items while talking to ${gameState.npcInConversation.name}.`);
            } else {
                equipItem(noun);
            }
            break;
        case 'STATUS':
        case 'STATS':
            showStatus();
            break;
        case 'SPELLS':
            showSpells();
            break;
        case 'CAST':
            if (gameState.npcInConversation) {
                output(`You can't cast spells while talking to ${gameState.npcInConversation.name}.`);
            } else if (noun) {
                castSpell(noun);
            } else {
                output("CAST WHAT SPELL?");
            }
            break;
        case 'ATTACK':
        case 'FIGHT':
            if (gameState.npcInConversation) {
                output(`You can't attack while talking to ${gameState.npcInConversation.name}.`);
            } else if (noun) {
                startCombat(noun);
            } else {
                output("ATTACK WHAT?");
            }
            break;
        case 'TALK':
        case 'SPEAK':
            if (gameState.npcInConversation) {
                output(`You're already talking to ${gameState.npcInConversation.name}. Type 'BYE' to end the conversation.`);
            } else if (noun) {
                talkToNPC(noun);
            } else {
                output("TALK TO WHO?");
            }
            break;
        case 'BUY':
            if (noun) {
                // If in conversation with a shopkeeper, process buy command
                if (gameState.npcInConversation && gameState.npcInConversation.shop) {
                    processNPCTalk(command);
                } else if (gameState.shopOpen) {
                    processShopCommand(command);
                } else {
                    output("THERE'S NO SHOP HERE.");
                }
            } else {
                output("BUY WHAT? (USE 'SHOP' TO SEE ITEMS)");
            }
            break;
        case 'SELL':
            if (noun) {
                // If in conversation with a shopkeeper, process sell command
                if (gameState.npcInConversation && gameState.npcInConversation.shop) {
                    processNPCTalk(command);
                } else if (gameState.shopOpen) {
                    processShopCommand(command);
                } else {
                    output("THERE'S NO ONE TO SELL TO.");
                }
            } else {
                output("SELL WHAT?");
            }
            break;
        case 'SHOP':
            if (gameState.npcInConversation && gameState.npcInConversation.shop) {
                processNPCTalk(command);
            } else {
                output("THERE'S NO SHOP HERE.");
            }
            break;
        case 'QUESTS':
        case 'Q':
            showQuests();
            break;
        case 'REST':
            if (gameState.npcInConversation) {
                output(`You can't rest while talking to ${gameState.npcInConversation.name}.`);
            } else {
                rest();
            }
            break;
        case 'QUIT':
            output("THANKS FOR PLAYING! REFRESH THE PAGE TO RESTART.");
            gameState.gamePhase = "game_over";
            break;
        default:
            // If we're talking to an NPC and they don't understand, show a friendly message
            if (gameState.npcInConversation) {
                output(`${gameState.npcInConversation.name} LOOKS CONFUSED.`);
                output("TRY: QUEST, SHOP, BUY [ITEM], SELL [ITEM], or BYE");
            } else {
                output("I DON'T UNDERSTAND THAT COMMAND. TYPE 'HELP' FOR A LIST.");
            }
    }
}

// Add this helper function for brief location description while talking
function describeLocationBrief() {
    const location = locations[gameState.currentLocation];
    output(`YOU ARE AT THE ${location.name}.`);
    
    // Show exits briefly
    const exitNames = Object.keys(location.exits);
    if (exitNames.length > 0) {
        output("EXITS: " + exitNames.map(exit => exit.toUpperCase()).join(", "));
    }
    
    // Show items briefly
    if (location.items.length > 0) {
        output("ITEMS HERE: " + location.items.join(", "));
    }
}

        // ===================== ENHANCED GAME FUNCTIONS =====================
        function showHelp() {
            clearOutput();
            output("AVAILABLE COMMANDS:");
            output("-------------------");
            output("MOVEMENT: N, S, E, W, UP, DOWN, GO [DIRECTION]");
            output("LOOK/L - DESCRIBE CURRENT LOCATION");
            output("INVENTORY/I - SHOW INVENTORY");
            output("GET/TAKE [ITEM] - PICK UP ITEM");
            output("DROP [ITEM] - DROP ITEM");
            output("USE [ITEM] - USE AN ITEM");
            output("EQUIP [ITEM] - EQUIP WEAPON OR ARMOR");
            output("STATUS - SHOW CHARACTER STATS");
            output("SPELLS - LIST AVAILABLE SPELLS");
            output("CAST [SPELL] - CAST A SPELL");
            output("ATTACK [ENEMY] - ATTACK AN ENEMY");
            output("TALK [NPC] - TALK TO AN NPC");
            output("SHOP - VIEW SHOP ITEMS");
            output("BUY [ITEM] - BUY AN ITEM");
            output("SELL [ITEM] - SELL AN ITEM");
            output("QUESTS - SHOW ACTIVE QUESTS");
            output("REST - REST TO REGAIN HP/MP");
            output("QUIT - EXIT THE GAME");
        }

        function describeLocation() {
            const location = locations[gameState.currentLocation];
            output(location.name);
            output("");
            output(location.desc);
            output("");
            
            // Show exits
            const exitNames = Object.keys(location.exits);
            if (exitNames.length > 0) {
                output("EXITS: " + exitNames.map(exit => exit.toUpperCase()).join(", "));
            }
            
            // Show items
            if (location.items.length > 0) {
                output("YOU SEE: " + location.items.join(", "));
            }
            
            // Show NPCs
            if (location.npcs.length > 0) {
                output("PEOPLE HERE: " + location.npcs.map(npc => npcs[npc].name).join(", "));
            }
            
            // Random encounter chance
            if (location.encounters.length > 0 && Math.random() < 0.3) {
                const enemyType = location.encounters[Math.floor(Math.random() * location.encounters.length)];
                startCombat(enemyType);
            }
        }

        function movePlayer(direction) {
            const location = locations[gameState.currentLocation];
            const normalizedDirection = direction.toLowerCase();
            
            if (location.exits[normalizedDirection]) {
                gameState.currentLocation = location.exits[normalizedDirection];
                updateLocation();
                clearOutput();
                describeLocation();
            } else {
                output(`YOU CAN'T GO ${direction.toUpperCase()} FROM HERE.`);
            }
        }

        function takeItem(itemName) {
            const location = locations[gameState.currentLocation];
            const itemIndex = location.items.findIndex(item => item === itemName);
            
            if (itemIndex !== -1) {
                addItemToInventory(itemName);
                location.items.splice(itemIndex, 1);
                output(`YOU TOOK THE ${itemName}.`);
                updateInventory();
            } else {
                output(`THERE IS NO ${itemName} HERE.`);
            }
        }

        function addItemToInventory(itemName) {
            if (gameState.player.inventory.length >= 20) {
                output("YOUR INVENTORY IS FULL!");
                return false;
            }
            
            gameState.player.inventory.push(itemName);
            updateInventory();
            return true;
        }

        function dropItem(itemName) {
            const itemIndex = gameState.player.inventory.findIndex(item => item === itemName);
            
            if (itemIndex !== -1) {
                gameState.player.inventory.splice(itemIndex, 1);
                locations[gameState.currentLocation].items.push(itemName);
                output(`YOU DROPPED THE ${itemName}.`);
                updateInventory();
            } else {
                output(`YOU DON'T HAVE A ${itemName}.`);
            }
        }

        function useItem(itemName) {
            if (!gameState.player.inventory.includes(itemName)) {
                output(`YOU DON'T HAVE A ${itemName}.`);
                return;
            }
            
            const item = items[itemName];
            if (!item) {
                output(`CANNOT USE ${itemName}.`);
                return;
            }
            
            switch(item.type) {
                case "consumable":
                    if (item.effect === "heal") {
                        const healAmount = item.amount;
                        gameState.player.hp = Math.min(gameState.player.maxHP, gameState.player.hp + healAmount);
                        output(`YOU USE THE ${itemName} AND RESTORE ${healAmount} HP.`);
                        removeFromInventory(itemName);
                        updatePlayerStats();
                    } else if (item.effect === "mana") {
                        const manaAmount = item.amount;
                        gameState.player.mp = Math.min(gameState.player.maxMP, gameState.player.mp + manaAmount);
                        output(`YOU USE THE ${itemName} AND RESTORE ${manaAmount} MP.`);
                        removeFromInventory(itemName);
                        updatePlayerStats();
                    } else if (item.effect === "poison") {
                        output(`YOU APPLY THE ${itemName} TO YOUR WEAPON.`);
                        // In a more complex system, this would apply a poison effect
                        removeFromInventory(itemName);
                    }
                    break;
                    
                case "scroll":
                    if (gameState.gamePhase === "combat") {
                        output(`YOU USE THE ${itemName} TO CAST ${item.spell}!`);
                        // Cast the spell from scroll
                        castSpellFromScroll(item.spell);
                        removeFromInventory(itemName);
                    } else {
                        output(`YOU CAN ONLY USE SCROLLS IN COMBAT.`);
                    }
                    break;
                    
                case "tool":
                    if (itemName === "TORCH") {
                        output("THE TORCH PROVIDES LIGHT, BUT YOU'RE NOT IN A DARK AREA.");
                    } else if (itemName === "LOCKPICK" || itemName === "THIEVES_TOOLS") {
                        output("THERE'S NOTHING TO PICK HERE.");
                    }
                    break;
                    
                default:
                    output(`YOU CAN'T USE THE ${itemName} DIRECTLY.`);
            }
        }

        function equipItem(itemName) {
            if (!gameState.player.inventory.includes(itemName)) {
                output(`YOU DON'T HAVE A ${itemName}.`);
                return;
            }
            
            const item = items[itemName];
            if (!item) {
                output(`CANNOT EQUIP ${itemName}.`);
                return;
            }
            
            if (item.type === "weapon") {
                // Unequip current weapon
                if (gameState.player.equipped.weapon.name !== "FISTS") {
                    gameState.player.inventory.push(gameState.player.equipped.weapon.name);
                }
                
                gameState.player.equipped.weapon = item;
                output(`YOU EQUIP THE ${itemName}.`);
                updateInventory();
                updatePlayerStats();
            } else if (item.type === "armor") {
                // Unequip current armor
                if (gameState.player.equipped.armor.name !== "CLOTHES") {
                    gameState.player.inventory.push(gameState.player.equipped.armor.name);
                }
                
                gameState.player.equipped.armor = item;
                output(`YOU EQUIP THE ${itemName}.`);
                updateInventory();
                updatePlayerStats();
            } else if (item.type === "accessory") {
                // Unequip current accessory
                if (gameState.player.equipped.accessory) {
                    gameState.player.inventory.push(gameState.player.equipped.accessory.name);
                }
                
                gameState.player.equipped.accessory = item;
                output(`YOU EQUIP THE ${itemName}.`);
                updateInventory();
            } else {
                output(`YOU CAN'T EQUIP A ${itemName}.`);
            }
        }

        function removeFromInventory(itemName) {
            const itemIndex = gameState.player.inventory.findIndex(item => item === itemName);
            if (itemIndex !== -1) {
                gameState.player.inventory.splice(itemIndex, 1);
                updateInventory();
            }
        }

        function showInventory() {
            clearOutput();
            output("YOUR INVENTORY:");
            output("----------------");
            if (gameState.player.inventory.length === 0) {
                output("EMPTY");
            } else {
                gameState.player.inventory.forEach(itemName => {
                    const item = items[itemName];
                    if (item) {
                        output(`- ${item.name} (${item.type.toUpperCase()}): ${item.desc}`);
                    } else {
                        output(`- ${itemName}`);
                    }
                });
            }
            output("");
            output("EQUIPPED:");
            output(`WEAPON: ${gameState.player.equipped.weapon.name}`);
            output(`ARMOR: ${gameState.player.equipped.armor.name}`);
            if (gameState.player.equipped.accessory) {
                output(`ACCESSORY: ${gameState.player.equipped.accessory.name}`);
            }
        }

        function showStatus() {
            clearOutput();
            output("CHARACTER STATUS:");
            output("-----------------");
            output(`NAME: ${gameState.player.name}`);
            output(`CLASS: ${gameState.player.class}`);
            output(`LEVEL: ${gameState.player.level}`);
            output(`HP: ${gameState.player.hp}/${gameState.player.maxHP}`);
            output(`MP: ${gameState.player.mp}/${gameState.player.maxMP}`);
            output(`XP: ${gameState.player.xp}/${gameState.player.xpToNextLevel}`);
            output(`GOLD: ${gameState.player.gold}`);
            output(`ARMOR RATING: ${calculateArmorRating()}`);
            output(`WEAPON DAMAGE: ${gameState.player.equipped.weapon.damage}`);
            output("");
            
            if (gameState.player.abilities.length > 0) {
                output("ABILITIES:");
                gameState.player.abilities.forEach(ability => {
                    output(`- ${ability}`);
                });
                output("");
            }
        }

        function showSpells() {
            clearOutput();
            output("YOUR SPELLS:");
            output("------------");
            if (gameState.player.spells.length === 0) {
                output("YOU DON'T KNOW ANY SPELLS.");
            } else {
                gameState.player.spells.forEach(spellName => {
                    const spell = spells[spellName];
                    if (spell) {
                        output(`- ${spell.name}: ${spell.desc} (${spell.mpCost} MP)`);
                    }
                });
            }
        }

        function talkToNPC(npcName) {
            const location = locations[gameState.currentLocation];
            const npc = Object.values(npcs).find(n => 
                n.name.toUpperCase() === npcName.toUpperCase() && 
                n.location === gameState.currentLocation
            );
            
            if (!npc) {
                output(`THERE IS NO ${npcName} HERE.`);
                return;
            }
            
            gameState.npcInConversation = npc;
            clearOutput();
            output(`YOU APPROACH ${npc.name}.`);
            output("");
            
            // Show dialogue
            npc.dialogue.forEach(line => {
                output(`<span class="npc-dialogue">${npc.name}: "${line}"</span>`);
            });
            
            output("");
            
            // Show options
            if (npc.quest) {
                const quest = quests[npc.quest];
                if (!isQuestActive(npc.quest)) {
                    output(`QUEST AVAILABLE: ${quest.name}`);
                    output(`TYPE 'QUEST' TO ACCEPT THE QUEST.`);
                } else if (isQuestComplete(npc.quest)) {
                    output(`QUEST COMPLETE: ${quest.name}`);
                    output(`TYPE 'COMPLETE' TO TURN IN THE QUEST.`);
                } else {
                    output(`ACTIVE QUEST: ${quest.name}`);
                    output(`TYPE 'QUEST' TO CHECK PROGRESS.`);
                }
            }
            
            if (npc.shop) {
                output(`TYPE 'SHOP' TO SEE WHAT ${npc.name} IS SELLING.`);
            }
            
            output(`TYPE 'BYE' TO END THE CONVERSATION.`);
        }

        function processNPCTalk(command) {
    const npc = gameState.npcInConversation;
    
    // Convert command to uppercase for comparison
    const cmd = command.toUpperCase();
    
    if (cmd === 'QUEST') {
        if (npc.quest) {
            const quest = quests[npc.quest];
            if (!isQuestActive(npc.quest)) {
                // Accept quest
                gameState.player.quests.push({...quest});
                output(`<span class="quest-update">QUEST ACCEPTED: ${quest.name}</span>`);
                output(`OBJECTIVE: ${quest.description}`);
                updateQuestLog();
            } else if (isQuestComplete(npc.quest)) {
                // Complete quest
                completeQuest(npc.quest);
            } else {
                // Check progress
                output(`QUEST IN PROGRESS: ${quest.name}`);
                output(`OBJECTIVE: ${quest.description}`);
                
                // Show progress for collect quests
                if (quest.objective.type === "collect") {
                    const count = gameState.player.inventory.filter(item => item === quest.objective.item).length;
                    output(`PROGRESS: ${count}/${quest.objective.amount}`);
                }
            }
        } else {
            output(`${npc.name} HAS NO QUEST FOR YOU.`);
        }
    } else if (cmd === 'COMPLETE') {
        if (npc.quest && isQuestComplete(npc.quest)) {
            completeQuest(npc.quest);
        } else {
            output("YOU HAVE NOT COMPLETED THE QUEST REQUIREMENTS.");
        }
    } else if (cmd === 'SHOP') {
        if (npc.shop) {
            gameState.shopOpen = true;
            showShop();
        } else {
            output(`${npc.name} HAS NOTHING TO SELL.`);
        }
    } else if (cmd.startsWith('BUY ')) {
        const itemName = cmd.substring(4).trim();
        buyItem(itemName);
    } else if (cmd.startsWith('SELL ')) {
        const itemName = cmd.substring(5).trim();
        sellItem(itemName);
    } else if (cmd === 'BYE' || cmd === 'GOODBYE' || cmd === 'LEAVE' || cmd === 'EXIT') {
        gameState.npcInConversation = null;
        gameState.shopOpen = false;
        output(`YOU END THE CONVERSATION WITH ${npc.name}.`);
        describeLocation();
    } else {
        // For any other command while talking to NPC, show appropriate response
        if (gameState.shopOpen) {
            output("IN THE SHOP, YOU CAN: BUY [ITEM], SELL [ITEM], or LEAVE");
        } else {
            output(`${npc.name} SAYS: "IS THERE SOMETHING ELSE YOU NEED?"`);
            output("YOU CAN ASK ABOUT: QUEST, SHOP, or say BYE");
        }
    }
}

        function showShop() {
            const npc = gameState.npcInConversation;
            if (!npc || !npc.shop) {
                output("THERE'S NO SHOP HERE.");
                return;
            }
            
            clearOutput();
            output(`${npc.name}'S SHOP:`);
            output("-----------------");
            
            npc.shop.forEach(itemName => {
                const item = items[itemName];
                if (item) {
                    const price = Math.floor(item.value * 1.2); // Shop prices are higher
                    output(`${item.name}: ${price} GOLD - ${item.desc}`);
                }
            });
            
            output("");
            output("YOUR GOLD: " + gameState.player.gold);
            output("TO BUY AN ITEM, TYPE 'BUY [ITEM NAME]'");
            output("TO SELL AN ITEM, TYPE 'SELL [ITEM NAME]'");
            output("TYPE 'LEAVE' TO EXIT THE SHOP");
        }

        function processShopCommand(command) {
            const words = command.split(' ');
            const verb = words[0];
            const noun = words.slice(1).join(' ');
            
            switch(verb) {
                case 'BUY':
                    buyItem(noun);
                    break;
                case 'SELL':
                    sellItem(noun);
                    break;
                case 'LEAVE':
                case 'EXIT':
                    gameState.shopOpen = false;
                    output("YOU LEAVE THE SHOP.");
                    describeLocation();
                    break;
                default:
                    output("IN SHOP: USE 'BUY [ITEM]', 'SELL [ITEM]', OR 'LEAVE'");
            }
        }

        function buyItem(itemName) {
    const npc = gameState.npcInConversation;
    if (!npc || !npc.shop) {
        output("THERE'S NO SHOP HERE.");
        return;
    }
    
    // Handle case sensitivity
    const shopItem = npc.shop.find(item => item.toUpperCase() === itemName);
    if (!shopItem) {
        output(`${npc.name} DOESN'T SELL ${itemName}.`);
        return;
    }
    
    const item = items[shopItem];
    if (!item) {
        output(`CANNOT BUY ${itemName}.`);
        return;
    }
    
    const price = Math.floor(item.value * 1.2);
    if (gameState.player.gold < price) {
        output(`YOU NEED ${price} GOLD TO BUY ${item.name}. YOU HAVE ${gameState.player.gold}.`);
        return;
    }
    
    if (!addItemToInventory(shopItem)) {
        output("YOUR INVENTORY IS FULL!");
        return;
    }
    
    gameState.player.gold -= price;
    output(`YOU BOUGHT ${item.name} FOR ${price} GOLD.`);
    updatePlayerStats();
    updateInventory();
}

function sellItem(itemName) {
    const npc = gameState.npcInConversation;
    if (!npc) {
        output("THERE'S NO ONE TO SELL TO.");
        return;
    }
    
    // Handle case sensitivity
    const inventoryItem = gameState.player.inventory.find(item => item.toUpperCase() === itemName);
    if (!inventoryItem) {
        output(`YOU DON'T HAVE ${itemName}.`);
        return;
    }
    
    const item = items[inventoryItem];
    if (!item) {
        output(`CANNOT SELL ${itemName}.`);
        return;
    }
    
    // Can't sell equipped items
    if (gameState.player.equipped.weapon.name.toUpperCase() === itemName || 
        gameState.player.equipped.armor.name.toUpperCase() === itemName ||
        (gameState.player.equipped.accessory && gameState.player.equipped.accessory.name.toUpperCase() === itemName)) {
        output(`YOU CAN'T SELL EQUIPPED ITEMS. UNEQUIP IT FIRST.`);
        return;
    }
    
    const price = Math.floor(item.value * 0.8);
    gameState.player.gold += price;
    removeFromInventory(inventoryItem);
    output(`YOU SOLD ${item.name} FOR ${price} GOLD.`);
    updatePlayerStats();
    updateInventory();
}

        function showQuests() {
            clearOutput();
            output("ACTIVE QUESTS:");
            output("--------------");
            
            if (gameState.player.quests.length === 0) {
                output("NO ACTIVE QUESTS.");
                return;
            }
            
            gameState.player.quests.forEach(quest => {
                output(`${quest.name}: ${quest.description}`);
                if (quest.completed) {
                    output("  [COMPLETED - READY TO TURN IN]");
                } else {
                    output("  [IN PROGRESS]");
                }
                output("");
            });
        }

        function isQuestActive(questId) {
            return gameState.player.quests.some(q => q.name === quests[questId].name);
        }

        function isQuestComplete(questId) {
            const quest = gameState.player.quests.find(q => q.name === quests[questId].name);
            if (!quest) return false;
            
            if (quest.completed) return true;
            
            const questDef = quests[questId];
            if (questDef.objective.type === "collect") {
                const count = gameState.player.inventory.filter(item => item === questDef.objective.item).length;
                quest.completed = count >= questDef.objective.amount;
            } else if (questDef.objective.type === "kill") {
                // For simplicity, we'll mark kill quests as complete when the enemy is killed in combat
                // In a full implementation, we'd track kills
            }
            
            return quest.completed;
        }

        function completeQuest(questId) {
            const questIndex = gameState.player.quests.findIndex(q => q.name === quests[questId].name);
            if (questIndex === -1) return;
            
            const questDef = quests[questId];
            const quest = gameState.player.quests[questIndex];
            
            if (!quest.completed && !isQuestComplete(questId)) {
                output("YOU HAVEN'T COMPLETED THE QUEST REQUIREMENTS.");
                return;
            }
            
            // Give rewards
            if (questDef.reward.gold) {
                gameState.player.gold += questDef.reward.gold;
                output(`YOU RECEIVE ${questDef.reward.gold} GOLD.`);
            }
            
            if (questDef.reward.item) {
                if (addItemToInventory(questDef.reward.item)) {
                    output(`YOU RECEIVE ${questDef.reward.item}.`);
                }
            }
            
            if (questDef.reward.xp) {
                gameState.player.xp += questDef.reward.xp;
                output(`YOU GAIN ${questDef.reward.xp} EXPERIENCE.`);
                checkLevelUp();
            }
            
            // Remove quest items if needed
            if (questDef.objective.type === "collect") {
                const count = questDef.objective.amount;
                for (let i = 0; i < count; i++) {
                    const itemIndex = gameState.player.inventory.findIndex(item => item === questDef.objective.item);
                    if (itemIndex !== -1) {
                        gameState.player.inventory.splice(itemIndex, 1);
                    }
                }
                updateInventory();
            }
            
            // Mark quest as completed
            gameState.player.quests.splice(questIndex, 1);
            output(`QUEST '${questDef.name}' COMPLETED!`);
            
            updatePlayerStats();
            updateQuestLog();
        }

        // ===================== COMBAT SYSTEM =====================
        function startCombat(enemyType) {
            if (!enemies[enemyType]) {
                output(`THERE IS NO ${enemyType} HERE.`);
                return;
            }
            
            gameState.combatEnemy = {
                ...enemies[enemyType],
                currentHP: enemies[enemyType].hp
            };
            
            gameState.gamePhase = "combat";
            
            clearOutput();
            output(`A ${gameState.combatEnemy.name} APPEARS!`);
            output("COMBAT BEGINS!");
            output("");
            output(`YOUR HP: ${gameState.player.hp}/${gameState.player.maxHP}`);
            output(`${gameState.combatEnemy.name} HP: ${gameState.combatEnemy.currentHP}/${gameState.combatEnemy.hp}`);
            output("");
            output("COMMANDS: ATTACK, CAST [SPELL], USE [ITEM], FLEE");
        }

        function processCombatCommand(command) {
            const words = command.split(' ');
            const verb = words[0];
            const noun = words.slice(1).join(' ');
            
            switch(verb) {
                case 'ATTACK':
                    playerAttack();
                    break;
                case 'CAST':
                    if (noun) {
                        castSpell(noun);
                    } else {
                        output("CAST WHAT SPELL?");
                        return;
                    }
                    break;
                case 'USE':
                    if (noun) {
                        useItem(noun);
                        enemyAttack();
                    } else {
                        output("USE WHAT?");
                    }
                    break;
                case 'FLEE':
                    attemptFlee();
                    break;
                default:
                    output("INVALID COMBAT COMMAND. YOU CAN: ATTACK, CAST [SPELL], USE [ITEM], FLEE");
            }
            
            checkCombatEnd();
        }

        function playerAttack() {
            let damage = rollDice(gameState.player.equipped.weapon.damage) + gameState.player.damageBonus;
            
            // Check for critical hit (10% chance)
            if (Math.random() < 0.1) {
                damage = Math.floor(damage * 1.5);
                output("CRITICAL HIT!");
            }
            
            // Apply weapon bonuses
            if (gameState.player.equipped.weapon.dragonBonus && gameState.combatEnemy.name.includes("DRAGON")) {
                damage += gameState.player.equipped.weapon.dragonBonus;
            }
            
            gameState.combatEnemy.currentHP -= damage;
            
            output(`YOU HIT THE ${gameState.combatEnemy.name} FOR ${damage} DAMAGE!`);
            
            if (gameState.combatEnemy.currentHP <= 0) {
                defeatEnemy();
                return;
            }
            
            enemyAttack();
        }

        function castSpell(spellName) {
            if (!gameState.player.spells.includes(spellName)) {
                output(`YOU DON'T KNOW THE ${spellName} SPELL.`);
                return;
            }
            
            const spell = spells[spellName];
            if (!spell) {
                output(`SPELL ${spellName} NOT FOUND.`);
                return;
            }
            
            if (gameState.player.mp < spell.mpCost) {
                output(`NOT ENOUGH MP TO CAST ${spellName}. YOU NEED ${spell.mpCost} MP.`);
                return;
            }
            
            gameState.player.mp -= spell.mpCost;
            
            // Handle different spell types
            if (spell.damage) {
                let damage = rollDice(spell.damage);
                
                // Apply class bonuses
                if (gameState.player.class === "WIZARD" || gameState.player.class === "SORCERER") {
                    damage = Math.floor(damage * 1.2);
                }
                
                gameState.combatEnemy.currentHP -= damage;
                output(`YOU CAST ${spellName} AND HIT THE ${gameState.combatEnemy.name} FOR ${damage} DAMAGE!`);
                
                if (gameState.combatEnemy.currentHP <= 0) {
                    defeatEnemy();
                    return;
                }
            } else if (spell.heal) {
                const healAmount = rollDice(spell.heal);
                gameState.player.hp = Math.min(gameState.player.maxHP, gameState.player.hp + healAmount);
                output(`YOU CAST ${spellName} AND HEAL YOURSELF FOR ${healAmount} HP.`);
                updatePlayerStats();
            }
            
            enemyAttack();
            updatePlayerStats();
        }

        function castSpellFromScroll(spellName) {
            const spell = spells[spellName];
            if (!spell) return;
            
            if (spell.damage) {
                const damage = rollDice(spell.damage);
                gameState.combatEnemy.currentHP -= damage;
                output(`SCROLL CASTS ${spellName} AND HITS FOR ${damage} DAMAGE!`);
                
                if (gameState.combatEnemy.currentHP <= 0) {
                    defeatEnemy();
                    return;
                }
            }
            
            enemyAttack();
        }

        function enemyAttack() {
            let damage = rollDice(gameState.combatEnemy.damage);
            
            // Apply enemy special attacks
            if (gameState.combatEnemy.fireBreath && Math.random() < 0.3) {
                damage += rollDice(gameState.combatEnemy.fireBreath);
                output(`THE ${gameState.combatEnemy.name} USES FIRE BREATH!`);
            } else if (gameState.combatEnemy.magicDamage && Math.random() < 0.4) {
                damage += rollDice(gameState.combatEnemy.magicDamage);
                output(`THE ${gameState.combatEnemy.name} CASTS A SPELL!`);
            }
            
            // Reduce damage by armor
            damage = Math.max(1, damage - calculateArmorRating());
            
            gameState.player.hp -= damage;
            output(`THE ${gameState.combatEnemy.name} HITS YOU FOR ${damage} DAMAGE!`);
            updatePlayerStats();
            
            if (gameState.player.hp <= 0) {
                gameOver();
            }
        }

        function attemptFlee() {
            if (Math.random() < 0.6) {
                output("YOU SUCCESSFULLY FLEE FROM COMBAT!");
                gameState.gamePhase = "playing";
                describeLocation();
            } else {
                output("YOU FAIL TO FLEE!");
                enemyAttack();
            }
        }

        function defeatEnemy() {
            const xpGained = gameState.combatEnemy.xp;
            const goldGained = rollDice(gameState.combatEnemy.gold);
            
            gameState.player.xp += xpGained;
            gameState.player.gold += goldGained;
            
            output(`YOU DEFEATED THE ${gameState.combatEnemy.name}!`);
            output(`YOU GAIN ${xpGained} XP AND ${goldGained} GOLD.`);
            
            // Drop loot
            if (gameState.combatEnemy.loot && gameState.combatEnemy.loot.length > 0) {
                gameState.combatEnemy.loot.forEach(itemName => {
                    if (Math.random() < 0.5) { // 50% drop chance
                        if (addItemToInventory(itemName)) {
                            output(`THE ENEMY DROPS ${itemName}.`);
                        }
                    }
                });
            }
            
            // Check quest completion for kill quests
            gameState.player.quests.forEach(quest => {
                if (!quest.completed && quest.objective.type === "kill" && 
                    quest.objective.enemy === gameState.combatEnemy.name) {
                    quest.completed = true;
                    output(`<span class="quest-update">QUEST PROGRESS: ${quest.name} COMPLETED!</span>`);
                }
            });
            
            // Special victory for dragon lord
            if (gameState.combatEnemy.name === "DRAGON LORD") {
                victory();
                return;
            }
            
            checkLevelUp();
            gameState.gamePhase = "playing";
            updatePlayerStats();
            output("");
            describeLocation();
        }

        function checkCombatEnd() {
            if (gameState.combatEnemy && gameState.combatEnemy.currentHP <= 0) {
                defeatEnemy();
            } else if (gameState.player.hp <= 0) {
                gameOver();
            } else {
                output("");
                output(`YOUR HP: ${gameState.player.hp}/${gameState.player.maxHP} MP: ${gameState.player.mp}/${gameState.player.maxMP}`);
                output(`${gameState.combatEnemy.name} HP: ${gameState.combatEnemy.currentHP}/${gameState.combatEnemy.hp}`);
            }
        }

        // ===================== UTILITY FUNCTIONS =====================
        function calculateArmorRating() {
            let armor = gameState.player.armorBonus;
            if (gameState.player.equipped.armor) {
                armor += gameState.player.equipped.armor.defense || 0;
            }
            return armor;
        }

        function checkLevelUp() {
            while (gameState.player.xp >= gameState.player.xpToNextLevel) {
                gameState.player.level++;
                gameState.player.xp -= gameState.player.xpToNextLevel;
                gameState.player.xpToNextLevel = Math.floor(gameState.player.xpToNextLevel * 1.5);
                
                const hpIncrease = rollDice("1d10") + 5;
                const mpIncrease = rollDice("1d6") + 2;
                
                gameState.player.maxHP += hpIncrease;
                gameState.player.maxMP += mpIncrease;
                gameState.player.hp = gameState.player.maxHP;
                gameState.player.mp = gameState.player.maxMP;
                
                output("");
                output("*** YOU ADVANCE TO LEVEL " + gameState.player.level + "! ***");
                output(`YOUR MAX HP INCREASES BY ${hpIncrease}!`);
                output(`YOUR MAX MP INCREASES BY ${mpIncrease}!`);
                
                // Learn new abilities at certain levels
                if (gameState.player.level === 3) {
                    const newSpell = getClassSpellForLevel(gameState.player.class, 3);
                    if (newSpell && !gameState.player.spells.includes(newSpell)) {
                        gameState.player.spells.push(newSpell);
                        output(`YOU LEARN THE ${newSpell} SPELL!`);
                    }
                }
                
                if (gameState.player.level === 5) {
                    const newSpell = getClassSpellForLevel(gameState.player.class, 5);
                    if (newSpell && !gameState.player.spells.includes(newSpell)) {
                        gameState.player.spells.push(newSpell);
                        output(`YOU LEARN THE ${newSpell} SPELL!`);
                    }
                }
                
                updatePlayerStats();
            }
        }

        function getClassSpellForLevel(className, level) {
            // Define which spells classes learn at which levels
            const spellProgressions = {
                WIZARD: { 3: "ICE_BOLT", 5: "TELEPORT" },
                SORCERER: { 3: "FIRE_BLAST", 5: "ICE_STORM" },
                NECROMANCER: { 3: "DARK_BOLT", 5: "RAISE_DEAD" },
                PRIEST: { 3: "BLESS", 5: "SMITE" },
                HEALER: { 3: "PROTECTION", 5: "REGENERATE" }
            };
            
            return spellProgressions[className]?.[level];
        }

        function rest() {
            if (Math.random() < 0.2) {
                const location = locations[gameState.currentLocation];
                if (location.encounters.length > 0) {
                    const enemyType = location.encounters[Math.floor(Math.random() * location.encounters.length)];
                    output("WHILE RESTING, YOU ARE AMBUSHED!");
                    startCombat(enemyType);
                    return;
                }
            }
            
            const hpRestore = Math.floor(gameState.player.maxHP * 0.5);
            const mpRestore = Math.floor(gameState.player.maxMP * 0.5);
            
            gameState.player.hp = Math.min(gameState.player.maxHP, gameState.player.hp + hpRestore);
            gameState.player.mp = Math.min(gameState.player.maxMP, gameState.player.mp + mpRestore);
            
            output(`YOU REST AND REGAIN ${hpRestore} HP AND ${mpRestore} MP.`);
            updatePlayerStats();
        }

        function gameOver() {
            clearOutput();
            output("YOU HAVE BEEN DEFEATED!");
            output("");
            output("YOUR ADVENTURE ENDS HERE...");
            output("");
            output("FINAL STATS:");
            output(`LEVEL: ${gameState.player.level}`);
            output(`GOLD: ${gameState.player.gold}`);
            output(`QUESTS COMPLETED: ${gameState.player.quests.filter(q => q.completed).length}`);
            output("");
            output("TYPE 'RESTART' TO BEGIN A NEW ADVENTURE.");
            
            gameState.gamePhase = "game_over";
        }

        function victory() {
            clearOutput();
            output("*** VICTORY! ***");
            output("");
            output("YOU HAVE DEFEATED THE DRAGON LORD AND SAVED AETHELGARD!");
            output("");
            output("THE KINGDOM SHALL SING OF YOUR DEEDS FOR GENERATIONS TO COME.");
            output("");
            output("FINAL STATS:");
            output(`LEVEL: ${gameState.player.level}`);
            output(`GOLD: ${gameState.player.gold}`);
            output(`QUESTS COMPLETED: ${gameState.player.quests.filter(q => q.completed).length + 1}`); // +1 for dragon lord
            output("");
            output("THANK YOU FOR PLAYING CHRONICLES OF AETHELGARD!");
            output("TYPE 'RESTART' TO BEGIN A NEW ADVENTURE.");
            
            gameState.gamePhase = "victory";
        }

        function restartGame() {
            // Reset game state
            gameState.player = {
                name: "",
                class: "",
                level: 1,
                hp: 0,
                maxHP: 0,
                mp: 0,
                maxMP: 0,
                xp: 0,
                xpToNextLevel: 100,
                gold: 0,
                inventory: [],
                equipped: {
                    weapon: { name: "FISTS", damage: "1d4", type: "melee" },
                    armor: { name: "CLOTHES", defense: 0, type: "light" },
                    accessory: null
                },
                armorBonus: 0,
                damageBonus: 0,
                spells: [],
                abilities: [],
                quests: []
            };
            
            gameState.currentLocation = "town_square";
            gameState.gamePhase = "character_creation_name";
            gameState.combatEnemy = null;
            gameState.npcInConversation = null;
            gameState.shopOpen = false;
            
            // Reset locations items
            Object.keys(locations).forEach(loc => {
                locations[loc].items = [];
            });
            
            // Add default items to locations
            locations.town_square.items = ["TORCH"];
            locations.dark_forest.items = ["HEALING_HERBS", "HEALING_HERBS"];
            locations.forest_deep.items = ["ANCIENT_AMULET"];
            locations.dragons_cave.items = ["DRAGON_SCALE"];
            locations.abandoned_temple.items = ["HOLY_SYMBOL"];
            locations.crypt.items = ["ANCIENT_AMULET"];
            locations.dragons_lair.items = ["DRAGONBANE_SWORD", "DRAGONSCALE_ARMOR", "DRAGON_SCALE", "DRAGON_SCALE", "DRAGON_SCALE"];
            
            initGame();
        }

        function rollDice(diceString) {
            const match = diceString.match(/(\d+)d(\d+)([+-]\d+)?/);
            if (!match) {
                // Check for fixed number
                const fixed = parseInt(diceString);
                return isNaN(fixed) ? 0 : fixed;
            }
            
            const numDice = parseInt(match[1]);
            const diceSides = parseInt(match[2]);
            const modifier = match[3] ? parseInt(match[3]) : 0;
            let total = 0;
            
            for (let i = 0; i < numDice; i++) {
                total += Math.floor(Math.random() * diceSides) + 1;
            }
            
            return total + modifier;
        }

        // ===================== UI UPDATES =====================
        function clearOutput() {
            outputText.innerHTML = '';
        }

        function output(text) {
            const p = document.createElement('p');
            p.innerHTML = text;
            outputText.appendChild(p);
            outputText.scrollTop = outputText.scrollHeight;
        }

        function updateUI() {
            updatePlayerStats();
            updateLocation();
            updateInventory();
            updateQuestLog();
        }

        function updatePlayerStats() {
            playerNameEl.textContent = gameState.player.name || "-";
            playerClassEl.textContent = gameState.player.class || "-";
            playerLevelEl.textContent = gameState.player.level;
            playerHPElement.textContent = `${gameState.player.hp}/${gameState.player.maxHP}`;
            playerMPElement.textContent = `${gameState.player.mp}/${gameState.player.maxMP}`;
            playerXPElement.textContent = `${gameState.player.xp}/${gameState.player.xpToNextLevel}`;
            playerGoldElement.textContent = gameState.player.gold;
            playerArmorEl.textContent = calculateArmorRating();
            playerDamageEl.textContent = gameState.player.equipped.weapon.damage;
        }

        function updateLocation() {
            currentLocationEl.textContent = locations[gameState.currentLocation].name;
        }

        function updateInventory() {
            inventoryList.innerHTML = '';
            
            if (gameState.player.inventory.length === 0) {
                inventoryList.innerHTML = '<p>EMPTY</p>';
            } else {
                const itemCounts = {};
                gameState.player.inventory.forEach(itemName => {
                    itemCounts[itemName] = (itemCounts[itemName] || 0) + 1;
                });
                
                Object.keys(itemCounts).forEach(itemName => {
                    const count = itemCounts[itemName];
                    const displayName = count > 1 ? `${itemName} (${count})` : itemName;
                    const itemEl = document.createElement('p');
                    itemEl.textContent = `- ${displayName}`;
                    inventoryList.appendChild(itemEl);
                });
            }
        }

        function updateQuestLog() {
            questList.innerHTML = '';
            
            const activeQuests = gameState.player.quests.filter(q => !q.completed);
            if (activeQuests.length === 0) {
                questList.innerHTML = '<p>NONE</p>';
            } else {
                activeQuests.forEach(quest => {
                    const questEl = document.createElement('p');
                    questEl.textContent = `- ${quest.name}`;
                    questList.appendChild(questEl);
                });
            }
        }

        function updateCommandHistory() {
            commandHistory.innerHTML = 'LAST COMMANDS:<br>' + 
                gameState.commandHistory.map(cmd => `> ${cmd}`).join('<br>');
        }

        // Initialize the game when page loads
        window.onload = function() {
            setTimeout(() => {
                initGame();
            }, 1000);
        };
    </script>
</body>
</html>
